
Intelligent-parking-system.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000099f4  10001000  10001000  00001000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .eh_frame     00000000  1000a9f4  1000a9f4  0000a9f4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .VENEER_Code  00000110  2000000c  1000a9f4  0001000c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 Stack         00000404  2000011c  00000000  0000011c  2**0
                  ALLOC
  4 .data         00000180  20000520  1000ab04  00010520  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          00000290  200006a0  00000584  000106a0  2**2
                  ALLOC
  6 .no_init      00000004  20003ffc  00003ee0  0000011c  2**2
                  ALLOC
  7 .debug_aranges 00000f40  00000000  00000000  000106a0  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   00013dbd  00000000  00000000  000115e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 0000329b  00000000  00000000  0002539d  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   00009cbd  00000000  00000000  00028638  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  00004448  00000000  00000000  000322f8  2**2
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    00007d15  00000000  00000000  00036740  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    000052c7  00000000  00000000  0003e455  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000d20  00000000  00000000  00043720  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .build_attributes 00000f78  00000000  00000000  00044440  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

10001000 <__Vectors>:
10001000:	20 05 00 20 19 10 00 10 00 00 00 00 91 10 00 10      .. ............
10001010:	00 04 01 00 00 00 00 80                             ........

10001018 <Reset_Handler>:
    .thumb_func 
    .globl  Reset_Handler
    .type   Reset_Handler, %function
Reset_Handler: 
/* Initialize interrupt veneer */
	ldr	r1, =eROData
10001018:	4910      	ldr	r1, [pc, #64]	; (1000105c <__copy_data+0xe>)
	ldr	r2, =VeneerStart
1000101a:	4a11      	ldr	r2, [pc, #68]	; (10001060 <__copy_data+0x12>)
	ldr	r3, =VeneerEnd
1000101c:	4b11      	ldr	r3, [pc, #68]	; (10001064 <__copy_data+0x16>)
	bl  __copy_data
1000101e:	f000 f816 	bl	1000104e <__copy_data>

    ldr  r0, =SystemInit
10001022:	4811      	ldr	r0, [pc, #68]	; (10001068 <__copy_data+0x1a>)
    blx  r0
10001024:	4780      	blx	r0
	
/* Initialize data */
	ldr	r1, =DataLoadAddr
10001026:	4911      	ldr	r1, [pc, #68]	; (1000106c <__copy_data+0x1e>)
	ldr	r2, =__data_start
10001028:	4a11      	ldr	r2, [pc, #68]	; (10001070 <__copy_data+0x22>)
	ldr	r3, =__data_end
1000102a:	4b12      	ldr	r3, [pc, #72]	; (10001074 <__copy_data+0x26>)
	bl  __copy_data
1000102c:	f000 f80f 	bl	1000104e <__copy_data>

/* RAM code */
	ldr	r1, =__ram_code_load
10001030:	4911      	ldr	r1, [pc, #68]	; (10001078 <__copy_data+0x2a>)
	ldr	r2, =__ram_code_start
10001032:	4a12      	ldr	r2, [pc, #72]	; (1000107c <__copy_data+0x2e>)
	ldr	r3, =__ram_code_end
10001034:	4b12      	ldr	r3, [pc, #72]	; (10001080 <__copy_data+0x32>)
	bl  __copy_data
10001036:	f000 f80a 	bl	1000104e <__copy_data>
 *    __bss_end__: end of the BSS section.
 *
 *  Both addresses must be aligned to 4 bytes boundary.
 */
#ifndef __SKIP_BSS_CLEAR
	ldr	r1, =__bss_start
1000103a:	4912      	ldr	r1, [pc, #72]	; (10001084 <__copy_data+0x36>)
	ldr	r2, =__bss_end
1000103c:	4a12      	ldr	r2, [pc, #72]	; (10001088 <__copy_data+0x3a>)

	movs	r0, 0
1000103e:	2000      	movs	r0, #0

	subs	r2, r1
10001040:	1a52      	subs	r2, r2, r1
	ble	.L_loop3_done
10001042:	dd02      	ble.n	1000104a <Reset_Handler+0x32>

.L_loop3:
	subs	r2, #4
10001044:	3a04      	subs	r2, #4
	str	r0, [r1, r2]
10001046:	5088      	str	r0, [r1, r2]
	bgt	.L_loop3
10001048:	dcfc      	bgt.n	10001044 <Reset_Handler+0x2c>
#ifndef __SKIP_LIBC_INIT_ARRAY
    ldr  r0, =__libc_init_array
    blx  r0
#endif

    ldr  r0, =main
1000104a:	4810      	ldr	r0, [pc, #64]	; (1000108c <__copy_data+0x3e>)
    blx  r0
1000104c:	4780      	blx	r0

1000104e <__copy_data>:
 *    r3: end of the section to copy to
 *
 *  All addresses must be aligned to 4 bytes boundary.
 *  Uses r0
 */
	subs	r3, r2
1000104e:	1a9b      	subs	r3, r3, r2
	ble	.L_loop_done
10001050:	dd03      	ble.n	1000105a <__copy_data+0xc>

.L_loop:
	subs	r3, #4
10001052:	3b04      	subs	r3, #4
	ldr	r0, [r1,r3]
10001054:	58c8      	ldr	r0, [r1, r3]
	str	r0, [r2,r3]
10001056:	50d0      	str	r0, [r2, r3]
	bgt	.L_loop
10001058:	dcfb      	bgt.n	10001052 <__copy_data+0x4>

.L_loop_done:
	bx  lr
1000105a:	4770      	bx	lr
    .thumb_func 
    .globl  Reset_Handler
    .type   Reset_Handler, %function
Reset_Handler: 
/* Initialize interrupt veneer */
	ldr	r1, =eROData
1000105c:	1000a9f4 	.word	0x1000a9f4
	ldr	r2, =VeneerStart
10001060:	2000000c 	.word	0x2000000c
	ldr	r3, =VeneerEnd
10001064:	2000011c 	.word	0x2000011c
	bl  __copy_data

    ldr  r0, =SystemInit
10001068:	10001095 	.word	0x10001095
    blx  r0
	
/* Initialize data */
	ldr	r1, =DataLoadAddr
1000106c:	1000ab04 	.word	0x1000ab04
	ldr	r2, =__data_start
10001070:	20000520 	.word	0x20000520
	ldr	r3, =__data_end
10001074:	200006a0 	.word	0x200006a0
	bl  __copy_data

/* RAM code */
	ldr	r1, =__ram_code_load
10001078:	1000ac84 	.word	0x1000ac84
	ldr	r2, =__ram_code_start
1000107c:	200006a0 	.word	0x200006a0
	ldr	r3, =__ram_code_end
10001080:	200006a0 	.word	0x200006a0
 *    __bss_end__: end of the BSS section.
 *
 *  Both addresses must be aligned to 4 bytes boundary.
 */
#ifndef __SKIP_BSS_CLEAR
	ldr	r1, =__bss_start
10001084:	200006a0 	.word	0x200006a0
	ldr	r2, =__bss_end
10001088:	2000092c 	.word	0x2000092c
#ifndef __SKIP_LIBC_INIT_ARRAY
    ldr  r0, =__libc_init_array
    blx  r0
#endif

    ldr  r0, =main
1000108c:	1000524d 	.word	0x1000524d

10001090 <CCU40_0_IRQHandler>:
    
    .thumb_func
    .weak Default_handler
    .type Default_handler, %function
Default_handler:
    b  .
10001090:	e7fe      	b.n	10001090 <CCU40_0_IRQHandler>
	...

10001094 <SystemInit>:
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

__WEAK void SystemInit(void)
{    
10001094:	b580      	push	{r7, lr}
10001096:	af00      	add	r7, sp, #0
  SystemCoreSetup();
10001098:	f003 ff76 	bl	10004f88 <SystemCoreSetup>
  SystemCoreClockSetup();
1000109c:	f003 ffba 	bl	10005014 <SystemCoreClockSetup>
}
100010a0:	46bd      	mov	sp, r7
100010a2:	bd80      	pop	{r7, pc}

100010a4 <SystemCoreClockUpdate>:
  
  SystemCoreClockUpdate();
}

__WEAK void SystemCoreClockUpdate(void)
{
100010a4:	b580      	push	{r7, lr}
100010a6:	af00      	add	r7, sp, #0
  static uint32_t IDIV, FDIV;

  IDIV = ((SCU_CLK->CLKCR) & SCU_CLK_CLKCR_IDIV_Msk) >> SCU_CLK_CLKCR_IDIV_Pos;
100010a8:	4b12      	ldr	r3, [pc, #72]	; (100010f4 <SystemCoreClockUpdate+0x50>)
100010aa:	681a      	ldr	r2, [r3, #0]
100010ac:	23ff      	movs	r3, #255	; 0xff
100010ae:	021b      	lsls	r3, r3, #8
100010b0:	4013      	ands	r3, r2
100010b2:	0a1a      	lsrs	r2, r3, #8
100010b4:	4b10      	ldr	r3, [pc, #64]	; (100010f8 <SystemCoreClockUpdate+0x54>)
100010b6:	601a      	str	r2, [r3, #0]
  FDIV = ((SCU_CLK->CLKCR) & SCU_CLK_CLKCR_FDIV_Msk) >> SCU_CLK_CLKCR_FDIV_Pos;
100010b8:	4b0e      	ldr	r3, [pc, #56]	; (100010f4 <SystemCoreClockUpdate+0x50>)
100010ba:	681b      	ldr	r3, [r3, #0]
100010bc:	22ff      	movs	r2, #255	; 0xff
100010be:	401a      	ands	r2, r3
100010c0:	4b0e      	ldr	r3, [pc, #56]	; (100010fc <SystemCoreClockUpdate+0x58>)
100010c2:	601a      	str	r2, [r3, #0]
  
  if (IDIV != 0)
100010c4:	4b0c      	ldr	r3, [pc, #48]	; (100010f8 <SystemCoreClockUpdate+0x54>)
100010c6:	681b      	ldr	r3, [r3, #0]
100010c8:	2b00      	cmp	r3, #0
100010ca:	d00e      	beq.n	100010ea <SystemCoreClockUpdate+0x46>
  {
    /* Fractional divider is enabled and used */
    SystemCoreClock = ((DCO1_FREQUENCY << 6U) / ((IDIV << 8) + FDIV)) << 1U;
100010cc:	4b0a      	ldr	r3, [pc, #40]	; (100010f8 <SystemCoreClockUpdate+0x54>)
100010ce:	681b      	ldr	r3, [r3, #0]
100010d0:	021a      	lsls	r2, r3, #8
100010d2:	4b0a      	ldr	r3, [pc, #40]	; (100010fc <SystemCoreClockUpdate+0x58>)
100010d4:	681b      	ldr	r3, [r3, #0]
100010d6:	18d3      	adds	r3, r2, r3
100010d8:	4809      	ldr	r0, [pc, #36]	; (10001100 <SystemCoreClockUpdate+0x5c>)
100010da:	1c19      	adds	r1, r3, #0
100010dc:	f004 facc 	bl	10005678 <__aeabi_uidiv>
100010e0:	1c03      	adds	r3, r0, #0
100010e2:	005a      	lsls	r2, r3, #1
100010e4:	4b07      	ldr	r3, [pc, #28]	; (10001104 <SystemCoreClockUpdate+0x60>)
100010e6:	601a      	str	r2, [r3, #0]
100010e8:	e002      	b.n	100010f0 <SystemCoreClockUpdate+0x4c>
  }
  else
  {
    /* Fractional divider bypassed. Simply divide DCO_DCLK by 2 */
    SystemCoreClock = DCO1_FREQUENCY >> 1U;
100010ea:	4b06      	ldr	r3, [pc, #24]	; (10001104 <SystemCoreClockUpdate+0x60>)
100010ec:	4a06      	ldr	r2, [pc, #24]	; (10001108 <SystemCoreClockUpdate+0x64>)
100010ee:	601a      	str	r2, [r3, #0]
  }
}
100010f0:	46bd      	mov	sp, r7
100010f2:	bd80      	pop	{r7, pc}
100010f4:	40010300 	.word	0x40010300
100010f8:	200006a0 	.word	0x200006a0
100010fc:	200006a4 	.word	0x200006a4
10001100:	f4240000 	.word	0xf4240000
10001104:	20003ffc 	.word	0x20003ffc
10001108:	01e84800 	.word	0x01e84800

1000110c <XMC_GPIO_Init>:
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

void XMC_GPIO_Init(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_CONFIG_t *const config)
{
1000110c:	b590      	push	{r4, r7, lr}
1000110e:	b085      	sub	sp, #20
10001110:	af00      	add	r7, sp, #0
10001112:	60f8      	str	r0, [r7, #12]
10001114:	607a      	str	r2, [r7, #4]
10001116:	230b      	movs	r3, #11
10001118:	18fb      	adds	r3, r7, r3
1000111a:	1c0a      	adds	r2, r1, #0
1000111c:	701a      	strb	r2, [r3, #0]
  XMC_ASSERT("XMC_GPIO_Init: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_Init: Invalid mode", XMC_GPIO_IsModeValid(config->mode));
  XMC_ASSERT("XMC_GPIO_Init: Invalid input hysteresis", XMC_GPIO_CHECK_INPUT_HYSTERESIS(config->input_hysteresis));

  /* Switch to input */
  port->IOCR[pin >> 2U] &= ~(uint32_t)((uint32_t)PORT_IOCR_PC_Msk << (PORT_IOCR_PC_Size * (pin & 0x3U)));
1000111e:	230b      	movs	r3, #11
10001120:	18fb      	adds	r3, r7, r3
10001122:	781b      	ldrb	r3, [r3, #0]
10001124:	089b      	lsrs	r3, r3, #2
10001126:	b2db      	uxtb	r3, r3
10001128:	1c18      	adds	r0, r3, #0
1000112a:	230b      	movs	r3, #11
1000112c:	18fb      	adds	r3, r7, r3
1000112e:	781b      	ldrb	r3, [r3, #0]
10001130:	089b      	lsrs	r3, r3, #2
10001132:	b2db      	uxtb	r3, r3
10001134:	1c1a      	adds	r2, r3, #0
10001136:	68fb      	ldr	r3, [r7, #12]
10001138:	3204      	adds	r2, #4
1000113a:	0092      	lsls	r2, r2, #2
1000113c:	58d3      	ldr	r3, [r2, r3]
1000113e:	220b      	movs	r2, #11
10001140:	18ba      	adds	r2, r7, r2
10001142:	7812      	ldrb	r2, [r2, #0]
10001144:	2103      	movs	r1, #3
10001146:	400a      	ands	r2, r1
10001148:	00d2      	lsls	r2, r2, #3
1000114a:	1c11      	adds	r1, r2, #0
1000114c:	22f8      	movs	r2, #248	; 0xf8
1000114e:	408a      	lsls	r2, r1
10001150:	43d2      	mvns	r2, r2
10001152:	401a      	ands	r2, r3
10001154:	1c11      	adds	r1, r2, #0
10001156:	68fb      	ldr	r3, [r7, #12]
10001158:	1d02      	adds	r2, r0, #4
1000115a:	0092      	lsls	r2, r2, #2
1000115c:	50d1      	str	r1, [r2, r3]

  /* HW port control is disabled */
  port->HWSEL &= ~(uint32_t)((uint32_t)PORT_HWSEL_Msk << ((uint32_t)pin << 1U));
1000115e:	68fb      	ldr	r3, [r7, #12]
10001160:	6f5b      	ldr	r3, [r3, #116]	; 0x74
10001162:	220b      	movs	r2, #11
10001164:	18ba      	adds	r2, r7, r2
10001166:	7812      	ldrb	r2, [r2, #0]
10001168:	0052      	lsls	r2, r2, #1
1000116a:	1c11      	adds	r1, r2, #0
1000116c:	2203      	movs	r2, #3
1000116e:	408a      	lsls	r2, r1
10001170:	43d2      	mvns	r2, r2
10001172:	401a      	ands	r2, r3
10001174:	68fb      	ldr	r3, [r7, #12]
10001176:	675a      	str	r2, [r3, #116]	; 0x74

  /* Set input hysteresis */
  port->PHCR[(uint32_t)pin >> 3U] &= ~(uint32_t)((uint32_t)PORT_PHCR_Msk << ((uint32_t)PORT_PHCR_Size * ((uint32_t)pin & 0x7U)));
10001178:	230b      	movs	r3, #11
1000117a:	18fb      	adds	r3, r7, r3
1000117c:	781b      	ldrb	r3, [r3, #0]
1000117e:	08db      	lsrs	r3, r3, #3
10001180:	b2db      	uxtb	r3, r3
10001182:	1c18      	adds	r0, r3, #0
10001184:	230b      	movs	r3, #11
10001186:	18fb      	adds	r3, r7, r3
10001188:	781b      	ldrb	r3, [r3, #0]
1000118a:	08db      	lsrs	r3, r3, #3
1000118c:	b2db      	uxtb	r3, r3
1000118e:	1c1a      	adds	r2, r3, #0
10001190:	68fb      	ldr	r3, [r7, #12]
10001192:	3210      	adds	r2, #16
10001194:	0092      	lsls	r2, r2, #2
10001196:	58d3      	ldr	r3, [r2, r3]
10001198:	220b      	movs	r2, #11
1000119a:	18ba      	adds	r2, r7, r2
1000119c:	7812      	ldrb	r2, [r2, #0]
1000119e:	2107      	movs	r1, #7
100011a0:	400a      	ands	r2, r1
100011a2:	0092      	lsls	r2, r2, #2
100011a4:	1c11      	adds	r1, r2, #0
100011a6:	2204      	movs	r2, #4
100011a8:	408a      	lsls	r2, r1
100011aa:	43d2      	mvns	r2, r2
100011ac:	401a      	ands	r2, r3
100011ae:	1c11      	adds	r1, r2, #0
100011b0:	68fb      	ldr	r3, [r7, #12]
100011b2:	1c02      	adds	r2, r0, #0
100011b4:	3210      	adds	r2, #16
100011b6:	0092      	lsls	r2, r2, #2
100011b8:	50d1      	str	r1, [r2, r3]
  port->PHCR[(uint32_t)pin >> 3U] |= (uint32_t)config->input_hysteresis << ((uint32_t)PORT_PHCR_Size * ((uint32_t)pin & 0x7U));
100011ba:	230b      	movs	r3, #11
100011bc:	18fb      	adds	r3, r7, r3
100011be:	781b      	ldrb	r3, [r3, #0]
100011c0:	08db      	lsrs	r3, r3, #3
100011c2:	b2db      	uxtb	r3, r3
100011c4:	1c18      	adds	r0, r3, #0
100011c6:	230b      	movs	r3, #11
100011c8:	18fb      	adds	r3, r7, r3
100011ca:	781b      	ldrb	r3, [r3, #0]
100011cc:	08db      	lsrs	r3, r3, #3
100011ce:	b2db      	uxtb	r3, r3
100011d0:	1c1a      	adds	r2, r3, #0
100011d2:	68fb      	ldr	r3, [r7, #12]
100011d4:	3210      	adds	r2, #16
100011d6:	0092      	lsls	r2, r2, #2
100011d8:	58d2      	ldr	r2, [r2, r3]
100011da:	687b      	ldr	r3, [r7, #4]
100011dc:	785b      	ldrb	r3, [r3, #1]
100011de:	1c1c      	adds	r4, r3, #0
100011e0:	230b      	movs	r3, #11
100011e2:	18fb      	adds	r3, r7, r3
100011e4:	781b      	ldrb	r3, [r3, #0]
100011e6:	2107      	movs	r1, #7
100011e8:	400b      	ands	r3, r1
100011ea:	009b      	lsls	r3, r3, #2
100011ec:	409c      	lsls	r4, r3
100011ee:	1c23      	adds	r3, r4, #0
100011f0:	431a      	orrs	r2, r3
100011f2:	1c11      	adds	r1, r2, #0
100011f4:	68fb      	ldr	r3, [r7, #12]
100011f6:	1c02      	adds	r2, r0, #0
100011f8:	3210      	adds	r2, #16
100011fa:	0092      	lsls	r2, r2, #2
100011fc:	50d1      	str	r1, [r2, r3]

  /* Enable digital input */
  if (XMC_GPIO_CHECK_ANALOG_PORT(port))
100011fe:	68fb      	ldr	r3, [r7, #12]
10001200:	4a20      	ldr	r2, [pc, #128]	; (10001284 <XMC_GPIO_Init+0x178>)
10001202:	4293      	cmp	r3, r2
10001204:	d10b      	bne.n	1000121e <XMC_GPIO_Init+0x112>
  {
    port->PDISC &= ~(uint32_t)((uint32_t)0x1U << pin);
10001206:	68fb      	ldr	r3, [r7, #12]
10001208:	6e1b      	ldr	r3, [r3, #96]	; 0x60
1000120a:	220b      	movs	r2, #11
1000120c:	18ba      	adds	r2, r7, r2
1000120e:	7812      	ldrb	r2, [r2, #0]
10001210:	2101      	movs	r1, #1
10001212:	4091      	lsls	r1, r2
10001214:	1c0a      	adds	r2, r1, #0
10001216:	43d2      	mvns	r2, r2
10001218:	401a      	ands	r2, r3
1000121a:	68fb      	ldr	r3, [r7, #12]
1000121c:	661a      	str	r2, [r3, #96]	; 0x60
  }

  if ((config->mode & XMC_GPIO_MODE_OE) != 0)
1000121e:	687b      	ldr	r3, [r7, #4]
10001220:	781b      	ldrb	r3, [r3, #0]
10001222:	b2db      	uxtb	r3, r3
10001224:	b25b      	sxtb	r3, r3
10001226:	2b00      	cmp	r3, #0
10001228:	da07      	bge.n	1000123a <XMC_GPIO_Init+0x12e>
  {
    /* If output is enabled */

    /* Set output level */
    port->OMR = (uint32_t)config->output_level << pin;
1000122a:	687b      	ldr	r3, [r7, #4]
1000122c:	685a      	ldr	r2, [r3, #4]
1000122e:	230b      	movs	r3, #11
10001230:	18fb      	adds	r3, r7, r3
10001232:	781b      	ldrb	r3, [r3, #0]
10001234:	409a      	lsls	r2, r3
10001236:	68fb      	ldr	r3, [r7, #12]
10001238:	605a      	str	r2, [r3, #4]
  }

  /* Set mode */
  port->IOCR[pin >> 2U] |= (uint32_t)config->mode << (PORT_IOCR_PC_Size * (pin & 0x3U));
1000123a:	230b      	movs	r3, #11
1000123c:	18fb      	adds	r3, r7, r3
1000123e:	781b      	ldrb	r3, [r3, #0]
10001240:	089b      	lsrs	r3, r3, #2
10001242:	b2db      	uxtb	r3, r3
10001244:	1c18      	adds	r0, r3, #0
10001246:	230b      	movs	r3, #11
10001248:	18fb      	adds	r3, r7, r3
1000124a:	781b      	ldrb	r3, [r3, #0]
1000124c:	089b      	lsrs	r3, r3, #2
1000124e:	b2db      	uxtb	r3, r3
10001250:	1c1a      	adds	r2, r3, #0
10001252:	68fb      	ldr	r3, [r7, #12]
10001254:	3204      	adds	r2, #4
10001256:	0092      	lsls	r2, r2, #2
10001258:	58d2      	ldr	r2, [r2, r3]
1000125a:	687b      	ldr	r3, [r7, #4]
1000125c:	781b      	ldrb	r3, [r3, #0]
1000125e:	1c1c      	adds	r4, r3, #0
10001260:	230b      	movs	r3, #11
10001262:	18fb      	adds	r3, r7, r3
10001264:	781b      	ldrb	r3, [r3, #0]
10001266:	2103      	movs	r1, #3
10001268:	400b      	ands	r3, r1
1000126a:	00db      	lsls	r3, r3, #3
1000126c:	409c      	lsls	r4, r3
1000126e:	1c23      	adds	r3, r4, #0
10001270:	431a      	orrs	r2, r3
10001272:	1c11      	adds	r1, r2, #0
10001274:	68fb      	ldr	r3, [r7, #12]
10001276:	1d02      	adds	r2, r0, #4
10001278:	0092      	lsls	r2, r2, #2
1000127a:	50d1      	str	r1, [r2, r3]
}
1000127c:	46bd      	mov	sp, r7
1000127e:	b005      	add	sp, #20
10001280:	bd90      	pop	{r4, r7, pc}
10001282:	46c0      	nop			; (mov r8, r8)
10001284:	40040200 	.word	0x40040200

10001288 <XMC_SCU_LockProtectedBits>:
#endif
}

/* API to lock protected bitfields from being modified */
void XMC_SCU_LockProtectedBits(void)
{
10001288:	b580      	push	{r7, lr}
1000128a:	af00      	add	r7, sp, #0
  SCU_GENERAL->PASSWD = SCU_GCU_PASSWD_PROT_ENABLE;
1000128c:	4b02      	ldr	r3, [pc, #8]	; (10001298 <XMC_SCU_LockProtectedBits+0x10>)
1000128e:	22c3      	movs	r2, #195	; 0xc3
10001290:	625a      	str	r2, [r3, #36]	; 0x24
}
10001292:	46bd      	mov	sp, r7
10001294:	bd80      	pop	{r7, pc}
10001296:	46c0      	nop			; (mov r8, r8)
10001298:	40010000 	.word	0x40010000

1000129c <XMC_SCU_UnlockProtectedBits>:

/* API to make protected bitfields available for modification */
void XMC_SCU_UnlockProtectedBits(void)
{
1000129c:	b580      	push	{r7, lr}
1000129e:	af00      	add	r7, sp, #0
  SCU_GENERAL->PASSWD = SCU_GCU_PASSWD_PROT_DISABLE;
100012a0:	4b05      	ldr	r3, [pc, #20]	; (100012b8 <XMC_SCU_UnlockProtectedBits+0x1c>)
100012a2:	22c0      	movs	r2, #192	; 0xc0
100012a4:	625a      	str	r2, [r3, #36]	; 0x24

  while (((SCU_GENERAL->PASSWD) & SCU_GENERAL_PASSWD_PROTS_Msk))
100012a6:	46c0      	nop			; (mov r8, r8)
100012a8:	4b03      	ldr	r3, [pc, #12]	; (100012b8 <XMC_SCU_UnlockProtectedBits+0x1c>)
100012aa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
100012ac:	2204      	movs	r2, #4
100012ae:	4013      	ands	r3, r2
100012b0:	d1fa      	bne.n	100012a8 <XMC_SCU_UnlockProtectedBits+0xc>
  {
    /* Loop until the lock is removed */
  }
}
100012b2:	46bd      	mov	sp, r7
100012b4:	bd80      	pop	{r7, pc}
100012b6:	46c0      	nop			; (mov r8, r8)
100012b8:	40010000 	.word	0x40010000

100012bc <XMC_SCU_CLOCK_Init>:
}


/* API which initializes the clock tree ofthe device */
void XMC_SCU_CLOCK_Init(const XMC_SCU_CLOCK_CONFIG_t *const config)
{
100012bc:	b580      	push	{r7, lr}
100012be:	b082      	sub	sp, #8
100012c0:	af00      	add	r7, sp, #0
100012c2:	6078      	str	r0, [r7, #4]
  /* Remove protection */
  XMC_SCU_UnlockProtectedBits();
100012c4:	f7ff ffea 	bl	1000129c <XMC_SCU_UnlockProtectedBits>
  SCU_CLK->CLKCR1 = (SCU_CLK->CLKCR1 & ~SCU_CLK_CLKCR1_DCLKSEL_Msk) |
                    config->dclk_src;

#endif
  /* Update PCLK selection mux. */
  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_PCLKSEL_Msk | SCU_CLK_CLKCR_RTCCLKSEL_Msk)) |
100012c8:	4a0c      	ldr	r2, [pc, #48]	; (100012fc <XMC_SCU_CLOCK_Init+0x40>)
100012ca:	4b0c      	ldr	r3, [pc, #48]	; (100012fc <XMC_SCU_CLOCK_Init+0x40>)
100012cc:	681b      	ldr	r3, [r3, #0]
100012ce:	490c      	ldr	r1, [pc, #48]	; (10001300 <XMC_SCU_CLOCK_Init+0x44>)
100012d0:	4019      	ands	r1, r3
                   config->rtc_src |
100012d2:	687b      	ldr	r3, [r7, #4]
100012d4:	689b      	ldr	r3, [r3, #8]
  SCU_CLK->CLKCR1 = (SCU_CLK->CLKCR1 & ~SCU_CLK_CLKCR1_DCLKSEL_Msk) |
                    config->dclk_src;

#endif
  /* Update PCLK selection mux. */
  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_PCLKSEL_Msk | SCU_CLK_CLKCR_RTCCLKSEL_Msk)) |
100012d6:	4319      	orrs	r1, r3
                   config->rtc_src |
                   config->pclk_src;
100012d8:	687b      	ldr	r3, [r7, #4]
100012da:	685b      	ldr	r3, [r3, #4]
                    config->dclk_src;

#endif
  /* Update PCLK selection mux. */
  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_PCLKSEL_Msk | SCU_CLK_CLKCR_RTCCLKSEL_Msk)) |
                   config->rtc_src |
100012dc:	430b      	orrs	r3, r1
  SCU_CLK->CLKCR1 = (SCU_CLK->CLKCR1 & ~SCU_CLK_CLKCR1_DCLKSEL_Msk) |
                    config->dclk_src;

#endif
  /* Update PCLK selection mux. */
  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_PCLKSEL_Msk | SCU_CLK_CLKCR_RTCCLKSEL_Msk)) |
100012de:	6013      	str	r3, [r2, #0]
                   config->rtc_src |
                   config->pclk_src;

  /* Close the lock opened above. */
  XMC_SCU_LockProtectedBits();
100012e0:	f7ff ffd2 	bl	10001288 <XMC_SCU_LockProtectedBits>

  /* Update the dividers now */
  XMC_SCU_CLOCK_ScaleMCLKFrequency(config->idiv, config->fdiv);
100012e4:	687b      	ldr	r3, [r7, #4]
100012e6:	785b      	ldrb	r3, [r3, #1]
100012e8:	1c1a      	adds	r2, r3, #0
100012ea:	687b      	ldr	r3, [r7, #4]
100012ec:	781b      	ldrb	r3, [r3, #0]
100012ee:	1c10      	adds	r0, r2, #0
100012f0:	1c19      	adds	r1, r3, #0
100012f2:	f000 f839 	bl	10001368 <XMC_SCU_CLOCK_ScaleMCLKFrequency>

}
100012f6:	46bd      	mov	sp, r7
100012f8:	b002      	add	sp, #8
100012fa:	bd80      	pop	{r7, pc}
100012fc:	40010300 	.word	0x40010300
10001300:	fff0ffff 	.word	0xfff0ffff

10001304 <XMC_SCU_CLOCK_UngatePeripheralClock>:
  XMC_SCU_LockProtectedBits();
}

/* API which ungates a clock note at its source */
void XMC_SCU_CLOCK_UngatePeripheralClock(const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)
{
10001304:	b580      	push	{r7, lr}
10001306:	b082      	sub	sp, #8
10001308:	af00      	add	r7, sp, #0
1000130a:	1c02      	adds	r2, r0, #0
1000130c:	1dbb      	adds	r3, r7, #6
1000130e:	801a      	strh	r2, [r3, #0]
  XMC_SCU_UnlockProtectedBits();
10001310:	f7ff ffc4 	bl	1000129c <XMC_SCU_UnlockProtectedBits>
  SCU_CLK->CGATCLR0 |= (uint32_t)peripheral;
10001314:	4b09      	ldr	r3, [pc, #36]	; (1000133c <XMC_SCU_CLOCK_UngatePeripheralClock+0x38>)
10001316:	4a09      	ldr	r2, [pc, #36]	; (1000133c <XMC_SCU_CLOCK_UngatePeripheralClock+0x38>)
10001318:	6911      	ldr	r1, [r2, #16]
1000131a:	1dba      	adds	r2, r7, #6
1000131c:	8812      	ldrh	r2, [r2, #0]
1000131e:	430a      	orrs	r2, r1
10001320:	611a      	str	r2, [r3, #16]
  while ((SCU_CLK->CLKCR) & SCU_CLK_CLKCR_VDDC2LOW_Msk)
10001322:	46c0      	nop			; (mov r8, r8)
10001324:	4b05      	ldr	r3, [pc, #20]	; (1000133c <XMC_SCU_CLOCK_UngatePeripheralClock+0x38>)
10001326:	681a      	ldr	r2, [r3, #0]
10001328:	2380      	movs	r3, #128	; 0x80
1000132a:	05db      	lsls	r3, r3, #23
1000132c:	4013      	ands	r3, r2
1000132e:	d1f9      	bne.n	10001324 <XMC_SCU_CLOCK_UngatePeripheralClock+0x20>
  {
    /* Wait voltage suply stabilization */
  }
  XMC_SCU_LockProtectedBits();
10001330:	f7ff ffaa 	bl	10001288 <XMC_SCU_LockProtectedBits>
}
10001334:	46bd      	mov	sp, r7
10001336:	b002      	add	sp, #8
10001338:	bd80      	pop	{r7, pc}
1000133a:	46c0      	nop			; (mov r8, r8)
1000133c:	40010300 	.word	0x40010300

10001340 <XMC_SCU_CLOCK_IsPeripheralClockGated>:

/* Checks the status of peripheral clock gating */
bool XMC_SCU_CLOCK_IsPeripheralClockGated(const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)
{
10001340:	b580      	push	{r7, lr}
10001342:	b082      	sub	sp, #8
10001344:	af00      	add	r7, sp, #0
10001346:	1c02      	adds	r2, r0, #0
10001348:	1dbb      	adds	r3, r7, #6
1000134a:	801a      	strh	r2, [r3, #0]
  return (bool)((SCU_CLK->CGATSTAT0 & peripheral) != 0);
1000134c:	4b05      	ldr	r3, [pc, #20]	; (10001364 <XMC_SCU_CLOCK_IsPeripheralClockGated+0x24>)
1000134e:	689b      	ldr	r3, [r3, #8]
10001350:	1dba      	adds	r2, r7, #6
10001352:	8812      	ldrh	r2, [r2, #0]
10001354:	4013      	ands	r3, r2
10001356:	1e5a      	subs	r2, r3, #1
10001358:	4193      	sbcs	r3, r2
1000135a:	b2db      	uxtb	r3, r3
}
1000135c:	1c18      	adds	r0, r3, #0
1000135e:	46bd      	mov	sp, r7
10001360:	b002      	add	sp, #8
10001362:	bd80      	pop	{r7, pc}
10001364:	40010300 	.word	0x40010300

10001368 <XMC_SCU_CLOCK_ScaleMCLKFrequency>:
}


/* A utility routine which updates the fractional dividers in steps */
void XMC_SCU_CLOCK_ScaleMCLKFrequency(uint32_t idiv, uint32_t fdiv)
{
10001368:	b580      	push	{r7, lr}
1000136a:	b084      	sub	sp, #16
1000136c:	af00      	add	r7, sp, #0
1000136e:	6078      	str	r0, [r7, #4]
10001370:	6039      	str	r1, [r7, #0]
  /* Find out current and target value of idiv */
  uint32_t curr_idiv;

  XMC_SCU_UnlockProtectedBits();
10001372:	f7ff ff93 	bl	1000129c <XMC_SCU_UnlockProtectedBits>

  /* Take a snapshot of value already programmed into IDIV */
  curr_idiv = (SCU_CLK->CLKCR & SCU_CLK_CLKCR_IDIV_Msk) >> SCU_CLK_CLKCR_IDIV_Pos;
10001376:	4b21      	ldr	r3, [pc, #132]	; (100013fc <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x94>)
10001378:	681a      	ldr	r2, [r3, #0]
1000137a:	23ff      	movs	r3, #255	; 0xff
1000137c:	021b      	lsls	r3, r3, #8
1000137e:	4013      	ands	r3, r2
10001380:	0a1b      	lsrs	r3, r3, #8
10001382:	60fb      	str	r3, [r7, #12]

  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_FDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
                   (uint32_t)((fdiv & 0xffU) << SCU_CLK_CLKCR_FDIV_Pos) |
                   (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);
#else
  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_FDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
10001384:	4b1d      	ldr	r3, [pc, #116]	; (100013fc <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x94>)
10001386:	4a1d      	ldr	r2, [pc, #116]	; (100013fc <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x94>)
10001388:	6812      	ldr	r2, [r2, #0]
1000138a:	491d      	ldr	r1, [pc, #116]	; (10001400 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x98>)
1000138c:	4011      	ands	r1, r2
1000138e:	683a      	ldr	r2, [r7, #0]
10001390:	430a      	orrs	r2, r1
                   (uint32_t)(fdiv << SCU_CLK_CLKCR_FDIV_Pos) |
10001392:	491c      	ldr	r1, [pc, #112]	; (10001404 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x9c>)
10001394:	430a      	orrs	r2, r1

  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_FDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
                   (uint32_t)((fdiv & 0xffU) << SCU_CLK_CLKCR_FDIV_Pos) |
                   (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);
#else
  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_FDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
10001396:	601a      	str	r2, [r3, #0]
                   (uint32_t)(fdiv << SCU_CLK_CLKCR_FDIV_Pos) |
                   (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);
#endif

  while ((SCU_CLK->CLKCR)& SCU_CLK_CLKCR_VDDC2LOW_Msk)
10001398:	46c0      	nop			; (mov r8, r8)
1000139a:	4b18      	ldr	r3, [pc, #96]	; (100013fc <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x94>)
1000139c:	681a      	ldr	r2, [r3, #0]
1000139e:	2380      	movs	r3, #128	; 0x80
100013a0:	05db      	lsls	r3, r3, #23
100013a2:	4013      	ands	r3, r2
100013a4:	d1f9      	bne.n	1000139a <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x32>
  {
    /* Spin until the core supply stabilizes */
  }

  if (curr_idiv <= idiv)
100013a6:	68fa      	ldr	r2, [r7, #12]
100013a8:	687b      	ldr	r3, [r7, #4]
100013aa:	429a      	cmp	r2, r3
100013ac:	d806      	bhi.n	100013bc <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x54>
  {
    /* Requested IDIV is greater than currently programmed IDIV. So downscale the frequency */
    XMC_SCU_CLOCK_lFrequencyDownScaling(curr_idiv, idiv);
100013ae:	68fa      	ldr	r2, [r7, #12]
100013b0:	687b      	ldr	r3, [r7, #4]
100013b2:	1c10      	adds	r0, r2, #0
100013b4:	1c19      	adds	r1, r3, #0
100013b6:	f000 f853 	bl	10001460 <XMC_SCU_CLOCK_lFrequencyDownScaling>
100013ba:	e005      	b.n	100013c8 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x60>
  }
  else
  {
    /* Requested IDIV is lower than currently programmed IDIV. So upscale the frequency */
    XMC_SCU_CLOCK_lFrequencyUpScaling(curr_idiv, idiv);
100013bc:	68fa      	ldr	r2, [r7, #12]
100013be:	687b      	ldr	r3, [r7, #4]
100013c0:	1c10      	adds	r0, r2, #0
100013c2:	1c19      	adds	r1, r3, #0
100013c4:	f000 f822 	bl	1000140c <XMC_SCU_CLOCK_lFrequencyUpScaling>
  }

  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
100013c8:	4b0c      	ldr	r3, [pc, #48]	; (100013fc <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x94>)
100013ca:	4a0c      	ldr	r2, [pc, #48]	; (100013fc <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x94>)
100013cc:	6812      	ldr	r2, [r2, #0]
100013ce:	490e      	ldr	r1, [pc, #56]	; (10001408 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xa0>)
100013d0:	4011      	ands	r1, r2
                   (uint32_t)(idiv << SCU_CLK_CLKCR_IDIV_Pos) | (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);
100013d2:	687a      	ldr	r2, [r7, #4]
100013d4:	0212      	lsls	r2, r2, #8
  {
    /* Requested IDIV is lower than currently programmed IDIV. So upscale the frequency */
    XMC_SCU_CLOCK_lFrequencyUpScaling(curr_idiv, idiv);
  }

  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
100013d6:	430a      	orrs	r2, r1
                   (uint32_t)(idiv << SCU_CLK_CLKCR_IDIV_Pos) | (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);
100013d8:	490a      	ldr	r1, [pc, #40]	; (10001404 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x9c>)
100013da:	430a      	orrs	r2, r1
  {
    /* Requested IDIV is lower than currently programmed IDIV. So upscale the frequency */
    XMC_SCU_CLOCK_lFrequencyUpScaling(curr_idiv, idiv);
  }

  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
100013dc:	601a      	str	r2, [r3, #0]
                   (uint32_t)(idiv << SCU_CLK_CLKCR_IDIV_Pos) | (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);

  while ((SCU_CLK->CLKCR) & SCU_CLK_CLKCR_VDDC2LOW_Msk)
100013de:	46c0      	nop			; (mov r8, r8)
100013e0:	4b06      	ldr	r3, [pc, #24]	; (100013fc <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x94>)
100013e2:	681a      	ldr	r2, [r3, #0]
100013e4:	2380      	movs	r3, #128	; 0x80
100013e6:	05db      	lsls	r3, r3, #23
100013e8:	4013      	ands	r3, r2
100013ea:	d1f9      	bne.n	100013e0 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x78>
  {
    /* Wait voltage suply stabilization */
  }

  XMC_SCU_LockProtectedBits();
100013ec:	f7ff ff4c 	bl	10001288 <XMC_SCU_LockProtectedBits>

  SystemCoreClockUpdate();
100013f0:	f7ff fe58 	bl	100010a4 <SystemCoreClockUpdate>

}
100013f4:	46bd      	mov	sp, r7
100013f6:	b004      	add	sp, #16
100013f8:	bd80      	pop	{r7, pc}
100013fa:	46c0      	nop			; (mov r8, r8)
100013fc:	40010300 	.word	0x40010300
10001400:	c00fff00 	.word	0xc00fff00
10001404:	3ff00000 	.word	0x3ff00000
10001408:	c00f00ff 	.word	0xc00f00ff

1000140c <XMC_SCU_CLOCK_lFrequencyUpScaling>:

/* Utility routine to perform frequency up scaling */
static void XMC_SCU_CLOCK_lFrequencyUpScaling(uint32_t curr_idiv, uint32_t target_idiv)
{
1000140c:	b580      	push	{r7, lr}
1000140e:	b082      	sub	sp, #8
10001410:	af00      	add	r7, sp, #0
10001412:	6078      	str	r0, [r7, #4]
10001414:	6039      	str	r1, [r7, #0]
  while (curr_idiv > (target_idiv * 4UL))
10001416:	e014      	b.n	10001442 <XMC_SCU_CLOCK_lFrequencyUpScaling+0x36>
  {
    curr_idiv = (uint32_t)(curr_idiv >> 2UL);   /* Divide by 4. */
10001418:	687b      	ldr	r3, [r7, #4]
1000141a:	089b      	lsrs	r3, r3, #2
1000141c:	607b      	str	r3, [r7, #4]

    SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
1000141e:	4b0d      	ldr	r3, [pc, #52]	; (10001454 <XMC_SCU_CLOCK_lFrequencyUpScaling+0x48>)
10001420:	4a0c      	ldr	r2, [pc, #48]	; (10001454 <XMC_SCU_CLOCK_lFrequencyUpScaling+0x48>)
10001422:	6812      	ldr	r2, [r2, #0]
10001424:	490c      	ldr	r1, [pc, #48]	; (10001458 <XMC_SCU_CLOCK_lFrequencyUpScaling+0x4c>)
10001426:	4011      	ands	r1, r2
                     (uint32_t)(curr_idiv << SCU_CLK_CLKCR_IDIV_Pos) |
10001428:	687a      	ldr	r2, [r7, #4]
1000142a:	0212      	lsls	r2, r2, #8
{
  while (curr_idiv > (target_idiv * 4UL))
  {
    curr_idiv = (uint32_t)(curr_idiv >> 2UL);   /* Divide by 4. */

    SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
1000142c:	430a      	orrs	r2, r1
                     (uint32_t)(curr_idiv << SCU_CLK_CLKCR_IDIV_Pos) |
1000142e:	490b      	ldr	r1, [pc, #44]	; (1000145c <XMC_SCU_CLOCK_lFrequencyUpScaling+0x50>)
10001430:	430a      	orrs	r2, r1
{
  while (curr_idiv > (target_idiv * 4UL))
  {
    curr_idiv = (uint32_t)(curr_idiv >> 2UL);   /* Divide by 4. */

    SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
10001432:	601a      	str	r2, [r3, #0]
                     (uint32_t)(curr_idiv << SCU_CLK_CLKCR_IDIV_Pos) |
                     (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);

    while (SCU_CLK->CLKCR & SCU_CLK_CLKCR_VDDC2LOW_Msk)
10001434:	46c0      	nop			; (mov r8, r8)
10001436:	4b07      	ldr	r3, [pc, #28]	; (10001454 <XMC_SCU_CLOCK_lFrequencyUpScaling+0x48>)
10001438:	681a      	ldr	r2, [r3, #0]
1000143a:	2380      	movs	r3, #128	; 0x80
1000143c:	05db      	lsls	r3, r3, #23
1000143e:	4013      	ands	r3, r2
10001440:	d1f9      	bne.n	10001436 <XMC_SCU_CLOCK_lFrequencyUpScaling+0x2a>
}

/* Utility routine to perform frequency up scaling */
static void XMC_SCU_CLOCK_lFrequencyUpScaling(uint32_t curr_idiv, uint32_t target_idiv)
{
  while (curr_idiv > (target_idiv * 4UL))
10001442:	683b      	ldr	r3, [r7, #0]
10001444:	009a      	lsls	r2, r3, #2
10001446:	687b      	ldr	r3, [r7, #4]
10001448:	429a      	cmp	r2, r3
1000144a:	d3e5      	bcc.n	10001418 <XMC_SCU_CLOCK_lFrequencyUpScaling+0xc>
    while (SCU_CLK->CLKCR & SCU_CLK_CLKCR_VDDC2LOW_Msk)
    {
      /* Wait voltage suply stabilization */
    }
  }
}
1000144c:	46bd      	mov	sp, r7
1000144e:	b002      	add	sp, #8
10001450:	bd80      	pop	{r7, pc}
10001452:	46c0      	nop			; (mov r8, r8)
10001454:	40010300 	.word	0x40010300
10001458:	c00f00ff 	.word	0xc00f00ff
1000145c:	3ff00000 	.word	0x3ff00000

10001460 <XMC_SCU_CLOCK_lFrequencyDownScaling>:

/* Utility routine to perform frequency down scaling */
static void XMC_SCU_CLOCK_lFrequencyDownScaling(uint32_t curr_idiv, uint32_t target_idiv)
{
10001460:	b580      	push	{r7, lr}
10001462:	b082      	sub	sp, #8
10001464:	af00      	add	r7, sp, #0
10001466:	6078      	str	r0, [r7, #4]
10001468:	6039      	str	r1, [r7, #0]

  while ((curr_idiv * 4UL) < target_idiv)
1000146a:	e019      	b.n	100014a0 <XMC_SCU_CLOCK_lFrequencyDownScaling+0x40>
  {
    if (0U == curr_idiv)
1000146c:	687b      	ldr	r3, [r7, #4]
1000146e:	2b00      	cmp	r3, #0
10001470:	d101      	bne.n	10001476 <XMC_SCU_CLOCK_lFrequencyDownScaling+0x16>
    {
      curr_idiv = 1U;
10001472:	2301      	movs	r3, #1
10001474:	607b      	str	r3, [r7, #4]
    }
    curr_idiv  = (uint32_t)(curr_idiv << 2UL);   /* Multiply by 4. */
10001476:	687b      	ldr	r3, [r7, #4]
10001478:	009b      	lsls	r3, r3, #2
1000147a:	607b      	str	r3, [r7, #4]
    SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
1000147c:	4b0c      	ldr	r3, [pc, #48]	; (100014b0 <XMC_SCU_CLOCK_lFrequencyDownScaling+0x50>)
1000147e:	4a0c      	ldr	r2, [pc, #48]	; (100014b0 <XMC_SCU_CLOCK_lFrequencyDownScaling+0x50>)
10001480:	6812      	ldr	r2, [r2, #0]
10001482:	490c      	ldr	r1, [pc, #48]	; (100014b4 <XMC_SCU_CLOCK_lFrequencyDownScaling+0x54>)
10001484:	4011      	ands	r1, r2
                     (uint32_t)(curr_idiv << SCU_CLK_CLKCR_IDIV_Pos) |
10001486:	687a      	ldr	r2, [r7, #4]
10001488:	0212      	lsls	r2, r2, #8
    if (0U == curr_idiv)
    {
      curr_idiv = 1U;
    }
    curr_idiv  = (uint32_t)(curr_idiv << 2UL);   /* Multiply by 4. */
    SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
1000148a:	430a      	orrs	r2, r1
                     (uint32_t)(curr_idiv << SCU_CLK_CLKCR_IDIV_Pos) |
1000148c:	490a      	ldr	r1, [pc, #40]	; (100014b8 <XMC_SCU_CLOCK_lFrequencyDownScaling+0x58>)
1000148e:	430a      	orrs	r2, r1
    if (0U == curr_idiv)
    {
      curr_idiv = 1U;
    }
    curr_idiv  = (uint32_t)(curr_idiv << 2UL);   /* Multiply by 4. */
    SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
10001490:	601a      	str	r2, [r3, #0]
                     (uint32_t)(curr_idiv << SCU_CLK_CLKCR_IDIV_Pos) |
                     (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);

    while (SCU_CLK->CLKCR & SCU_CLK_CLKCR_VDDC2LOW_Msk)
10001492:	46c0      	nop			; (mov r8, r8)
10001494:	4b06      	ldr	r3, [pc, #24]	; (100014b0 <XMC_SCU_CLOCK_lFrequencyDownScaling+0x50>)
10001496:	681a      	ldr	r2, [r3, #0]
10001498:	2380      	movs	r3, #128	; 0x80
1000149a:	05db      	lsls	r3, r3, #23
1000149c:	4013      	ands	r3, r2
1000149e:	d1f9      	bne.n	10001494 <XMC_SCU_CLOCK_lFrequencyDownScaling+0x34>

/* Utility routine to perform frequency down scaling */
static void XMC_SCU_CLOCK_lFrequencyDownScaling(uint32_t curr_idiv, uint32_t target_idiv)
{

  while ((curr_idiv * 4UL) < target_idiv)
100014a0:	687b      	ldr	r3, [r7, #4]
100014a2:	009a      	lsls	r2, r3, #2
100014a4:	683b      	ldr	r3, [r7, #0]
100014a6:	429a      	cmp	r2, r3
100014a8:	d3e0      	bcc.n	1000146c <XMC_SCU_CLOCK_lFrequencyDownScaling+0xc>
    while (SCU_CLK->CLKCR & SCU_CLK_CLKCR_VDDC2LOW_Msk)
    {
      /* Wait voltage suply stabilization */
    }
  }
}
100014aa:	46bd      	mov	sp, r7
100014ac:	b002      	add	sp, #8
100014ae:	bd80      	pop	{r7, pc}
100014b0:	40010300 	.word	0x40010300
100014b4:	c00f00ff 	.word	0xc00f00ff
100014b8:	3ff00000 	.word	0x3ff00000

100014bc <XMC_SCU_CLOCK_GetPeripheralClockFrequency>:

/*
 * API to retrieve clock frequency of peripherals on the peripheral bus using a shared functional clock
 */
uint32_t XMC_SCU_CLOCK_GetPeripheralClockFrequency(void)
{
100014bc:	b580      	push	{r7, lr}
100014be:	af00      	add	r7, sp, #0
  return (SystemCoreClock);
100014c0:	4b02      	ldr	r3, [pc, #8]	; (100014cc <XMC_SCU_CLOCK_GetPeripheralClockFrequency+0x10>)
100014c2:	681b      	ldr	r3, [r3, #0]
}
100014c4:	1c18      	adds	r0, r3, #0
100014c6:	46bd      	mov	sp, r7
100014c8:	bd80      	pop	{r7, pc}
100014ca:	46c0      	nop			; (mov r8, r8)
100014cc:	20003ffc 	.word	0x20003ffc

100014d0 <XMC_CCU4_StartPrescaler>:
 * \par<b>Related APIs:</b><br>
 * XMC_CCU4_Init()<BR> XMC_CCU4_EnableClock()<BR> XMC_CCU4_DisableClock()<BR> XMC_CCU4_StartPrescaler()<BR>
 * XMC_CCU4_StopPrescaler().
 */
__STATIC_INLINE void XMC_CCU4_StartPrescaler(XMC_CCU4_MODULE_t *const module)
{
100014d0:	b580      	push	{r7, lr}
100014d2:	b082      	sub	sp, #8
100014d4:	af00      	add	r7, sp, #0
100014d6:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_CCU4_StartPrescaler:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));
  module->GIDLC = (uint32_t) CCU4_GIDLC_SPRB_Msk;
100014d8:	687b      	ldr	r3, [r7, #4]
100014da:	2280      	movs	r2, #128	; 0x80
100014dc:	0052      	lsls	r2, r2, #1
100014de:	60da      	str	r2, [r3, #12]
}
100014e0:	46bd      	mov	sp, r7
100014e2:	b002      	add	sp, #8
100014e4:	bd80      	pop	{r7, pc}
100014e6:	46c0      	nop			; (mov r8, r8)

100014e8 <XMC_CCU4_lUngateClock>:
    XMC_ASSERT("XMC_CCU4_lGateClock:Invalid Module Pointer", 0);
  }
}

__STATIC_INLINE void XMC_CCU4_lUngateClock(const XMC_CCU4_MODULE_t *const module)
{
100014e8:	b580      	push	{r7, lr}
100014ea:	b082      	sub	sp, #8
100014ec:	af00      	add	r7, sp, #0
100014ee:	6078      	str	r0, [r7, #4]
  if (module == CCU40)
100014f0:	687b      	ldr	r3, [r7, #4]
100014f2:	4a04      	ldr	r2, [pc, #16]	; (10001504 <XMC_CCU4_lUngateClock+0x1c>)
100014f4:	4293      	cmp	r3, r2
100014f6:	d102      	bne.n	100014fe <XMC_CCU4_lUngateClock+0x16>
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU40);
100014f8:	2004      	movs	r0, #4
100014fa:	f7ff ff03 	bl	10001304 <XMC_SCU_CLOCK_UngatePeripheralClock>
#endif
  else
  {
    XMC_ASSERT("XMC_CCU4_lUngateClock:Invalid Module Pointer", 0);
  }
}
100014fe:	46bd      	mov	sp, r7
10001500:	b002      	add	sp, #8
10001502:	bd80      	pop	{r7, pc}
10001504:	48040000 	.word	0x48040000

10001508 <XMC_CCU4_EnableModule>:
/*********************************************************************************************************************
 * API IMPLEMENTATION
 ********************************************************************************************************************/

void XMC_CCU4_EnableModule(XMC_CCU4_MODULE_t *const module)
{
10001508:	b580      	push	{r7, lr}
1000150a:	b082      	sub	sp, #8
1000150c:	af00      	add	r7, sp, #0
1000150e:	6078      	str	r0, [r7, #4]
  /* Enable CCU4 module clock */
  XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_CCU);
#endif

#if defined(CLOCK_GATING_SUPPORTED)
  XMC_CCU4_lUngateClock(module);
10001510:	687b      	ldr	r3, [r7, #4]
10001512:	1c18      	adds	r0, r3, #0
10001514:	f7ff ffe8 	bl	100014e8 <XMC_CCU4_lUngateClock>
#endif

#if defined(PERIPHERAL_RESET_SUPPORTED)
  XMC_CCU4_lDeassertReset(module);
#endif
}
10001518:	46bd      	mov	sp, r7
1000151a:	b002      	add	sp, #8
1000151c:	bd80      	pop	{r7, pc}
1000151e:	46c0      	nop			; (mov r8, r8)

10001520 <XMC_CCU4_Init>:
#endif
}

/* API to initialize CCU4 global resources  */
void XMC_CCU4_Init(XMC_CCU4_MODULE_t *const module, const XMC_CCU4_SLICE_MCMS_ACTION_t mcs_action)
{
10001520:	b580      	push	{r7, lr}
10001522:	b084      	sub	sp, #16
10001524:	af00      	add	r7, sp, #0
10001526:	6078      	str	r0, [r7, #4]
10001528:	1c0a      	adds	r2, r1, #0
1000152a:	1cfb      	adds	r3, r7, #3
1000152c:	701a      	strb	r2, [r3, #0]

  XMC_ASSERT("XMC_CCU4_Init:Invalid module pointer", XMC_CCU4_IsValidModule(module));
  XMC_ASSERT("XMC_CCU4_Init:Invalid mcs action", XMC_CCU4_SLICE_CHECK_MCS_ACTION(mcs_action));

  /* Enable CCU4 module */
  XMC_CCU4_EnableModule(module);
1000152e:	687b      	ldr	r3, [r7, #4]
10001530:	1c18      	adds	r0, r3, #0
10001532:	f7ff ffe9 	bl	10001508 <XMC_CCU4_EnableModule>
  /* Start the prescaler */
  XMC_CCU4_StartPrescaler(module);
10001536:	687b      	ldr	r3, [r7, #4]
10001538:	1c18      	adds	r0, r3, #0
1000153a:	f7ff ffc9 	bl	100014d0 <XMC_CCU4_StartPrescaler>

  gctrl = module->GCTRL;
1000153e:	687b      	ldr	r3, [r7, #4]
10001540:	681b      	ldr	r3, [r3, #0]
10001542:	60fb      	str	r3, [r7, #12]
  gctrl &= ~((uint32_t) CCU4_GCTRL_MSDE_Msk);
10001544:	68fb      	ldr	r3, [r7, #12]
10001546:	4a07      	ldr	r2, [pc, #28]	; (10001564 <XMC_CCU4_Init+0x44>)
10001548:	4013      	ands	r3, r2
1000154a:	60fb      	str	r3, [r7, #12]
  gctrl |= ((uint32_t) mcs_action) << CCU4_GCTRL_MSDE_Pos;
1000154c:	1cfb      	adds	r3, r7, #3
1000154e:	781b      	ldrb	r3, [r3, #0]
10001550:	039b      	lsls	r3, r3, #14
10001552:	68fa      	ldr	r2, [r7, #12]
10001554:	4313      	orrs	r3, r2
10001556:	60fb      	str	r3, [r7, #12]

  module->GCTRL = gctrl;
10001558:	687b      	ldr	r3, [r7, #4]
1000155a:	68fa      	ldr	r2, [r7, #12]
1000155c:	601a      	str	r2, [r3, #0]
}
1000155e:	46bd      	mov	sp, r7
10001560:	b004      	add	sp, #16
10001562:	bd80      	pop	{r7, pc}
10001564:	ffff3fff 	.word	0xffff3fff

10001568 <XMC_CCU4_SLICE_CompareInit>:
}

/* API to configure CC4 Slice as Timer */
void XMC_CCU4_SLICE_CompareInit(XMC_CCU4_SLICE_t *const slice,
                                const XMC_CCU4_SLICE_COMPARE_CONFIG_t *const compare_init)
{
10001568:	b580      	push	{r7, lr}
1000156a:	b082      	sub	sp, #8
1000156c:	af00      	add	r7, sp, #0
1000156e:	6078      	str	r0, [r7, #4]
10001570:	6039      	str	r1, [r7, #0]
  XMC_ASSERT("XMC_CCU4_SLICE_CompareInit:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_CompareInit:Compare Init Pointer is NULL",
             (XMC_CCU4_SLICE_COMPARE_CONFIG_t *) NULL != compare_init);

  /* Program the timer mode */
  slice->TC = compare_init->tc;
10001572:	683b      	ldr	r3, [r7, #0]
10001574:	681a      	ldr	r2, [r3, #0]
10001576:	687b      	ldr	r3, [r7, #4]
10001578:	615a      	str	r2, [r3, #20]
  /* Enable the timer concatenation */
  slice->CMC = ((uint32_t) compare_init->timer_concatenation << CCU4_CC4_CMC_TCE_Pos);
1000157a:	683b      	ldr	r3, [r7, #0]
1000157c:	795b      	ldrb	r3, [r3, #5]
1000157e:	069b      	lsls	r3, r3, #26
10001580:	0fdb      	lsrs	r3, r3, #31
10001582:	b2db      	uxtb	r3, r3
10001584:	051a      	lsls	r2, r3, #20
10001586:	687b      	ldr	r3, [r7, #4]
10001588:	605a      	str	r2, [r3, #4]
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) compare_init->prescaler_initval;
1000158a:	683b      	ldr	r3, [r7, #0]
1000158c:	791b      	ldrb	r3, [r3, #4]
1000158e:	071b      	lsls	r3, r3, #28
10001590:	0f1b      	lsrs	r3, r3, #28
10001592:	b2db      	uxtb	r3, r3
10001594:	1c1a      	adds	r2, r3, #0
10001596:	687b      	ldr	r3, [r7, #4]
10001598:	625a      	str	r2, [r3, #36]	; 0x24
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
1000159a:	683b      	ldr	r3, [r7, #0]
1000159c:	795b      	ldrb	r3, [r3, #5]
1000159e:	071b      	lsls	r3, r3, #28
100015a0:	0f1b      	lsrs	r3, r3, #28
100015a2:	b2db      	uxtb	r3, r3
100015a4:	1c1a      	adds	r2, r3, #0
100015a6:	687b      	ldr	r3, [r7, #4]
100015a8:	621a      	str	r2, [r3, #32]
  /* Program timer output passive level */
  slice->PSL = (uint32_t) compare_init->passive_level;
100015aa:	683b      	ldr	r3, [r7, #0]
100015ac:	795b      	ldrb	r3, [r3, #5]
100015ae:	06db      	lsls	r3, r3, #27
100015b0:	0fdb      	lsrs	r3, r3, #31
100015b2:	b2db      	uxtb	r3, r3
100015b4:	1c1a      	adds	r2, r3, #0
100015b6:	687b      	ldr	r3, [r7, #4]
100015b8:	619a      	str	r2, [r3, #24]
  /* Program floating prescaler compare value */
  slice->FPCS = (uint32_t) compare_init->float_limit;
100015ba:	683b      	ldr	r3, [r7, #0]
100015bc:	791b      	ldrb	r3, [r3, #4]
100015be:	061b      	lsls	r3, r3, #24
100015c0:	0f1b      	lsrs	r3, r3, #28
100015c2:	b2db      	uxtb	r3, r3
100015c4:	1c1a      	adds	r2, r3, #0
100015c6:	687b      	ldr	r3, [r7, #4]
100015c8:	62da      	str	r2, [r3, #44]	; 0x2c
}
100015ca:	46bd      	mov	sp, r7
100015cc:	b002      	add	sp, #8
100015ce:	bd80      	pop	{r7, pc}

100015d0 <XMC_CCU4_SLICE_SetInterruptNode>:

/* Binds a capcom event to an NVIC node  */
void XMC_CCU4_SLICE_SetInterruptNode(XMC_CCU4_SLICE_t *const slice,
                                     const XMC_CCU4_SLICE_IRQ_ID_t event,
                                     const XMC_CCU4_SLICE_SR_ID_t sr)
{
100015d0:	b580      	push	{r7, lr}
100015d2:	b086      	sub	sp, #24
100015d4:	af00      	add	r7, sp, #0
100015d6:	6078      	str	r0, [r7, #4]
100015d8:	1c08      	adds	r0, r1, #0
100015da:	1c11      	adds	r1, r2, #0
100015dc:	1cfb      	adds	r3, r7, #3
100015de:	1c02      	adds	r2, r0, #0
100015e0:	701a      	strb	r2, [r3, #0]
100015e2:	1cbb      	adds	r3, r7, #2
100015e4:	1c0a      	adds	r2, r1, #0
100015e6:	701a      	strb	r2, [r3, #0]

  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid SR ID ", XMC_CCU4_SLICE_CHECK_SR_ID(sr));
  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid event", XMC_CCU4_SLICE_CHECK_INTERRUPT(event));

  switch (event)
100015e8:	1cfb      	adds	r3, r7, #3
100015ea:	781b      	ldrb	r3, [r3, #0]
100015ec:	2b0b      	cmp	r3, #11
100015ee:	d820      	bhi.n	10001632 <XMC_CCU4_SLICE_SetInterruptNode+0x62>
100015f0:	009a      	lsls	r2, r3, #2
100015f2:	4b20      	ldr	r3, [pc, #128]	; (10001674 <XMC_CCU4_SLICE_SetInterruptNode+0xa4>)
100015f4:	18d3      	adds	r3, r2, r3
100015f6:	681b      	ldr	r3, [r3, #0]
100015f8:	469f      	mov	pc, r3
  {
    case XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH:
    case XMC_CCU4_SLICE_IRQ_ID_ONE_MATCH:
      mask = ((uint32_t) CCU4_CC4_SRS_POSR_Msk);
100015fa:	2303      	movs	r3, #3
100015fc:	613b      	str	r3, [r7, #16]
      pos  = CCU4_CC4_SRS_POSR_Pos;
100015fe:	2300      	movs	r3, #0
10001600:	617b      	str	r3, [r7, #20]
      break;
10001602:	e01b      	b.n	1000163c <XMC_CCU4_SLICE_SetInterruptNode+0x6c>

    case XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_UP:
    case XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_DOWN:
      mask = ((uint32_t) CCU4_CC4_SRS_CMSR_Msk);
10001604:	230c      	movs	r3, #12
10001606:	613b      	str	r3, [r7, #16]
      pos  = CCU4_CC4_SRS_CMSR_Pos;
10001608:	2302      	movs	r3, #2
1000160a:	617b      	str	r3, [r7, #20]
      break;
1000160c:	e016      	b.n	1000163c <XMC_CCU4_SLICE_SetInterruptNode+0x6c>

    case XMC_CCU4_SLICE_IRQ_ID_EVENT0:
      mask = ((uint32_t) CCU4_CC4_SRS_E0SR_Msk);
1000160e:	23c0      	movs	r3, #192	; 0xc0
10001610:	009b      	lsls	r3, r3, #2
10001612:	613b      	str	r3, [r7, #16]
      pos  = CCU4_CC4_SRS_E0SR_Pos;
10001614:	2308      	movs	r3, #8
10001616:	617b      	str	r3, [r7, #20]
      break;
10001618:	e010      	b.n	1000163c <XMC_CCU4_SLICE_SetInterruptNode+0x6c>

    case XMC_CCU4_SLICE_IRQ_ID_EVENT1:
      mask = ((uint32_t) CCU4_CC4_SRS_E1SR_Msk);
1000161a:	23c0      	movs	r3, #192	; 0xc0
1000161c:	011b      	lsls	r3, r3, #4
1000161e:	613b      	str	r3, [r7, #16]
      pos  = CCU4_CC4_SRS_E1SR_Pos;
10001620:	230a      	movs	r3, #10
10001622:	617b      	str	r3, [r7, #20]
      break;
10001624:	e00a      	b.n	1000163c <XMC_CCU4_SLICE_SetInterruptNode+0x6c>

    case XMC_CCU4_SLICE_IRQ_ID_EVENT2:
    case XMC_CCU4_SLICE_IRQ_ID_TRAP:
      mask = ((uint32_t) CCU4_CC4_SRS_E2SR_Msk);
10001626:	23c0      	movs	r3, #192	; 0xc0
10001628:	019b      	lsls	r3, r3, #6
1000162a:	613b      	str	r3, [r7, #16]
      pos  = CCU4_CC4_SRS_E2SR_Pos;
1000162c:	230c      	movs	r3, #12
1000162e:	617b      	str	r3, [r7, #20]
      break;
10001630:	e004      	b.n	1000163c <XMC_CCU4_SLICE_SetInterruptNode+0x6c>
	  
	default:
	  mask = 0;
10001632:	2300      	movs	r3, #0
10001634:	613b      	str	r3, [r7, #16]
	  pos = 0;
10001636:	2300      	movs	r3, #0
10001638:	617b      	str	r3, [r7, #20]
	  break;
1000163a:	46c0      	nop			; (mov r8, r8)
  }

  if (mask != 0)
1000163c:	693b      	ldr	r3, [r7, #16]
1000163e:	2b00      	cmp	r3, #0
10001640:	d014      	beq.n	1000166c <XMC_CCU4_SLICE_SetInterruptNode+0x9c>
  {
    srs = slice->SRS;
10001642:	687b      	ldr	r3, [r7, #4]
10001644:	22a8      	movs	r2, #168	; 0xa8
10001646:	589b      	ldr	r3, [r3, r2]
10001648:	60fb      	str	r3, [r7, #12]
    srs &= ~mask;
1000164a:	693b      	ldr	r3, [r7, #16]
1000164c:	43da      	mvns	r2, r3
1000164e:	68fb      	ldr	r3, [r7, #12]
10001650:	4013      	ands	r3, r2
10001652:	60fb      	str	r3, [r7, #12]
    srs |= (uint32_t)sr << pos;
10001654:	1cbb      	adds	r3, r7, #2
10001656:	781a      	ldrb	r2, [r3, #0]
10001658:	697b      	ldr	r3, [r7, #20]
1000165a:	409a      	lsls	r2, r3
1000165c:	1c13      	adds	r3, r2, #0
1000165e:	68fa      	ldr	r2, [r7, #12]
10001660:	4313      	orrs	r3, r2
10001662:	60fb      	str	r3, [r7, #12]
    slice->SRS = srs;
10001664:	687b      	ldr	r3, [r7, #4]
10001666:	21a8      	movs	r1, #168	; 0xa8
10001668:	68fa      	ldr	r2, [r7, #12]
1000166a:	505a      	str	r2, [r3, r1]
  }
}
1000166c:	46bd      	mov	sp, r7
1000166e:	b006      	add	sp, #24
10001670:	bd80      	pop	{r7, pc}
10001672:	46c0      	nop			; (mov r8, r8)
10001674:	1000a55c 	.word	0x1000a55c

10001678 <XMC_GPIO_SetHardwareControl>:
  port->IOCR[(uint32_t)pin >> 2U] &= ~(uint32_t)((uint32_t)PORT_IOCR_PC_Msk << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U)));
  port->IOCR[(uint32_t)pin >> 2U] |= (uint32_t)mode << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U));
}

void XMC_GPIO_SetHardwareControl(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_HWCTRL_t hwctrl)
{
10001678:	b580      	push	{r7, lr}
1000167a:	b082      	sub	sp, #8
1000167c:	af00      	add	r7, sp, #0
1000167e:	6078      	str	r0, [r7, #4]
10001680:	1c08      	adds	r0, r1, #0
10001682:	1c11      	adds	r1, r2, #0
10001684:	1cfb      	adds	r3, r7, #3
10001686:	1c02      	adds	r2, r0, #0
10001688:	701a      	strb	r2, [r3, #0]
1000168a:	1cbb      	adds	r3, r7, #2
1000168c:	1c0a      	adds	r2, r1, #0
1000168e:	701a      	strb	r2, [r3, #0]
  XMC_ASSERT("XMC_GPIO_SetHardwareControl: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_SetHardwareControl: Invalid hwctrl", XMC_GPIO_CHECK_HWCTRL(hwctrl));

  port->HWSEL &= ~(uint32_t)((uint32_t)PORT_HWSEL_Msk << ((uint32_t)pin << 1U));
10001690:	687b      	ldr	r3, [r7, #4]
10001692:	6f5b      	ldr	r3, [r3, #116]	; 0x74
10001694:	1cfa      	adds	r2, r7, #3
10001696:	7812      	ldrb	r2, [r2, #0]
10001698:	0052      	lsls	r2, r2, #1
1000169a:	1c11      	adds	r1, r2, #0
1000169c:	2203      	movs	r2, #3
1000169e:	408a      	lsls	r2, r1
100016a0:	43d2      	mvns	r2, r2
100016a2:	401a      	ands	r2, r3
100016a4:	687b      	ldr	r3, [r7, #4]
100016a6:	675a      	str	r2, [r3, #116]	; 0x74
  port->HWSEL |= (uint32_t)hwctrl << ((uint32_t)pin << 1U);
100016a8:	687b      	ldr	r3, [r7, #4]
100016aa:	6f5a      	ldr	r2, [r3, #116]	; 0x74
100016ac:	1cbb      	adds	r3, r7, #2
100016ae:	781b      	ldrb	r3, [r3, #0]
100016b0:	1cf9      	adds	r1, r7, #3
100016b2:	7809      	ldrb	r1, [r1, #0]
100016b4:	0049      	lsls	r1, r1, #1
100016b6:	408b      	lsls	r3, r1
100016b8:	431a      	orrs	r2, r3
100016ba:	687b      	ldr	r3, [r7, #4]
100016bc:	675a      	str	r2, [r3, #116]	; 0x74
}
100016be:	46bd      	mov	sp, r7
100016c0:	b002      	add	sp, #8
100016c2:	bd80      	pop	{r7, pc}

100016c4 <XMC_USIC_CH_GetTransmitBufferStatus>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_SetDataOutputMode() \n\n\n
 */
__STATIC_INLINE XMC_USIC_CH_TBUF_STATUS_t XMC_USIC_CH_GetTransmitBufferStatus(XMC_USIC_CH_t *const channel)
{
100016c4:	b580      	push	{r7, lr}
100016c6:	b082      	sub	sp, #8
100016c8:	af00      	add	r7, sp, #0
100016ca:	6078      	str	r0, [r7, #4]
  return (XMC_USIC_CH_TBUF_STATUS_t)(channel->TCSR & USIC_CH_TCSR_TDV_Msk);
100016cc:	687b      	ldr	r3, [r7, #4]
100016ce:	6b9b      	ldr	r3, [r3, #56]	; 0x38
100016d0:	b2db      	uxtb	r3, r3
100016d2:	227f      	movs	r2, #127	; 0x7f
100016d4:	4393      	bics	r3, r2
100016d6:	b2db      	uxtb	r3, r3
}
100016d8:	1c18      	adds	r0, r3, #0
100016da:	46bd      	mov	sp, r7
100016dc:	b002      	add	sp, #8
100016de:	bd80      	pop	{r7, pc}

100016e0 <XMC_UART_CH_ClearStatusFlag>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_UART_CH_DisableEvent(),  XMC_UART_CH_GetStatusFlag()\n\n\n
 */
__STATIC_INLINE void XMC_UART_CH_ClearStatusFlag(XMC_USIC_CH_t *const channel, const uint32_t flag)
{
100016e0:	b580      	push	{r7, lr}
100016e2:	b082      	sub	sp, #8
100016e4:	af00      	add	r7, sp, #0
100016e6:	6078      	str	r0, [r7, #4]
100016e8:	6039      	str	r1, [r7, #0]
  channel->PSCR = flag;
100016ea:	687b      	ldr	r3, [r7, #4]
100016ec:	683a      	ldr	r2, [r7, #0]
100016ee:	64da      	str	r2, [r3, #76]	; 0x4c
}
100016f0:	46bd      	mov	sp, r7
100016f2:	b002      	add	sp, #8
100016f4:	bd80      	pop	{r7, pc}
100016f6:	46c0      	nop			; (mov r8, r8)

100016f8 <XMC_UART_CH_InitEx>:
/*********************************************************************************************************************
 * API IMPLEMENTATION
 *********************************************************************************************************************/

void XMC_UART_CH_InitEx(XMC_USIC_CH_t *channel, const XMC_UART_CH_CONFIG_t *const config, bool init_brg)
{
100016f8:	b580      	push	{r7, lr}
100016fa:	b086      	sub	sp, #24
100016fc:	af00      	add	r7, sp, #0
100016fe:	60f8      	str	r0, [r7, #12]
10001700:	60b9      	str	r1, [r7, #8]
10001702:	1dfb      	adds	r3, r7, #7
10001704:	701a      	strb	r2, [r3, #0]
  uint32_t oversampling = XMC_UART_CH_OVERSAMPLING;
10001706:	2310      	movs	r3, #16
10001708:	617b      	str	r3, [r7, #20]

  /* USIC channel switched on*/
  XMC_USIC_CH_Enable(channel);
1000170a:	68fb      	ldr	r3, [r7, #12]
1000170c:	1c18      	adds	r0, r3, #0
1000170e:	f000 f8af 	bl	10001870 <XMC_USIC_CH_Enable>

  if (config->oversampling != 0U)
10001712:	68bb      	ldr	r3, [r7, #8]
10001714:	7a1b      	ldrb	r3, [r3, #8]
10001716:	2b00      	cmp	r3, #0
10001718:	d002      	beq.n	10001720 <XMC_UART_CH_InitEx+0x28>
  {
    oversampling = (uint32_t)config->oversampling;
1000171a:	68bb      	ldr	r3, [r7, #8]
1000171c:	7a1b      	ldrb	r3, [r3, #8]
1000171e:	617b      	str	r3, [r7, #20]
  }

  if (init_brg)
10001720:	1dfb      	adds	r3, r7, #7
10001722:	781b      	ldrb	r3, [r3, #0]
10001724:	2b00      	cmp	r3, #0
10001726:	d016      	beq.n	10001756 <XMC_UART_CH_InitEx+0x5e>
  {
    /* Configure baud rate */
    if (config->normal_divider_mode)
10001728:	68bb      	ldr	r3, [r7, #8]
1000172a:	791b      	ldrb	r3, [r3, #4]
1000172c:	2b00      	cmp	r3, #0
1000172e:	d009      	beq.n	10001744 <XMC_UART_CH_InitEx+0x4c>
    {
      /* Normal divider mode */
      (void)XMC_USIC_CH_SetBaudrateEx(channel, config->baudrate, oversampling);
10001730:	68bb      	ldr	r3, [r7, #8]
10001732:	681b      	ldr	r3, [r3, #0]
10001734:	1c19      	adds	r1, r3, #0
10001736:	697b      	ldr	r3, [r7, #20]
10001738:	68fa      	ldr	r2, [r7, #12]
1000173a:	1c10      	adds	r0, r2, #0
1000173c:	1c1a      	adds	r2, r3, #0
1000173e:	f000 f939 	bl	100019b4 <XMC_USIC_CH_SetBaudrateEx>
10001742:	e008      	b.n	10001756 <XMC_UART_CH_InitEx+0x5e>
    }
    else
    {
      /* Fractional divider mode */
      (void)XMC_USIC_CH_SetBaudrate(channel, config->baudrate, oversampling);
10001744:	68bb      	ldr	r3, [r7, #8]
10001746:	681a      	ldr	r2, [r3, #0]
10001748:	68f9      	ldr	r1, [r7, #12]
1000174a:	697b      	ldr	r3, [r7, #20]
1000174c:	1c08      	adds	r0, r1, #0
1000174e:	1c11      	adds	r1, r2, #0
10001750:	1c1a      	adds	r2, r3, #0
10001752:	f000 f8b5 	bl	100018c0 <XMC_USIC_CH_SetBaudrate>
   * i.e. the 0 level is signaled during the complete bit time
   * Sampling point set equal to the half of the oversampling period
   * Enable Sample Majority Decision
   * Enable Transfer Status BUSY
   */
  channel->PCR_ASCMode = (uint32_t)(((config->stop_bits - 1UL) << USIC_CH_PCR_ASCMode_STPB_Pos) |
10001756:	68bb      	ldr	r3, [r7, #8]
10001758:	79db      	ldrb	r3, [r3, #7]
1000175a:	3b01      	subs	r3, #1
1000175c:	005a      	lsls	r2, r3, #1
                                    (((oversampling >> 1UL) + 1UL) << USIC_CH_PCR_ASCMode_SP_Pos) |
1000175e:	697b      	ldr	r3, [r7, #20]
10001760:	085b      	lsrs	r3, r3, #1
10001762:	3301      	adds	r3, #1
10001764:	021b      	lsls	r3, r3, #8
   * i.e. the 0 level is signaled during the complete bit time
   * Sampling point set equal to the half of the oversampling period
   * Enable Sample Majority Decision
   * Enable Transfer Status BUSY
   */
  channel->PCR_ASCMode = (uint32_t)(((config->stop_bits - 1UL) << USIC_CH_PCR_ASCMode_STPB_Pos) |
10001766:	4313      	orrs	r3, r2
10001768:	4a19      	ldr	r2, [pc, #100]	; (100017d0 <XMC_UART_CH_InitEx+0xd8>)
1000176a:	431a      	orrs	r2, r3
1000176c:	68fb      	ldr	r3, [r7, #12]
1000176e:	63da      	str	r2, [r3, #60]	; 0x3c
  /* Set passive data level, high
     Set word length. Data bits - 1
     If frame length is > 0, frame_lemgth-1; else, FLE = WLE (Data bits - 1)
     Transmission Mode: The shift control signal is considered active if it
     is at 1-level. This is the setting to be programmed to allow data transfers */
  channel->SCTR = (uint32_t)((((uint32_t)config->data_bits - 1UL) << USIC_CH_SCTR_WLE_Pos) |
10001770:	68bb      	ldr	r3, [r7, #8]
10001772:	795b      	ldrb	r3, [r3, #5]
10001774:	3b01      	subs	r3, #1
10001776:	061b      	lsls	r3, r3, #24
10001778:	2281      	movs	r2, #129	; 0x81
1000177a:	0052      	lsls	r2, r2, #1
1000177c:	431a      	orrs	r2, r3
1000177e:	68fb      	ldr	r3, [r7, #12]
10001780:	635a      	str	r2, [r3, #52]	; 0x34
                             ((0x1UL << USIC_CH_SCTR_TRM_Pos) | USIC_CH_SCTR_PDL_Msk));

  if (config->frame_length != 0U)
10001782:	68bb      	ldr	r3, [r7, #8]
10001784:	799b      	ldrb	r3, [r3, #6]
10001786:	2b00      	cmp	r3, #0
10001788:	d009      	beq.n	1000179e <XMC_UART_CH_InitEx+0xa6>
  {
    channel->SCTR |= (uint32_t)(((uint32_t)config->frame_length - 1UL) << USIC_CH_SCTR_FLE_Pos);
1000178a:	68fb      	ldr	r3, [r7, #12]
1000178c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
1000178e:	68bb      	ldr	r3, [r7, #8]
10001790:	799b      	ldrb	r3, [r3, #6]
10001792:	3b01      	subs	r3, #1
10001794:	041b      	lsls	r3, r3, #16
10001796:	431a      	orrs	r2, r3
10001798:	68fb      	ldr	r3, [r7, #12]
1000179a:	635a      	str	r2, [r3, #52]	; 0x34
1000179c:	e008      	b.n	100017b0 <XMC_UART_CH_InitEx+0xb8>
  }
  else
  {
    channel->SCTR |= (uint32_t)(((uint32_t)config->data_bits - 1UL) << USIC_CH_SCTR_FLE_Pos);
1000179e:	68fb      	ldr	r3, [r7, #12]
100017a0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
100017a2:	68bb      	ldr	r3, [r7, #8]
100017a4:	795b      	ldrb	r3, [r3, #5]
100017a6:	3b01      	subs	r3, #1
100017a8:	041b      	lsls	r3, r3, #16
100017aa:	431a      	orrs	r2, r3
100017ac:	68fb      	ldr	r3, [r7, #12]
100017ae:	635a      	str	r2, [r3, #52]	; 0x34
  }

  /* Enable transfer buffer */
  channel->TCSR = (0x1UL << USIC_CH_TCSR_TDEN_Pos) |
100017b0:	68fb      	ldr	r3, [r7, #12]
100017b2:	22a0      	movs	r2, #160	; 0xa0
100017b4:	00d2      	lsls	r2, r2, #3
100017b6:	639a      	str	r2, [r3, #56]	; 0x38
                  USIC_CH_TCSR_TDSSM_Msk;

  /* Clear protocol status */
  channel->PSCR = 0xFFFFFFFFUL;
100017b8:	68fb      	ldr	r3, [r7, #12]
100017ba:	2201      	movs	r2, #1
100017bc:	4252      	negs	r2, r2
100017be:	64da      	str	r2, [r3, #76]	; 0x4c

  /* Set parity settings */
  channel->CCR = (uint32_t)config->parity_mode;
100017c0:	68bb      	ldr	r3, [r7, #8]
100017c2:	895b      	ldrh	r3, [r3, #10]
100017c4:	1c1a      	adds	r2, r3, #0
100017c6:	68fb      	ldr	r3, [r7, #12]
100017c8:	641a      	str	r2, [r3, #64]	; 0x40
}
100017ca:	46bd      	mov	sp, r7
100017cc:	b006      	add	sp, #24
100017ce:	bd80      	pop	{r7, pc}
100017d0:	00030001 	.word	0x00030001

100017d4 <XMC_UART_CH_Transmit>:

  return (XMC_UART_CH_STATUS_t)status;
}

void XMC_UART_CH_Transmit(XMC_USIC_CH_t *const channel, const uint16_t data)
{
100017d4:	b580      	push	{r7, lr}
100017d6:	b082      	sub	sp, #8
100017d8:	af00      	add	r7, sp, #0
100017da:	6078      	str	r0, [r7, #4]
100017dc:	1c0a      	adds	r2, r1, #0
100017de:	1cbb      	adds	r3, r7, #2
100017e0:	801a      	strh	r2, [r3, #0]
  /* Check FIFO size */
  if ((channel->TBCTR & USIC_CH_TBCTR_SIZE_Msk) == 0UL)
100017e2:	687a      	ldr	r2, [r7, #4]
100017e4:	2384      	movs	r3, #132	; 0x84
100017e6:	005b      	lsls	r3, r3, #1
100017e8:	58d2      	ldr	r2, [r2, r3]
100017ea:	23e0      	movs	r3, #224	; 0xe0
100017ec:	04db      	lsls	r3, r3, #19
100017ee:	4013      	ands	r3, r2
100017f0:	d114      	bne.n	1000181c <XMC_UART_CH_Transmit+0x48>
  {
    /* Wait till the Transmit Buffer is free for transmission */
    while (XMC_USIC_CH_GetTransmitBufferStatus(channel) == XMC_USIC_CH_TBUF_STATUS_BUSY)
100017f2:	46c0      	nop			; (mov r8, r8)
100017f4:	687b      	ldr	r3, [r7, #4]
100017f6:	1c18      	adds	r0, r3, #0
100017f8:	f7ff ff64 	bl	100016c4 <XMC_USIC_CH_GetTransmitBufferStatus>
100017fc:	1e03      	subs	r3, r0, #0
100017fe:	2b80      	cmp	r3, #128	; 0x80
10001800:	d0f8      	beq.n	100017f4 <XMC_UART_CH_Transmit+0x20>
    {
    }

    /* Clear the Transmit Buffer indication flag */
    XMC_UART_CH_ClearStatusFlag(channel, (uint32_t)XMC_UART_CH_STATUS_FLAG_TRANSMIT_BUFFER_INDICATION);
10001802:	687a      	ldr	r2, [r7, #4]
10001804:	2380      	movs	r3, #128	; 0x80
10001806:	019b      	lsls	r3, r3, #6
10001808:	1c10      	adds	r0, r2, #0
1000180a:	1c19      	adds	r1, r3, #0
1000180c:	f7ff ff68 	bl	100016e0 <XMC_UART_CH_ClearStatusFlag>

    /*Transmit data */
    channel->TBUF[0U] = data;
10001810:	1cbb      	adds	r3, r7, #2
10001812:	881a      	ldrh	r2, [r3, #0]
10001814:	687b      	ldr	r3, [r7, #4]
10001816:	2180      	movs	r1, #128	; 0x80
10001818:	505a      	str	r2, [r3, r1]
1000181a:	e005      	b.n	10001828 <XMC_UART_CH_Transmit+0x54>
  }
  else
  {
    channel->IN[0U] = data;
1000181c:	1cbb      	adds	r3, r7, #2
1000181e:	8819      	ldrh	r1, [r3, #0]
10001820:	687a      	ldr	r2, [r7, #4]
10001822:	23c0      	movs	r3, #192	; 0xc0
10001824:	005b      	lsls	r3, r3, #1
10001826:	50d1      	str	r1, [r2, r3]
  }
}
10001828:	46bd      	mov	sp, r7
1000182a:	b002      	add	sp, #8
1000182c:	bd80      	pop	{r7, pc}
1000182e:	46c0      	nop			; (mov r8, r8)

10001830 <XMC_UART_CH_GetReceivedData>:

uint16_t XMC_UART_CH_GetReceivedData(XMC_USIC_CH_t *const channel)
{
10001830:	b580      	push	{r7, lr}
10001832:	b084      	sub	sp, #16
10001834:	af00      	add	r7, sp, #0
10001836:	6078      	str	r0, [r7, #4]
  uint16_t retval;

  /* Check FIFO size */
  if ((channel->RBCTR & USIC_CH_RBCTR_SIZE_Msk) == 0U)
10001838:	687a      	ldr	r2, [r7, #4]
1000183a:	2386      	movs	r3, #134	; 0x86
1000183c:	005b      	lsls	r3, r3, #1
1000183e:	58d2      	ldr	r2, [r2, r3]
10001840:	23e0      	movs	r3, #224	; 0xe0
10001842:	04db      	lsls	r3, r3, #19
10001844:	4013      	ands	r3, r2
10001846:	d105      	bne.n	10001854 <XMC_UART_CH_GetReceivedData+0x24>
  {
    retval = (uint16_t)channel->RBUF;
10001848:	687b      	ldr	r3, [r7, #4]
1000184a:	6d5a      	ldr	r2, [r3, #84]	; 0x54
1000184c:	230e      	movs	r3, #14
1000184e:	18fb      	adds	r3, r7, r3
10001850:	801a      	strh	r2, [r3, #0]
10001852:	e006      	b.n	10001862 <XMC_UART_CH_GetReceivedData+0x32>
  }
  else
  {
    retval = (uint16_t)channel->OUTR;
10001854:	687a      	ldr	r2, [r7, #4]
10001856:	238e      	movs	r3, #142	; 0x8e
10001858:	005b      	lsls	r3, r3, #1
1000185a:	58d2      	ldr	r2, [r2, r3]
1000185c:	230e      	movs	r3, #14
1000185e:	18fb      	adds	r3, r7, r3
10001860:	801a      	strh	r2, [r3, #0]
  }

  return retval;
10001862:	230e      	movs	r3, #14
10001864:	18fb      	adds	r3, r7, r3
10001866:	881b      	ldrh	r3, [r3, #0]
}
10001868:	1c18      	adds	r0, r3, #0
1000186a:	46bd      	mov	sp, r7
1000186c:	b004      	add	sp, #16
1000186e:	bd80      	pop	{r7, pc}

10001870 <XMC_USIC_CH_Enable>:
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

void XMC_USIC_CH_Enable(XMC_USIC_CH_t *const channel)
{
10001870:	b580      	push	{r7, lr}
10001872:	b082      	sub	sp, #8
10001874:	af00      	add	r7, sp, #0
10001876:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_USIC_CH_Enable: channel not valid", XMC_USIC_IsChannelValid(channel));

  if ((channel == XMC_USIC0_CH0) || (channel == XMC_USIC0_CH1))
10001878:	687a      	ldr	r2, [r7, #4]
1000187a:	2390      	movs	r3, #144	; 0x90
1000187c:	05db      	lsls	r3, r3, #23
1000187e:	429a      	cmp	r2, r3
10001880:	d003      	beq.n	1000188a <XMC_USIC_CH_Enable+0x1a>
10001882:	687b      	ldr	r3, [r7, #4]
10001884:	4a0c      	ldr	r2, [pc, #48]	; (100018b8 <XMC_USIC_CH_Enable+0x48>)
10001886:	4293      	cmp	r3, r2
10001888:	d103      	bne.n	10001892 <XMC_USIC_CH_Enable+0x22>
  {
    XMC_USIC_Enable(XMC_USIC0);
1000188a:	4b0c      	ldr	r3, [pc, #48]	; (100018bc <XMC_USIC_CH_Enable+0x4c>)
1000188c:	1c18      	adds	r0, r3, #0
1000188e:	f000 f9fb 	bl	10001c88 <XMC_USIC_Enable>
  {
    XMC_ASSERT("USIC module not available", 0U/*Always*/);
  }

  /* USIC channel switched on*/
  channel->KSCFG = (USIC_CH_KSCFG_MODEN_Msk | USIC_CH_KSCFG_BPMODEN_Msk);
10001892:	687b      	ldr	r3, [r7, #4]
10001894:	2203      	movs	r2, #3
10001896:	60da      	str	r2, [r3, #12]
  while ((channel->KSCFG & USIC_CH_KSCFG_MODEN_Msk) == 0U)
10001898:	46c0      	nop			; (mov r8, r8)
1000189a:	687b      	ldr	r3, [r7, #4]
1000189c:	68db      	ldr	r3, [r3, #12]
1000189e:	2201      	movs	r2, #1
100018a0:	4013      	ands	r3, r2
100018a2:	d0fa      	beq.n	1000189a <XMC_USIC_CH_Enable+0x2a>
  {
    /* Wait till the channel is enabled */
  }

  /* Set USIC channel in IDLE mode */
  channel->CCR &= (uint32_t)~USIC_CH_CCR_MODE_Msk;
100018a4:	687b      	ldr	r3, [r7, #4]
100018a6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
100018a8:	220f      	movs	r2, #15
100018aa:	4393      	bics	r3, r2
100018ac:	1c1a      	adds	r2, r3, #0
100018ae:	687b      	ldr	r3, [r7, #4]
100018b0:	641a      	str	r2, [r3, #64]	; 0x40
}
100018b2:	46bd      	mov	sp, r7
100018b4:	b002      	add	sp, #8
100018b6:	bd80      	pop	{r7, pc}
100018b8:	48000200 	.word	0x48000200
100018bc:	48000008 	.word	0x48000008

100018c0 <XMC_USIC_CH_SetBaudrate>:
{
  channel->KSCFG = (uint32_t)((channel->KSCFG & (~USIC_CH_KSCFG_MODEN_Msk)) | USIC_CH_KSCFG_BPMODEN_Msk);
}

XMC_USIC_CH_STATUS_t XMC_USIC_CH_SetBaudrate(XMC_USIC_CH_t *const channel, uint32_t rate, uint32_t oversampling)
{
100018c0:	b580      	push	{r7, lr}
100018c2:	b08e      	sub	sp, #56	; 0x38
100018c4:	af00      	add	r7, sp, #0
100018c6:	60f8      	str	r0, [r7, #12]
100018c8:	60b9      	str	r1, [r7, #8]
100018ca:	607a      	str	r2, [r7, #4]

  uint32_t pdiv_frac;
  uint32_t pdiv_frac_min;

  /* The rate and peripheral clock are divided by 100 to be able to use only 32bit arithmetic */
  if ((rate >= 100U) && (oversampling != 0U))
100018cc:	68bb      	ldr	r3, [r7, #8]
100018ce:	2b63      	cmp	r3, #99	; 0x63
100018d0:	d960      	bls.n	10001994 <XMC_USIC_CH_SetBaudrate+0xd4>
100018d2:	687b      	ldr	r3, [r7, #4]
100018d4:	2b00      	cmp	r3, #0
100018d6:	d05d      	beq.n	10001994 <XMC_USIC_CH_SetBaudrate+0xd4>
  {
    peripheral_clock = XMC_SCU_CLOCK_GetPeripheralClockFrequency() / 100U;
100018d8:	f7ff fdf0 	bl	100014bc <XMC_SCU_CLOCK_GetPeripheralClockFrequency>
100018dc:	1c03      	adds	r3, r0, #0
100018de:	1c18      	adds	r0, r3, #0
100018e0:	2164      	movs	r1, #100	; 0x64
100018e2:	f003 fec9 	bl	10005678 <__aeabi_uidiv>
100018e6:	1c03      	adds	r3, r0, #0
100018e8:	623b      	str	r3, [r7, #32]
    rate = rate / 100U;
100018ea:	68bb      	ldr	r3, [r7, #8]
100018ec:	1c18      	adds	r0, r3, #0
100018ee:	2164      	movs	r1, #100	; 0x64
100018f0:	f003 fec2 	bl	10005678 <__aeabi_uidiv>
100018f4:	1c03      	adds	r3, r0, #0
100018f6:	60bb      	str	r3, [r7, #8]

    clock_divider_min = 1024U;
100018f8:	2380      	movs	r3, #128	; 0x80
100018fa:	00db      	lsls	r3, r3, #3
100018fc:	62fb      	str	r3, [r7, #44]	; 0x2c
    pdiv_int_min = 1U;
100018fe:	2301      	movs	r3, #1
10001900:	62bb      	str	r3, [r7, #40]	; 0x28
    pdiv_frac_min = 0x3ffU;
10001902:	4b2a      	ldr	r3, [pc, #168]	; (100019ac <XMC_USIC_CH_SetBaudrate+0xec>)
10001904:	627b      	str	r3, [r7, #36]	; 0x24

    for (clock_divider = 1024U; clock_divider > 0U; --clock_divider)
10001906:	2380      	movs	r3, #128	; 0x80
10001908:	00db      	lsls	r3, r3, #3
1000190a:	633b      	str	r3, [r7, #48]	; 0x30
1000190c:	e025      	b.n	1000195a <XMC_USIC_CH_SetBaudrate+0x9a>
    {
      pdiv = ((peripheral_clock * clock_divider) / (rate * oversampling));
1000190e:	6a3b      	ldr	r3, [r7, #32]
10001910:	6b3a      	ldr	r2, [r7, #48]	; 0x30
10001912:	435a      	muls	r2, r3
10001914:	1c11      	adds	r1, r2, #0
10001916:	68bb      	ldr	r3, [r7, #8]
10001918:	687a      	ldr	r2, [r7, #4]
1000191a:	4353      	muls	r3, r2
1000191c:	1c08      	adds	r0, r1, #0
1000191e:	1c19      	adds	r1, r3, #0
10001920:	f003 feaa 	bl	10005678 <__aeabi_uidiv>
10001924:	1c03      	adds	r3, r0, #0
10001926:	61fb      	str	r3, [r7, #28]
      pdiv_int = pdiv >> 10U;
10001928:	69fb      	ldr	r3, [r7, #28]
1000192a:	0a9b      	lsrs	r3, r3, #10
1000192c:	61bb      	str	r3, [r7, #24]
      pdiv_frac = pdiv & 0x3ffU;
1000192e:	69fb      	ldr	r3, [r7, #28]
10001930:	059b      	lsls	r3, r3, #22
10001932:	0d9b      	lsrs	r3, r3, #22
10001934:	617b      	str	r3, [r7, #20]

      if ((pdiv_int <= 1024U) && (pdiv_frac < pdiv_frac_min))
10001936:	69ba      	ldr	r2, [r7, #24]
10001938:	2380      	movs	r3, #128	; 0x80
1000193a:	00db      	lsls	r3, r3, #3
1000193c:	429a      	cmp	r2, r3
1000193e:	d809      	bhi.n	10001954 <XMC_USIC_CH_SetBaudrate+0x94>
10001940:	697a      	ldr	r2, [r7, #20]
10001942:	6a7b      	ldr	r3, [r7, #36]	; 0x24
10001944:	429a      	cmp	r2, r3
10001946:	d205      	bcs.n	10001954 <XMC_USIC_CH_SetBaudrate+0x94>
      {
        pdiv_frac_min = pdiv_frac;
10001948:	697b      	ldr	r3, [r7, #20]
1000194a:	627b      	str	r3, [r7, #36]	; 0x24
        pdiv_int_min = pdiv_int;
1000194c:	69bb      	ldr	r3, [r7, #24]
1000194e:	62bb      	str	r3, [r7, #40]	; 0x28
        clock_divider_min = clock_divider;
10001950:	6b3b      	ldr	r3, [r7, #48]	; 0x30
10001952:	62fb      	str	r3, [r7, #44]	; 0x2c

    clock_divider_min = 1024U;
    pdiv_int_min = 1U;
    pdiv_frac_min = 0x3ffU;

    for (clock_divider = 1024U; clock_divider > 0U; --clock_divider)
10001954:	6b3b      	ldr	r3, [r7, #48]	; 0x30
10001956:	3b01      	subs	r3, #1
10001958:	633b      	str	r3, [r7, #48]	; 0x30
1000195a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
1000195c:	2b00      	cmp	r3, #0
1000195e:	d1d6      	bne.n	1000190e <XMC_USIC_CH_SetBaudrate+0x4e>
        clock_divider_min = clock_divider;
      }
    }

    channel->FDR = XMC_USIC_CH_BRG_CLOCK_DIVIDER_MODE_FRACTIONAL |
                   ((clock_divider_min - 1) << USIC_CH_FDR_STEP_Pos);
10001960:	6afb      	ldr	r3, [r7, #44]	; 0x2c
10001962:	3b01      	subs	r3, #1
        pdiv_int_min = pdiv_int;
        clock_divider_min = clock_divider;
      }
    }

    channel->FDR = XMC_USIC_CH_BRG_CLOCK_DIVIDER_MODE_FRACTIONAL |
10001964:	2280      	movs	r2, #128	; 0x80
10001966:	0212      	lsls	r2, r2, #8
10001968:	431a      	orrs	r2, r3
1000196a:	68fb      	ldr	r3, [r7, #12]
1000196c:	611a      	str	r2, [r3, #16]
                   ((clock_divider_min - 1) << USIC_CH_FDR_STEP_Pos);

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
1000196e:	68fb      	ldr	r3, [r7, #12]
10001970:	695b      	ldr	r3, [r3, #20]
10001972:	4a0f      	ldr	r2, [pc, #60]	; (100019b0 <XMC_USIC_CH_SetBaudrate+0xf0>)
10001974:	401a      	ands	r2, r3
                                     USIC_CH_BRG_PDIV_Msk |
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
10001976:	687b      	ldr	r3, [r7, #4]
10001978:	3b01      	subs	r3, #1
1000197a:	029b      	lsls	r3, r3, #10
                   ((clock_divider_min - 1) << USIC_CH_FDR_STEP_Pos);

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
                                     USIC_CH_BRG_PDIV_Msk |
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
1000197c:	431a      	orrs	r2, r3
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
                   ((pdiv_int_min - 1U) << USIC_CH_BRG_PDIV_Pos);
1000197e:	6abb      	ldr	r3, [r7, #40]	; 0x28
10001980:	3b01      	subs	r3, #1
10001982:	041b      	lsls	r3, r3, #16

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
                                     USIC_CH_BRG_PDIV_Msk |
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
10001984:	431a      	orrs	r2, r3
    }

    channel->FDR = XMC_USIC_CH_BRG_CLOCK_DIVIDER_MODE_FRACTIONAL |
                   ((clock_divider_min - 1) << USIC_CH_FDR_STEP_Pos);

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
10001986:	68fb      	ldr	r3, [r7, #12]
10001988:	615a      	str	r2, [r3, #20]
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
                   ((pdiv_int_min - 1U) << USIC_CH_BRG_PDIV_Pos);

    status = XMC_USIC_CH_STATUS_OK;
1000198a:	2337      	movs	r3, #55	; 0x37
1000198c:	18fb      	adds	r3, r7, r3
1000198e:	2200      	movs	r2, #0
10001990:	701a      	strb	r2, [r3, #0]
10001992:	e003      	b.n	1000199c <XMC_USIC_CH_SetBaudrate+0xdc>
  }
  else
  {
    status = XMC_USIC_CH_STATUS_ERROR;
10001994:	2337      	movs	r3, #55	; 0x37
10001996:	18fb      	adds	r3, r7, r3
10001998:	2201      	movs	r2, #1
1000199a:	701a      	strb	r2, [r3, #0]
  }

  return status;
1000199c:	2337      	movs	r3, #55	; 0x37
1000199e:	18fb      	adds	r3, r7, r3
100019a0:	781b      	ldrb	r3, [r3, #0]
}
100019a2:	1c18      	adds	r0, r3, #0
100019a4:	46bd      	mov	sp, r7
100019a6:	b00e      	add	sp, #56	; 0x38
100019a8:	bd80      	pop	{r7, pc}
100019aa:	46c0      	nop			; (mov r8, r8)
100019ac:	000003ff 	.word	0x000003ff
100019b0:	fc0080ef 	.word	0xfc0080ef

100019b4 <XMC_USIC_CH_SetBaudrateEx>:

XMC_USIC_CH_STATUS_t XMC_USIC_CH_SetBaudrateEx(XMC_USIC_CH_t *const channel, int32_t rate, int32_t oversampling)
{
100019b4:	b580      	push	{r7, lr}
100019b6:	b08c      	sub	sp, #48	; 0x30
100019b8:	af00      	add	r7, sp, #0
100019ba:	60f8      	str	r0, [r7, #12]
100019bc:	60b9      	str	r1, [r7, #8]
100019be:	607a      	str	r2, [r7, #4]
  int32_t peripheral_clock = XMC_SCU_CLOCK_GetPeripheralClockFrequency();
100019c0:	f7ff fd7c 	bl	100014bc <XMC_SCU_CLOCK_GetPeripheralClockFrequency>
100019c4:	1c03      	adds	r3, r0, #0
100019c6:	623b      	str	r3, [r7, #32]
  int32_t brg_clock = rate * oversampling;
100019c8:	68bb      	ldr	r3, [r7, #8]
100019ca:	687a      	ldr	r2, [r7, #4]
100019cc:	4353      	muls	r3, r2
100019ce:	61fb      	str	r3, [r7, #28]
  int32_t actual_rate_upper;
  int32_t actual_rate_lower;
  uint32_t pdiv = 1;
100019d0:	2301      	movs	r3, #1
100019d2:	62fb      	str	r3, [r7, #44]	; 0x2c
  uint32_t divider_step;
  XMC_USIC_CH_STATUS_t status;

  if (peripheral_clock > brg_clock)
100019d4:	6a3a      	ldr	r2, [r7, #32]
100019d6:	69fb      	ldr	r3, [r7, #28]
100019d8:	429a      	cmp	r2, r3
100019da:	dd62      	ble.n	10001aa2 <XMC_USIC_CH_SetBaudrateEx+0xee>
  {
    divider_step = peripheral_clock / brg_clock; // integer division gets truncated
100019dc:	6a38      	ldr	r0, [r7, #32]
100019de:	69f9      	ldr	r1, [r7, #28]
100019e0:	f003 feda 	bl	10005798 <__aeabi_idiv>
100019e4:	1c03      	adds	r3, r0, #0
100019e6:	62bb      	str	r3, [r7, #40]	; 0x28
    while (divider_step >= 1023)
100019e8:	e00f      	b.n	10001a0a <XMC_USIC_CH_SetBaudrateEx+0x56>
    {
      pdiv++;
100019ea:	6afb      	ldr	r3, [r7, #44]	; 0x2c
100019ec:	3301      	adds	r3, #1
100019ee:	62fb      	str	r3, [r7, #44]	; 0x2c
      brg_clock = rate * oversampling * pdiv;
100019f0:	68bb      	ldr	r3, [r7, #8]
100019f2:	687a      	ldr	r2, [r7, #4]
100019f4:	4353      	muls	r3, r2
100019f6:	1c1a      	adds	r2, r3, #0
100019f8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
100019fa:	4353      	muls	r3, r2
100019fc:	61fb      	str	r3, [r7, #28]
      divider_step = peripheral_clock / brg_clock; // integer division gets truncated
100019fe:	6a38      	ldr	r0, [r7, #32]
10001a00:	69f9      	ldr	r1, [r7, #28]
10001a02:	f003 fec9 	bl	10005798 <__aeabi_idiv>
10001a06:	1c03      	adds	r3, r0, #0
10001a08:	62bb      	str	r3, [r7, #40]	; 0x28
  XMC_USIC_CH_STATUS_t status;

  if (peripheral_clock > brg_clock)
  {
    divider_step = peripheral_clock / brg_clock; // integer division gets truncated
    while (divider_step >= 1023)
10001a0a:	6abb      	ldr	r3, [r7, #40]	; 0x28
10001a0c:	4a2a      	ldr	r2, [pc, #168]	; (10001ab8 <XMC_USIC_CH_SetBaudrateEx+0x104>)
10001a0e:	4293      	cmp	r3, r2
10001a10:	d8eb      	bhi.n	100019ea <XMC_USIC_CH_SetBaudrateEx+0x36>
    {
      pdiv++;
      brg_clock = rate * oversampling * pdiv;
      divider_step = peripheral_clock / brg_clock; // integer division gets truncated
    }
    actual_rate_upper = peripheral_clock / (divider_step * oversampling * pdiv);
10001a12:	6a39      	ldr	r1, [r7, #32]
10001a14:	687b      	ldr	r3, [r7, #4]
10001a16:	6aba      	ldr	r2, [r7, #40]	; 0x28
10001a18:	4353      	muls	r3, r2
10001a1a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
10001a1c:	4353      	muls	r3, r2
10001a1e:	1c08      	adds	r0, r1, #0
10001a20:	1c19      	adds	r1, r3, #0
10001a22:	f003 fe29 	bl	10005678 <__aeabi_uidiv>
10001a26:	1c03      	adds	r3, r0, #0
10001a28:	61bb      	str	r3, [r7, #24]
    actual_rate_lower = peripheral_clock / ((divider_step + 1) * oversampling * pdiv);
10001a2a:	6a39      	ldr	r1, [r7, #32]
10001a2c:	6abb      	ldr	r3, [r7, #40]	; 0x28
10001a2e:	3301      	adds	r3, #1
10001a30:	687a      	ldr	r2, [r7, #4]
10001a32:	4353      	muls	r3, r2
10001a34:	6afa      	ldr	r2, [r7, #44]	; 0x2c
10001a36:	4353      	muls	r3, r2
10001a38:	1c08      	adds	r0, r1, #0
10001a3a:	1c19      	adds	r1, r3, #0
10001a3c:	f003 fe1c 	bl	10005678 <__aeabi_uidiv>
10001a40:	1c03      	adds	r3, r0, #0
10001a42:	617b      	str	r3, [r7, #20]

    // choose better approximation if the peripheral frequency is not a multiple of the baudrate
    if (abs(rate - actual_rate_lower) < abs(rate - actual_rate_upper))
10001a44:	68ba      	ldr	r2, [r7, #8]
10001a46:	697b      	ldr	r3, [r7, #20]
10001a48:	1ad3      	subs	r3, r2, r3
10001a4a:	17d9      	asrs	r1, r3, #31
10001a4c:	185a      	adds	r2, r3, r1
10001a4e:	404a      	eors	r2, r1
10001a50:	68b9      	ldr	r1, [r7, #8]
10001a52:	69bb      	ldr	r3, [r7, #24]
10001a54:	1acb      	subs	r3, r1, r3
10001a56:	17d9      	asrs	r1, r3, #31
10001a58:	185b      	adds	r3, r3, r1
10001a5a:	404b      	eors	r3, r1
10001a5c:	429a      	cmp	r2, r3
10001a5e:	da02      	bge.n	10001a66 <XMC_USIC_CH_SetBaudrateEx+0xb2>
    {
      divider_step += 1;
10001a60:	6abb      	ldr	r3, [r7, #40]	; 0x28
10001a62:	3301      	adds	r3, #1
10001a64:	62bb      	str	r3, [r7, #40]	; 0x28
    }

    divider_step = 1024 - divider_step;
10001a66:	6abb      	ldr	r3, [r7, #40]	; 0x28
10001a68:	2280      	movs	r2, #128	; 0x80
10001a6a:	00d2      	lsls	r2, r2, #3
10001a6c:	1ad3      	subs	r3, r2, r3
10001a6e:	62bb      	str	r3, [r7, #40]	; 0x28


    channel->FDR = XMC_USIC_CH_BRG_CLOCK_DIVIDER_MODE_NORMAL |
10001a70:	6abb      	ldr	r3, [r7, #40]	; 0x28
10001a72:	2280      	movs	r2, #128	; 0x80
10001a74:	01d2      	lsls	r2, r2, #7
10001a76:	431a      	orrs	r2, r3
10001a78:	68fb      	ldr	r3, [r7, #12]
10001a7a:	611a      	str	r2, [r3, #16]
                   (divider_step << USIC_CH_FDR_STEP_Pos);

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
10001a7c:	68fb      	ldr	r3, [r7, #12]
10001a7e:	695b      	ldr	r3, [r3, #20]
10001a80:	4a0e      	ldr	r2, [pc, #56]	; (10001abc <XMC_USIC_CH_SetBaudrateEx+0x108>)
10001a82:	401a      	ands	r2, r3
                                     USIC_CH_BRG_PDIV_Msk |
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
10001a84:	687b      	ldr	r3, [r7, #4]
10001a86:	3b01      	subs	r3, #1
10001a88:	029b      	lsls	r3, r3, #10
                   (divider_step << USIC_CH_FDR_STEP_Pos);

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
                                     USIC_CH_BRG_PDIV_Msk |
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
10001a8a:	431a      	orrs	r2, r3
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
                   ((pdiv - 1) << USIC_CH_BRG_PDIV_Pos);
10001a8c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
10001a8e:	3b01      	subs	r3, #1
10001a90:	041b      	lsls	r3, r3, #16

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
                                     USIC_CH_BRG_PDIV_Msk |
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
10001a92:	431a      	orrs	r2, r3


    channel->FDR = XMC_USIC_CH_BRG_CLOCK_DIVIDER_MODE_NORMAL |
                   (divider_step << USIC_CH_FDR_STEP_Pos);

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
10001a94:	68fb      	ldr	r3, [r7, #12]
10001a96:	615a      	str	r2, [r3, #20]
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
                   ((pdiv - 1) << USIC_CH_BRG_PDIV_Pos);

    status = XMC_USIC_CH_STATUS_OK;
10001a98:	2327      	movs	r3, #39	; 0x27
10001a9a:	18fb      	adds	r3, r7, r3
10001a9c:	2200      	movs	r2, #0
10001a9e:	701a      	strb	r2, [r3, #0]
10001aa0:	e003      	b.n	10001aaa <XMC_USIC_CH_SetBaudrateEx+0xf6>
  }
  else
  {
    status = XMC_USIC_CH_STATUS_ERROR;
10001aa2:	2327      	movs	r3, #39	; 0x27
10001aa4:	18fb      	adds	r3, r7, r3
10001aa6:	2201      	movs	r2, #1
10001aa8:	701a      	strb	r2, [r3, #0]
  }

  return status;
10001aaa:	2327      	movs	r3, #39	; 0x27
10001aac:	18fb      	adds	r3, r7, r3
10001aae:	781b      	ldrb	r3, [r3, #0]
}
10001ab0:	1c18      	adds	r0, r3, #0
10001ab2:	46bd      	mov	sp, r7
10001ab4:	b00c      	add	sp, #48	; 0x30
10001ab6:	bd80      	pop	{r7, pc}
10001ab8:	000003fe 	.word	0x000003fe
10001abc:	fc0080ef 	.word	0xfc0080ef

10001ac0 <XMC_USIC_CH_TXFIFO_Configure>:

void XMC_USIC_CH_TXFIFO_Configure(XMC_USIC_CH_t *const channel,
                                  const uint32_t data_pointer,
                                  const XMC_USIC_CH_FIFO_SIZE_t size,
                                  const uint32_t limit)
{
10001ac0:	b580      	push	{r7, lr}
10001ac2:	b084      	sub	sp, #16
10001ac4:	af00      	add	r7, sp, #0
10001ac6:	60f8      	str	r0, [r7, #12]
10001ac8:	60b9      	str	r1, [r7, #8]
10001aca:	603b      	str	r3, [r7, #0]
10001acc:	1dfb      	adds	r3, r7, #7
10001ace:	701a      	strb	r2, [r3, #0]
  /* Disable FIFO */
  channel->TBCTR &= (uint32_t)~USIC_CH_TBCTR_SIZE_Msk;
10001ad0:	68fa      	ldr	r2, [r7, #12]
10001ad2:	2384      	movs	r3, #132	; 0x84
10001ad4:	005b      	lsls	r3, r3, #1
10001ad6:	58d3      	ldr	r3, [r2, r3]
10001ad8:	4a0e      	ldr	r2, [pc, #56]	; (10001b14 <XMC_USIC_CH_TXFIFO_Configure+0x54>)
10001ada:	4013      	ands	r3, r2
10001adc:	1c19      	adds	r1, r3, #0
10001ade:	68fa      	ldr	r2, [r7, #12]
10001ae0:	2384      	movs	r3, #132	; 0x84
10001ae2:	005b      	lsls	r3, r3, #1
10001ae4:	50d1      	str	r1, [r2, r3]
  /* LOF = 0, A standard transmit buffer event occurs when the filling level equals the limit value and gets
   * lower due to transmission of a data word
   * STBTEN = 0, the trigger of the standard transmit buffer event is based on the transition of the fill level
   *  from equal to below the limit, not the fact being below
   */
  channel->TBCTR = (uint32_t)(channel->TBCTR & (uint32_t)~(USIC_CH_TBCTR_LIMIT_Msk |
10001ae6:	68fa      	ldr	r2, [r7, #12]
10001ae8:	2384      	movs	r3, #132	; 0x84
10001aea:	005b      	lsls	r3, r3, #1
10001aec:	58d3      	ldr	r3, [r2, r3]
10001aee:	4a0a      	ldr	r2, [pc, #40]	; (10001b18 <XMC_USIC_CH_TXFIFO_Configure+0x58>)
10001af0:	401a      	ands	r2, r3
                              USIC_CH_TBCTR_DPTR_Msk |
                              USIC_CH_TBCTR_SIZE_Msk)) |
                   (uint32_t)((limit << USIC_CH_TBCTR_LIMIT_Pos) |
10001af2:	683b      	ldr	r3, [r7, #0]
10001af4:	0219      	lsls	r1, r3, #8
10001af6:	68bb      	ldr	r3, [r7, #8]
10001af8:	4319      	orrs	r1, r3
                              (data_pointer << USIC_CH_TBCTR_DPTR_Pos) |
                              ((uint32_t)size << USIC_CH_TBCTR_SIZE_Pos));
10001afa:	1dfb      	adds	r3, r7, #7
10001afc:	781b      	ldrb	r3, [r3, #0]
10001afe:	061b      	lsls	r3, r3, #24
   *  from equal to below the limit, not the fact being below
   */
  channel->TBCTR = (uint32_t)(channel->TBCTR & (uint32_t)~(USIC_CH_TBCTR_LIMIT_Msk |
                              USIC_CH_TBCTR_DPTR_Msk |
                              USIC_CH_TBCTR_SIZE_Msk)) |
                   (uint32_t)((limit << USIC_CH_TBCTR_LIMIT_Pos) |
10001b00:	430b      	orrs	r3, r1
   * STBTEN = 0, the trigger of the standard transmit buffer event is based on the transition of the fill level
   *  from equal to below the limit, not the fact being below
   */
  channel->TBCTR = (uint32_t)(channel->TBCTR & (uint32_t)~(USIC_CH_TBCTR_LIMIT_Msk |
                              USIC_CH_TBCTR_DPTR_Msk |
                              USIC_CH_TBCTR_SIZE_Msk)) |
10001b02:	431a      	orrs	r2, r3
10001b04:	1c11      	adds	r1, r2, #0
  /* LOF = 0, A standard transmit buffer event occurs when the filling level equals the limit value and gets
   * lower due to transmission of a data word
   * STBTEN = 0, the trigger of the standard transmit buffer event is based on the transition of the fill level
   *  from equal to below the limit, not the fact being below
   */
  channel->TBCTR = (uint32_t)(channel->TBCTR & (uint32_t)~(USIC_CH_TBCTR_LIMIT_Msk |
10001b06:	68fa      	ldr	r2, [r7, #12]
10001b08:	2384      	movs	r3, #132	; 0x84
10001b0a:	005b      	lsls	r3, r3, #1
10001b0c:	50d1      	str	r1, [r2, r3]
                              USIC_CH_TBCTR_DPTR_Msk |
                              USIC_CH_TBCTR_SIZE_Msk)) |
                   (uint32_t)((limit << USIC_CH_TBCTR_LIMIT_Pos) |
                              (data_pointer << USIC_CH_TBCTR_DPTR_Pos) |
                              ((uint32_t)size << USIC_CH_TBCTR_SIZE_Pos));
}
10001b0e:	46bd      	mov	sp, r7
10001b10:	b004      	add	sp, #16
10001b12:	bd80      	pop	{r7, pc}
10001b14:	f8ffffff 	.word	0xf8ffffff
10001b18:	f8ffc0c0 	.word	0xf8ffc0c0

10001b1c <XMC_USIC_CH_RXFIFO_Configure>:

void XMC_USIC_CH_RXFIFO_Configure(XMC_USIC_CH_t *const channel,
                                  const uint32_t data_pointer,
                                  const XMC_USIC_CH_FIFO_SIZE_t size,
                                  const uint32_t limit)
{
10001b1c:	b580      	push	{r7, lr}
10001b1e:	b084      	sub	sp, #16
10001b20:	af00      	add	r7, sp, #0
10001b22:	60f8      	str	r0, [r7, #12]
10001b24:	60b9      	str	r1, [r7, #8]
10001b26:	603b      	str	r3, [r7, #0]
10001b28:	1dfb      	adds	r3, r7, #7
10001b2a:	701a      	strb	r2, [r3, #0]
  /* Disable FIFO */
  channel->RBCTR &= (uint32_t)~USIC_CH_RBCTR_SIZE_Msk;
10001b2c:	68fa      	ldr	r2, [r7, #12]
10001b2e:	2386      	movs	r3, #134	; 0x86
10001b30:	005b      	lsls	r3, r3, #1
10001b32:	58d3      	ldr	r3, [r2, r3]
10001b34:	4a10      	ldr	r2, [pc, #64]	; (10001b78 <XMC_USIC_CH_RXFIFO_Configure+0x5c>)
10001b36:	4013      	ands	r3, r2
10001b38:	1c19      	adds	r1, r3, #0
10001b3a:	68fa      	ldr	r2, [r7, #12]
10001b3c:	2386      	movs	r3, #134	; 0x86
10001b3e:	005b      	lsls	r3, r3, #1
10001b40:	50d1      	str	r1, [r2, r3]

  /* LOF = 1, A standard receive buffer event occurs when the filling level equals the limit value and gets bigger
   *  due to the reception of a new data word
   */
  channel->RBCTR = (uint32_t)((channel->RBCTR & (uint32_t)~(USIC_CH_RBCTR_LIMIT_Msk |
10001b42:	68fa      	ldr	r2, [r7, #12]
10001b44:	2386      	movs	r3, #134	; 0x86
10001b46:	005b      	lsls	r3, r3, #1
10001b48:	58d3      	ldr	r3, [r2, r3]
10001b4a:	4a0c      	ldr	r2, [pc, #48]	; (10001b7c <XMC_USIC_CH_RXFIFO_Configure+0x60>)
10001b4c:	401a      	ands	r2, r3
                               USIC_CH_RBCTR_DPTR_Msk |
                               USIC_CH_RBCTR_LOF_Msk)) |
                              ((limit << USIC_CH_RBCTR_LIMIT_Pos) |
10001b4e:	683b      	ldr	r3, [r7, #0]
10001b50:	0219      	lsls	r1, r3, #8
10001b52:	68bb      	ldr	r3, [r7, #8]
10001b54:	4319      	orrs	r1, r3
                               (data_pointer << USIC_CH_RBCTR_DPTR_Pos) |
                               ((uint32_t)size << USIC_CH_RBCTR_SIZE_Pos) |
10001b56:	1dfb      	adds	r3, r7, #7
10001b58:	781b      	ldrb	r3, [r3, #0]
10001b5a:	061b      	lsls	r3, r3, #24
   */
  channel->RBCTR = (uint32_t)((channel->RBCTR & (uint32_t)~(USIC_CH_RBCTR_LIMIT_Msk |
                               USIC_CH_RBCTR_DPTR_Msk |
                               USIC_CH_RBCTR_LOF_Msk)) |
                              ((limit << USIC_CH_RBCTR_LIMIT_Pos) |
                               (data_pointer << USIC_CH_RBCTR_DPTR_Pos) |
10001b5c:	430b      	orrs	r3, r1
  channel->RBCTR &= (uint32_t)~USIC_CH_RBCTR_SIZE_Msk;

  /* LOF = 1, A standard receive buffer event occurs when the filling level equals the limit value and gets bigger
   *  due to the reception of a new data word
   */
  channel->RBCTR = (uint32_t)((channel->RBCTR & (uint32_t)~(USIC_CH_RBCTR_LIMIT_Msk |
10001b5e:	4313      	orrs	r3, r2
10001b60:	2280      	movs	r2, #128	; 0x80
10001b62:	0552      	lsls	r2, r2, #21
10001b64:	431a      	orrs	r2, r3
10001b66:	1c11      	adds	r1, r2, #0
10001b68:	68fa      	ldr	r2, [r7, #12]
10001b6a:	2386      	movs	r3, #134	; 0x86
10001b6c:	005b      	lsls	r3, r3, #1
10001b6e:	50d1      	str	r1, [r2, r3]
                               USIC_CH_RBCTR_LOF_Msk)) |
                              ((limit << USIC_CH_RBCTR_LIMIT_Pos) |
                               (data_pointer << USIC_CH_RBCTR_DPTR_Pos) |
                               ((uint32_t)size << USIC_CH_RBCTR_SIZE_Pos) |
                               (uint32_t)USIC_CH_RBCTR_LOF_Msk));
}
10001b70:	46bd      	mov	sp, r7
10001b72:	b004      	add	sp, #16
10001b74:	bd80      	pop	{r7, pc}
10001b76:	46c0      	nop			; (mov r8, r8)
10001b78:	f8ffffff 	.word	0xf8ffffff
10001b7c:	efffc0c0 	.word	0xefffc0c0

10001b80 <XMC_USIC_CH_RXFIFO_SetSizeTriggerLimit>:
}

void XMC_USIC_CH_RXFIFO_SetSizeTriggerLimit(XMC_USIC_CH_t *const channel,
    const XMC_USIC_CH_FIFO_SIZE_t size,
    const uint32_t limit)
{
10001b80:	b580      	push	{r7, lr}
10001b82:	b084      	sub	sp, #16
10001b84:	af00      	add	r7, sp, #0
10001b86:	60f8      	str	r0, [r7, #12]
10001b88:	607a      	str	r2, [r7, #4]
10001b8a:	230b      	movs	r3, #11
10001b8c:	18fb      	adds	r3, r7, r3
10001b8e:	1c0a      	adds	r2, r1, #0
10001b90:	701a      	strb	r2, [r3, #0]
  XMC_UNUSED_ARG(size);

  channel->RBCTR = (uint32_t)((uint32_t)(channel->RBCTR & (uint32_t)~USIC_CH_RBCTR_LIMIT_Msk) |
10001b92:	68fa      	ldr	r2, [r7, #12]
10001b94:	2386      	movs	r3, #134	; 0x86
10001b96:	005b      	lsls	r3, r3, #1
10001b98:	58d3      	ldr	r3, [r2, r3]
10001b9a:	4a06      	ldr	r2, [pc, #24]	; (10001bb4 <XMC_USIC_CH_RXFIFO_SetSizeTriggerLimit+0x34>)
10001b9c:	401a      	ands	r2, r3
                              (limit << USIC_CH_RBCTR_LIMIT_Pos));
10001b9e:	687b      	ldr	r3, [r7, #4]
10001ba0:	021b      	lsls	r3, r3, #8
    const XMC_USIC_CH_FIFO_SIZE_t size,
    const uint32_t limit)
{
  XMC_UNUSED_ARG(size);

  channel->RBCTR = (uint32_t)((uint32_t)(channel->RBCTR & (uint32_t)~USIC_CH_RBCTR_LIMIT_Msk) |
10001ba2:	431a      	orrs	r2, r3
10001ba4:	1c11      	adds	r1, r2, #0
10001ba6:	68fa      	ldr	r2, [r7, #12]
10001ba8:	2386      	movs	r3, #134	; 0x86
10001baa:	005b      	lsls	r3, r3, #1
10001bac:	50d1      	str	r1, [r2, r3]
                              (limit << USIC_CH_RBCTR_LIMIT_Pos));
}
10001bae:	46bd      	mov	sp, r7
10001bb0:	b004      	add	sp, #16
10001bb2:	bd80      	pop	{r7, pc}
10001bb4:	ffffc0ff 	.word	0xffffc0ff

10001bb8 <XMC_USIC_CH_SetInterruptNodePointer>:

void XMC_USIC_CH_SetInterruptNodePointer(XMC_USIC_CH_t *const channel,
    const XMC_USIC_CH_INTERRUPT_NODE_POINTER_t interrupt_node,
    const uint32_t service_request)
{
10001bb8:	b580      	push	{r7, lr}
10001bba:	b084      	sub	sp, #16
10001bbc:	af00      	add	r7, sp, #0
10001bbe:	60f8      	str	r0, [r7, #12]
10001bc0:	607a      	str	r2, [r7, #4]
10001bc2:	230b      	movs	r3, #11
10001bc4:	18fb      	adds	r3, r7, r3
10001bc6:	1c0a      	adds	r2, r1, #0
10001bc8:	701a      	strb	r2, [r3, #0]
  channel->INPR = (uint32_t)((channel->INPR & (~(uint32_t)(USIC_CH_INPR_Msk << (uint32_t)interrupt_node))) |
10001bca:	68fb      	ldr	r3, [r7, #12]
10001bcc:	699b      	ldr	r3, [r3, #24]
10001bce:	220b      	movs	r2, #11
10001bd0:	18ba      	adds	r2, r7, r2
10001bd2:	7812      	ldrb	r2, [r2, #0]
10001bd4:	2107      	movs	r1, #7
10001bd6:	4091      	lsls	r1, r2
10001bd8:	1c0a      	adds	r2, r1, #0
10001bda:	43d2      	mvns	r2, r2
10001bdc:	401a      	ands	r2, r3
                             (service_request << (uint32_t)interrupt_node));
10001bde:	230b      	movs	r3, #11
10001be0:	18fb      	adds	r3, r7, r3
10001be2:	781b      	ldrb	r3, [r3, #0]
10001be4:	6879      	ldr	r1, [r7, #4]
10001be6:	4099      	lsls	r1, r3
10001be8:	1c0b      	adds	r3, r1, #0

void XMC_USIC_CH_SetInterruptNodePointer(XMC_USIC_CH_t *const channel,
    const XMC_USIC_CH_INTERRUPT_NODE_POINTER_t interrupt_node,
    const uint32_t service_request)
{
  channel->INPR = (uint32_t)((channel->INPR & (~(uint32_t)(USIC_CH_INPR_Msk << (uint32_t)interrupt_node))) |
10001bea:	431a      	orrs	r2, r3
10001bec:	68fb      	ldr	r3, [r7, #12]
10001bee:	619a      	str	r2, [r3, #24]
                             (service_request << (uint32_t)interrupt_node));
}
10001bf0:	46bd      	mov	sp, r7
10001bf2:	b004      	add	sp, #16
10001bf4:	bd80      	pop	{r7, pc}
10001bf6:	46c0      	nop			; (mov r8, r8)

10001bf8 <XMC_USIC_CH_TXFIFO_SetInterruptNodePointer>:

void XMC_USIC_CH_TXFIFO_SetInterruptNodePointer(XMC_USIC_CH_t *const channel,
    const XMC_USIC_CH_TXFIFO_INTERRUPT_NODE_POINTER_t interrupt_node,
    const uint32_t service_request)
{
10001bf8:	b580      	push	{r7, lr}
10001bfa:	b084      	sub	sp, #16
10001bfc:	af00      	add	r7, sp, #0
10001bfe:	60f8      	str	r0, [r7, #12]
10001c00:	607a      	str	r2, [r7, #4]
10001c02:	230b      	movs	r3, #11
10001c04:	18fb      	adds	r3, r7, r3
10001c06:	1c0a      	adds	r2, r1, #0
10001c08:	701a      	strb	r2, [r3, #0]
  channel->TBCTR = (uint32_t)((channel->TBCTR & (~(uint32_t)(USIC_CH_INPR_Msk << (uint32_t)interrupt_node))) |
10001c0a:	68fa      	ldr	r2, [r7, #12]
10001c0c:	2384      	movs	r3, #132	; 0x84
10001c0e:	005b      	lsls	r3, r3, #1
10001c10:	58d3      	ldr	r3, [r2, r3]
10001c12:	220b      	movs	r2, #11
10001c14:	18ba      	adds	r2, r7, r2
10001c16:	7812      	ldrb	r2, [r2, #0]
10001c18:	2107      	movs	r1, #7
10001c1a:	4091      	lsls	r1, r2
10001c1c:	1c0a      	adds	r2, r1, #0
10001c1e:	43d2      	mvns	r2, r2
10001c20:	401a      	ands	r2, r3
                              (service_request << (uint32_t)interrupt_node));
10001c22:	230b      	movs	r3, #11
10001c24:	18fb      	adds	r3, r7, r3
10001c26:	781b      	ldrb	r3, [r3, #0]
10001c28:	6879      	ldr	r1, [r7, #4]
10001c2a:	4099      	lsls	r1, r3
10001c2c:	1c0b      	adds	r3, r1, #0

void XMC_USIC_CH_TXFIFO_SetInterruptNodePointer(XMC_USIC_CH_t *const channel,
    const XMC_USIC_CH_TXFIFO_INTERRUPT_NODE_POINTER_t interrupt_node,
    const uint32_t service_request)
{
  channel->TBCTR = (uint32_t)((channel->TBCTR & (~(uint32_t)(USIC_CH_INPR_Msk << (uint32_t)interrupt_node))) |
10001c2e:	431a      	orrs	r2, r3
10001c30:	1c11      	adds	r1, r2, #0
10001c32:	68fa      	ldr	r2, [r7, #12]
10001c34:	2384      	movs	r3, #132	; 0x84
10001c36:	005b      	lsls	r3, r3, #1
10001c38:	50d1      	str	r1, [r2, r3]
                              (service_request << (uint32_t)interrupt_node));
}
10001c3a:	46bd      	mov	sp, r7
10001c3c:	b004      	add	sp, #16
10001c3e:	bd80      	pop	{r7, pc}

10001c40 <XMC_USIC_CH_RXFIFO_SetInterruptNodePointer>:

void XMC_USIC_CH_RXFIFO_SetInterruptNodePointer(XMC_USIC_CH_t *const channel,
    const XMC_USIC_CH_RXFIFO_INTERRUPT_NODE_POINTER_t interrupt_node,
    const uint32_t service_request)
{
10001c40:	b580      	push	{r7, lr}
10001c42:	b084      	sub	sp, #16
10001c44:	af00      	add	r7, sp, #0
10001c46:	60f8      	str	r0, [r7, #12]
10001c48:	607a      	str	r2, [r7, #4]
10001c4a:	230b      	movs	r3, #11
10001c4c:	18fb      	adds	r3, r7, r3
10001c4e:	1c0a      	adds	r2, r1, #0
10001c50:	701a      	strb	r2, [r3, #0]
  channel->RBCTR = (uint32_t)((channel->RBCTR & (~(uint32_t)(USIC_CH_INPR_Msk << (uint32_t)interrupt_node))) |
10001c52:	68fa      	ldr	r2, [r7, #12]
10001c54:	2386      	movs	r3, #134	; 0x86
10001c56:	005b      	lsls	r3, r3, #1
10001c58:	58d3      	ldr	r3, [r2, r3]
10001c5a:	220b      	movs	r2, #11
10001c5c:	18ba      	adds	r2, r7, r2
10001c5e:	7812      	ldrb	r2, [r2, #0]
10001c60:	2107      	movs	r1, #7
10001c62:	4091      	lsls	r1, r2
10001c64:	1c0a      	adds	r2, r1, #0
10001c66:	43d2      	mvns	r2, r2
10001c68:	401a      	ands	r2, r3
                              (service_request << (uint32_t)interrupt_node));
10001c6a:	230b      	movs	r3, #11
10001c6c:	18fb      	adds	r3, r7, r3
10001c6e:	781b      	ldrb	r3, [r3, #0]
10001c70:	6879      	ldr	r1, [r7, #4]
10001c72:	4099      	lsls	r1, r3
10001c74:	1c0b      	adds	r3, r1, #0

void XMC_USIC_CH_RXFIFO_SetInterruptNodePointer(XMC_USIC_CH_t *const channel,
    const XMC_USIC_CH_RXFIFO_INTERRUPT_NODE_POINTER_t interrupt_node,
    const uint32_t service_request)
{
  channel->RBCTR = (uint32_t)((channel->RBCTR & (~(uint32_t)(USIC_CH_INPR_Msk << (uint32_t)interrupt_node))) |
10001c76:	431a      	orrs	r2, r3
10001c78:	1c11      	adds	r1, r2, #0
10001c7a:	68fa      	ldr	r2, [r7, #12]
10001c7c:	2386      	movs	r3, #134	; 0x86
10001c7e:	005b      	lsls	r3, r3, #1
10001c80:	50d1      	str	r1, [r2, r3]
                              (service_request << (uint32_t)interrupt_node));
}
10001c82:	46bd      	mov	sp, r7
10001c84:	b004      	add	sp, #16
10001c86:	bd80      	pop	{r7, pc}

10001c88 <XMC_USIC_Enable>:

void XMC_USIC_Enable(XMC_USIC_t *const usic)
{
10001c88:	b580      	push	{r7, lr}
10001c8a:	b082      	sub	sp, #8
10001c8c:	af00      	add	r7, sp, #0
10001c8e:	6078      	str	r0, [r7, #4]
  if (usic == USIC0)
10001c90:	687b      	ldr	r3, [r7, #4]
10001c92:	4a07      	ldr	r2, [pc, #28]	; (10001cb0 <XMC_USIC_Enable+0x28>)
10001c94:	4293      	cmp	r3, r2
10001c96:	d108      	bne.n	10001caa <XMC_USIC_Enable+0x22>
  {
#if defined(CLOCK_GATING_SUPPORTED)
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_USIC0);
10001c98:	2008      	movs	r0, #8
10001c9a:	f7ff fb33 	bl	10001304 <XMC_SCU_CLOCK_UngatePeripheralClock>
    while (XMC_SCU_CLOCK_IsPeripheralClockGated(XMC_SCU_PERIPHERAL_CLOCK_USIC0));
10001c9e:	46c0      	nop			; (mov r8, r8)
10001ca0:	2008      	movs	r0, #8
10001ca2:	f7ff fb4d 	bl	10001340 <XMC_SCU_CLOCK_IsPeripheralClockGated>
10001ca6:	1e03      	subs	r3, r0, #0
10001ca8:	d1fa      	bne.n	10001ca0 <XMC_USIC_Enable+0x18>
#endif
  else
  {
    XMC_ASSERT("USIC module not available", 0/*Always*/);
  }
}
10001caa:	46bd      	mov	sp, r7
10001cac:	b002      	add	sp, #8
10001cae:	bd80      	pop	{r7, pc}
10001cb0:	48000008 	.word	0x48000008

10001cb4 <_sbrk>:

// defined in linker script
extern caddr_t Heap_Bank1_Start;
extern caddr_t Heap_Bank1_End;
caddr_t _sbrk(int nbytes)
{
10001cb4:	b580      	push	{r7, lr}
10001cb6:	b084      	sub	sp, #16
10001cb8:	af00      	add	r7, sp, #0
10001cba:	6078      	str	r0, [r7, #4]
  static caddr_t heap_ptr = NULL;
  caddr_t base;

  if (heap_ptr == NULL) {
10001cbc:	4b14      	ldr	r3, [pc, #80]	; (10001d10 <_sbrk+0x5c>)
10001cbe:	681b      	ldr	r3, [r3, #0]
10001cc0:	2b00      	cmp	r3, #0
10001cc2:	d102      	bne.n	10001cca <_sbrk+0x16>
    heap_ptr = (caddr_t)&Heap_Bank1_Start;
10001cc4:	4b12      	ldr	r3, [pc, #72]	; (10001d10 <_sbrk+0x5c>)
10001cc6:	4a13      	ldr	r2, [pc, #76]	; (10001d14 <_sbrk+0x60>)
10001cc8:	601a      	str	r2, [r3, #0]
  }

  base = heap_ptr;
10001cca:	4b11      	ldr	r3, [pc, #68]	; (10001d10 <_sbrk+0x5c>)
10001ccc:	681b      	ldr	r3, [r3, #0]
10001cce:	60fb      	str	r3, [r7, #12]

  /* heap word alignment */
  nbytes = (nbytes + 3) & ~0x3U;
10001cd0:	687b      	ldr	r3, [r7, #4]
10001cd2:	3303      	adds	r3, #3
10001cd4:	2203      	movs	r2, #3
10001cd6:	4393      	bics	r3, r2
10001cd8:	607b      	str	r3, [r7, #4]
  if ((caddr_t)&Heap_Bank1_End > (heap_ptr + nbytes))
10001cda:	4b0d      	ldr	r3, [pc, #52]	; (10001d10 <_sbrk+0x5c>)
10001cdc:	681a      	ldr	r2, [r3, #0]
10001cde:	687b      	ldr	r3, [r7, #4]
10001ce0:	18d2      	adds	r2, r2, r3
10001ce2:	4b0d      	ldr	r3, [pc, #52]	; (10001d18 <_sbrk+0x64>)
10001ce4:	429a      	cmp	r2, r3
10001ce6:	d207      	bcs.n	10001cf8 <_sbrk+0x44>
  {
    heap_ptr += nbytes;
10001ce8:	4b09      	ldr	r3, [pc, #36]	; (10001d10 <_sbrk+0x5c>)
10001cea:	681a      	ldr	r2, [r3, #0]
10001cec:	687b      	ldr	r3, [r7, #4]
10001cee:	18d2      	adds	r2, r2, r3
10001cf0:	4b07      	ldr	r3, [pc, #28]	; (10001d10 <_sbrk+0x5c>)
10001cf2:	601a      	str	r2, [r3, #0]
    return (base);
10001cf4:	68fb      	ldr	r3, [r7, #12]
10001cf6:	e006      	b.n	10001d06 <_sbrk+0x52>
  }
  else
  {
    /* Heap overflow */
    errno = ENOMEM;
10001cf8:	f003 fe5e 	bl	100059b8 <__errno>
10001cfc:	1c03      	adds	r3, r0, #0
10001cfe:	220c      	movs	r2, #12
10001d00:	601a      	str	r2, [r3, #0]
    return ((caddr_t)-1);
10001d02:	2301      	movs	r3, #1
10001d04:	425b      	negs	r3, r3
  }
}
10001d06:	1c18      	adds	r0, r3, #0
10001d08:	46bd      	mov	sp, r7
10001d0a:	b004      	add	sp, #16
10001d0c:	bd80      	pop	{r7, pc}
10001d0e:	46c0      	nop			; (mov r8, r8)
10001d10:	200006a8 	.word	0x200006a8
10001d14:	20000930 	.word	0x20000930
10001d18:	20003ffc 	.word	0x20003ffc

10001d1c <XMC_USIC_CH_EnableEvent>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_DisableEvent(), XMC_USIC_CH_SetInterruptNodePointer() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_EnableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
{
10001d1c:	b580      	push	{r7, lr}
10001d1e:	b082      	sub	sp, #8
10001d20:	af00      	add	r7, sp, #0
10001d22:	6078      	str	r0, [r7, #4]
10001d24:	6039      	str	r1, [r7, #0]
  channel->CCR |= event;
10001d26:	687b      	ldr	r3, [r7, #4]
10001d28:	6c1a      	ldr	r2, [r3, #64]	; 0x40
10001d2a:	683b      	ldr	r3, [r7, #0]
10001d2c:	431a      	orrs	r2, r3
10001d2e:	687b      	ldr	r3, [r7, #4]
10001d30:	641a      	str	r2, [r3, #64]	; 0x40
}
10001d32:	46bd      	mov	sp, r7
10001d34:	b002      	add	sp, #8
10001d36:	bd80      	pop	{r7, pc}

10001d38 <XMC_USIC_CH_DisableEvent>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_EnableEvent(), XMC_USIC_CH_SetInterruptNodePointer() \n\n\n
*/
__STATIC_INLINE void XMC_USIC_CH_DisableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
{
10001d38:	b580      	push	{r7, lr}
10001d3a:	b082      	sub	sp, #8
10001d3c:	af00      	add	r7, sp, #0
10001d3e:	6078      	str	r0, [r7, #4]
10001d40:	6039      	str	r1, [r7, #0]
  channel->CCR &= (uint32_t)~event;
10001d42:	687b      	ldr	r3, [r7, #4]
10001d44:	6c1b      	ldr	r3, [r3, #64]	; 0x40
10001d46:	683a      	ldr	r2, [r7, #0]
10001d48:	43d2      	mvns	r2, r2
10001d4a:	401a      	ands	r2, r3
10001d4c:	687b      	ldr	r3, [r7, #4]
10001d4e:	641a      	str	r2, [r3, #64]	; 0x40
}
10001d50:	46bd      	mov	sp, r7
10001d52:	b002      	add	sp, #8
10001d54:	bd80      	pop	{r7, pc}
10001d56:	46c0      	nop			; (mov r8, r8)

10001d58 <XMC_USIC_CH_GetTransmitBufferStatus>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_SetDataOutputMode() \n\n\n
 */
__STATIC_INLINE XMC_USIC_CH_TBUF_STATUS_t XMC_USIC_CH_GetTransmitBufferStatus(XMC_USIC_CH_t *const channel)
{
10001d58:	b580      	push	{r7, lr}
10001d5a:	b082      	sub	sp, #8
10001d5c:	af00      	add	r7, sp, #0
10001d5e:	6078      	str	r0, [r7, #4]
  return (XMC_USIC_CH_TBUF_STATUS_t)(channel->TCSR & USIC_CH_TCSR_TDV_Msk);
10001d60:	687b      	ldr	r3, [r7, #4]
10001d62:	6b9b      	ldr	r3, [r3, #56]	; 0x38
10001d64:	b2db      	uxtb	r3, r3
10001d66:	227f      	movs	r2, #127	; 0x7f
10001d68:	4393      	bics	r3, r2
10001d6a:	b2db      	uxtb	r3, r3
}
10001d6c:	1c18      	adds	r0, r3, #0
10001d6e:	46bd      	mov	sp, r7
10001d70:	b002      	add	sp, #8
10001d72:	bd80      	pop	{r7, pc}

10001d74 <XMC_USIC_CH_TriggerServiceRequest>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_SetInterruptNodePointer() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_TriggerServiceRequest(XMC_USIC_CH_t *const channel, const uint32_t service_request_line)
{
10001d74:	b580      	push	{r7, lr}
10001d76:	b082      	sub	sp, #8
10001d78:	af00      	add	r7, sp, #0
10001d7a:	6078      	str	r0, [r7, #4]
10001d7c:	6039      	str	r1, [r7, #0]
  channel->FMR = (uint32_t)(USIC_CH_FMR_SIO0_Msk << service_request_line);
10001d7e:	683b      	ldr	r3, [r7, #0]
10001d80:	2280      	movs	r2, #128	; 0x80
10001d82:	0252      	lsls	r2, r2, #9
10001d84:	409a      	lsls	r2, r3
10001d86:	687b      	ldr	r3, [r7, #4]
10001d88:	669a      	str	r2, [r3, #104]	; 0x68
}
10001d8a:	46bd      	mov	sp, r7
10001d8c:	b002      	add	sp, #8
10001d8e:	bd80      	pop	{r7, pc}

10001d90 <XMC_USIC_CH_TXFIFO_EnableEvent>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_TXFIFO_SetInterruptNodePointer() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_TXFIFO_EnableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
{
10001d90:	b580      	push	{r7, lr}
10001d92:	b082      	sub	sp, #8
10001d94:	af00      	add	r7, sp, #0
10001d96:	6078      	str	r0, [r7, #4]
10001d98:	6039      	str	r1, [r7, #0]
  channel->TBCTR |= event;
10001d9a:	687a      	ldr	r2, [r7, #4]
10001d9c:	2384      	movs	r3, #132	; 0x84
10001d9e:	005b      	lsls	r3, r3, #1
10001da0:	58d2      	ldr	r2, [r2, r3]
10001da2:	683b      	ldr	r3, [r7, #0]
10001da4:	431a      	orrs	r2, r3
10001da6:	1c11      	adds	r1, r2, #0
10001da8:	687a      	ldr	r2, [r7, #4]
10001daa:	2384      	movs	r3, #132	; 0x84
10001dac:	005b      	lsls	r3, r3, #1
10001dae:	50d1      	str	r1, [r2, r3]
}
10001db0:	46bd      	mov	sp, r7
10001db2:	b002      	add	sp, #8
10001db4:	bd80      	pop	{r7, pc}
10001db6:	46c0      	nop			; (mov r8, r8)

10001db8 <XMC_USIC_CH_TXFIFO_DisableEvent>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_TXFIFO_GetEvent(), XMC_USIC_CH_TXFIFO_EnableEvent() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_TXFIFO_DisableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
{
10001db8:	b580      	push	{r7, lr}
10001dba:	b082      	sub	sp, #8
10001dbc:	af00      	add	r7, sp, #0
10001dbe:	6078      	str	r0, [r7, #4]
10001dc0:	6039      	str	r1, [r7, #0]
  channel->TBCTR &= (uint32_t)~event;
10001dc2:	687a      	ldr	r2, [r7, #4]
10001dc4:	2384      	movs	r3, #132	; 0x84
10001dc6:	005b      	lsls	r3, r3, #1
10001dc8:	58d3      	ldr	r3, [r2, r3]
10001dca:	683a      	ldr	r2, [r7, #0]
10001dcc:	43d2      	mvns	r2, r2
10001dce:	401a      	ands	r2, r3
10001dd0:	1c11      	adds	r1, r2, #0
10001dd2:	687a      	ldr	r2, [r7, #4]
10001dd4:	2384      	movs	r3, #132	; 0x84
10001dd6:	005b      	lsls	r3, r3, #1
10001dd8:	50d1      	str	r1, [r2, r3]
}
10001dda:	46bd      	mov	sp, r7
10001ddc:	b002      	add	sp, #8
10001dde:	bd80      	pop	{r7, pc}

10001de0 <XMC_USIC_CH_TXFIFO_Flush>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_TXFIFO_GetLevel() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_TXFIFO_Flush(XMC_USIC_CH_t *const channel)
{
10001de0:	b580      	push	{r7, lr}
10001de2:	b082      	sub	sp, #8
10001de4:	af00      	add	r7, sp, #0
10001de6:	6078      	str	r0, [r7, #4]
  channel->TRBSCR = (uint32_t)USIC_CH_TRBSCR_FLUSHTB_Msk;
10001de8:	687a      	ldr	r2, [r7, #4]
10001dea:	238c      	movs	r3, #140	; 0x8c
10001dec:	005b      	lsls	r3, r3, #1
10001dee:	2180      	movs	r1, #128	; 0x80
10001df0:	0209      	lsls	r1, r1, #8
10001df2:	50d1      	str	r1, [r2, r3]
}
10001df4:	46bd      	mov	sp, r7
10001df6:	b002      	add	sp, #8
10001df8:	bd80      	pop	{r7, pc}
10001dfa:	46c0      	nop			; (mov r8, r8)

10001dfc <XMC_USIC_CH_TXFIFO_IsFull>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_TXFIFO_IsEmpty(), XMC_USIC_CH_TXFIFO_Flush() \n\n\n
 */
__STATIC_INLINE bool XMC_USIC_CH_TXFIFO_IsFull(XMC_USIC_CH_t *const channel)
{
10001dfc:	b580      	push	{r7, lr}
10001dfe:	b082      	sub	sp, #8
10001e00:	af00      	add	r7, sp, #0
10001e02:	6078      	str	r0, [r7, #4]
  return (bool)(channel->TRBSR & USIC_CH_TRBSR_TFULL_Msk);
10001e04:	687a      	ldr	r2, [r7, #4]
10001e06:	238a      	movs	r3, #138	; 0x8a
10001e08:	005b      	lsls	r3, r3, #1
10001e0a:	58d2      	ldr	r2, [r2, r3]
10001e0c:	2380      	movs	r3, #128	; 0x80
10001e0e:	015b      	lsls	r3, r3, #5
10001e10:	4013      	ands	r3, r2
10001e12:	1e5a      	subs	r2, r3, #1
10001e14:	4193      	sbcs	r3, r2
10001e16:	b2db      	uxtb	r3, r3
}
10001e18:	1c18      	adds	r0, r3, #0
10001e1a:	46bd      	mov	sp, r7
10001e1c:	b002      	add	sp, #8
10001e1e:	bd80      	pop	{r7, pc}

10001e20 <XMC_USIC_CH_TXFIFO_IsEmpty>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_TXFIFO_Flush(), XMC_USIC_CH_TXFIFO_PutData() \n\n\n
 */
__STATIC_INLINE bool XMC_USIC_CH_TXFIFO_IsEmpty(XMC_USIC_CH_t *const channel)
{
10001e20:	b580      	push	{r7, lr}
10001e22:	b082      	sub	sp, #8
10001e24:	af00      	add	r7, sp, #0
10001e26:	6078      	str	r0, [r7, #4]
  return (bool)(channel->TRBSR & USIC_CH_TRBSR_TEMPTY_Msk);
10001e28:	687a      	ldr	r2, [r7, #4]
10001e2a:	238a      	movs	r3, #138	; 0x8a
10001e2c:	005b      	lsls	r3, r3, #1
10001e2e:	58d2      	ldr	r2, [r2, r3]
10001e30:	2380      	movs	r3, #128	; 0x80
10001e32:	011b      	lsls	r3, r3, #4
10001e34:	4013      	ands	r3, r2
10001e36:	1e5a      	subs	r2, r3, #1
10001e38:	4193      	sbcs	r3, r2
10001e3a:	b2db      	uxtb	r3, r3
}
10001e3c:	1c18      	adds	r0, r3, #0
10001e3e:	46bd      	mov	sp, r7
10001e40:	b002      	add	sp, #8
10001e42:	bd80      	pop	{r7, pc}

10001e44 <XMC_USIC_CH_RXFIFO_DisableEvent>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_RXFIFO_GetEvent(), XMC_USIC_CH_RXFIFO_EnableEvent() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_RXFIFO_DisableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
{
10001e44:	b580      	push	{r7, lr}
10001e46:	b082      	sub	sp, #8
10001e48:	af00      	add	r7, sp, #0
10001e4a:	6078      	str	r0, [r7, #4]
10001e4c:	6039      	str	r1, [r7, #0]
  channel->RBCTR &= (uint32_t)~event;
10001e4e:	687a      	ldr	r2, [r7, #4]
10001e50:	2386      	movs	r3, #134	; 0x86
10001e52:	005b      	lsls	r3, r3, #1
10001e54:	58d3      	ldr	r3, [r2, r3]
10001e56:	683a      	ldr	r2, [r7, #0]
10001e58:	43d2      	mvns	r2, r2
10001e5a:	401a      	ands	r2, r3
10001e5c:	1c11      	adds	r1, r2, #0
10001e5e:	687a      	ldr	r2, [r7, #4]
10001e60:	2386      	movs	r3, #134	; 0x86
10001e62:	005b      	lsls	r3, r3, #1
10001e64:	50d1      	str	r1, [r2, r3]
}
10001e66:	46bd      	mov	sp, r7
10001e68:	b002      	add	sp, #8
10001e6a:	bd80      	pop	{r7, pc}

10001e6c <XMC_USIC_CH_RXFIFO_IsEmpty>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_RXFIFO_Flush(), XMC_USIC_CH_RXFIFO_PutData() \n\n\n
 */
__STATIC_INLINE bool XMC_USIC_CH_RXFIFO_IsEmpty(XMC_USIC_CH_t *const channel)
{
10001e6c:	b580      	push	{r7, lr}
10001e6e:	b082      	sub	sp, #8
10001e70:	af00      	add	r7, sp, #0
10001e72:	6078      	str	r0, [r7, #4]
  return (bool)(channel->TRBSR & USIC_CH_TRBSR_REMPTY_Msk);
10001e74:	687a      	ldr	r2, [r7, #4]
10001e76:	238a      	movs	r3, #138	; 0x8a
10001e78:	005b      	lsls	r3, r3, #1
10001e7a:	58d3      	ldr	r3, [r2, r3]
10001e7c:	2208      	movs	r2, #8
10001e7e:	4013      	ands	r3, r2
10001e80:	1e5a      	subs	r2, r3, #1
10001e82:	4193      	sbcs	r3, r2
10001e84:	b2db      	uxtb	r3, r3
}
10001e86:	1c18      	adds	r0, r3, #0
10001e88:	46bd      	mov	sp, r7
10001e8a:	b002      	add	sp, #8
10001e8c:	bd80      	pop	{r7, pc}
10001e8e:	46c0      	nop			; (mov r8, r8)

10001e90 <UART_Init>:
 *          UART_SUCCESS: for successful UART initialization.<BR>
 *          UART_STATUS_FAILURE  : If UART initialization fails.<BR>
 *
 */
UART_STATUS_t UART_Init(const UART_t *const handle)
{
10001e90:	b590      	push	{r4, r7, lr}
10001e92:	b085      	sub	sp, #20
10001e94:	af00      	add	r7, sp, #0
10001e96:	6078      	str	r0, [r7, #4]
  UART_STATUS_t status = UART_STATUS_SUCCESS;
10001e98:	230f      	movs	r3, #15
10001e9a:	18fb      	adds	r3, r7, r3
10001e9c:	2200      	movs	r2, #0
10001e9e:	701a      	strb	r2, [r3, #0]
  XMC_ASSERT("UART_Init : UART APP handle invalid", (((handle != NULL)&&
      (handle->config != NULL)) &&((handle->config->fptr_uart_config != NULL)&&
      (handle->runtime != NULL))));

  /*Initialize the multiplexers required for UART configuration*/
  status = handle->config->fptr_uart_config();
10001ea0:	687b      	ldr	r3, [r7, #4]
10001ea2:	685b      	ldr	r3, [r3, #4]
10001ea4:	685b      	ldr	r3, [r3, #4]
10001ea6:	220f      	movs	r2, #15
10001ea8:	18bc      	adds	r4, r7, r2
10001eaa:	4798      	blx	r3
10001eac:	1c03      	adds	r3, r0, #0
10001eae:	7023      	strb	r3, [r4, #0]

  return status;
10001eb0:	230f      	movs	r3, #15
10001eb2:	18fb      	adds	r3, r7, r3
10001eb4:	781b      	ldrb	r3, [r3, #0]
}
10001eb6:	1c18      	adds	r0, r3, #0
10001eb8:	46bd      	mov	sp, r7
10001eba:	b005      	add	sp, #20
10001ebc:	bd90      	pop	{r4, r7, pc}
10001ebe:	46c0      	nop			; (mov r8, r8)

10001ec0 <UART_Transmit>:
 *          UART_STATUS_BUFFER_INVALID: Either if buffer is NULL or count is 0.<BR>
 *          UART_STATUS_MODE_MISMATCH: If the configured mode is invalid.<BR>
 *
 */
UART_STATUS_t UART_Transmit(const UART_t *const handle, uint8_t* data_ptr, uint32_t count)
{
10001ec0:	b590      	push	{r4, r7, lr}
10001ec2:	b087      	sub	sp, #28
10001ec4:	af00      	add	r7, sp, #0
10001ec6:	60f8      	str	r0, [r7, #12]
10001ec8:	60b9      	str	r1, [r7, #8]
10001eca:	607a      	str	r2, [r7, #4]
  UART_STATUS_t ret_stat = UART_STATUS_MODE_MISMATCH;
10001ecc:	2317      	movs	r3, #23
10001ece:	18fb      	adds	r3, r7, r3
10001ed0:	2204      	movs	r2, #4
10001ed2:	701a      	strb	r2, [r3, #0]

  switch(handle->config->transmit_mode)
10001ed4:	68fb      	ldr	r3, [r7, #12]
10001ed6:	685b      	ldr	r3, [r3, #4]
10001ed8:	2229      	movs	r2, #41	; 0x29
10001eda:	5c9b      	ldrb	r3, [r3, r2]
10001edc:	2b00      	cmp	r3, #0
10001ede:	d000      	beq.n	10001ee2 <UART_Transmit+0x22>
  case UART_TRANSFER_MODE_DIRECT:
    ret_stat = UART_lStartTransmitPolling(handle, data_ptr, count);
    break;
#endif
  default:
    break;
10001ee0:	e00c      	b.n	10001efc <UART_Transmit+0x3c>

  switch(handle->config->transmit_mode)
  {
#ifdef UART_TX_INTERRUPT_USED
  case UART_TRANSFER_MODE_INTERRUPT:
    ret_stat = UART_StartTransmitIRQ(handle, data_ptr, count);
10001ee2:	2317      	movs	r3, #23
10001ee4:	18fc      	adds	r4, r7, r3
10001ee6:	68f9      	ldr	r1, [r7, #12]
10001ee8:	68ba      	ldr	r2, [r7, #8]
10001eea:	687b      	ldr	r3, [r7, #4]
10001eec:	1c08      	adds	r0, r1, #0
10001eee:	1c11      	adds	r1, r2, #0
10001ef0:	1c1a      	adds	r2, r3, #0
10001ef2:	f000 f80b 	bl	10001f0c <UART_StartTransmitIRQ>
10001ef6:	1c03      	adds	r3, r0, #0
10001ef8:	7023      	strb	r3, [r4, #0]
    break;
10001efa:	46c0      	nop			; (mov r8, r8)
    break;
#endif
  default:
    break;
  }
  return ret_stat;
10001efc:	2317      	movs	r3, #23
10001efe:	18fb      	adds	r3, r7, r3
10001f00:	781b      	ldrb	r3, [r3, #0]
}
10001f02:	1c18      	adds	r0, r3, #0
10001f04:	46bd      	mov	sp, r7
10001f06:	b007      	add	sp, #28
10001f08:	bd90      	pop	{r4, r7, pc}
10001f0a:	46c0      	nop			; (mov r8, r8)

10001f0c <UART_StartTransmitIRQ>:
 * request is registered.
 *
 *
 */
UART_STATUS_t UART_StartTransmitIRQ(const UART_t *const handle, uint8_t* data_ptr, uint32_t count)
{
10001f0c:	b580      	push	{r7, lr}
10001f0e:	b086      	sub	sp, #24
10001f10:	af00      	add	r7, sp, #0
10001f12:	60f8      	str	r0, [r7, #12]
10001f14:	60b9      	str	r1, [r7, #8]
10001f16:	607a      	str	r2, [r7, #4]
  UART_STATUS_t ret_stat = UART_STATUS_MODE_MISMATCH;
10001f18:	2317      	movs	r3, #23
10001f1a:	18fb      	adds	r3, r7, r3
10001f1c:	2204      	movs	r2, #4
10001f1e:	701a      	strb	r2, [r3, #0]
  UART_RUNTIME_t * ptr_runtime = handle->runtime;
10001f20:	68fb      	ldr	r3, [r7, #12]
10001f22:	689b      	ldr	r3, [r3, #8]
10001f24:	613b      	str	r3, [r7, #16]

  XMC_ASSERT("UART_StartTransmitIRQ: UART APP handle invalid", ((handle != NULL)&&
            (handle->runtime != NULL)));

  if (handle->config->transmit_mode == UART_TRANSFER_MODE_INTERRUPT)
10001f26:	68fb      	ldr	r3, [r7, #12]
10001f28:	685b      	ldr	r3, [r3, #4]
10001f2a:	2229      	movs	r2, #41	; 0x29
10001f2c:	5c9b      	ldrb	r3, [r3, r2]
10001f2e:	2b00      	cmp	r3, #0
10001f30:	d14c      	bne.n	10001fcc <UART_StartTransmitIRQ+0xc0>
  {
    ret_stat = UART_STATUS_BUSY;
10001f32:	2317      	movs	r3, #23
10001f34:	18fb      	adds	r3, r7, r3
10001f36:	2202      	movs	r2, #2
10001f38:	701a      	strb	r2, [r3, #0]
    if (ptr_runtime->tx_busy == false)
10001f3a:	693b      	ldr	r3, [r7, #16]
10001f3c:	7e1b      	ldrb	r3, [r3, #24]
10001f3e:	b2db      	uxtb	r3, r3
10001f40:	2201      	movs	r2, #1
10001f42:	4053      	eors	r3, r2
10001f44:	b2db      	uxtb	r3, r3
10001f46:	2b00      	cmp	r3, #0
10001f48:	d040      	beq.n	10001fcc <UART_StartTransmitIRQ+0xc0>
    {
      /*If there is no transmission in progress*/
      if ((data_ptr != NULL) && (count > 0U))
10001f4a:	68bb      	ldr	r3, [r7, #8]
10001f4c:	2b00      	cmp	r3, #0
10001f4e:	d039      	beq.n	10001fc4 <UART_StartTransmitIRQ+0xb8>
10001f50:	687b      	ldr	r3, [r7, #4]
10001f52:	2b00      	cmp	r3, #0
10001f54:	d036      	beq.n	10001fc4 <UART_StartTransmitIRQ+0xb8>
      {
        /*Obtain the address of data, size of data*/
        ptr_runtime->tx_data = data_ptr;
10001f56:	693b      	ldr	r3, [r7, #16]
10001f58:	68ba      	ldr	r2, [r7, #8]
10001f5a:	601a      	str	r2, [r3, #0]
        ptr_runtime->tx_data_count = count;
10001f5c:	693b      	ldr	r3, [r7, #16]
10001f5e:	687a      	ldr	r2, [r7, #4]
10001f60:	609a      	str	r2, [r3, #8]
        /*Initialize to first index and set the busy flag*/
        ptr_runtime->tx_data_index = 0U;
10001f62:	693b      	ldr	r3, [r7, #16]
10001f64:	2200      	movs	r2, #0
10001f66:	60da      	str	r2, [r3, #12]
        ptr_runtime->tx_busy = true;
10001f68:	693b      	ldr	r3, [r7, #16]
10001f6a:	2201      	movs	r2, #1
10001f6c:	761a      	strb	r2, [r3, #24]

        /*Enable the transmit buffer event*/
        if (handle->config->tx_fifo_size != XMC_USIC_CH_FIFO_DISABLED)
10001f6e:	68fb      	ldr	r3, [r7, #12]
10001f70:	685b      	ldr	r3, [r3, #4]
10001f72:	222b      	movs	r2, #43	; 0x2b
10001f74:	5c9b      	ldrb	r3, [r3, r2]
10001f76:	2b00      	cmp	r3, #0
10001f78:	d00d      	beq.n	10001f96 <UART_StartTransmitIRQ+0x8a>
        {
          /*Clear the transmit FIFO*/
          XMC_USIC_CH_TXFIFO_Flush(handle->channel);
10001f7a:	68fb      	ldr	r3, [r7, #12]
10001f7c:	681b      	ldr	r3, [r3, #0]
10001f7e:	1c18      	adds	r0, r3, #0
10001f80:	f7ff ff2e 	bl	10001de0 <XMC_USIC_CH_TXFIFO_Flush>
          /*Enable transmit buffer interrupt*/
          XMC_USIC_CH_TXFIFO_EnableEvent(handle->channel,(uint32_t)XMC_USIC_CH_TXFIFO_EVENT_CONF_STANDARD);
10001f84:	68fb      	ldr	r3, [r7, #12]
10001f86:	681a      	ldr	r2, [r3, #0]
10001f88:	2380      	movs	r3, #128	; 0x80
10001f8a:	05db      	lsls	r3, r3, #23
10001f8c:	1c10      	adds	r0, r2, #0
10001f8e:	1c19      	adds	r1, r3, #0
10001f90:	f7ff fefe 	bl	10001d90 <XMC_USIC_CH_TXFIFO_EnableEvent>
10001f94:	e007      	b.n	10001fa6 <UART_StartTransmitIRQ+0x9a>
        }
        else
        {
          XMC_USIC_CH_EnableEvent(handle->channel, (uint32_t)XMC_USIC_CH_EVENT_TRANSMIT_BUFFER);
10001f96:	68fb      	ldr	r3, [r7, #12]
10001f98:	681a      	ldr	r2, [r3, #0]
10001f9a:	2380      	movs	r3, #128	; 0x80
10001f9c:	019b      	lsls	r3, r3, #6
10001f9e:	1c10      	adds	r0, r2, #0
10001fa0:	1c19      	adds	r1, r3, #0
10001fa2:	f7ff febb 	bl	10001d1c <XMC_USIC_CH_EnableEvent>
        }
        ret_stat = UART_STATUS_SUCCESS;
10001fa6:	2317      	movs	r3, #23
10001fa8:	18fb      	adds	r3, r7, r3
10001faa:	2200      	movs	r2, #0
10001fac:	701a      	strb	r2, [r3, #0]
        /*Trigger the transmit buffer interrupt*/
        XMC_USIC_CH_TriggerServiceRequest(handle->channel, (uint32_t)handle->config->tx_sr);
10001fae:	68fb      	ldr	r3, [r7, #12]
10001fb0:	6819      	ldr	r1, [r3, #0]
10001fb2:	68fb      	ldr	r3, [r7, #12]
10001fb4:	685b      	ldr	r3, [r3, #4]
10001fb6:	222d      	movs	r2, #45	; 0x2d
10001fb8:	5c9b      	ldrb	r3, [r3, r2]
10001fba:	1c08      	adds	r0, r1, #0
10001fbc:	1c19      	adds	r1, r3, #0
10001fbe:	f7ff fed9 	bl	10001d74 <XMC_USIC_CH_TriggerServiceRequest>
10001fc2:	e003      	b.n	10001fcc <UART_StartTransmitIRQ+0xc0>
      }
      else
      {
        ret_stat = UART_STATUS_BUFFER_INVALID;
10001fc4:	2317      	movs	r3, #23
10001fc6:	18fb      	adds	r3, r7, r3
10001fc8:	2203      	movs	r2, #3
10001fca:	701a      	strb	r2, [r3, #0]
      }
    }
  }
  return ret_stat;
10001fcc:	2317      	movs	r3, #23
10001fce:	18fb      	adds	r3, r7, r3
10001fd0:	781b      	ldrb	r3, [r3, #0]
}
10001fd2:	1c18      	adds	r0, r3, #0
10001fd4:	46bd      	mov	sp, r7
10001fd6:	b006      	add	sp, #24
10001fd8:	bd80      	pop	{r7, pc}
10001fda:	46c0      	nop			; (mov r8, r8)

10001fdc <UART_lTransmitHandler>:
 *  * param[in]  handle UART APP handle pointer of type UART_t*
 *
 *  * return void
 */
void UART_lTransmitHandler(const UART_t * const handle)
{
10001fdc:	b580      	push	{r7, lr}
10001fde:	b084      	sub	sp, #16
10001fe0:	af00      	add	r7, sp, #0
10001fe2:	6078      	str	r0, [r7, #4]
  UART_RUNTIME_t * ptr_runtime = handle->runtime;
10001fe4:	687b      	ldr	r3, [r7, #4]
10001fe6:	689b      	ldr	r3, [r3, #8]
10001fe8:	60fb      	str	r3, [r7, #12]

  if (ptr_runtime->tx_data_index < ptr_runtime->tx_data_count)
10001fea:	68fb      	ldr	r3, [r7, #12]
10001fec:	68da      	ldr	r2, [r3, #12]
10001fee:	68fb      	ldr	r3, [r7, #12]
10001ff0:	689b      	ldr	r3, [r3, #8]
10001ff2:	429a      	cmp	r2, r3
10001ff4:	d241      	bcs.n	1000207a <UART_lTransmitHandler+0x9e>
  {
    if (handle->config->tx_fifo_size != XMC_USIC_CH_FIFO_DISABLED)
10001ff6:	687b      	ldr	r3, [r7, #4]
10001ff8:	685b      	ldr	r3, [r3, #4]
10001ffa:	222b      	movs	r2, #43	; 0x2b
10001ffc:	5c9b      	ldrb	r3, [r3, r2]
10001ffe:	2b00      	cmp	r3, #0
10002000:	d028      	beq.n	10002054 <UART_lTransmitHandler+0x78>
    {
      /*When Transmit FIFO is enabled*/
      /*Fill the transmit FIFO */
      while (XMC_USIC_CH_TXFIFO_IsFull(handle->channel) == false)
10002002:	e01a      	b.n	1000203a <UART_lTransmitHandler+0x5e>
      {
        if (ptr_runtime->tx_data_index < ptr_runtime->tx_data_count)
10002004:	68fb      	ldr	r3, [r7, #12]
10002006:	68da      	ldr	r2, [r3, #12]
10002008:	68fb      	ldr	r3, [r7, #12]
1000200a:	689b      	ldr	r3, [r3, #8]
1000200c:	429a      	cmp	r2, r3
1000200e:	d212      	bcs.n	10002036 <UART_lTransmitHandler+0x5a>
        {
          /*Load the FIFO byte by byte till either FIFO is full or all data is loaded*/
          XMC_UART_CH_Transmit(handle->channel,(uint16_t)ptr_runtime->tx_data[ptr_runtime->tx_data_index]);
10002010:	687b      	ldr	r3, [r7, #4]
10002012:	6819      	ldr	r1, [r3, #0]
10002014:	68fb      	ldr	r3, [r7, #12]
10002016:	681a      	ldr	r2, [r3, #0]
10002018:	68fb      	ldr	r3, [r7, #12]
1000201a:	68db      	ldr	r3, [r3, #12]
1000201c:	18d3      	adds	r3, r2, r3
1000201e:	781b      	ldrb	r3, [r3, #0]
10002020:	b29b      	uxth	r3, r3
10002022:	1c08      	adds	r0, r1, #0
10002024:	1c19      	adds	r1, r3, #0
10002026:	f7ff fbd5 	bl	100017d4 <XMC_UART_CH_Transmit>
          (ptr_runtime->tx_data_index)++;
1000202a:	68fb      	ldr	r3, [r7, #12]
1000202c:	68db      	ldr	r3, [r3, #12]
1000202e:	1c5a      	adds	r2, r3, #1
10002030:	68fb      	ldr	r3, [r7, #12]
10002032:	60da      	str	r2, [r3, #12]
10002034:	e001      	b.n	1000203a <UART_lTransmitHandler+0x5e>
        }
        else
        {
          break;
10002036:	46c0      	nop			; (mov r8, r8)
10002038:	e055      	b.n	100020e6 <UART_lTransmitHandler+0x10a>
  {
    if (handle->config->tx_fifo_size != XMC_USIC_CH_FIFO_DISABLED)
    {
      /*When Transmit FIFO is enabled*/
      /*Fill the transmit FIFO */
      while (XMC_USIC_CH_TXFIFO_IsFull(handle->channel) == false)
1000203a:	687b      	ldr	r3, [r7, #4]
1000203c:	681b      	ldr	r3, [r3, #0]
1000203e:	1c18      	adds	r0, r3, #0
10002040:	f7ff fedc 	bl	10001dfc <XMC_USIC_CH_TXFIFO_IsFull>
10002044:	1c03      	adds	r3, r0, #0
10002046:	1c1a      	adds	r2, r3, #0
10002048:	2301      	movs	r3, #1
1000204a:	4053      	eors	r3, r2
1000204c:	b2db      	uxtb	r3, r3
1000204e:	2b00      	cmp	r3, #0
10002050:	d1d8      	bne.n	10002004 <UART_lTransmitHandler+0x28>
10002052:	e048      	b.n	100020e6 <UART_lTransmitHandler+0x10a>
      }
    }
    else
    {
      /*When Transmit FIFO is disabled*/
      XMC_UART_CH_Transmit(handle->channel,(uint16_t)ptr_runtime->tx_data[ptr_runtime->tx_data_index]);
10002054:	687b      	ldr	r3, [r7, #4]
10002056:	6819      	ldr	r1, [r3, #0]
10002058:	68fb      	ldr	r3, [r7, #12]
1000205a:	681a      	ldr	r2, [r3, #0]
1000205c:	68fb      	ldr	r3, [r7, #12]
1000205e:	68db      	ldr	r3, [r3, #12]
10002060:	18d3      	adds	r3, r2, r3
10002062:	781b      	ldrb	r3, [r3, #0]
10002064:	b29b      	uxth	r3, r3
10002066:	1c08      	adds	r0, r1, #0
10002068:	1c19      	adds	r1, r3, #0
1000206a:	f7ff fbb3 	bl	100017d4 <XMC_UART_CH_Transmit>
      (ptr_runtime->tx_data_index)++;
1000206e:	68fb      	ldr	r3, [r7, #12]
10002070:	68db      	ldr	r3, [r3, #12]
10002072:	1c5a      	adds	r2, r3, #1
10002074:	68fb      	ldr	r3, [r7, #12]
10002076:	60da      	str	r2, [r3, #12]
10002078:	e035      	b.n	100020e6 <UART_lTransmitHandler+0x10a>
    }
  }
  else
  {
    if (XMC_USIC_CH_TXFIFO_IsEmpty(handle->channel) == true)
1000207a:	687b      	ldr	r3, [r7, #4]
1000207c:	681b      	ldr	r3, [r3, #0]
1000207e:	1c18      	adds	r0, r3, #0
10002080:	f7ff fece 	bl	10001e20 <XMC_USIC_CH_TXFIFO_IsEmpty>
10002084:	1e03      	subs	r3, r0, #0
10002086:	d02e      	beq.n	100020e6 <UART_lTransmitHandler+0x10a>
    {
      if (handle->config->tx_fifo_size != XMC_USIC_CH_FIFO_DISABLED)
10002088:	687b      	ldr	r3, [r7, #4]
1000208a:	685b      	ldr	r3, [r3, #4]
1000208c:	222b      	movs	r2, #43	; 0x2b
1000208e:	5c9b      	ldrb	r3, [r3, r2]
10002090:	2b00      	cmp	r3, #0
10002092:	d008      	beq.n	100020a6 <UART_lTransmitHandler+0xca>
      {
        /*Disable the transmit FIFO event*/
        XMC_USIC_CH_TXFIFO_DisableEvent(handle->channel,(uint32_t)XMC_USIC_CH_TXFIFO_EVENT_CONF_STANDARD);
10002094:	687b      	ldr	r3, [r7, #4]
10002096:	681a      	ldr	r2, [r3, #0]
10002098:	2380      	movs	r3, #128	; 0x80
1000209a:	05db      	lsls	r3, r3, #23
1000209c:	1c10      	adds	r0, r2, #0
1000209e:	1c19      	adds	r1, r3, #0
100020a0:	f7ff fe8a 	bl	10001db8 <XMC_USIC_CH_TXFIFO_DisableEvent>
100020a4:	e007      	b.n	100020b6 <UART_lTransmitHandler+0xda>
      }
      else
      {
        /*Disable the standard transmit event*/
        XMC_USIC_CH_DisableEvent(handle->channel, (uint32_t)XMC_USIC_CH_EVENT_TRANSMIT_BUFFER);
100020a6:	687b      	ldr	r3, [r7, #4]
100020a8:	681a      	ldr	r2, [r3, #0]
100020aa:	2380      	movs	r3, #128	; 0x80
100020ac:	019b      	lsls	r3, r3, #6
100020ae:	1c10      	adds	r0, r2, #0
100020b0:	1c19      	adds	r1, r3, #0
100020b2:	f7ff fe41 	bl	10001d38 <XMC_USIC_CH_DisableEvent>
      }

      /*Wait for the transmit buffer to be free to ensure that all data is transmitted*/
      while (XMC_USIC_CH_GetTransmitBufferStatus(handle->channel) == XMC_USIC_CH_TBUF_STATUS_BUSY)
100020b6:	46c0      	nop			; (mov r8, r8)
100020b8:	687b      	ldr	r3, [r7, #4]
100020ba:	681b      	ldr	r3, [r3, #0]
100020bc:	1c18      	adds	r0, r3, #0
100020be:	f7ff fe4b 	bl	10001d58 <XMC_USIC_CH_GetTransmitBufferStatus>
100020c2:	1e03      	subs	r3, r0, #0
100020c4:	2b80      	cmp	r3, #128	; 0x80
100020c6:	d0f7      	beq.n	100020b8 <UART_lTransmitHandler+0xdc>
      {

      }
      /*All data is transmitted*/
      ptr_runtime->tx_busy = false;
100020c8:	68fb      	ldr	r3, [r7, #12]
100020ca:	2200      	movs	r2, #0
100020cc:	761a      	strb	r2, [r3, #24]
      ptr_runtime->tx_data = NULL;
100020ce:	68fb      	ldr	r3, [r7, #12]
100020d0:	2200      	movs	r2, #0
100020d2:	601a      	str	r2, [r3, #0]

      if (handle->config->tx_cbhandler != NULL)
100020d4:	687b      	ldr	r3, [r7, #4]
100020d6:	685b      	ldr	r3, [r3, #4]
100020d8:	689b      	ldr	r3, [r3, #8]
100020da:	2b00      	cmp	r3, #0
100020dc:	d003      	beq.n	100020e6 <UART_lTransmitHandler+0x10a>
      {
        /*Execute the callback function provided in the UART APP UI*/
        handle->config->tx_cbhandler();
100020de:	687b      	ldr	r3, [r7, #4]
100020e0:	685b      	ldr	r3, [r3, #4]
100020e2:	689b      	ldr	r3, [r3, #8]
100020e4:	4798      	blx	r3
      }
    }
  }
}
100020e6:	46bd      	mov	sp, r7
100020e8:	b004      	add	sp, #16
100020ea:	bd80      	pop	{r7, pc}

100020ec <UART_lReceiveHandler>:
 * param[in]  handle UART APP handle pointer of type UART_t*
 *
 * return void
 */
void UART_lReceiveHandler(const UART_t * const handle)
{
100020ec:	b590      	push	{r4, r7, lr}
100020ee:	b085      	sub	sp, #20
100020f0:	af00      	add	r7, sp, #0
100020f2:	6078      	str	r0, [r7, #4]
  UART_RUNTIME_t * ptr_runtime = handle->runtime;
100020f4:	687b      	ldr	r3, [r7, #4]
100020f6:	689b      	ldr	r3, [r3, #8]
100020f8:	60fb      	str	r3, [r7, #12]

  if (handle->config->rx_fifo_size != XMC_USIC_CH_FIFO_DISABLED)
100020fa:	687b      	ldr	r3, [r7, #4]
100020fc:	685b      	ldr	r3, [r3, #4]
100020fe:	222c      	movs	r2, #44	; 0x2c
10002100:	5c9b      	ldrb	r3, [r3, r2]
10002102:	2b00      	cmp	r3, #0
10002104:	d051      	beq.n	100021aa <UART_lReceiveHandler+0xbe>
  {
    /*When Receive FIFO is enabled*/
    while (XMC_USIC_CH_RXFIFO_IsEmpty(handle->channel) == false)
10002106:	e033      	b.n	10002170 <UART_lReceiveHandler+0x84>
    {
      if (ptr_runtime->rx_data_index < ptr_runtime->rx_data_count)
10002108:	68fb      	ldr	r3, [r7, #12]
1000210a:	695a      	ldr	r2, [r3, #20]
1000210c:	68fb      	ldr	r3, [r7, #12]
1000210e:	691b      	ldr	r3, [r3, #16]
10002110:	429a      	cmp	r2, r3
10002112:	d211      	bcs.n	10002138 <UART_lReceiveHandler+0x4c>
      {
        /*Read all the content of Receive FIFO */
        ptr_runtime->rx_data[ptr_runtime->rx_data_index] = (uint8_t)XMC_UART_CH_GetReceivedData(handle->channel);
10002114:	68fb      	ldr	r3, [r7, #12]
10002116:	685a      	ldr	r2, [r3, #4]
10002118:	68fb      	ldr	r3, [r7, #12]
1000211a:	695b      	ldr	r3, [r3, #20]
1000211c:	18d4      	adds	r4, r2, r3
1000211e:	687b      	ldr	r3, [r7, #4]
10002120:	681b      	ldr	r3, [r3, #0]
10002122:	1c18      	adds	r0, r3, #0
10002124:	f7ff fb84 	bl	10001830 <XMC_UART_CH_GetReceivedData>
10002128:	1c03      	adds	r3, r0, #0
1000212a:	b2db      	uxtb	r3, r3
1000212c:	7023      	strb	r3, [r4, #0]
        (ptr_runtime->rx_data_index)++;
1000212e:	68fb      	ldr	r3, [r7, #12]
10002130:	695b      	ldr	r3, [r3, #20]
10002132:	1c5a      	adds	r2, r3, #1
10002134:	68fb      	ldr	r3, [r7, #12]
10002136:	615a      	str	r2, [r3, #20]
      }

      if (ptr_runtime->rx_data_index == ptr_runtime->rx_data_count)
10002138:	68fb      	ldr	r3, [r7, #12]
1000213a:	695a      	ldr	r2, [r3, #20]
1000213c:	68fb      	ldr	r3, [r7, #12]
1000213e:	691b      	ldr	r3, [r3, #16]
10002140:	429a      	cmp	r2, r3
10002142:	d115      	bne.n	10002170 <UART_lReceiveHandler+0x84>
      {
        /*Reception complete*/
        ptr_runtime->rx_busy = false;
10002144:	68fb      	ldr	r3, [r7, #12]
10002146:	2200      	movs	r2, #0
10002148:	765a      	strb	r2, [r3, #25]
        /*Disable both standard receive and alternative receive FIFO events*/
        XMC_USIC_CH_RXFIFO_DisableEvent(handle->channel,
1000214a:	687b      	ldr	r3, [r7, #4]
1000214c:	681a      	ldr	r2, [r3, #0]
1000214e:	23c0      	movs	r3, #192	; 0xc0
10002150:	05db      	lsls	r3, r3, #23
10002152:	1c10      	adds	r0, r2, #0
10002154:	1c19      	adds	r1, r3, #0
10002156:	f7ff fe75 	bl	10001e44 <XMC_USIC_CH_RXFIFO_DisableEvent>
            (uint32_t)((uint32_t)XMC_USIC_CH_RXFIFO_EVENT_CONF_STANDARD |
            (uint32_t)XMC_USIC_CH_RXFIFO_EVENT_CONF_ALTERNATE));
        if (handle->config->rx_cbhandler != NULL)
1000215a:	687b      	ldr	r3, [r7, #4]
1000215c:	685b      	ldr	r3, [r3, #4]
1000215e:	68db      	ldr	r3, [r3, #12]
10002160:	2b00      	cmp	r3, #0
10002162:	d004      	beq.n	1000216e <UART_lReceiveHandler+0x82>
        {
          /*Execute the 'End of reception' callback function*/
          handle->config->rx_cbhandler();
10002164:	687b      	ldr	r3, [r7, #4]
10002166:	685b      	ldr	r3, [r3, #4]
10002168:	68db      	ldr	r3, [r3, #12]
1000216a:	4798      	blx	r3
        }
        break;
1000216c:	e00c      	b.n	10002188 <UART_lReceiveHandler+0x9c>
1000216e:	e00b      	b.n	10002188 <UART_lReceiveHandler+0x9c>
  UART_RUNTIME_t * ptr_runtime = handle->runtime;

  if (handle->config->rx_fifo_size != XMC_USIC_CH_FIFO_DISABLED)
  {
    /*When Receive FIFO is enabled*/
    while (XMC_USIC_CH_RXFIFO_IsEmpty(handle->channel) == false)
10002170:	687b      	ldr	r3, [r7, #4]
10002172:	681b      	ldr	r3, [r3, #0]
10002174:	1c18      	adds	r0, r3, #0
10002176:	f7ff fe79 	bl	10001e6c <XMC_USIC_CH_RXFIFO_IsEmpty>
1000217a:	1c03      	adds	r3, r0, #0
1000217c:	1c1a      	adds	r2, r3, #0
1000217e:	2301      	movs	r3, #1
10002180:	4053      	eors	r3, r2
10002182:	b2db      	uxtb	r3, r3
10002184:	2b00      	cmp	r3, #0
10002186:	d1bf      	bne.n	10002108 <UART_lReceiveHandler+0x1c>
        }
        break;
      }
    }
    /*Set the trigger limit if data still to be received*/
    if (ptr_runtime->rx_data_index < ptr_runtime->rx_data_count)
10002188:	68fb      	ldr	r3, [r7, #12]
1000218a:	695a      	ldr	r2, [r3, #20]
1000218c:	68fb      	ldr	r3, [r7, #12]
1000218e:	691b      	ldr	r3, [r3, #16]
10002190:	429a      	cmp	r2, r3
10002192:	d23c      	bcs.n	1000220e <UART_lReceiveHandler+0x122>
    {
      UART_lReconfigureRxFIFO(handle,
          (uint32_t)(ptr_runtime->rx_data_count - ptr_runtime->rx_data_index));
10002194:	68fb      	ldr	r3, [r7, #12]
10002196:	691a      	ldr	r2, [r3, #16]
10002198:	68fb      	ldr	r3, [r7, #12]
1000219a:	695b      	ldr	r3, [r3, #20]
      }
    }
    /*Set the trigger limit if data still to be received*/
    if (ptr_runtime->rx_data_index < ptr_runtime->rx_data_count)
    {
      UART_lReconfigureRxFIFO(handle,
1000219c:	1ad3      	subs	r3, r2, r3
1000219e:	687a      	ldr	r2, [r7, #4]
100021a0:	1c10      	adds	r0, r2, #0
100021a2:	1c19      	adds	r1, r3, #0
100021a4:	f000 f836 	bl	10002214 <UART_lReconfigureRxFIFO>
100021a8:	e031      	b.n	1000220e <UART_lReceiveHandler+0x122>
    }
  }
  else
  {
    /*When RxFIFO is disabled*/
    if (ptr_runtime->rx_data_index < ptr_runtime->rx_data_count)
100021aa:	68fb      	ldr	r3, [r7, #12]
100021ac:	695a      	ldr	r2, [r3, #20]
100021ae:	68fb      	ldr	r3, [r7, #12]
100021b0:	691b      	ldr	r3, [r3, #16]
100021b2:	429a      	cmp	r2, r3
100021b4:	d211      	bcs.n	100021da <UART_lReceiveHandler+0xee>
    {
      ptr_runtime->rx_data[ptr_runtime->rx_data_index] = (uint8_t)XMC_UART_CH_GetReceivedData(handle->channel);
100021b6:	68fb      	ldr	r3, [r7, #12]
100021b8:	685a      	ldr	r2, [r3, #4]
100021ba:	68fb      	ldr	r3, [r7, #12]
100021bc:	695b      	ldr	r3, [r3, #20]
100021be:	18d4      	adds	r4, r2, r3
100021c0:	687b      	ldr	r3, [r7, #4]
100021c2:	681b      	ldr	r3, [r3, #0]
100021c4:	1c18      	adds	r0, r3, #0
100021c6:	f7ff fb33 	bl	10001830 <XMC_UART_CH_GetReceivedData>
100021ca:	1c03      	adds	r3, r0, #0
100021cc:	b2db      	uxtb	r3, r3
100021ce:	7023      	strb	r3, [r4, #0]
      (ptr_runtime->rx_data_index)++;
100021d0:	68fb      	ldr	r3, [r7, #12]
100021d2:	695b      	ldr	r3, [r3, #20]
100021d4:	1c5a      	adds	r2, r3, #1
100021d6:	68fb      	ldr	r3, [r7, #12]
100021d8:	615a      	str	r2, [r3, #20]
    }

    if (ptr_runtime->rx_data_index == ptr_runtime->rx_data_count)
100021da:	68fb      	ldr	r3, [r7, #12]
100021dc:	695a      	ldr	r2, [r3, #20]
100021de:	68fb      	ldr	r3, [r7, #12]
100021e0:	691b      	ldr	r3, [r3, #16]
100021e2:	429a      	cmp	r2, r3
100021e4:	d113      	bne.n	1000220e <UART_lReceiveHandler+0x122>
    {
      /*Reception complete*/
      ptr_runtime->rx_busy = false;
100021e6:	68fb      	ldr	r3, [r7, #12]
100021e8:	2200      	movs	r2, #0
100021ea:	765a      	strb	r2, [r3, #25]
      /*Disable both standard receive and alternative receive FIFO events*/
      XMC_USIC_CH_DisableEvent(handle->channel,
100021ec:	687b      	ldr	r3, [r7, #4]
100021ee:	681a      	ldr	r2, [r3, #0]
100021f0:	23c0      	movs	r3, #192	; 0xc0
100021f2:	021b      	lsls	r3, r3, #8
100021f4:	1c10      	adds	r0, r2, #0
100021f6:	1c19      	adds	r1, r3, #0
100021f8:	f7ff fd9e 	bl	10001d38 <XMC_USIC_CH_DisableEvent>
          (uint32_t)((uint32_t)XMC_USIC_CH_EVENT_ALTERNATIVE_RECEIVE | (uint32_t)XMC_USIC_CH_EVENT_STANDARD_RECEIVE));

      if (handle->config->rx_cbhandler != NULL)
100021fc:	687b      	ldr	r3, [r7, #4]
100021fe:	685b      	ldr	r3, [r3, #4]
10002200:	68db      	ldr	r3, [r3, #12]
10002202:	2b00      	cmp	r3, #0
10002204:	d003      	beq.n	1000220e <UART_lReceiveHandler+0x122>
      {
        /*Execute the 'End of reception' callback function*/
        handle->config->rx_cbhandler();
10002206:	687b      	ldr	r3, [r7, #4]
10002208:	685b      	ldr	r3, [r3, #4]
1000220a:	68db      	ldr	r3, [r3, #12]
1000220c:	4798      	blx	r3
      }
    }
  }
}
1000220e:	46bd      	mov	sp, r7
10002210:	b005      	add	sp, #20
10002212:	bd90      	pop	{r4, r7, pc}

10002214 <UART_lReconfigureRxFIFO>:
 * param[in] uint8_t  number of bytes to be received.
 *
 * return void.
 */
static void UART_lReconfigureRxFIFO(const UART_t * const handle, uint32_t data_size)
{
10002214:	b580      	push	{r7, lr}
10002216:	b084      	sub	sp, #16
10002218:	af00      	add	r7, sp, #0
1000221a:	6078      	str	r0, [r7, #4]
1000221c:	6039      	str	r1, [r7, #0]
  uint32_t fifo_size;
  uint32_t ret_limit_val = 0U;
1000221e:	2300      	movs	r3, #0
10002220:	60fb      	str	r3, [r7, #12]

  /*Get FIFO size in bytes*/
  fifo_size = (uint32_t)(0x01UL << (uint8_t)(handle->config->rx_fifo_size));
10002222:	687b      	ldr	r3, [r7, #4]
10002224:	685b      	ldr	r3, [r3, #4]
10002226:	222c      	movs	r2, #44	; 0x2c
10002228:	5c9b      	ldrb	r3, [r3, r2]
1000222a:	1c1a      	adds	r2, r3, #0
1000222c:	2301      	movs	r3, #1
1000222e:	4093      	lsls	r3, r2
10002230:	60bb      	str	r3, [r7, #8]
  /*If data size is more than FIFO size, configure the limit to the FIFO size*/
  if (data_size < fifo_size)
10002232:	683a      	ldr	r2, [r7, #0]
10002234:	68bb      	ldr	r3, [r7, #8]
10002236:	429a      	cmp	r2, r3
10002238:	d203      	bcs.n	10002242 <UART_lReconfigureRxFIFO+0x2e>
  {
    ret_limit_val = (uint32_t)(data_size - 1U);
1000223a:	683b      	ldr	r3, [r7, #0]
1000223c:	3b01      	subs	r3, #1
1000223e:	60fb      	str	r3, [r7, #12]
10002240:	e002      	b.n	10002248 <UART_lReconfigureRxFIFO+0x34>
  }
  else
  {
    ret_limit_val = (uint32_t)(fifo_size - 1U);
10002242:	68bb      	ldr	r3, [r7, #8]
10002244:	3b01      	subs	r3, #1
10002246:	60fb      	str	r3, [r7, #12]
  }
  /*Set the limit value*/
  XMC_USIC_CH_RXFIFO_SetSizeTriggerLimit(handle->channel,
10002248:	687b      	ldr	r3, [r7, #4]
1000224a:	6819      	ldr	r1, [r3, #0]
        handle->config->rx_fifo_size, ret_limit_val);
1000224c:	687b      	ldr	r3, [r7, #4]
1000224e:	685b      	ldr	r3, [r3, #4]
  else
  {
    ret_limit_val = (uint32_t)(fifo_size - 1U);
  }
  /*Set the limit value*/
  XMC_USIC_CH_RXFIFO_SetSizeTriggerLimit(handle->channel,
10002250:	222c      	movs	r2, #44	; 0x2c
10002252:	5c9a      	ldrb	r2, [r3, r2]
10002254:	68fb      	ldr	r3, [r7, #12]
10002256:	1c08      	adds	r0, r1, #0
10002258:	1c11      	adds	r1, r2, #0
1000225a:	1c1a      	adds	r2, r3, #0
1000225c:	f7ff fc90 	bl	10001b80 <XMC_USIC_CH_RXFIFO_SetSizeTriggerLimit>
        handle->config->rx_fifo_size, ret_limit_val);
}
10002260:	46bd      	mov	sp, r7
10002262:	b004      	add	sp, #16
10002264:	bd80      	pop	{r7, pc}
10002266:	46c0      	nop			; (mov r8, r8)

10002268 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
10002268:	b580      	push	{r7, lr}
1000226a:	b082      	sub	sp, #8
1000226c:	af00      	add	r7, sp, #0
1000226e:	1c02      	adds	r2, r0, #0
10002270:	1dfb      	adds	r3, r7, #7
10002272:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
10002274:	1dfb      	adds	r3, r7, #7
10002276:	781b      	ldrb	r3, [r3, #0]
10002278:	2b7f      	cmp	r3, #127	; 0x7f
1000227a:	d809      	bhi.n	10002290 <__NVIC_EnableIRQ+0x28>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
1000227c:	4b06      	ldr	r3, [pc, #24]	; (10002298 <__NVIC_EnableIRQ+0x30>)
1000227e:	1dfa      	adds	r2, r7, #7
10002280:	7812      	ldrb	r2, [r2, #0]
10002282:	1c11      	adds	r1, r2, #0
10002284:	221f      	movs	r2, #31
10002286:	400a      	ands	r2, r1
10002288:	2101      	movs	r1, #1
1000228a:	4091      	lsls	r1, r2
1000228c:	1c0a      	adds	r2, r1, #0
1000228e:	601a      	str	r2, [r3, #0]
    __COMPILER_BARRIER();
  }
}
10002290:	46bd      	mov	sp, r7
10002292:	b002      	add	sp, #8
10002294:	bd80      	pop	{r7, pc}
10002296:	46c0      	nop			; (mov r8, r8)
10002298:	e000e100 	.word	0xe000e100

1000229c <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
1000229c:	b5b0      	push	{r4, r5, r7, lr}
1000229e:	b082      	sub	sp, #8
100022a0:	af00      	add	r7, sp, #0
100022a2:	1c02      	adds	r2, r0, #0
100022a4:	6039      	str	r1, [r7, #0]
100022a6:	1dfb      	adds	r3, r7, #7
100022a8:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
100022aa:	1dfb      	adds	r3, r7, #7
100022ac:	781b      	ldrb	r3, [r3, #0]
100022ae:	2b7f      	cmp	r3, #127	; 0x7f
100022b0:	d827      	bhi.n	10002302 <__NVIC_SetPriority+0x66>
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
100022b2:	4c2d      	ldr	r4, [pc, #180]	; (10002368 <__NVIC_SetPriority+0xcc>)
100022b4:	1dfb      	adds	r3, r7, #7
100022b6:	781b      	ldrb	r3, [r3, #0]
100022b8:	b25b      	sxtb	r3, r3
100022ba:	089b      	lsrs	r3, r3, #2
100022bc:	492a      	ldr	r1, [pc, #168]	; (10002368 <__NVIC_SetPriority+0xcc>)
100022be:	1dfa      	adds	r2, r7, #7
100022c0:	7812      	ldrb	r2, [r2, #0]
100022c2:	b252      	sxtb	r2, r2
100022c4:	0892      	lsrs	r2, r2, #2
100022c6:	32c0      	adds	r2, #192	; 0xc0
100022c8:	0092      	lsls	r2, r2, #2
100022ca:	5852      	ldr	r2, [r2, r1]
100022cc:	1df9      	adds	r1, r7, #7
100022ce:	7809      	ldrb	r1, [r1, #0]
100022d0:	1c08      	adds	r0, r1, #0
100022d2:	2103      	movs	r1, #3
100022d4:	4001      	ands	r1, r0
100022d6:	00c9      	lsls	r1, r1, #3
100022d8:	1c08      	adds	r0, r1, #0
100022da:	21ff      	movs	r1, #255	; 0xff
100022dc:	4081      	lsls	r1, r0
100022de:	43c9      	mvns	r1, r1
100022e0:	4011      	ands	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
100022e2:	683a      	ldr	r2, [r7, #0]
100022e4:	0192      	lsls	r2, r2, #6
100022e6:	20ff      	movs	r0, #255	; 0xff
100022e8:	4002      	ands	r2, r0
100022ea:	1df8      	adds	r0, r7, #7
100022ec:	7800      	ldrb	r0, [r0, #0]
100022ee:	1c05      	adds	r5, r0, #0
100022f0:	2003      	movs	r0, #3
100022f2:	4028      	ands	r0, r5
100022f4:	00c0      	lsls	r0, r0, #3
100022f6:	4082      	lsls	r2, r0
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
100022f8:	430a      	orrs	r2, r1
100022fa:	33c0      	adds	r3, #192	; 0xc0
100022fc:	009b      	lsls	r3, r3, #2
100022fe:	511a      	str	r2, [r3, r4]
10002300:	e02e      	b.n	10002360 <__NVIC_SetPriority+0xc4>
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
10002302:	4c1a      	ldr	r4, [pc, #104]	; (1000236c <__NVIC_SetPriority+0xd0>)
10002304:	1dfb      	adds	r3, r7, #7
10002306:	781b      	ldrb	r3, [r3, #0]
10002308:	1c1a      	adds	r2, r3, #0
1000230a:	230f      	movs	r3, #15
1000230c:	4013      	ands	r3, r2
1000230e:	3b08      	subs	r3, #8
10002310:	0899      	lsrs	r1, r3, #2
10002312:	4a16      	ldr	r2, [pc, #88]	; (1000236c <__NVIC_SetPriority+0xd0>)
10002314:	1dfb      	adds	r3, r7, #7
10002316:	781b      	ldrb	r3, [r3, #0]
10002318:	1c18      	adds	r0, r3, #0
1000231a:	230f      	movs	r3, #15
1000231c:	4003      	ands	r3, r0
1000231e:	3b08      	subs	r3, #8
10002320:	089b      	lsrs	r3, r3, #2
10002322:	3306      	adds	r3, #6
10002324:	009b      	lsls	r3, r3, #2
10002326:	18d3      	adds	r3, r2, r3
10002328:	685b      	ldr	r3, [r3, #4]
1000232a:	1dfa      	adds	r2, r7, #7
1000232c:	7812      	ldrb	r2, [r2, #0]
1000232e:	1c10      	adds	r0, r2, #0
10002330:	2203      	movs	r2, #3
10002332:	4002      	ands	r2, r0
10002334:	00d2      	lsls	r2, r2, #3
10002336:	1c10      	adds	r0, r2, #0
10002338:	22ff      	movs	r2, #255	; 0xff
1000233a:	4082      	lsls	r2, r0
1000233c:	43d2      	mvns	r2, r2
1000233e:	401a      	ands	r2, r3
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
10002340:	683b      	ldr	r3, [r7, #0]
10002342:	019b      	lsls	r3, r3, #6
10002344:	20ff      	movs	r0, #255	; 0xff
10002346:	4003      	ands	r3, r0
10002348:	1df8      	adds	r0, r7, #7
1000234a:	7800      	ldrb	r0, [r0, #0]
1000234c:	1c05      	adds	r5, r0, #0
1000234e:	2003      	movs	r0, #3
10002350:	4028      	ands	r0, r5
10002352:	00c0      	lsls	r0, r0, #3
10002354:	4083      	lsls	r3, r0
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
10002356:	431a      	orrs	r2, r3
10002358:	1d8b      	adds	r3, r1, #6
1000235a:	009b      	lsls	r3, r3, #2
1000235c:	18e3      	adds	r3, r4, r3
1000235e:	605a      	str	r2, [r3, #4]
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
}
10002360:	46bd      	mov	sp, r7
10002362:	b002      	add	sp, #8
10002364:	bdb0      	pop	{r4, r5, r7, pc}
10002366:	46c0      	nop			; (mov r8, r8)
10002368:	e000e100 	.word	0xe000e100
1000236c:	e000ed00 	.word	0xe000ed00

10002370 <XMC_USIC_CH_SetInputSource>:
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_EnableInputInversion(), XMC_USIC_CH_EnableInputDigitalFilter(), XMC_USIC_CH_EnableInputSync(),
 * XMC_USIC_CH_SetInputSamplingFreq()\n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_SetInputSource(XMC_USIC_CH_t *const channel, const XMC_USIC_CH_INPUT_t input, const uint8_t source)
{
10002370:	b580      	push	{r7, lr}
10002372:	b082      	sub	sp, #8
10002374:	af00      	add	r7, sp, #0
10002376:	6078      	str	r0, [r7, #4]
10002378:	1c08      	adds	r0, r1, #0
1000237a:	1c11      	adds	r1, r2, #0
1000237c:	1cfb      	adds	r3, r7, #3
1000237e:	1c02      	adds	r2, r0, #0
10002380:	701a      	strb	r2, [r3, #0]
10002382:	1cbb      	adds	r3, r7, #2
10002384:	1c0a      	adds	r2, r1, #0
10002386:	701a      	strb	r2, [r3, #0]
  channel->DXCR[input] = (uint32_t)((channel->DXCR[input] & (uint32_t)(~USIC_CH_DXCR_DSEL_Msk)) |
10002388:	1cfb      	adds	r3, r7, #3
1000238a:	7818      	ldrb	r0, [r3, #0]
1000238c:	1cfb      	adds	r3, r7, #3
1000238e:	781b      	ldrb	r3, [r3, #0]
10002390:	687a      	ldr	r2, [r7, #4]
10002392:	3306      	adds	r3, #6
10002394:	009b      	lsls	r3, r3, #2
10002396:	18d3      	adds	r3, r2, r3
10002398:	685b      	ldr	r3, [r3, #4]
1000239a:	2207      	movs	r2, #7
1000239c:	4393      	bics	r3, r2
1000239e:	1c1a      	adds	r2, r3, #0
                                    ((uint32_t)source << USIC_CH_DXCR_DSEL_Pos));
100023a0:	1cbb      	adds	r3, r7, #2
100023a2:	781b      	ldrb	r3, [r3, #0]
 * XMC_USIC_CH_EnableInputInversion(), XMC_USIC_CH_EnableInputDigitalFilter(), XMC_USIC_CH_EnableInputSync(),
 * XMC_USIC_CH_SetInputSamplingFreq()\n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_SetInputSource(XMC_USIC_CH_t *const channel, const XMC_USIC_CH_INPUT_t input, const uint8_t source)
{
  channel->DXCR[input] = (uint32_t)((channel->DXCR[input] & (uint32_t)(~USIC_CH_DXCR_DSEL_Msk)) |
100023a4:	431a      	orrs	r2, r3
100023a6:	6879      	ldr	r1, [r7, #4]
100023a8:	1d83      	adds	r3, r0, #6
100023aa:	009b      	lsls	r3, r3, #2
100023ac:	18cb      	adds	r3, r1, r3
100023ae:	605a      	str	r2, [r3, #4]
                                    ((uint32_t)source << USIC_CH_DXCR_DSEL_Pos));
}
100023b0:	46bd      	mov	sp, r7
100023b2:	b002      	add	sp, #8
100023b4:	bd80      	pop	{r7, pc}
100023b6:	46c0      	nop			; (mov r8, r8)

100023b8 <XMC_UART_CH_Init>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_UART_CH_Start(), XMC_UART_CH_Stop(), XMC_UART_CH_Transmit()\n\n\n
 */
__STATIC_INLINE void XMC_UART_CH_Init(XMC_USIC_CH_t *const channel, const XMC_UART_CH_CONFIG_t *const config)
{
100023b8:	b580      	push	{r7, lr}
100023ba:	b082      	sub	sp, #8
100023bc:	af00      	add	r7, sp, #0
100023be:	6078      	str	r0, [r7, #4]
100023c0:	6039      	str	r1, [r7, #0]
  XMC_UART_CH_InitEx(channel, config, true);
100023c2:	687a      	ldr	r2, [r7, #4]
100023c4:	683b      	ldr	r3, [r7, #0]
100023c6:	1c10      	adds	r0, r2, #0
100023c8:	1c19      	adds	r1, r3, #0
100023ca:	2201      	movs	r2, #1
100023cc:	f7ff f994 	bl	100016f8 <XMC_UART_CH_InitEx>
}
100023d0:	46bd      	mov	sp, r7
100023d2:	b002      	add	sp, #8
100023d4:	bd80      	pop	{r7, pc}
100023d6:	46c0      	nop			; (mov r8, r8)

100023d8 <XMC_UART_CH_Start>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_UART_CH_Stop(), XMC_UART_CH_Transmit()\n\n\n
 */
__STATIC_INLINE void XMC_UART_CH_Start(XMC_USIC_CH_t *const channel)
{
100023d8:	b580      	push	{r7, lr}
100023da:	b082      	sub	sp, #8
100023dc:	af00      	add	r7, sp, #0
100023de:	6078      	str	r0, [r7, #4]
  channel->CCR = (uint32_t)(((channel->CCR) & (~USIC_CH_CCR_MODE_Msk)) | (uint32_t)XMC_USIC_CH_OPERATING_MODE_UART);
100023e0:	687b      	ldr	r3, [r7, #4]
100023e2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
100023e4:	220f      	movs	r2, #15
100023e6:	4393      	bics	r3, r2
100023e8:	2202      	movs	r2, #2
100023ea:	431a      	orrs	r2, r3
100023ec:	687b      	ldr	r3, [r7, #4]
100023ee:	641a      	str	r2, [r3, #64]	; 0x40
}
100023f0:	46bd      	mov	sp, r7
100023f2:	b002      	add	sp, #8
100023f4:	bd80      	pop	{r7, pc}
100023f6:	46c0      	nop			; (mov r8, r8)

100023f8 <UART_BLUETOOTH_init>:
/**********************************************************************************************************************
 * API IMPLEMENTATION
 **********************************************************************************************************************/
/*Channel initialization function*/
UART_STATUS_t UART_BLUETOOTH_init()
{
100023f8:	b580      	push	{r7, lr}
100023fa:	b082      	sub	sp, #8
100023fc:	af00      	add	r7, sp, #0
  UART_STATUS_t status = UART_STATUS_SUCCESS;
100023fe:	1dfb      	adds	r3, r7, #7
10002400:	2200      	movs	r2, #0
10002402:	701a      	strb	r2, [r3, #0]
  /*Configure Receive pin*/
  XMC_GPIO_Init((XMC_GPIO_PORT_t *)PORT1_BASE, 2U, &UART_BLUETOOTH_rx_pin_config);
10002404:	4a31      	ldr	r2, [pc, #196]	; (100024cc <UART_BLUETOOTH_init+0xd4>)
10002406:	4b32      	ldr	r3, [pc, #200]	; (100024d0 <UART_BLUETOOTH_init+0xd8>)
10002408:	1c10      	adds	r0, r2, #0
1000240a:	2102      	movs	r1, #2
1000240c:	1c1a      	adds	r2, r3, #0
1000240e:	f7fe fe7d 	bl	1000110c <XMC_GPIO_Init>
  /* Initialize USIC channel in UART mode*/
  XMC_UART_CH_Init(XMC_UART0_CH1, &UART_BLUETOOTH_channel_config);
10002412:	4a30      	ldr	r2, [pc, #192]	; (100024d4 <UART_BLUETOOTH_init+0xdc>)
10002414:	4b30      	ldr	r3, [pc, #192]	; (100024d8 <UART_BLUETOOTH_init+0xe0>)
10002416:	1c10      	adds	r0, r2, #0
10002418:	1c19      	adds	r1, r3, #0
1000241a:	f7ff ffcd 	bl	100023b8 <XMC_UART_CH_Init>
  /*Set input source path*/
  XMC_USIC_CH_SetInputSource(XMC_UART0_CH1, XMC_USIC_CH_INPUT_DX0, 1U);
1000241e:	4b2d      	ldr	r3, [pc, #180]	; (100024d4 <UART_BLUETOOTH_init+0xdc>)
10002420:	1c18      	adds	r0, r3, #0
10002422:	2100      	movs	r1, #0
10002424:	2201      	movs	r2, #1
10002426:	f7ff ffa3 	bl	10002370 <XMC_USIC_CH_SetInputSource>
  XMC_USIC_CH_SetInputSource(XMC_UART0_CH1, XMC_USIC_CH_INPUT_DX3, 0U);
1000242a:	4b2a      	ldr	r3, [pc, #168]	; (100024d4 <UART_BLUETOOTH_init+0xdc>)
1000242c:	1c18      	adds	r0, r3, #0
1000242e:	2103      	movs	r1, #3
10002430:	2200      	movs	r2, #0
10002432:	f7ff ff9d 	bl	10002370 <XMC_USIC_CH_SetInputSource>
  XMC_USIC_CH_SetInputSource(XMC_UART0_CH1, XMC_USIC_CH_INPUT_DX5, 0U);
10002436:	4b27      	ldr	r3, [pc, #156]	; (100024d4 <UART_BLUETOOTH_init+0xdc>)
10002438:	1c18      	adds	r0, r3, #0
1000243a:	2105      	movs	r1, #5
1000243c:	2200      	movs	r2, #0
1000243e:	f7ff ff97 	bl	10002370 <XMC_USIC_CH_SetInputSource>
  /*Configure transmit FIFO*/
  XMC_USIC_CH_TXFIFO_Configure(XMC_UART0_CH1,
10002442:	4b24      	ldr	r3, [pc, #144]	; (100024d4 <UART_BLUETOOTH_init+0xdc>)
10002444:	1c18      	adds	r0, r3, #0
10002446:	2110      	movs	r1, #16
10002448:	2204      	movs	r2, #4
1000244a:	2301      	movs	r3, #1
1000244c:	f7ff fb38 	bl	10001ac0 <XMC_USIC_CH_TXFIFO_Configure>
        16U,
        XMC_USIC_CH_FIFO_SIZE_16WORDS,
        1U);
  /*Configure receive FIFO*/
  XMC_USIC_CH_RXFIFO_Configure(XMC_UART0_CH1,
10002450:	4b20      	ldr	r3, [pc, #128]	; (100024d4 <UART_BLUETOOTH_init+0xdc>)
10002452:	1c18      	adds	r0, r3, #0
10002454:	2100      	movs	r1, #0
10002456:	2204      	movs	r2, #4
10002458:	2300      	movs	r3, #0
1000245a:	f7ff fb5f 	bl	10001b1c <XMC_USIC_CH_RXFIFO_Configure>
        0U,
        XMC_USIC_CH_FIFO_SIZE_16WORDS,
        0U);
  /* Start UART */
  XMC_UART_CH_Start(XMC_UART0_CH1);
1000245e:	4b1d      	ldr	r3, [pc, #116]	; (100024d4 <UART_BLUETOOTH_init+0xdc>)
10002460:	1c18      	adds	r0, r3, #0
10002462:	f7ff ffb9 	bl	100023d8 <XMC_UART_CH_Start>

  /* Initialize UART TX pin */
  XMC_GPIO_Init((XMC_GPIO_PORT_t *)PORT1_BASE, 3U, &UART_BLUETOOTH_tx_pin_config);
10002466:	4a19      	ldr	r2, [pc, #100]	; (100024cc <UART_BLUETOOTH_init+0xd4>)
10002468:	4b1c      	ldr	r3, [pc, #112]	; (100024dc <UART_BLUETOOTH_init+0xe4>)
1000246a:	1c10      	adds	r0, r2, #0
1000246c:	2103      	movs	r1, #3
1000246e:	1c1a      	adds	r2, r3, #0
10002470:	f7fe fe4c 	bl	1000110c <XMC_GPIO_Init>

  /*Set service request for UART protocol events*/
  XMC_USIC_CH_SetInterruptNodePointer(XMC_UART0_CH1, XMC_USIC_CH_INTERRUPT_NODE_POINTER_PROTOCOL,
10002474:	4b17      	ldr	r3, [pc, #92]	; (100024d4 <UART_BLUETOOTH_init+0xdc>)
10002476:	1c18      	adds	r0, r3, #0
10002478:	2110      	movs	r1, #16
1000247a:	2201      	movs	r2, #1
1000247c:	f7ff fb9c 	bl	10001bb8 <XMC_USIC_CH_SetInterruptNodePointer>
     1U);
  /*Set service request for tx FIFO transmit interrupt*/
  XMC_USIC_CH_TXFIFO_SetInterruptNodePointer(XMC_UART0_CH1, XMC_USIC_CH_TXFIFO_INTERRUPT_NODE_POINTER_STANDARD,
10002480:	4b14      	ldr	r3, [pc, #80]	; (100024d4 <UART_BLUETOOTH_init+0xdc>)
10002482:	1c18      	adds	r0, r3, #0
10002484:	2110      	movs	r1, #16
10002486:	2201      	movs	r2, #1
10002488:	f7ff fbb6 	bl	10001bf8 <XMC_USIC_CH_TXFIFO_SetInterruptNodePointer>
      1U);
  /*Set service request for rx FIFO receive interrupt*/
  XMC_USIC_CH_RXFIFO_SetInterruptNodePointer(XMC_UART0_CH1, XMC_USIC_CH_RXFIFO_INTERRUPT_NODE_POINTER_STANDARD,
1000248c:	4b11      	ldr	r3, [pc, #68]	; (100024d4 <UART_BLUETOOTH_init+0xdc>)
1000248e:	1c18      	adds	r0, r3, #0
10002490:	2110      	movs	r1, #16
10002492:	2200      	movs	r2, #0
10002494:	f7ff fbd4 	bl	10001c40 <XMC_USIC_CH_RXFIFO_SetInterruptNodePointer>
       0x0U);
  XMC_USIC_CH_RXFIFO_SetInterruptNodePointer(XMC_UART0_CH1, XMC_USIC_CH_RXFIFO_INTERRUPT_NODE_POINTER_ALTERNATE,
10002498:	4b0e      	ldr	r3, [pc, #56]	; (100024d4 <UART_BLUETOOTH_init+0xdc>)
1000249a:	1c18      	adds	r0, r3, #0
1000249c:	2113      	movs	r1, #19
1000249e:	2200      	movs	r2, #0
100024a0:	f7ff fbce 	bl	10001c40 <XMC_USIC_CH_RXFIFO_SetInterruptNodePointer>
       0x0U);
  /*Set priority and enable NVIC node for transmit interrupt*/
  NVIC_SetPriority((IRQn_Type)10, 3U);
100024a4:	200a      	movs	r0, #10
100024a6:	2103      	movs	r1, #3
100024a8:	f7ff fef8 	bl	1000229c <__NVIC_SetPriority>
  NVIC_EnableIRQ((IRQn_Type)10);
100024ac:	200a      	movs	r0, #10
100024ae:	f7ff fedb 	bl	10002268 <__NVIC_EnableIRQ>
  /*Set priority and enable NVIC node for receive interrupt*/
  NVIC_SetPriority((IRQn_Type)9, 3U);
100024b2:	2009      	movs	r0, #9
100024b4:	2103      	movs	r1, #3
100024b6:	f7ff fef1 	bl	1000229c <__NVIC_SetPriority>
  NVIC_EnableIRQ((IRQn_Type)9);
100024ba:	2009      	movs	r0, #9
100024bc:	f7ff fed4 	bl	10002268 <__NVIC_EnableIRQ>
  return status;
100024c0:	1dfb      	adds	r3, r7, #7
100024c2:	781b      	ldrb	r3, [r3, #0]
}
100024c4:	1c18      	adds	r0, r3, #0
100024c6:	46bd      	mov	sp, r7
100024c8:	b002      	add	sp, #8
100024ca:	bd80      	pop	{r7, pc}
100024cc:	40040100 	.word	0x40040100
100024d0:	1000a5dc 	.word	0x1000a5dc
100024d4:	48000200 	.word	0x48000200
100024d8:	1000a58c 	.word	0x1000a58c
100024dc:	1000a598 	.word	0x1000a598

100024e0 <USIC0_1_IRQHandler>:
/*Interrupt handlers*/
/*Transmit ISR*/
void UART_BLUETOOTH_TX_HANDLER()
{
100024e0:	b580      	push	{r7, lr}
100024e2:	af00      	add	r7, sp, #0
  UART_lTransmitHandler(&UART_BLUETOOTH);
100024e4:	4b02      	ldr	r3, [pc, #8]	; (100024f0 <USIC0_1_IRQHandler+0x10>)
100024e6:	1c18      	adds	r0, r3, #0
100024e8:	f7ff fd78 	bl	10001fdc <UART_lTransmitHandler>
}
100024ec:	46bd      	mov	sp, r7
100024ee:	bd80      	pop	{r7, pc}
100024f0:	20000520 	.word	0x20000520

100024f4 <USIC0_0_IRQHandler>:

/*Receive ISR*/
void UART_BLUETOOTH_RX_HANDLER()
{
100024f4:	b580      	push	{r7, lr}
100024f6:	af00      	add	r7, sp, #0
  UART_lReceiveHandler(&UART_BLUETOOTH);
100024f8:	4b02      	ldr	r3, [pc, #8]	; (10002504 <USIC0_0_IRQHandler+0x10>)
100024fa:	1c18      	adds	r0, r3, #0
100024fc:	f7ff fdf6 	bl	100020ec <UART_lReceiveHandler>
}
10002500:	46bd      	mov	sp, r7
10002502:	bd80      	pop	{r7, pc}
10002504:	20000520 	.word	0x20000520

10002508 <XMC_CCU4_EnableClock>:
 *
 * \par<b>Related APIs:</b><br>
 * XMC_CCU4_DisableClock()<BR> XMC_CCU4_EnableMultipleClocks()<BR> XMC_CCU4_StartPrescaler()<BR> XMC_CCU4_StopPrescaler().
 */
__STATIC_INLINE void XMC_CCU4_EnableClock(XMC_CCU4_MODULE_t *const module, const uint8_t slice_number)
{
10002508:	b580      	push	{r7, lr}
1000250a:	b082      	sub	sp, #8
1000250c:	af00      	add	r7, sp, #0
1000250e:	6078      	str	r0, [r7, #4]
10002510:	1c0a      	adds	r2, r1, #0
10002512:	1cfb      	adds	r3, r7, #3
10002514:	701a      	strb	r2, [r3, #0]
  XMC_ASSERT("XMC_CCU4_EnableClock:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));
  XMC_ASSERT("XMC_CCU4_EnableClock:Invalid Slice Number", (slice_number < 4U));

  module->GIDLC = ((uint32_t) 1) << slice_number;
10002516:	1cfb      	adds	r3, r7, #3
10002518:	781b      	ldrb	r3, [r3, #0]
1000251a:	2201      	movs	r2, #1
1000251c:	409a      	lsls	r2, r3
1000251e:	687b      	ldr	r3, [r7, #4]
10002520:	60da      	str	r2, [r3, #12]
}
10002522:	46bd      	mov	sp, r7
10002524:	b002      	add	sp, #8
10002526:	bd80      	pop	{r7, pc}

10002528 <XMC_CCU4_SLICE_StartTimer>:
 *
 * \par<b>Related APIs:</b><br>
 *  XMC_CCU4_SLICE_StopTimer().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_StartTimer(XMC_CCU4_SLICE_t *const slice)
{
10002528:	b580      	push	{r7, lr}
1000252a:	b082      	sub	sp, #8
1000252c:	af00      	add	r7, sp, #0
1000252e:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_CCU4_SLICE_StartTimer:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TCSET = CCU4_CC4_TCSET_TRBS_Msk;
10002530:	687b      	ldr	r3, [r7, #4]
10002532:	2201      	movs	r2, #1
10002534:	60da      	str	r2, [r3, #12]
}
10002536:	46bd      	mov	sp, r7
10002538:	b002      	add	sp, #8
1000253a:	bd80      	pop	{r7, pc}

1000253c <XMC_CCU4_SLICE_ClearTimer>:
 *
 * \par<b>Related APIs:</b><br>
 *  XMC_CCU4_SLICE_StartTimer().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_ClearTimer(XMC_CCU4_SLICE_t *const slice)
{
1000253c:	b580      	push	{r7, lr}
1000253e:	b082      	sub	sp, #8
10002540:	af00      	add	r7, sp, #0
10002542:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_CCU4_SLICE_ClearTimer:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TCCLR = (uint32_t) CCU4_CC4_TCCLR_TCC_Msk;
10002544:	687b      	ldr	r3, [r7, #4]
10002546:	2202      	movs	r2, #2
10002548:	611a      	str	r2, [r3, #16]
}
1000254a:	46bd      	mov	sp, r7
1000254c:	b002      	add	sp, #8
1000254e:	bd80      	pop	{r7, pc}

10002550 <XMC_CCU4_SLICE_SetTimerPeriodMatch>:
 *
 * \par<b>Related APIs:</b><br>
 *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerPeriodMatch(XMC_CCU4_SLICE_t *const slice, const uint16_t period_val)
{
10002550:	b580      	push	{r7, lr}
10002552:	b082      	sub	sp, #8
10002554:	af00      	add	r7, sp, #0
10002556:	6078      	str	r0, [r7, #4]
10002558:	1c0a      	adds	r2, r1, #0
1000255a:	1cbb      	adds	r3, r7, #2
1000255c:	801a      	strh	r2, [r3, #0]
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerPeriodMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->PRS = (uint32_t) period_val;
1000255e:	1cbb      	adds	r3, r7, #2
10002560:	881a      	ldrh	r2, [r3, #0]
10002562:	687b      	ldr	r3, [r7, #4]
10002564:	635a      	str	r2, [r3, #52]	; 0x34
}
10002566:	46bd      	mov	sp, r7
10002568:	b002      	add	sp, #8
1000256a:	bd80      	pop	{r7, pc}

1000256c <XMC_CCU4_SLICE_SetTimerCompareMatch>:
 *
 * \par<b>Related APIs:</b><br>
 *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerCompareMatch(XMC_CCU4_SLICE_t *const slice, const uint16_t compare_val)
{
1000256c:	b580      	push	{r7, lr}
1000256e:	b082      	sub	sp, #8
10002570:	af00      	add	r7, sp, #0
10002572:	6078      	str	r0, [r7, #4]
10002574:	1c0a      	adds	r2, r1, #0
10002576:	1cbb      	adds	r3, r7, #2
10002578:	801a      	strh	r2, [r3, #0]
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerCompareMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->CRS = (uint32_t) compare_val;
1000257a:	1cbb      	adds	r3, r7, #2
1000257c:	881a      	ldrh	r2, [r3, #0]
1000257e:	687b      	ldr	r3, [r7, #4]
10002580:	63da      	str	r2, [r3, #60]	; 0x3c
}
10002582:	46bd      	mov	sp, r7
10002584:	b002      	add	sp, #8
10002586:	bd80      	pop	{r7, pc}

10002588 <XMC_CCU4_EnableShadowTransfer>:
 *
 * \par<b>Related APIs:</b><br>
 *  None.
 */
__STATIC_INLINE void XMC_CCU4_EnableShadowTransfer(XMC_CCU4_MODULE_t *const module, const uint32_t shadow_transfer_msk)
{
10002588:	b580      	push	{r7, lr}
1000258a:	b082      	sub	sp, #8
1000258c:	af00      	add	r7, sp, #0
1000258e:	6078      	str	r0, [r7, #4]
10002590:	6039      	str	r1, [r7, #0]
  XMC_ASSERT("XMC_CCU4_EnableShadowTransfer:Invalid Slice Pointer", XMC_CCU4_IsValidModule(module));
  module->GCSS = (uint32_t)shadow_transfer_msk;
10002592:	687b      	ldr	r3, [r7, #4]
10002594:	683a      	ldr	r2, [r7, #0]
10002596:	611a      	str	r2, [r3, #16]
}
10002598:	46bd      	mov	sp, r7
1000259a:	b002      	add	sp, #8
1000259c:	bd80      	pop	{r7, pc}
1000259e:	46c0      	nop			; (mov r8, r8)

100025a0 <XMC_CCU4_SLICE_EnableEvent>:
 *  XMC_CCU4_SLICE_SetInterruptNode()<BR> XMC_CCU4_SLICE_EnableMultipleEvents()<BR> XMC_CCU4_SLICE_DisableEvent()<BR>
 *  XMC_CCU4_SLICE_DisableMultipleEvents().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_EnableEvent(XMC_CCU4_SLICE_t *const slice,
    const XMC_CCU4_SLICE_IRQ_ID_t event)
{
100025a0:	b580      	push	{r7, lr}
100025a2:	b082      	sub	sp, #8
100025a4:	af00      	add	r7, sp, #0
100025a6:	6078      	str	r0, [r7, #4]
100025a8:	1c0a      	adds	r2, r1, #0
100025aa:	1cfb      	adds	r3, r7, #3
100025ac:	701a      	strb	r2, [r3, #0]
  XMC_ASSERT("XMC_CCU4_SLICE_EnableEvent:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_EnableEvent:Invalid SR event", XMC_CCU4_SLICE_CHECK_INTERRUPT(event));
  slice->INTE |= ((uint32_t) 1) << ((uint32_t) event);
100025ae:	687b      	ldr	r3, [r7, #4]
100025b0:	22a4      	movs	r2, #164	; 0xa4
100025b2:	589a      	ldr	r2, [r3, r2]
100025b4:	1cfb      	adds	r3, r7, #3
100025b6:	781b      	ldrb	r3, [r3, #0]
100025b8:	2101      	movs	r1, #1
100025ba:	4099      	lsls	r1, r3
100025bc:	1c0b      	adds	r3, r1, #0
100025be:	431a      	orrs	r2, r3
100025c0:	687b      	ldr	r3, [r7, #4]
100025c2:	21a4      	movs	r1, #164	; 0xa4
100025c4:	505a      	str	r2, [r3, r1]
}
100025c6:	46bd      	mov	sp, r7
100025c8:	b002      	add	sp, #8
100025ca:	bd80      	pop	{r7, pc}

100025cc <TIMER_Init>:
/*
 * This function initializes a TIMER APP based on user configuration.
 *
 */
TIMER_STATUS_t TIMER_Init(TIMER_t* const handle_ptr)
{
100025cc:	b590      	push	{r4, r7, lr}
100025ce:	b085      	sub	sp, #20
100025d0:	af00      	add	r7, sp, #0
100025d2:	6078      	str	r0, [r7, #4]
  TIMER_STATUS_t status;

  XMC_ASSERT("TIMER_Init:handle_ptr NULL" , (handle_ptr != NULL));

  status = TIMER_STATUS_SUCCESS;
100025d4:	230f      	movs	r3, #15
100025d6:	18fb      	adds	r3, r7, r3
100025d8:	2200      	movs	r2, #0
100025da:	701a      	strb	r2, [r3, #0]
  /* Check for APP instance is initialized or not */
  if (false == handle_ptr->initialized)
100025dc:	687b      	ldr	r3, [r7, #4]
100025de:	2226      	movs	r2, #38	; 0x26
100025e0:	5c9b      	ldrb	r3, [r3, r2]
100025e2:	2201      	movs	r2, #1
100025e4:	4053      	eors	r3, r2
100025e6:	b2db      	uxtb	r3, r3
100025e8:	2b00      	cmp	r3, #0
100025ea:	d00c      	beq.n	10002606 <TIMER_Init+0x3a>
  {
#ifdef TIMER_CCU4_USED
    if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
100025ec:	687b      	ldr	r3, [r7, #4]
100025ee:	2221      	movs	r2, #33	; 0x21
100025f0:	5c9b      	ldrb	r3, [r3, r2]
100025f2:	2b00      	cmp	r3, #0
100025f4:	d107      	bne.n	10002606 <TIMER_Init+0x3a>
    {
      /* Configure CCU4 timer for the required time tick settings */
      status = TIMER_CCU4_lInit(handle_ptr);
100025f6:	230f      	movs	r3, #15
100025f8:	18fc      	adds	r4, r7, r3
100025fa:	687b      	ldr	r3, [r7, #4]
100025fc:	1c18      	adds	r0, r3, #0
100025fe:	f000 f82d 	bl	1000265c <TIMER_CCU4_lInit>
10002602:	1c03      	adds	r3, r0, #0
10002604:	7023      	strb	r3, [r4, #0]
      status = TIMER_CCU8_lInit(handle_ptr);
    }
#endif
  }

  return (status);
10002606:	230f      	movs	r3, #15
10002608:	18fb      	adds	r3, r7, r3
1000260a:	781b      	ldrb	r3, [r3, #0]
}
1000260c:	1c18      	adds	r0, r3, #0
1000260e:	46bd      	mov	sp, r7
10002610:	b005      	add	sp, #20
10002612:	bd90      	pop	{r4, r7, pc}

10002614 <TIMER_Start>:

/*
 * This function starts the timer to generate the events for the specified time_interval value
 */
TIMER_STATUS_t TIMER_Start(TIMER_t  *const handle_ptr)
{
10002614:	b580      	push	{r7, lr}
10002616:	b084      	sub	sp, #16
10002618:	af00      	add	r7, sp, #0
1000261a:	6078      	str	r0, [r7, #4]
  TIMER_STATUS_t status;

  XMC_ASSERT("TIMER_Start:handle_ptr NULL" , (handle_ptr != NULL));

  /* Check for APP instance is initialized or not */
  if (true == handle_ptr->initialized)
1000261c:	687b      	ldr	r3, [r7, #4]
1000261e:	2226      	movs	r2, #38	; 0x26
10002620:	5c9b      	ldrb	r3, [r3, r2]
10002622:	2b00      	cmp	r3, #0
10002624:	d00e      	beq.n	10002644 <TIMER_Start+0x30>
  {
#ifdef TIMER_CCU4_USED
    if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
10002626:	687b      	ldr	r3, [r7, #4]
10002628:	2221      	movs	r2, #33	; 0x21
1000262a:	5c9b      	ldrb	r3, [r3, r2]
1000262c:	2b00      	cmp	r3, #0
1000262e:	d104      	bne.n	1000263a <TIMER_Start+0x26>
    {
      /* Start the timer manually */
      XMC_CCU4_SLICE_StartTimer(handle_ptr->ccu4_slice_ptr);
10002630:	687b      	ldr	r3, [r7, #4]
10002632:	695b      	ldr	r3, [r3, #20]
10002634:	1c18      	adds	r0, r3, #0
10002636:	f7ff ff77 	bl	10002528 <XMC_CCU4_SLICE_StartTimer>
       {
      /* Start the timer manually */
      XMC_CCU8_SLICE_StartTimer(handle_ptr->ccu8_slice_ptr);
       }
#endif
    status = TIMER_STATUS_SUCCESS;
1000263a:	230f      	movs	r3, #15
1000263c:	18fb      	adds	r3, r7, r3
1000263e:	2200      	movs	r2, #0
10002640:	701a      	strb	r2, [r3, #0]
10002642:	e003      	b.n	1000264c <TIMER_Start+0x38>
  }
  else
  {
    status = TIMER_STATUS_FAILURE;
10002644:	230f      	movs	r3, #15
10002646:	18fb      	adds	r3, r7, r3
10002648:	2201      	movs	r2, #1
1000264a:	701a      	strb	r2, [r3, #0]
  }

  return (status);
1000264c:	230f      	movs	r3, #15
1000264e:	18fb      	adds	r3, r7, r3
10002650:	781b      	ldrb	r3, [r3, #0]
}
10002652:	1c18      	adds	r0, r3, #0
10002654:	46bd      	mov	sp, r7
10002656:	b004      	add	sp, #16
10002658:	bd80      	pop	{r7, pc}
1000265a:	46c0      	nop			; (mov r8, r8)

1000265c <TIMER_CCU4_lInit>:
#ifdef TIMER_CCU4_USED
/*
 * This function configures timer ccu4 timer with required time tick value
 */
TIMER_STATUS_t TIMER_CCU4_lInit(TIMER_t* const handle_ptr)
{
1000265c:	b590      	push	{r4, r7, lr}
1000265e:	b085      	sub	sp, #20
10002660:	af00      	add	r7, sp, #0
10002662:	6078      	str	r0, [r7, #4]
  TIMER_STATUS_t status;
  /* Initialize the global registers */
  status = (TIMER_STATUS_t)GLOBAL_CCU4_Init(handle_ptr->global_ccu4_handler);
10002664:	687b      	ldr	r3, [r7, #4]
10002666:	691b      	ldr	r3, [r3, #16]
10002668:	220f      	movs	r2, #15
1000266a:	18bc      	adds	r4, r7, r2
1000266c:	1c18      	adds	r0, r3, #0
1000266e:	f000 fa61 	bl	10002b34 <GLOBAL_CCU4_Init>
10002672:	1c03      	adds	r3, r0, #0
10002674:	7023      	strb	r3, [r4, #0]

  /* Enable the clock for selected timer */
  XMC_CCU4_EnableClock(handle_ptr->global_ccu4_handler->module_ptr, handle_ptr->ccu4_slice_number);
10002676:	687b      	ldr	r3, [r7, #4]
10002678:	691b      	ldr	r3, [r3, #16]
1000267a:	689a      	ldr	r2, [r3, #8]
1000267c:	687b      	ldr	r3, [r7, #4]
1000267e:	7e1b      	ldrb	r3, [r3, #24]
10002680:	1c10      	adds	r0, r2, #0
10002682:	1c19      	adds	r1, r3, #0
10002684:	f7ff ff40 	bl	10002508 <XMC_CCU4_EnableClock>
  /* Configure the timer with required settings */
  XMC_CCU4_SLICE_CompareInit(handle_ptr->ccu4_slice_ptr, handle_ptr->ccu4_slice_config_ptr);
10002688:	687b      	ldr	r3, [r7, #4]
1000268a:	695a      	ldr	r2, [r3, #20]
1000268c:	687b      	ldr	r3, [r7, #4]
1000268e:	69db      	ldr	r3, [r3, #28]
10002690:	1c10      	adds	r0, r2, #0
10002692:	1c19      	adds	r1, r3, #0
10002694:	f7fe ff68 	bl	10001568 <XMC_CCU4_SLICE_CompareInit>
  /* programs the timer period and compare register according to time interval value and do the shadow transfer */
  TIMER_CCU4_lShadowTransfer(handle_ptr);
10002698:	687b      	ldr	r3, [r7, #4]
1000269a:	1c18      	adds	r0, r3, #0
1000269c:	f000 f830 	bl	10002700 <TIMER_CCU4_lShadowTransfer>

#ifdef  TIMER_INTERRUPT
  if (true == handle_ptr->period_match_enable)
100026a0:	687b      	ldr	r3, [r7, #4]
100026a2:	2225      	movs	r2, #37	; 0x25
100026a4:	5c9b      	ldrb	r3, [r3, r2]
100026a6:	2b00      	cmp	r3, #0
100026a8:	d00f      	beq.n	100026ca <TIMER_CCU4_lInit+0x6e>
  {
    /* Binds a period match event to an NVIC node  */
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH,
100026aa:	687b      	ldr	r3, [r7, #4]
100026ac:	6959      	ldr	r1, [r3, #20]
100026ae:	687b      	ldr	r3, [r7, #4]
100026b0:	2220      	movs	r2, #32
100026b2:	5c9b      	ldrb	r3, [r3, r2]
100026b4:	1c08      	adds	r0, r1, #0
100026b6:	2100      	movs	r1, #0
100026b8:	1c1a      	adds	r2, r3, #0
100026ba:	f7fe ff89 	bl	100015d0 <XMC_CCU4_SLICE_SetInterruptNode>
                                    handle_ptr->ccu4_period_match_node);
    /* Enables a timer(period match) event  */
    XMC_CCU4_SLICE_EnableEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH);
100026be:	687b      	ldr	r3, [r7, #4]
100026c0:	695b      	ldr	r3, [r3, #20]
100026c2:	1c18      	adds	r0, r3, #0
100026c4:	2100      	movs	r1, #0
100026c6:	f7ff ff6b 	bl	100025a0 <XMC_CCU4_SLICE_EnableEvent>
  }
#endif
  /* Clears the timer register */
  XMC_CCU4_SLICE_ClearTimer(handle_ptr->ccu4_slice_ptr);
100026ca:	687b      	ldr	r3, [r7, #4]
100026cc:	695b      	ldr	r3, [r3, #20]
100026ce:	1c18      	adds	r0, r3, #0
100026d0:	f7ff ff34 	bl	1000253c <XMC_CCU4_SLICE_ClearTimer>

  /* update the initialization flag as true for particular instance*/
  handle_ptr->initialized = true;
100026d4:	687b      	ldr	r3, [r7, #4]
100026d6:	2226      	movs	r2, #38	; 0x26
100026d8:	2101      	movs	r1, #1
100026da:	5499      	strb	r1, [r3, r2]

  /* Check whether the start of the timer is enabled during initialization or not */
  if (handle_ptr->start_control == true)
100026dc:	687b      	ldr	r3, [r7, #4]
100026de:	2224      	movs	r2, #36	; 0x24
100026e0:	5c9b      	ldrb	r3, [r3, r2]
100026e2:	2b00      	cmp	r3, #0
100026e4:	d004      	beq.n	100026f0 <TIMER_CCU4_lInit+0x94>
  {
    /* Start the timer */
    XMC_CCU4_SLICE_StartTimer(handle_ptr->ccu4_slice_ptr);
100026e6:	687b      	ldr	r3, [r7, #4]
100026e8:	695b      	ldr	r3, [r3, #20]
100026ea:	1c18      	adds	r0, r3, #0
100026ec:	f7ff ff1c 	bl	10002528 <XMC_CCU4_SLICE_StartTimer>
  }

  return (status);
100026f0:	230f      	movs	r3, #15
100026f2:	18fb      	adds	r3, r7, r3
100026f4:	781b      	ldrb	r3, [r3, #0]
}
100026f6:	1c18      	adds	r0, r3, #0
100026f8:	46bd      	mov	sp, r7
100026fa:	b005      	add	sp, #20
100026fc:	bd90      	pop	{r4, r7, pc}
100026fe:	46c0      	nop			; (mov r8, r8)

10002700 <TIMER_CCU4_lShadowTransfer>:

/*
 * This function configures timer period and compare values and triggers the shadow transfer operation
 */
void TIMER_CCU4_lShadowTransfer(TIMER_t* const handle_ptr)
{
10002700:	b580      	push	{r7, lr}
10002702:	b082      	sub	sp, #8
10002704:	af00      	add	r7, sp, #0
10002706:	6078      	str	r0, [r7, #4]
  /* programs the timer period register according to time interval value */
  XMC_CCU4_SLICE_SetTimerPeriodMatch(handle_ptr->ccu4_slice_ptr, handle_ptr->period_value);
10002708:	687b      	ldr	r3, [r7, #4]
1000270a:	695a      	ldr	r2, [r3, #20]
1000270c:	687b      	ldr	r3, [r7, #4]
1000270e:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
10002710:	1c10      	adds	r0, r2, #0
10002712:	1c19      	adds	r1, r3, #0
10002714:	f7ff ff1c 	bl	10002550 <XMC_CCU4_SLICE_SetTimerPeriodMatch>
  /* programs the timer compare register for 50% duty cycle */
  XMC_CCU4_SLICE_SetTimerCompareMatch(handle_ptr->ccu4_slice_ptr, TIMER_CMP_100_DUTY);
10002718:	687b      	ldr	r3, [r7, #4]
1000271a:	695b      	ldr	r3, [r3, #20]
1000271c:	1c18      	adds	r0, r3, #0
1000271e:	2100      	movs	r1, #0
10002720:	f7ff ff24 	bl	1000256c <XMC_CCU4_SLICE_SetTimerCompareMatch>
  /* Transfers value from shadow timer registers to actual timer registers */
  XMC_CCU4_EnableShadowTransfer(handle_ptr->global_ccu4_handler->module_ptr, handle_ptr->shadow_mask);
10002724:	687b      	ldr	r3, [r7, #4]
10002726:	691b      	ldr	r3, [r3, #16]
10002728:	689a      	ldr	r2, [r3, #8]
1000272a:	687b      	ldr	r3, [r7, #4]
1000272c:	68db      	ldr	r3, [r3, #12]
1000272e:	1c10      	adds	r0, r2, #0
10002730:	1c19      	adds	r1, r3, #0
10002732:	f7ff ff29 	bl	10002588 <XMC_CCU4_EnableShadowTransfer>
}
10002736:	46bd      	mov	sp, r7
10002738:	b002      	add	sp, #8
1000273a:	bd80      	pop	{r7, pc}

1000273c <XMC_CCU4_EnableClock>:
 *
 * \par<b>Related APIs:</b><br>
 * XMC_CCU4_DisableClock()<BR> XMC_CCU4_EnableMultipleClocks()<BR> XMC_CCU4_StartPrescaler()<BR> XMC_CCU4_StopPrescaler().
 */
__STATIC_INLINE void XMC_CCU4_EnableClock(XMC_CCU4_MODULE_t *const module, const uint8_t slice_number)
{
1000273c:	b580      	push	{r7, lr}
1000273e:	b082      	sub	sp, #8
10002740:	af00      	add	r7, sp, #0
10002742:	6078      	str	r0, [r7, #4]
10002744:	1c0a      	adds	r2, r1, #0
10002746:	1cfb      	adds	r3, r7, #3
10002748:	701a      	strb	r2, [r3, #0]
  XMC_ASSERT("XMC_CCU4_EnableClock:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));
  XMC_ASSERT("XMC_CCU4_EnableClock:Invalid Slice Number", (slice_number < 4U));

  module->GIDLC = ((uint32_t) 1) << slice_number;
1000274a:	1cfb      	adds	r3, r7, #3
1000274c:	781b      	ldrb	r3, [r3, #0]
1000274e:	2201      	movs	r2, #1
10002750:	409a      	lsls	r2, r3
10002752:	687b      	ldr	r3, [r7, #4]
10002754:	60da      	str	r2, [r3, #12]
}
10002756:	46bd      	mov	sp, r7
10002758:	b002      	add	sp, #8
1000275a:	bd80      	pop	{r7, pc}

1000275c <XMC_CCU4_SLICE_StartTimer>:
 *
 * \par<b>Related APIs:</b><br>
 *  XMC_CCU4_SLICE_StopTimer().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_StartTimer(XMC_CCU4_SLICE_t *const slice)
{
1000275c:	b580      	push	{r7, lr}
1000275e:	b082      	sub	sp, #8
10002760:	af00      	add	r7, sp, #0
10002762:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_CCU4_SLICE_StartTimer:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TCSET = CCU4_CC4_TCSET_TRBS_Msk;
10002764:	687b      	ldr	r3, [r7, #4]
10002766:	2201      	movs	r2, #1
10002768:	60da      	str	r2, [r3, #12]
}
1000276a:	46bd      	mov	sp, r7
1000276c:	b002      	add	sp, #8
1000276e:	bd80      	pop	{r7, pc}

10002770 <XMC_CCU4_SLICE_SetTimerPeriodMatch>:
 *
 * \par<b>Related APIs:</b><br>
 *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerPeriodMatch(XMC_CCU4_SLICE_t *const slice, const uint16_t period_val)
{
10002770:	b580      	push	{r7, lr}
10002772:	b082      	sub	sp, #8
10002774:	af00      	add	r7, sp, #0
10002776:	6078      	str	r0, [r7, #4]
10002778:	1c0a      	adds	r2, r1, #0
1000277a:	1cbb      	adds	r3, r7, #2
1000277c:	801a      	strh	r2, [r3, #0]
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerPeriodMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->PRS = (uint32_t) period_val;
1000277e:	1cbb      	adds	r3, r7, #2
10002780:	881a      	ldrh	r2, [r3, #0]
10002782:	687b      	ldr	r3, [r7, #4]
10002784:	635a      	str	r2, [r3, #52]	; 0x34
}
10002786:	46bd      	mov	sp, r7
10002788:	b002      	add	sp, #8
1000278a:	bd80      	pop	{r7, pc}

1000278c <XMC_CCU4_SLICE_SetTimerCompareMatch>:
 *
 * \par<b>Related APIs:</b><br>
 *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerCompareMatch(XMC_CCU4_SLICE_t *const slice, const uint16_t compare_val)
{
1000278c:	b580      	push	{r7, lr}
1000278e:	b082      	sub	sp, #8
10002790:	af00      	add	r7, sp, #0
10002792:	6078      	str	r0, [r7, #4]
10002794:	1c0a      	adds	r2, r1, #0
10002796:	1cbb      	adds	r3, r7, #2
10002798:	801a      	strh	r2, [r3, #0]
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerCompareMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->CRS = (uint32_t) compare_val;
1000279a:	1cbb      	adds	r3, r7, #2
1000279c:	881a      	ldrh	r2, [r3, #0]
1000279e:	687b      	ldr	r3, [r7, #4]
100027a0:	63da      	str	r2, [r3, #60]	; 0x3c
}
100027a2:	46bd      	mov	sp, r7
100027a4:	b002      	add	sp, #8
100027a6:	bd80      	pop	{r7, pc}

100027a8 <XMC_CCU4_EnableShadowTransfer>:
 *
 * \par<b>Related APIs:</b><br>
 *  None.
 */
__STATIC_INLINE void XMC_CCU4_EnableShadowTransfer(XMC_CCU4_MODULE_t *const module, const uint32_t shadow_transfer_msk)
{
100027a8:	b580      	push	{r7, lr}
100027aa:	b082      	sub	sp, #8
100027ac:	af00      	add	r7, sp, #0
100027ae:	6078      	str	r0, [r7, #4]
100027b0:	6039      	str	r1, [r7, #0]
  XMC_ASSERT("XMC_CCU4_EnableShadowTransfer:Invalid Slice Pointer", XMC_CCU4_IsValidModule(module));
  module->GCSS = (uint32_t)shadow_transfer_msk;
100027b2:	687b      	ldr	r3, [r7, #4]
100027b4:	683a      	ldr	r2, [r7, #0]
100027b6:	611a      	str	r2, [r3, #16]
}
100027b8:	46bd      	mov	sp, r7
100027ba:	b002      	add	sp, #8
100027bc:	bd80      	pop	{r7, pc}
100027be:	46c0      	nop			; (mov r8, r8)

100027c0 <XMC_CCU4_SLICE_EnableEvent>:
 *  XMC_CCU4_SLICE_SetInterruptNode()<BR> XMC_CCU4_SLICE_EnableMultipleEvents()<BR> XMC_CCU4_SLICE_DisableEvent()<BR>
 *  XMC_CCU4_SLICE_DisableMultipleEvents().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_EnableEvent(XMC_CCU4_SLICE_t *const slice,
    const XMC_CCU4_SLICE_IRQ_ID_t event)
{
100027c0:	b580      	push	{r7, lr}
100027c2:	b082      	sub	sp, #8
100027c4:	af00      	add	r7, sp, #0
100027c6:	6078      	str	r0, [r7, #4]
100027c8:	1c0a      	adds	r2, r1, #0
100027ca:	1cfb      	adds	r3, r7, #3
100027cc:	701a      	strb	r2, [r3, #0]
  XMC_ASSERT("XMC_CCU4_SLICE_EnableEvent:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_EnableEvent:Invalid SR event", XMC_CCU4_SLICE_CHECK_INTERRUPT(event));
  slice->INTE |= ((uint32_t) 1) << ((uint32_t) event);
100027ce:	687b      	ldr	r3, [r7, #4]
100027d0:	22a4      	movs	r2, #164	; 0xa4
100027d2:	589a      	ldr	r2, [r3, r2]
100027d4:	1cfb      	adds	r3, r7, #3
100027d6:	781b      	ldrb	r3, [r3, #0]
100027d8:	2101      	movs	r1, #1
100027da:	4099      	lsls	r1, r3
100027dc:	1c0b      	adds	r3, r1, #0
100027de:	431a      	orrs	r2, r3
100027e0:	687b      	ldr	r3, [r7, #4]
100027e2:	21a4      	movs	r1, #164	; 0xa4
100027e4:	505a      	str	r2, [r3, r1]
}
100027e6:	46bd      	mov	sp, r7
100027e8:	b002      	add	sp, #8
100027ea:	bd80      	pop	{r7, pc}

100027ec <PWM_lCCU4_Init>:

#ifdef PWM_SLICE_USED_CCU4

/*Initialize the APP and CCU4 slice. */
PWM_STATUS_t PWM_lCCU4_Init(PWM_t *const handle_ptr)
{
100027ec:	b590      	push	{r4, r7, lr}
100027ee:	b085      	sub	sp, #20
100027f0:	af00      	add	r7, sp, #0
100027f2:	6078      	str	r0, [r7, #4]
  PWM_STATUS_t status = PWM_STATUS_FAILURE;
100027f4:	230f      	movs	r3, #15
100027f6:	18fb      	adds	r3, r7, r3
100027f8:	2201      	movs	r2, #1
100027fa:	701a      	strb	r2, [r3, #0]

  XMC_ASSERT("PWM_lCCU4_Init:Invalid handle_ptr" , (handle_ptr != NULL));

  if (PWM_STATUS_UNINITIALIZED == handle_ptr->state)
100027fc:	687b      	ldr	r3, [r7, #4]
100027fe:	2229      	movs	r2, #41	; 0x29
10002800:	5c9b      	ldrb	r3, [r3, r2]
10002802:	2b02      	cmp	r3, #2
10002804:	d155      	bne.n	100028b2 <PWM_lCCU4_Init+0xc6>
  {
    /* Initialize consumed Apps */
    status = (PWM_STATUS_t)GLOBAL_CCU4_Init(handle_ptr->global_ccu4_handle);
10002806:	687b      	ldr	r3, [r7, #4]
10002808:	681b      	ldr	r3, [r3, #0]
1000280a:	220f      	movs	r2, #15
1000280c:	18bc      	adds	r4, r7, r2
1000280e:	1c18      	adds	r0, r3, #0
10002810:	f000 f990 	bl	10002b34 <GLOBAL_CCU4_Init>
10002814:	1c03      	adds	r3, r0, #0
10002816:	7023      	strb	r3, [r4, #0]

    /*Initialize CCU4 slice */
    if (PWM_STATUS_SUCCESS == status)/*check GLOBAL_CCU4_Init status*/
10002818:	230f      	movs	r3, #15
1000281a:	18fb      	adds	r3, r7, r3
1000281c:	781b      	ldrb	r3, [r3, #0]
1000281e:	2b00      	cmp	r3, #0
10002820:	d143      	bne.n	100028aa <PWM_lCCU4_Init+0xbe>
    {
      XMC_DEBUG("PWM_lCCU4_Init:Initilizing Slice")
      XMC_CCU4_SLICE_CompareInit(handle_ptr->ccu4_slice_ptr, handle_ptr->ccu4_slice_config_ptr);
10002822:	687b      	ldr	r3, [r7, #4]
10002824:	689a      	ldr	r2, [r3, #8]
10002826:	687b      	ldr	r3, [r7, #4]
10002828:	68db      	ldr	r3, [r3, #12]
1000282a:	1c10      	adds	r0, r2, #0
1000282c:	1c19      	adds	r1, r3, #0
1000282e:	f7fe fe9b 	bl	10001568 <XMC_CCU4_SLICE_CompareInit>

      /* Set the period and compare register values */
      XMC_CCU4_SLICE_SetTimerPeriodMatch(handle_ptr->ccu4_slice_ptr,
10002832:	687b      	ldr	r3, [r7, #4]
10002834:	689a      	ldr	r2, [r3, #8]
    		                             (uint16_t)handle_ptr->period_value);
10002836:	687b      	ldr	r3, [r7, #4]
10002838:	69db      	ldr	r3, [r3, #28]
    {
      XMC_DEBUG("PWM_lCCU4_Init:Initilizing Slice")
      XMC_CCU4_SLICE_CompareInit(handle_ptr->ccu4_slice_ptr, handle_ptr->ccu4_slice_config_ptr);

      /* Set the period and compare register values */
      XMC_CCU4_SLICE_SetTimerPeriodMatch(handle_ptr->ccu4_slice_ptr,
1000283a:	b29b      	uxth	r3, r3
1000283c:	1c10      	adds	r0, r2, #0
1000283e:	1c19      	adds	r1, r3, #0
10002840:	f7ff ff96 	bl	10002770 <XMC_CCU4_SLICE_SetTimerPeriodMatch>
    		                             (uint16_t)handle_ptr->period_value);

      XMC_CCU4_SLICE_SetTimerCompareMatch(handle_ptr->ccu4_slice_ptr,
10002844:	687b      	ldr	r3, [r7, #4]
10002846:	689a      	ldr	r2, [r3, #8]
    		                              (uint16_t)handle_ptr->compare_value);
10002848:	687b      	ldr	r3, [r7, #4]
1000284a:	699b      	ldr	r3, [r3, #24]

      /* Set the period and compare register values */
      XMC_CCU4_SLICE_SetTimerPeriodMatch(handle_ptr->ccu4_slice_ptr,
    		                             (uint16_t)handle_ptr->period_value);

      XMC_CCU4_SLICE_SetTimerCompareMatch(handle_ptr->ccu4_slice_ptr,
1000284c:	b29b      	uxth	r3, r3
1000284e:	1c10      	adds	r0, r2, #0
10002850:	1c19      	adds	r1, r3, #0
10002852:	f7ff ff9b 	bl	1000278c <XMC_CCU4_SLICE_SetTimerCompareMatch>
    		                              (uint16_t)handle_ptr->compare_value);

      XMC_CCU4_EnableShadowTransfer(handle_ptr->ccu4_kernel_ptr, handle_ptr->shadow_mask);
10002856:	687b      	ldr	r3, [r7, #4]
10002858:	685a      	ldr	r2, [r3, #4]
1000285a:	687b      	ldr	r3, [r7, #4]
1000285c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
1000285e:	1c10      	adds	r0, r2, #0
10002860:	1c19      	adds	r1, r3, #0
10002862:	f7ff ffa1 	bl	100027a8 <XMC_CCU4_EnableShadowTransfer>

      /* Initialize interrupts */
      PWM_lCCU4_ConfigInterrupts(handle_ptr);
10002866:	687b      	ldr	r3, [r7, #4]
10002868:	1c18      	adds	r0, r3, #0
1000286a:	f000 f829 	bl	100028c0 <PWM_lCCU4_ConfigInterrupts>

      XMC_GPIO_Init(handle_ptr->gpio_out_port,handle_ptr->gpio_out_pin,
1000286e:	687b      	ldr	r3, [r7, #4]
10002870:	6919      	ldr	r1, [r3, #16]
10002872:	687b      	ldr	r3, [r7, #4]
10002874:	222c      	movs	r2, #44	; 0x2c
10002876:	5c9a      	ldrb	r2, [r3, r2]
10002878:	687b      	ldr	r3, [r7, #4]
1000287a:	695b      	ldr	r3, [r3, #20]
1000287c:	1c08      	adds	r0, r1, #0
1000287e:	1c11      	adds	r1, r2, #0
10002880:	1c1a      	adds	r2, r3, #0
10002882:	f7fe fc43 	bl	1000110c <XMC_GPIO_Init>
    		        handle_ptr->gpio_out_config);

      handle_ptr->state = PWM_STATUS_SUCCESS;
10002886:	687b      	ldr	r3, [r7, #4]
10002888:	2229      	movs	r2, #41	; 0x29
1000288a:	2100      	movs	r1, #0
1000288c:	5499      	strb	r1, [r3, r2]

      /* Start the PWM generation if start at initialization is enabled */
      if ((bool) true == handle_ptr->start_control)
1000288e:	687b      	ldr	r3, [r7, #4]
10002890:	222f      	movs	r2, #47	; 0x2f
10002892:	5c9b      	ldrb	r3, [r3, r2]
10002894:	2b00      	cmp	r3, #0
10002896:	d003      	beq.n	100028a0 <PWM_lCCU4_Init+0xb4>
      {
        PWM_Start(handle_ptr);
10002898:	687b      	ldr	r3, [r7, #4]
1000289a:	1c18      	adds	r0, r3, #0
1000289c:	f000 f882 	bl	100029a4 <PWM_Start>
      }
      status = PWM_STATUS_SUCCESS;
100028a0:	230f      	movs	r3, #15
100028a2:	18fb      	adds	r3, r7, r3
100028a4:	2200      	movs	r2, #0
100028a6:	701a      	strb	r2, [r3, #0]
100028a8:	e003      	b.n	100028b2 <PWM_lCCU4_Init+0xc6>
    }
    else
    {
      handle_ptr->state = PWM_STATUS_UNINITIALIZED;
100028aa:	687b      	ldr	r3, [r7, #4]
100028ac:	2229      	movs	r2, #41	; 0x29
100028ae:	2102      	movs	r1, #2
100028b0:	5499      	strb	r1, [r3, r2]
    }

  }
  return (status);
100028b2:	230f      	movs	r3, #15
100028b4:	18fb      	adds	r3, r7, r3
100028b6:	781b      	ldrb	r3, [r3, #0]
} /* end of PWM_lCCU4_Init() api */
100028b8:	1c18      	adds	r0, r3, #0
100028ba:	46bd      	mov	sp, r7
100028bc:	b005      	add	sp, #20
100028be:	bd90      	pop	{r4, r7, pc}

100028c0 <PWM_lCCU4_ConfigInterrupts>:

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Initialize interrupts */
void PWM_lCCU4_ConfigInterrupts(PWM_t *const handle_ptr)
{
100028c0:	b580      	push	{r7, lr}
100028c2:	b082      	sub	sp, #8
100028c4:	af00      	add	r7, sp, #0
100028c6:	6078      	str	r0, [r7, #4]
  if ((bool) true == handle_ptr->period_match_enable)
100028c8:	687b      	ldr	r3, [r7, #4]
100028ca:	2230      	movs	r2, #48	; 0x30
100028cc:	5c9b      	ldrb	r3, [r3, r2]
100028ce:	2b00      	cmp	r3, #0
100028d0:	d00f      	beq.n	100028f2 <PWM_lCCU4_ConfigInterrupts+0x32>
  {
    XMC_DEBUG("PWM_lCCU4_ConfigInterrupts:period match enable")
    XMC_CCU4_SLICE_EnableEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH);
100028d2:	687b      	ldr	r3, [r7, #4]
100028d4:	689b      	ldr	r3, [r3, #8]
100028d6:	1c18      	adds	r0, r3, #0
100028d8:	2100      	movs	r1, #0
100028da:	f7ff ff71 	bl	100027c0 <XMC_CCU4_SLICE_EnableEvent>

    /* Bind event to Service Request Node to period match event*/
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH,
100028de:	687b      	ldr	r3, [r7, #4]
100028e0:	6899      	ldr	r1, [r3, #8]
100028e2:	687b      	ldr	r3, [r7, #4]
100028e4:	222a      	movs	r2, #42	; 0x2a
100028e6:	5c9b      	ldrb	r3, [r3, r2]
100028e8:	1c08      	adds	r0, r1, #0
100028ea:	2100      	movs	r1, #0
100028ec:	1c1a      	adds	r2, r3, #0
100028ee:	f7fe fe6f 	bl	100015d0 <XMC_CCU4_SLICE_SetInterruptNode>
                                    handle_ptr->ccu4_slice_period_match_node);
  }

  if ((bool) true == handle_ptr->compare_match_enable)
100028f2:	687b      	ldr	r3, [r7, #4]
100028f4:	2231      	movs	r2, #49	; 0x31
100028f6:	5c9b      	ldrb	r3, [r3, r2]
100028f8:	2b00      	cmp	r3, #0
100028fa:	d00f      	beq.n	1000291c <PWM_lCCU4_ConfigInterrupts+0x5c>
  {
    XMC_DEBUG("PWM_lCCU4_ConfigInterrupts:compare match enable")
    XMC_CCU4_SLICE_EnableEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_UP);
100028fc:	687b      	ldr	r3, [r7, #4]
100028fe:	689b      	ldr	r3, [r3, #8]
10002900:	1c18      	adds	r0, r3, #0
10002902:	2102      	movs	r1, #2
10002904:	f7ff ff5c 	bl	100027c0 <XMC_CCU4_SLICE_EnableEvent>

    /* Bind event to Service Request Node to compare match event */
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_UP,
10002908:	687b      	ldr	r3, [r7, #4]
1000290a:	6899      	ldr	r1, [r3, #8]
1000290c:	687b      	ldr	r3, [r7, #4]
1000290e:	222b      	movs	r2, #43	; 0x2b
10002910:	5c9b      	ldrb	r3, [r3, r2]
10002912:	1c08      	adds	r0, r1, #0
10002914:	2102      	movs	r1, #2
10002916:	1c1a      	adds	r2, r3, #0
10002918:	f7fe fe5a 	bl	100015d0 <XMC_CCU4_SLICE_SetInterruptNode>
                                    handle_ptr->ccu4_slice_compare_match_node);
  }
}
1000291c:	46bd      	mov	sp, r7
1000291e:	b002      	add	sp, #8
10002920:	bd80      	pop	{r7, pc}
10002922:	46c0      	nop			; (mov r8, r8)

10002924 <PWM_lCCU4_Start>:

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/*Starts the CCU4 slice. */
void PWM_lCCU4_Start(PWM_t *const handle_ptr)
{
10002924:	b580      	push	{r7, lr}
10002926:	b082      	sub	sp, #8
10002928:	af00      	add	r7, sp, #0
1000292a:	6078      	str	r0, [r7, #4]
  if ((PWM_STATUS_SUCCESS == handle_ptr->state) || (PWM_STATUS_STOPPED == handle_ptr->state))
1000292c:	687b      	ldr	r3, [r7, #4]
1000292e:	2229      	movs	r2, #41	; 0x29
10002930:	5c9b      	ldrb	r3, [r3, r2]
10002932:	2b00      	cmp	r3, #0
10002934:	d004      	beq.n	10002940 <PWM_lCCU4_Start+0x1c>
10002936:	687b      	ldr	r3, [r7, #4]
10002938:	2229      	movs	r2, #41	; 0x29
1000293a:	5c9b      	ldrb	r3, [r3, r2]
1000293c:	2b04      	cmp	r3, #4
1000293e:	d111      	bne.n	10002964 <PWM_lCCU4_Start+0x40>
  {
    /* Clears the IDLE mode for the slice */
    XMC_CCU4_EnableClock(handle_ptr->ccu4_kernel_ptr,handle_ptr->slice_number);
10002940:	687b      	ldr	r3, [r7, #4]
10002942:	6859      	ldr	r1, [r3, #4]
10002944:	687b      	ldr	r3, [r7, #4]
10002946:	222e      	movs	r2, #46	; 0x2e
10002948:	5c9b      	ldrb	r3, [r3, r2]
1000294a:	1c08      	adds	r0, r1, #0
1000294c:	1c19      	adds	r1, r3, #0
1000294e:	f7ff fef5 	bl	1000273c <XMC_CCU4_EnableClock>
    XMC_CCU4_SLICE_StartTimer(handle_ptr->ccu4_slice_ptr);
10002952:	687b      	ldr	r3, [r7, #4]
10002954:	689b      	ldr	r3, [r3, #8]
10002956:	1c18      	adds	r0, r3, #0
10002958:	f7ff ff00 	bl	1000275c <XMC_CCU4_SLICE_StartTimer>

    handle_ptr->state = PWM_STATUS_RUNNING;
1000295c:	687b      	ldr	r3, [r7, #4]
1000295e:	2229      	movs	r2, #41	; 0x29
10002960:	2103      	movs	r1, #3
10002962:	5499      	strb	r1, [r3, r2]
    XMC_DEBUG("PWM_lCCU4_Start:start PWM")
  }
} /* end of PWM_lCCU4_Start() api */
10002964:	46bd      	mov	sp, r7
10002966:	b002      	add	sp, #8
10002968:	bd80      	pop	{r7, pc}
1000296a:	46c0      	nop			; (mov r8, r8)

1000296c <PWM_Init>:
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* This function initializes the app */
PWM_STATUS_t PWM_Init(PWM_t *const handle_ptr)
{
1000296c:	b590      	push	{r4, r7, lr}
1000296e:	b085      	sub	sp, #20
10002970:	af00      	add	r7, sp, #0
10002972:	6078      	str	r0, [r7, #4]
  PWM_STATUS_t status;
  status = PWM_STATUS_FAILURE;
10002974:	230f      	movs	r3, #15
10002976:	18fb      	adds	r3, r7, r3
10002978:	2201      	movs	r2, #1
1000297a:	701a      	strb	r2, [r3, #0]

  XMC_ASSERT("PWM_Init:Invalid handle_ptr" , (handle_ptr != NULL));

#ifdef PWM_SLICE_USED_CCU4
  if (PWM_TIMER_SLICE_CCU4 == handle_ptr->timer_type)
1000297c:	687b      	ldr	r3, [r7, #4]
1000297e:	2228      	movs	r2, #40	; 0x28
10002980:	5c9b      	ldrb	r3, [r3, r2]
10002982:	2b00      	cmp	r3, #0
10002984:	d107      	bne.n	10002996 <PWM_Init+0x2a>
  {
    status = PWM_lCCU4_Init(handle_ptr);
10002986:	230f      	movs	r3, #15
10002988:	18fc      	adds	r4, r7, r3
1000298a:	687b      	ldr	r3, [r7, #4]
1000298c:	1c18      	adds	r0, r3, #0
1000298e:	f7ff ff2d 	bl	100027ec <PWM_lCCU4_Init>
10002992:	1c03      	adds	r3, r0, #0
10002994:	7023      	strb	r3, [r4, #0]
  {
    status = PWM_lCCU8_Init(handle_ptr);
  }
#endif

  return (status);
10002996:	230f      	movs	r3, #15
10002998:	18fb      	adds	r3, r7, r3
1000299a:	781b      	ldrb	r3, [r3, #0]
}
1000299c:	1c18      	adds	r0, r3, #0
1000299e:	46bd      	mov	sp, r7
100029a0:	b005      	add	sp, #20
100029a2:	bd90      	pop	{r4, r7, pc}

100029a4 <PWM_Start>:

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* This function starts the PWM generation. This needs to be called even if external start is configured.*/
void PWM_Start(PWM_t *const handle_ptr)
{
100029a4:	b580      	push	{r7, lr}
100029a6:	b082      	sub	sp, #8
100029a8:	af00      	add	r7, sp, #0
100029aa:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("PWM_Start:Invalid handle_ptr" , (handle_ptr != NULL));

#ifdef PWM_SLICE_USED_CCU4
  if (PWM_TIMER_SLICE_CCU4 == handle_ptr->timer_type)
100029ac:	687b      	ldr	r3, [r7, #4]
100029ae:	2228      	movs	r2, #40	; 0x28
100029b0:	5c9b      	ldrb	r3, [r3, r2]
100029b2:	2b00      	cmp	r3, #0
100029b4:	d103      	bne.n	100029be <PWM_Start+0x1a>
  {
    PWM_lCCU4_Start(handle_ptr);
100029b6:	687b      	ldr	r3, [r7, #4]
100029b8:	1c18      	adds	r0, r3, #0
100029ba:	f7ff ffb3 	bl	10002924 <PWM_lCCU4_Start>
  if (PWM_TIMER_SLICE_CCU8 == handle_ptr->timer_type)
  {
    PWM_lCCU8_Start(handle_ptr);
  }
#endif
}
100029be:	46bd      	mov	sp, r7
100029c0:	b002      	add	sp, #8
100029c2:	bd80      	pop	{r7, pc}

100029c4 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
100029c4:	b580      	push	{r7, lr}
100029c6:	b082      	sub	sp, #8
100029c8:	af00      	add	r7, sp, #0
100029ca:	1c02      	adds	r2, r0, #0
100029cc:	1dfb      	adds	r3, r7, #7
100029ce:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
100029d0:	1dfb      	adds	r3, r7, #7
100029d2:	781b      	ldrb	r3, [r3, #0]
100029d4:	2b7f      	cmp	r3, #127	; 0x7f
100029d6:	d809      	bhi.n	100029ec <__NVIC_EnableIRQ+0x28>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
100029d8:	4b06      	ldr	r3, [pc, #24]	; (100029f4 <__NVIC_EnableIRQ+0x30>)
100029da:	1dfa      	adds	r2, r7, #7
100029dc:	7812      	ldrb	r2, [r2, #0]
100029de:	1c11      	adds	r1, r2, #0
100029e0:	221f      	movs	r2, #31
100029e2:	400a      	ands	r2, r1
100029e4:	2101      	movs	r1, #1
100029e6:	4091      	lsls	r1, r2
100029e8:	1c0a      	adds	r2, r1, #0
100029ea:	601a      	str	r2, [r3, #0]
    __COMPILER_BARRIER();
  }
}
100029ec:	46bd      	mov	sp, r7
100029ee:	b002      	add	sp, #8
100029f0:	bd80      	pop	{r7, pc}
100029f2:	46c0      	nop			; (mov r8, r8)
100029f4:	e000e100 	.word	0xe000e100

100029f8 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
100029f8:	b5b0      	push	{r4, r5, r7, lr}
100029fa:	b082      	sub	sp, #8
100029fc:	af00      	add	r7, sp, #0
100029fe:	1c02      	adds	r2, r0, #0
10002a00:	6039      	str	r1, [r7, #0]
10002a02:	1dfb      	adds	r3, r7, #7
10002a04:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
10002a06:	1dfb      	adds	r3, r7, #7
10002a08:	781b      	ldrb	r3, [r3, #0]
10002a0a:	2b7f      	cmp	r3, #127	; 0x7f
10002a0c:	d827      	bhi.n	10002a5e <__NVIC_SetPriority+0x66>
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
10002a0e:	4c2d      	ldr	r4, [pc, #180]	; (10002ac4 <__NVIC_SetPriority+0xcc>)
10002a10:	1dfb      	adds	r3, r7, #7
10002a12:	781b      	ldrb	r3, [r3, #0]
10002a14:	b25b      	sxtb	r3, r3
10002a16:	089b      	lsrs	r3, r3, #2
10002a18:	492a      	ldr	r1, [pc, #168]	; (10002ac4 <__NVIC_SetPriority+0xcc>)
10002a1a:	1dfa      	adds	r2, r7, #7
10002a1c:	7812      	ldrb	r2, [r2, #0]
10002a1e:	b252      	sxtb	r2, r2
10002a20:	0892      	lsrs	r2, r2, #2
10002a22:	32c0      	adds	r2, #192	; 0xc0
10002a24:	0092      	lsls	r2, r2, #2
10002a26:	5852      	ldr	r2, [r2, r1]
10002a28:	1df9      	adds	r1, r7, #7
10002a2a:	7809      	ldrb	r1, [r1, #0]
10002a2c:	1c08      	adds	r0, r1, #0
10002a2e:	2103      	movs	r1, #3
10002a30:	4001      	ands	r1, r0
10002a32:	00c9      	lsls	r1, r1, #3
10002a34:	1c08      	adds	r0, r1, #0
10002a36:	21ff      	movs	r1, #255	; 0xff
10002a38:	4081      	lsls	r1, r0
10002a3a:	43c9      	mvns	r1, r1
10002a3c:	4011      	ands	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
10002a3e:	683a      	ldr	r2, [r7, #0]
10002a40:	0192      	lsls	r2, r2, #6
10002a42:	20ff      	movs	r0, #255	; 0xff
10002a44:	4002      	ands	r2, r0
10002a46:	1df8      	adds	r0, r7, #7
10002a48:	7800      	ldrb	r0, [r0, #0]
10002a4a:	1c05      	adds	r5, r0, #0
10002a4c:	2003      	movs	r0, #3
10002a4e:	4028      	ands	r0, r5
10002a50:	00c0      	lsls	r0, r0, #3
10002a52:	4082      	lsls	r2, r0
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
10002a54:	430a      	orrs	r2, r1
10002a56:	33c0      	adds	r3, #192	; 0xc0
10002a58:	009b      	lsls	r3, r3, #2
10002a5a:	511a      	str	r2, [r3, r4]
10002a5c:	e02e      	b.n	10002abc <__NVIC_SetPriority+0xc4>
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
10002a5e:	4c1a      	ldr	r4, [pc, #104]	; (10002ac8 <__NVIC_SetPriority+0xd0>)
10002a60:	1dfb      	adds	r3, r7, #7
10002a62:	781b      	ldrb	r3, [r3, #0]
10002a64:	1c1a      	adds	r2, r3, #0
10002a66:	230f      	movs	r3, #15
10002a68:	4013      	ands	r3, r2
10002a6a:	3b08      	subs	r3, #8
10002a6c:	0899      	lsrs	r1, r3, #2
10002a6e:	4a16      	ldr	r2, [pc, #88]	; (10002ac8 <__NVIC_SetPriority+0xd0>)
10002a70:	1dfb      	adds	r3, r7, #7
10002a72:	781b      	ldrb	r3, [r3, #0]
10002a74:	1c18      	adds	r0, r3, #0
10002a76:	230f      	movs	r3, #15
10002a78:	4003      	ands	r3, r0
10002a7a:	3b08      	subs	r3, #8
10002a7c:	089b      	lsrs	r3, r3, #2
10002a7e:	3306      	adds	r3, #6
10002a80:	009b      	lsls	r3, r3, #2
10002a82:	18d3      	adds	r3, r2, r3
10002a84:	685b      	ldr	r3, [r3, #4]
10002a86:	1dfa      	adds	r2, r7, #7
10002a88:	7812      	ldrb	r2, [r2, #0]
10002a8a:	1c10      	adds	r0, r2, #0
10002a8c:	2203      	movs	r2, #3
10002a8e:	4002      	ands	r2, r0
10002a90:	00d2      	lsls	r2, r2, #3
10002a92:	1c10      	adds	r0, r2, #0
10002a94:	22ff      	movs	r2, #255	; 0xff
10002a96:	4082      	lsls	r2, r0
10002a98:	43d2      	mvns	r2, r2
10002a9a:	401a      	ands	r2, r3
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
10002a9c:	683b      	ldr	r3, [r7, #0]
10002a9e:	019b      	lsls	r3, r3, #6
10002aa0:	20ff      	movs	r0, #255	; 0xff
10002aa2:	4003      	ands	r3, r0
10002aa4:	1df8      	adds	r0, r7, #7
10002aa6:	7800      	ldrb	r0, [r0, #0]
10002aa8:	1c05      	adds	r5, r0, #0
10002aaa:	2003      	movs	r0, #3
10002aac:	4028      	ands	r0, r5
10002aae:	00c0      	lsls	r0, r0, #3
10002ab0:	4083      	lsls	r3, r0
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
10002ab2:	431a      	orrs	r2, r3
10002ab4:	1d8b      	adds	r3, r1, #6
10002ab6:	009b      	lsls	r3, r3, #2
10002ab8:	18e3      	adds	r3, r4, r3
10002aba:	605a      	str	r2, [r3, #4]
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
}
10002abc:	46bd      	mov	sp, r7
10002abe:	b002      	add	sp, #8
10002ac0:	bdb0      	pop	{r4, r5, r7, pc}
10002ac2:	46c0      	nop			; (mov r8, r8)
10002ac4:	e000e100 	.word	0xe000e100
10002ac8:	e000ed00 	.word	0xe000ed00

10002acc <INTERRUPT_Enable>:
 *    return 0;
 *  }
 * @endcode<BR> </p>
 */
__STATIC_INLINE void INTERRUPT_Enable(const INTERRUPT_t *const handler)
{
10002acc:	b580      	push	{r7, lr}
10002ace:	b082      	sub	sp, #8
10002ad0:	af00      	add	r7, sp, #0
10002ad2:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("Handler NULL", (handler != NULL));
  NVIC_EnableIRQ(handler->node);
10002ad4:	687b      	ldr	r3, [r7, #4]
10002ad6:	781b      	ldrb	r3, [r3, #0]
10002ad8:	b25b      	sxtb	r3, r3
10002ada:	1c18      	adds	r0, r3, #0
10002adc:	f7ff ff72 	bl	100029c4 <__NVIC_EnableIRQ>
}
10002ae0:	46bd      	mov	sp, r7
10002ae2:	b002      	add	sp, #8
10002ae4:	bd80      	pop	{r7, pc}
10002ae6:	46c0      	nop			; (mov r8, r8)

10002ae8 <INTERRUPT_Init>:

/*
 * API to initialize the INTERRUPT APP
 */
INTERRUPT_STATUS_t INTERRUPT_Init(const INTERRUPT_t *const handler)
{
10002ae8:	b580      	push	{r7, lr}
10002aea:	b082      	sub	sp, #8
10002aec:	af00      	add	r7, sp, #0
10002aee:	6078      	str	r0, [r7, #4]
    INTERRUPT_Enable(handler);
  }
#endif

#if(UC_FAMILY == XMC1)
  NVIC_SetPriority(handler->node, handler->priority);
10002af0:	687b      	ldr	r3, [r7, #4]
10002af2:	781a      	ldrb	r2, [r3, #0]
10002af4:	687b      	ldr	r3, [r7, #4]
10002af6:	785b      	ldrb	r3, [r3, #1]
10002af8:	1c19      	adds	r1, r3, #0
10002afa:	b253      	sxtb	r3, r2
10002afc:	1c18      	adds	r0, r3, #0
10002afe:	f7ff ff7b 	bl	100029f8 <__NVIC_SetPriority>
#if (UC_SERIES == XMC14)
  XMC_SCU_SetInterruptControl((uint8_t)handler->node, (XMC_SCU_IRQCTRL_t)((handler->node << 8) | handler->irqctrl));
#endif

  /* Enable the interrupt if enable_at_init is enabled */
  if (handler->enable_at_init == true)
10002b02:	687b      	ldr	r3, [r7, #4]
10002b04:	789b      	ldrb	r3, [r3, #2]
10002b06:	2b00      	cmp	r3, #0
10002b08:	d003      	beq.n	10002b12 <INTERRUPT_Init+0x2a>
  {
    INTERRUPT_Enable(handler);
10002b0a:	687b      	ldr	r3, [r7, #4]
10002b0c:	1c18      	adds	r0, r3, #0
10002b0e:	f7ff ffdd 	bl	10002acc <INTERRUPT_Enable>
  }
#endif

  return (INTERRUPT_STATUS_SUCCESS);
10002b12:	2300      	movs	r3, #0
}
10002b14:	1c18      	adds	r0, r3, #0
10002b16:	46bd      	mov	sp, r7
10002b18:	b002      	add	sp, #8
10002b1a:	bd80      	pop	{r7, pc}

10002b1c <XMC_CCU4_StartPrescaler>:
 * \par<b>Related APIs:</b><br>
 * XMC_CCU4_Init()<BR> XMC_CCU4_EnableClock()<BR> XMC_CCU4_DisableClock()<BR> XMC_CCU4_StartPrescaler()<BR>
 * XMC_CCU4_StopPrescaler().
 */
__STATIC_INLINE void XMC_CCU4_StartPrescaler(XMC_CCU4_MODULE_t *const module)
{
10002b1c:	b580      	push	{r7, lr}
10002b1e:	b082      	sub	sp, #8
10002b20:	af00      	add	r7, sp, #0
10002b22:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_CCU4_StartPrescaler:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));
  module->GIDLC = (uint32_t) CCU4_GIDLC_SPRB_Msk;
10002b24:	687b      	ldr	r3, [r7, #4]
10002b26:	2280      	movs	r2, #128	; 0x80
10002b28:	0052      	lsls	r2, r2, #1
10002b2a:	60da      	str	r2, [r3, #12]
}
10002b2c:	46bd      	mov	sp, r7
10002b2e:	b002      	add	sp, #8
10002b30:	bd80      	pop	{r7, pc}
10002b32:	46c0      	nop			; (mov r8, r8)

10002b34 <GLOBAL_CCU4_Init>:
  return version;
}

/* Initializes the slice with the generated configuration */
GLOBAL_CCU4_STATUS_t GLOBAL_CCU4_Init(GLOBAL_CCU4_t* handle)
{
10002b34:	b580      	push	{r7, lr}
10002b36:	b082      	sub	sp, #8
10002b38:	af00      	add	r7, sp, #0
10002b3a:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("GLOBAL_CCU4_Init:NULL handler", (NULL != handle));

  if (false == handle->is_initialized)
10002b3c:	687b      	ldr	r3, [r7, #4]
10002b3e:	7b5b      	ldrb	r3, [r3, #13]
10002b40:	2201      	movs	r2, #1
10002b42:	4053      	eors	r3, r2
10002b44:	b2db      	uxtb	r3, r3
10002b46:	2b00      	cmp	r3, #0
10002b48:	d00f      	beq.n	10002b6a <GLOBAL_CCU4_Init+0x36>
  {
    /* Enable CCU4 module */
    XMC_CCU4_Init(handle->module_ptr,handle->mcs_action);
10002b4a:	687b      	ldr	r3, [r7, #4]
10002b4c:	689a      	ldr	r2, [r3, #8]
10002b4e:	687b      	ldr	r3, [r7, #4]
10002b50:	7b1b      	ldrb	r3, [r3, #12]
10002b52:	1c10      	adds	r0, r2, #0
10002b54:	1c19      	adds	r1, r3, #0
10002b56:	f7fe fce3 	bl	10001520 <XMC_CCU4_Init>
    /* Start the prescaler */
    XMC_CCU4_StartPrescaler(handle->module_ptr);
10002b5a:	687b      	ldr	r3, [r7, #4]
10002b5c:	689b      	ldr	r3, [r3, #8]
10002b5e:	1c18      	adds	r0, r3, #0
10002b60:	f7ff ffdc 	bl	10002b1c <XMC_CCU4_StartPrescaler>
    /* Restricts multiple initializations */
    handle->is_initialized = true;
10002b64:	687b      	ldr	r3, [r7, #4]
10002b66:	2201      	movs	r2, #1
10002b68:	735a      	strb	r2, [r3, #13]
  }

  return (GLOBAL_CCU4_STATUS_SUCCESS);
10002b6a:	2300      	movs	r3, #0
}
10002b6c:	1c18      	adds	r0, r3, #0
10002b6e:	46bd      	mov	sp, r7
10002b70:	b002      	add	sp, #8
10002b72:	bd80      	pop	{r7, pc}

10002b74 <pxPortInitialiseStack>:
 * See header file for description.
 */
StackType_t * pxPortInitialiseStack( StackType_t * pxTopOfStack,
                                     TaskFunction_t pxCode,
                                     void * pvParameters )
{
10002b74:	b580      	push	{r7, lr}
10002b76:	b084      	sub	sp, #16
10002b78:	af00      	add	r7, sp, #0
10002b7a:	60f8      	str	r0, [r7, #12]
10002b7c:	60b9      	str	r1, [r7, #8]
10002b7e:	607a      	str	r2, [r7, #4]
    /* Simulate the stack frame as it would be created by a context switch
     * interrupt. */
    pxTopOfStack--;                                          /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
10002b80:	68fb      	ldr	r3, [r7, #12]
10002b82:	3b04      	subs	r3, #4
10002b84:	60fb      	str	r3, [r7, #12]
    *pxTopOfStack = portINITIAL_XPSR;                        /* xPSR */
10002b86:	68fb      	ldr	r3, [r7, #12]
10002b88:	2280      	movs	r2, #128	; 0x80
10002b8a:	0452      	lsls	r2, r2, #17
10002b8c:	601a      	str	r2, [r3, #0]
    pxTopOfStack--;
10002b8e:	68fb      	ldr	r3, [r7, #12]
10002b90:	3b04      	subs	r3, #4
10002b92:	60fb      	str	r3, [r7, #12]
    *pxTopOfStack = ( StackType_t ) pxCode;                  /* PC */
10002b94:	68ba      	ldr	r2, [r7, #8]
10002b96:	68fb      	ldr	r3, [r7, #12]
10002b98:	601a      	str	r2, [r3, #0]
    pxTopOfStack--;
10002b9a:	68fb      	ldr	r3, [r7, #12]
10002b9c:	3b04      	subs	r3, #4
10002b9e:	60fb      	str	r3, [r7, #12]
    *pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS; /* LR */
10002ba0:	4a08      	ldr	r2, [pc, #32]	; (10002bc4 <pxPortInitialiseStack+0x50>)
10002ba2:	68fb      	ldr	r3, [r7, #12]
10002ba4:	601a      	str	r2, [r3, #0]
    pxTopOfStack -= 5;                                       /* R12, R3, R2 and R1. */
10002ba6:	68fb      	ldr	r3, [r7, #12]
10002ba8:	3b14      	subs	r3, #20
10002baa:	60fb      	str	r3, [r7, #12]
    *pxTopOfStack = ( StackType_t ) pvParameters;            /* R0 */
10002bac:	687a      	ldr	r2, [r7, #4]
10002bae:	68fb      	ldr	r3, [r7, #12]
10002bb0:	601a      	str	r2, [r3, #0]
    pxTopOfStack -= 8;                                       /* R11..R4. */
10002bb2:	68fb      	ldr	r3, [r7, #12]
10002bb4:	3b20      	subs	r3, #32
10002bb6:	60fb      	str	r3, [r7, #12]

    return pxTopOfStack;
10002bb8:	68fb      	ldr	r3, [r7, #12]
}
10002bba:	1c18      	adds	r0, r3, #0
10002bbc:	46bd      	mov	sp, r7
10002bbe:	b004      	add	sp, #16
10002bc0:	bd80      	pop	{r7, pc}
10002bc2:	46c0      	nop			; (mov r8, r8)
10002bc4:	10002bc9 	.word	0x10002bc9

10002bc8 <prvTaskExitError>:
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
10002bc8:	b580      	push	{r7, lr}
10002bca:	b082      	sub	sp, #8
10002bcc:	af00      	add	r7, sp, #0
    volatile uint32_t ulDummy = 0UL;
10002bce:	2300      	movs	r3, #0
10002bd0:	607b      	str	r3, [r7, #4]
     * its caller as there is nothing to return to.  If a task wants to exit it
     * should instead call vTaskDelete( NULL ).
     *
     * Artificially force an assert() to be triggered if configASSERT() is
     * defined, then stop here so application writers can catch the error. */
    configASSERT( uxCriticalNesting == ~0UL );
10002bd2:	4b07      	ldr	r3, [pc, #28]	; (10002bf0 <prvTaskExitError+0x28>)
10002bd4:	681b      	ldr	r3, [r3, #0]
10002bd6:	3301      	adds	r3, #1
10002bd8:	d001      	beq.n	10002bde <prvTaskExitError+0x16>
10002bda:	b672      	cpsid	i
10002bdc:	e7fe      	b.n	10002bdc <prvTaskExitError+0x14>
    portDISABLE_INTERRUPTS();
10002bde:	b672      	cpsid	i

    while( ulDummy == 0 )
10002be0:	46c0      	nop			; (mov r8, r8)
10002be2:	687b      	ldr	r3, [r7, #4]
10002be4:	2b00      	cmp	r3, #0
10002be6:	d0fc      	beq.n	10002be2 <prvTaskExitError+0x1a>
         * about code appearing after this function is called - making ulDummy
         * volatile makes the compiler think the function could return and
         * therefore not output an 'unreachable code' warning for code that appears
         * after it. */
    }
}
10002be8:	46bd      	mov	sp, r7
10002bea:	b002      	add	sp, #8
10002bec:	bd80      	pop	{r7, pc}
10002bee:	46c0      	nop			; (mov r8, r8)
10002bf0:	200005f4 	.word	0x200005f4

10002bf4 <SVC_Handler>:
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
10002bf4:	b580      	push	{r7, lr}
10002bf6:	af00      	add	r7, sp, #0
    /* This function is no longer used, but retained for backward
     * compatibility. */
}
10002bf8:	46bd      	mov	sp, r7
10002bfa:	bd80      	pop	{r7, pc}
10002bfc:	0000      	movs	r0, r0
	...

10002c00 <vPortStartFirstTask>:
void vPortStartFirstTask( void )
{
    /* The MSP stack is not reset as, unlike on M3/4 parts, there is no vector
     * table offset register that can be used to locate the initial stack value.
     * Not all M0 parts have the application vector table at address 0. */
    __asm volatile (
10002c00:	4a0b      	ldr	r2, [pc, #44]	; (10002c30 <pxCurrentTCBConst2>)
10002c02:	6813      	ldr	r3, [r2, #0]
10002c04:	6818      	ldr	r0, [r3, #0]
10002c06:	3020      	adds	r0, #32
10002c08:	f380 8809 	msr	PSP, r0
10002c0c:	2002      	movs	r0, #2
10002c0e:	f380 8814 	msr	CONTROL, r0
10002c12:	f3bf 8f6f 	isb	sy
10002c16:	bc3f      	pop	{r0, r1, r2, r3, r4, r5}
10002c18:	46ae      	mov	lr, r5
10002c1a:	bc08      	pop	{r3}
10002c1c:	bc04      	pop	{r2}
10002c1e:	b662      	cpsie	i
10002c20:	4718      	bx	r3
10002c22:	46c0      	nop			; (mov r8, r8)
10002c24:	46c0      	nop			; (mov r8, r8)
10002c26:	46c0      	nop			; (mov r8, r8)
10002c28:	46c0      	nop			; (mov r8, r8)
10002c2a:	46c0      	nop			; (mov r8, r8)
10002c2c:	46c0      	nop			; (mov r8, r8)
10002c2e:	46c0      	nop			; (mov r8, r8)

10002c30 <pxCurrentTCBConst2>:
10002c30:	200006d8 	.word	0x200006d8
10002c34:	46c0      	nop			; (mov r8, r8)
10002c36:	46c0      	nop			; (mov r8, r8)
10002c38:	46c0      	nop			; (mov r8, r8)
10002c3a:	46c0      	nop			; (mov r8, r8)
10002c3c:	46c0      	nop			; (mov r8, r8)
10002c3e:	46c0      	nop			; (mov r8, r8)

10002c40 <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
10002c40:	b580      	push	{r7, lr}
10002c42:	af00      	add	r7, sp, #0
    /* Make PendSV, CallSV and SysTick the same priority as the kernel. */
    portNVIC_SHPR3_REG |= portNVIC_PENDSV_PRI;
10002c44:	4b0e      	ldr	r3, [pc, #56]	; (10002c80 <xPortStartScheduler+0x40>)
10002c46:	4a0e      	ldr	r2, [pc, #56]	; (10002c80 <xPortStartScheduler+0x40>)
10002c48:	6812      	ldr	r2, [r2, #0]
10002c4a:	21ff      	movs	r1, #255	; 0xff
10002c4c:	0409      	lsls	r1, r1, #16
10002c4e:	430a      	orrs	r2, r1
10002c50:	601a      	str	r2, [r3, #0]
    portNVIC_SHPR3_REG |= portNVIC_SYSTICK_PRI;
10002c52:	4b0b      	ldr	r3, [pc, #44]	; (10002c80 <xPortStartScheduler+0x40>)
10002c54:	4a0a      	ldr	r2, [pc, #40]	; (10002c80 <xPortStartScheduler+0x40>)
10002c56:	6812      	ldr	r2, [r2, #0]
10002c58:	21ff      	movs	r1, #255	; 0xff
10002c5a:	0609      	lsls	r1, r1, #24
10002c5c:	430a      	orrs	r2, r1
10002c5e:	601a      	str	r2, [r3, #0]

    /* Start the timer that generates the tick ISR.  Interrupts are disabled
     * here already. */
    vPortSetupTimerInterrupt();
10002c60:	f000 f896 	bl	10002d90 <vPortSetupTimerInterrupt>

    /* Initialise the critical nesting count ready for the first task. */
    uxCriticalNesting = 0;
10002c64:	4b07      	ldr	r3, [pc, #28]	; (10002c84 <xPortStartScheduler+0x44>)
10002c66:	2200      	movs	r2, #0
10002c68:	601a      	str	r2, [r3, #0]

    /* Start the first task. */
    vPortStartFirstTask();
10002c6a:	f7ff ffc9 	bl	10002c00 <vPortStartFirstTask>
     * exit error function to prevent compiler warnings about a static function
     * not being called in the case that the application writer overrides this
     * functionality by defining configTASK_RETURN_ADDRESS.  Call
     * vTaskSwitchContext() so link time optimisation does not remove the
     * symbol. */
    vTaskSwitchContext();
10002c6e:	f001 fa93 	bl	10004198 <vTaskSwitchContext>
    prvTaskExitError();
10002c72:	f7ff ffa9 	bl	10002bc8 <prvTaskExitError>

    /* Should not get here! */
    return 0;
10002c76:	2300      	movs	r3, #0
}
10002c78:	1c18      	adds	r0, r3, #0
10002c7a:	46bd      	mov	sp, r7
10002c7c:	bd80      	pop	{r7, pc}
10002c7e:	46c0      	nop			; (mov r8, r8)
10002c80:	e000ed20 	.word	0xe000ed20
10002c84:	200005f4 	.word	0x200005f4

10002c88 <vPortYield>:
    configASSERT( uxCriticalNesting == 1000UL );
}
/*-----------------------------------------------------------*/

void vPortYield( void )
{
10002c88:	b580      	push	{r7, lr}
10002c8a:	af00      	add	r7, sp, #0
    /* Set a PendSV to request a context switch. */
    portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
10002c8c:	4b04      	ldr	r3, [pc, #16]	; (10002ca0 <vPortYield+0x18>)
10002c8e:	2280      	movs	r2, #128	; 0x80
10002c90:	0552      	lsls	r2, r2, #21
10002c92:	601a      	str	r2, [r3, #0]

    /* Barriers are normally not required but do ensure the code is completely
     * within the specified behaviour for the architecture. */
    __asm volatile ( "dsb" ::: "memory" );
10002c94:	f3bf 8f4f 	dsb	sy
    __asm volatile ( "isb" );
10002c98:	f3bf 8f6f 	isb	sy
}
10002c9c:	46bd      	mov	sp, r7
10002c9e:	bd80      	pop	{r7, pc}
10002ca0:	e000ed04 	.word	0xe000ed04

10002ca4 <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
10002ca4:	b580      	push	{r7, lr}
10002ca6:	af00      	add	r7, sp, #0
    portDISABLE_INTERRUPTS();
10002ca8:	b672      	cpsid	i
    uxCriticalNesting++;
10002caa:	4b05      	ldr	r3, [pc, #20]	; (10002cc0 <vPortEnterCritical+0x1c>)
10002cac:	681b      	ldr	r3, [r3, #0]
10002cae:	1c5a      	adds	r2, r3, #1
10002cb0:	4b03      	ldr	r3, [pc, #12]	; (10002cc0 <vPortEnterCritical+0x1c>)
10002cb2:	601a      	str	r2, [r3, #0]
    __asm volatile ( "dsb" ::: "memory" );
10002cb4:	f3bf 8f4f 	dsb	sy
    __asm volatile ( "isb" );
10002cb8:	f3bf 8f6f 	isb	sy
}
10002cbc:	46bd      	mov	sp, r7
10002cbe:	bd80      	pop	{r7, pc}
10002cc0:	200005f4 	.word	0x200005f4

10002cc4 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
10002cc4:	b580      	push	{r7, lr}
10002cc6:	af00      	add	r7, sp, #0
    configASSERT( uxCriticalNesting );
10002cc8:	4b08      	ldr	r3, [pc, #32]	; (10002cec <vPortExitCritical+0x28>)
10002cca:	681b      	ldr	r3, [r3, #0]
10002ccc:	2b00      	cmp	r3, #0
10002cce:	d101      	bne.n	10002cd4 <vPortExitCritical+0x10>
10002cd0:	b672      	cpsid	i
10002cd2:	e7fe      	b.n	10002cd2 <vPortExitCritical+0xe>
    uxCriticalNesting--;
10002cd4:	4b05      	ldr	r3, [pc, #20]	; (10002cec <vPortExitCritical+0x28>)
10002cd6:	681b      	ldr	r3, [r3, #0]
10002cd8:	1e5a      	subs	r2, r3, #1
10002cda:	4b04      	ldr	r3, [pc, #16]	; (10002cec <vPortExitCritical+0x28>)
10002cdc:	601a      	str	r2, [r3, #0]

    if( uxCriticalNesting == 0 )
10002cde:	4b03      	ldr	r3, [pc, #12]	; (10002cec <vPortExitCritical+0x28>)
10002ce0:	681b      	ldr	r3, [r3, #0]
10002ce2:	2b00      	cmp	r3, #0
10002ce4:	d100      	bne.n	10002ce8 <vPortExitCritical+0x24>
    {
        portENABLE_INTERRUPTS();
10002ce6:	b662      	cpsie	i
    }
}
10002ce8:	46bd      	mov	sp, r7
10002cea:	bd80      	pop	{r7, pc}
10002cec:	200005f4 	.word	0x200005f4

10002cf0 <ulSetInterruptMaskFromISR>:
/*-----------------------------------------------------------*/

uint32_t ulSetInterruptMaskFromISR( void )
{
    __asm volatile (
10002cf0:	f3ef 8010 	mrs	r0, PRIMASK
10002cf4:	b672      	cpsid	i
10002cf6:	4770      	bx	lr
        " mrs r0, PRIMASK	\n"
        " cpsid i			\n"
        " bx lr				  "
        ::: "memory"
        );
}
10002cf8:	1c18      	adds	r0, r3, #0
10002cfa:	46c0      	nop			; (mov r8, r8)

10002cfc <vClearInterruptMaskFromISR>:
/*-----------------------------------------------------------*/

void vClearInterruptMaskFromISR( __attribute__( ( unused ) ) uint32_t ulMask )
{
    __asm volatile (
10002cfc:	f380 8810 	msr	PRIMASK, r0
10002d00:	4770      	bx	lr
10002d02:	46c0      	nop			; (mov r8, r8)
	...

10002d10 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
    /* This is a naked function. */

    __asm volatile
10002d10:	f3ef 8009 	mrs	r0, PSP
10002d14:	4b0e      	ldr	r3, [pc, #56]	; (10002d50 <pxCurrentTCBConst>)
10002d16:	681a      	ldr	r2, [r3, #0]
10002d18:	3820      	subs	r0, #32
10002d1a:	6010      	str	r0, [r2, #0]
10002d1c:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
10002d1e:	4644      	mov	r4, r8
10002d20:	464d      	mov	r5, r9
10002d22:	4656      	mov	r6, sl
10002d24:	465f      	mov	r7, fp
10002d26:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
10002d28:	b508      	push	{r3, lr}
10002d2a:	b672      	cpsid	i
10002d2c:	f001 fa34 	bl	10004198 <vTaskSwitchContext>
10002d30:	b662      	cpsie	i
10002d32:	bc0c      	pop	{r2, r3}
10002d34:	6811      	ldr	r1, [r2, #0]
10002d36:	6808      	ldr	r0, [r1, #0]
10002d38:	3010      	adds	r0, #16
10002d3a:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
10002d3c:	46a0      	mov	r8, r4
10002d3e:	46a9      	mov	r9, r5
10002d40:	46b2      	mov	sl, r6
10002d42:	46bb      	mov	fp, r7
10002d44:	f380 8809 	msr	PSP, r0
10002d48:	3820      	subs	r0, #32
10002d4a:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
10002d4c:	4718      	bx	r3
10002d4e:	46c0      	nop			; (mov r8, r8)

10002d50 <pxCurrentTCBConst>:
10002d50:	200006d8 	.word	0x200006d8
10002d54:	46c0      	nop			; (mov r8, r8)
10002d56:	46c0      	nop			; (mov r8, r8)
10002d58:	46c0      	nop			; (mov r8, r8)
10002d5a:	46c0      	nop			; (mov r8, r8)
10002d5c:	46c0      	nop			; (mov r8, r8)
10002d5e:	46c0      	nop			; (mov r8, r8)

10002d60 <SysTick_Handler>:
    );
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
10002d60:	b580      	push	{r7, lr}
10002d62:	b082      	sub	sp, #8
10002d64:	af00      	add	r7, sp, #0
    uint32_t ulPreviousMask;

    ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
10002d66:	f7ff ffc3 	bl	10002cf0 <ulSetInterruptMaskFromISR>
10002d6a:	1c03      	adds	r3, r0, #0
10002d6c:	607b      	str	r3, [r7, #4]
    {
        /* Increment the RTOS tick. */
        if( xTaskIncrementTick() != pdFALSE )
10002d6e:	f001 f963 	bl	10004038 <xTaskIncrementTick>
10002d72:	1e03      	subs	r3, r0, #0
10002d74:	d003      	beq.n	10002d7e <SysTick_Handler+0x1e>
        {
            /* Pend a context switch. */
            portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
10002d76:	4b05      	ldr	r3, [pc, #20]	; (10002d8c <SysTick_Handler+0x2c>)
10002d78:	2280      	movs	r2, #128	; 0x80
10002d7a:	0552      	lsls	r2, r2, #21
10002d7c:	601a      	str	r2, [r3, #0]
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
10002d7e:	687b      	ldr	r3, [r7, #4]
10002d80:	1c18      	adds	r0, r3, #0
10002d82:	f7ff ffbb 	bl	10002cfc <vClearInterruptMaskFromISR>
}
10002d86:	46bd      	mov	sp, r7
10002d88:	b002      	add	sp, #8
10002d8a:	bd80      	pop	{r7, pc}
10002d8c:	e000ed04 	.word	0xe000ed04

10002d90 <vPortSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
__attribute__( ( weak ) ) void vPortSetupTimerInterrupt( void )
{
10002d90:	b598      	push	{r3, r4, r7, lr}
10002d92:	af00      	add	r7, sp, #0
            ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR;
        }
    #endif /* configUSE_TICKLESS_IDLE */

    /* Stop and reset the SysTick. */
    portNVIC_SYSTICK_CTRL_REG = 0UL;
10002d94:	4b0a      	ldr	r3, [pc, #40]	; (10002dc0 <vPortSetupTimerInterrupt+0x30>)
10002d96:	2200      	movs	r2, #0
10002d98:	601a      	str	r2, [r3, #0]
    portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
10002d9a:	4b0a      	ldr	r3, [pc, #40]	; (10002dc4 <vPortSetupTimerInterrupt+0x34>)
10002d9c:	2200      	movs	r2, #0
10002d9e:	601a      	str	r2, [r3, #0]

    /* Configure SysTick to interrupt at the requested rate. */
    portNVIC_SYSTICK_LOAD_REG = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
10002da0:	4c09      	ldr	r4, [pc, #36]	; (10002dc8 <vPortSetupTimerInterrupt+0x38>)
10002da2:	4b0a      	ldr	r3, [pc, #40]	; (10002dcc <vPortSetupTimerInterrupt+0x3c>)
10002da4:	681b      	ldr	r3, [r3, #0]
10002da6:	1c18      	adds	r0, r3, #0
10002da8:	23fa      	movs	r3, #250	; 0xfa
10002daa:	0099      	lsls	r1, r3, #2
10002dac:	f002 fc64 	bl	10005678 <__aeabi_uidiv>
10002db0:	1c03      	adds	r3, r0, #0
10002db2:	3b01      	subs	r3, #1
10002db4:	6023      	str	r3, [r4, #0]
    portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT;
10002db6:	4b02      	ldr	r3, [pc, #8]	; (10002dc0 <vPortSetupTimerInterrupt+0x30>)
10002db8:	2207      	movs	r2, #7
10002dba:	601a      	str	r2, [r3, #0]
}
10002dbc:	46bd      	mov	sp, r7
10002dbe:	bd98      	pop	{r3, r4, r7, pc}
10002dc0:	e000e010 	.word	0xe000e010
10002dc4:	e000e018 	.word	0xe000e018
10002dc8:	e000e014 	.word	0xe000e014
10002dcc:	20003ffc 	.word	0x20003ffc

10002dd0 <pvPortMalloc>:
#endif

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
10002dd0:	b580      	push	{r7, lr}
10002dd2:	b084      	sub	sp, #16
10002dd4:	af00      	add	r7, sp, #0
10002dd6:	6078      	str	r0, [r7, #4]
    void * pvReturn;

    vTaskSuspendAll();
10002dd8:	f001 f888 	bl	10003eec <vTaskSuspendAll>
    {
        pvReturn = malloc( xWantedSize );
10002ddc:	687b      	ldr	r3, [r7, #4]
10002dde:	1c18      	adds	r0, r3, #0
10002de0:	f002 fdf0 	bl	100059c4 <malloc>
10002de4:	1c03      	adds	r3, r0, #0
10002de6:	60fb      	str	r3, [r7, #12]
        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
10002de8:	f001 f88c 	bl	10003f04 <xTaskResumeAll>
                vApplicationMallocFailedHook();
            }
        }
    #endif

    return pvReturn;
10002dec:	68fb      	ldr	r3, [r7, #12]
}
10002dee:	1c18      	adds	r0, r3, #0
10002df0:	46bd      	mov	sp, r7
10002df2:	b004      	add	sp, #16
10002df4:	bd80      	pop	{r7, pc}
10002df6:	46c0      	nop			; (mov r8, r8)

10002df8 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
10002df8:	b580      	push	{r7, lr}
10002dfa:	b082      	sub	sp, #8
10002dfc:	af00      	add	r7, sp, #0
10002dfe:	6078      	str	r0, [r7, #4]
    if( pv )
10002e00:	687b      	ldr	r3, [r7, #4]
10002e02:	2b00      	cmp	r3, #0
10002e04:	d007      	beq.n	10002e16 <vPortFree+0x1e>
    {
        vTaskSuspendAll();
10002e06:	f001 f871 	bl	10003eec <vTaskSuspendAll>
        {
            free( pv );
10002e0a:	687b      	ldr	r3, [r7, #4]
10002e0c:	1c18      	adds	r0, r3, #0
10002e0e:	f002 fde3 	bl	100059d8 <free>
            traceFREE( pv, 0 );
        }
        ( void ) xTaskResumeAll();
10002e12:	f001 f877 	bl	10003f04 <xTaskResumeAll>
    }
}
10002e16:	46bd      	mov	sp, r7
10002e18:	b002      	add	sp, #8
10002e1a:	bd80      	pop	{r7, pc}

10002e1c <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
10002e1c:	b580      	push	{r7, lr}
10002e1e:	b082      	sub	sp, #8
10002e20:	af00      	add	r7, sp, #0
10002e22:	6078      	str	r0, [r7, #4]
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
10002e24:	687b      	ldr	r3, [r7, #4]
10002e26:	3308      	adds	r3, #8
10002e28:	1c1a      	adds	r2, r3, #0
10002e2a:	687b      	ldr	r3, [r7, #4]
10002e2c:	605a      	str	r2, [r3, #4]

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
10002e2e:	687b      	ldr	r3, [r7, #4]
10002e30:	2201      	movs	r2, #1
10002e32:	4252      	negs	r2, r2
10002e34:	609a      	str	r2, [r3, #8]

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
10002e36:	687b      	ldr	r3, [r7, #4]
10002e38:	3308      	adds	r3, #8
10002e3a:	1c1a      	adds	r2, r3, #0
10002e3c:	687b      	ldr	r3, [r7, #4]
10002e3e:	60da      	str	r2, [r3, #12]
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
10002e40:	687b      	ldr	r3, [r7, #4]
10002e42:	3308      	adds	r3, #8
10002e44:	1c1a      	adds	r2, r3, #0
10002e46:	687b      	ldr	r3, [r7, #4]
10002e48:	611a      	str	r2, [r3, #16]

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
10002e4a:	687b      	ldr	r3, [r7, #4]
10002e4c:	2200      	movs	r2, #0
10002e4e:	601a      	str	r2, [r3, #0]

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
10002e50:	46bd      	mov	sp, r7
10002e52:	b002      	add	sp, #8
10002e54:	bd80      	pop	{r7, pc}
10002e56:	46c0      	nop			; (mov r8, r8)

10002e58 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
10002e58:	b580      	push	{r7, lr}
10002e5a:	b082      	sub	sp, #8
10002e5c:	af00      	add	r7, sp, #0
10002e5e:	6078      	str	r0, [r7, #4]
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
10002e60:	687b      	ldr	r3, [r7, #4]
10002e62:	2200      	movs	r2, #0
10002e64:	611a      	str	r2, [r3, #16]

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
10002e66:	46bd      	mov	sp, r7
10002e68:	b002      	add	sp, #8
10002e6a:	bd80      	pop	{r7, pc}

10002e6c <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
10002e6c:	b580      	push	{r7, lr}
10002e6e:	b084      	sub	sp, #16
10002e70:	af00      	add	r7, sp, #0
10002e72:	6078      	str	r0, [r7, #4]
10002e74:	6039      	str	r1, [r7, #0]
    ListItem_t * const pxIndex = pxList->pxIndex;
10002e76:	687b      	ldr	r3, [r7, #4]
10002e78:	685b      	ldr	r3, [r3, #4]
10002e7a:	60fb      	str	r3, [r7, #12]
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
10002e7c:	683b      	ldr	r3, [r7, #0]
10002e7e:	68fa      	ldr	r2, [r7, #12]
10002e80:	605a      	str	r2, [r3, #4]
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
10002e82:	68fb      	ldr	r3, [r7, #12]
10002e84:	689a      	ldr	r2, [r3, #8]
10002e86:	683b      	ldr	r3, [r7, #0]
10002e88:	609a      	str	r2, [r3, #8]

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
10002e8a:	68fb      	ldr	r3, [r7, #12]
10002e8c:	689b      	ldr	r3, [r3, #8]
10002e8e:	683a      	ldr	r2, [r7, #0]
10002e90:	605a      	str	r2, [r3, #4]
    pxIndex->pxPrevious = pxNewListItem;
10002e92:	68fb      	ldr	r3, [r7, #12]
10002e94:	683a      	ldr	r2, [r7, #0]
10002e96:	609a      	str	r2, [r3, #8]

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
10002e98:	683b      	ldr	r3, [r7, #0]
10002e9a:	687a      	ldr	r2, [r7, #4]
10002e9c:	611a      	str	r2, [r3, #16]

    ( pxList->uxNumberOfItems )++;
10002e9e:	687b      	ldr	r3, [r7, #4]
10002ea0:	681b      	ldr	r3, [r3, #0]
10002ea2:	1c5a      	adds	r2, r3, #1
10002ea4:	687b      	ldr	r3, [r7, #4]
10002ea6:	601a      	str	r2, [r3, #0]
}
10002ea8:	46bd      	mov	sp, r7
10002eaa:	b004      	add	sp, #16
10002eac:	bd80      	pop	{r7, pc}
10002eae:	46c0      	nop			; (mov r8, r8)

10002eb0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
10002eb0:	b580      	push	{r7, lr}
10002eb2:	b084      	sub	sp, #16
10002eb4:	af00      	add	r7, sp, #0
10002eb6:	6078      	str	r0, [r7, #4]
10002eb8:	6039      	str	r1, [r7, #0]
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
10002eba:	683b      	ldr	r3, [r7, #0]
10002ebc:	681b      	ldr	r3, [r3, #0]
10002ebe:	60bb      	str	r3, [r7, #8]
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
10002ec0:	68bb      	ldr	r3, [r7, #8]
10002ec2:	3301      	adds	r3, #1
10002ec4:	d103      	bne.n	10002ece <vListInsert+0x1e>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
10002ec6:	687b      	ldr	r3, [r7, #4]
10002ec8:	691b      	ldr	r3, [r3, #16]
10002eca:	60fb      	str	r3, [r7, #12]
10002ecc:	e00c      	b.n	10002ee8 <vListInsert+0x38>
        *   4) Using a queue or semaphore before it has been initialised or
        *      before the scheduler has been started (are interrupts firing
        *      before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
10002ece:	687b      	ldr	r3, [r7, #4]
10002ed0:	3308      	adds	r3, #8
10002ed2:	60fb      	str	r3, [r7, #12]
10002ed4:	e002      	b.n	10002edc <vListInsert+0x2c>
10002ed6:	68fb      	ldr	r3, [r7, #12]
10002ed8:	685b      	ldr	r3, [r3, #4]
10002eda:	60fb      	str	r3, [r7, #12]
10002edc:	68fb      	ldr	r3, [r7, #12]
10002ede:	685b      	ldr	r3, [r3, #4]
10002ee0:	681a      	ldr	r2, [r3, #0]
10002ee2:	68bb      	ldr	r3, [r7, #8]
10002ee4:	429a      	cmp	r2, r3
10002ee6:	d9f6      	bls.n	10002ed6 <vListInsert+0x26>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
10002ee8:	68fb      	ldr	r3, [r7, #12]
10002eea:	685a      	ldr	r2, [r3, #4]
10002eec:	683b      	ldr	r3, [r7, #0]
10002eee:	605a      	str	r2, [r3, #4]
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
10002ef0:	683b      	ldr	r3, [r7, #0]
10002ef2:	685b      	ldr	r3, [r3, #4]
10002ef4:	683a      	ldr	r2, [r7, #0]
10002ef6:	609a      	str	r2, [r3, #8]
    pxNewListItem->pxPrevious = pxIterator;
10002ef8:	683b      	ldr	r3, [r7, #0]
10002efa:	68fa      	ldr	r2, [r7, #12]
10002efc:	609a      	str	r2, [r3, #8]
    pxIterator->pxNext = pxNewListItem;
10002efe:	68fb      	ldr	r3, [r7, #12]
10002f00:	683a      	ldr	r2, [r7, #0]
10002f02:	605a      	str	r2, [r3, #4]

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
10002f04:	683b      	ldr	r3, [r7, #0]
10002f06:	687a      	ldr	r2, [r7, #4]
10002f08:	611a      	str	r2, [r3, #16]

    ( pxList->uxNumberOfItems )++;
10002f0a:	687b      	ldr	r3, [r7, #4]
10002f0c:	681b      	ldr	r3, [r3, #0]
10002f0e:	1c5a      	adds	r2, r3, #1
10002f10:	687b      	ldr	r3, [r7, #4]
10002f12:	601a      	str	r2, [r3, #0]
}
10002f14:	46bd      	mov	sp, r7
10002f16:	b004      	add	sp, #16
10002f18:	bd80      	pop	{r7, pc}
10002f1a:	46c0      	nop			; (mov r8, r8)

10002f1c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
10002f1c:	b580      	push	{r7, lr}
10002f1e:	b084      	sub	sp, #16
10002f20:	af00      	add	r7, sp, #0
10002f22:	6078      	str	r0, [r7, #4]
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
10002f24:	687b      	ldr	r3, [r7, #4]
10002f26:	691b      	ldr	r3, [r3, #16]
10002f28:	60fb      	str	r3, [r7, #12]

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
10002f2a:	687b      	ldr	r3, [r7, #4]
10002f2c:	685b      	ldr	r3, [r3, #4]
10002f2e:	687a      	ldr	r2, [r7, #4]
10002f30:	6892      	ldr	r2, [r2, #8]
10002f32:	609a      	str	r2, [r3, #8]
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
10002f34:	687b      	ldr	r3, [r7, #4]
10002f36:	689b      	ldr	r3, [r3, #8]
10002f38:	687a      	ldr	r2, [r7, #4]
10002f3a:	6852      	ldr	r2, [r2, #4]
10002f3c:	605a      	str	r2, [r3, #4]

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
10002f3e:	68fb      	ldr	r3, [r7, #12]
10002f40:	685a      	ldr	r2, [r3, #4]
10002f42:	687b      	ldr	r3, [r7, #4]
10002f44:	429a      	cmp	r2, r3
10002f46:	d103      	bne.n	10002f50 <uxListRemove+0x34>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
10002f48:	687b      	ldr	r3, [r7, #4]
10002f4a:	689a      	ldr	r2, [r3, #8]
10002f4c:	68fb      	ldr	r3, [r7, #12]
10002f4e:	605a      	str	r2, [r3, #4]
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
10002f50:	687b      	ldr	r3, [r7, #4]
10002f52:	2200      	movs	r2, #0
10002f54:	611a      	str	r2, [r3, #16]
    ( pxList->uxNumberOfItems )--;
10002f56:	68fb      	ldr	r3, [r7, #12]
10002f58:	681b      	ldr	r3, [r3, #0]
10002f5a:	1e5a      	subs	r2, r3, #1
10002f5c:	68fb      	ldr	r3, [r7, #12]
10002f5e:	601a      	str	r2, [r3, #0]

    return pxList->uxNumberOfItems;
10002f60:	68fb      	ldr	r3, [r7, #12]
10002f62:	681b      	ldr	r3, [r3, #0]
}
10002f64:	1c18      	adds	r0, r3, #0
10002f66:	46bd      	mov	sp, r7
10002f68:	b004      	add	sp, #16
10002f6a:	bd80      	pop	{r7, pc}

10002f6c <xQueueGenericReset>:
    taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
10002f6c:	b580      	push	{r7, lr}
10002f6e:	b084      	sub	sp, #16
10002f70:	af00      	add	r7, sp, #0
10002f72:	6078      	str	r0, [r7, #4]
10002f74:	6039      	str	r1, [r7, #0]
    Queue_t * const pxQueue = xQueue;
10002f76:	687b      	ldr	r3, [r7, #4]
10002f78:	60fb      	str	r3, [r7, #12]

    configASSERT( pxQueue );
10002f7a:	68fb      	ldr	r3, [r7, #12]
10002f7c:	2b00      	cmp	r3, #0
10002f7e:	d101      	bne.n	10002f84 <xQueueGenericReset+0x18>
10002f80:	b672      	cpsid	i
10002f82:	e7fe      	b.n	10002f82 <xQueueGenericReset+0x16>

    taskENTER_CRITICAL();
10002f84:	f7ff fe8e 	bl	10002ca4 <vPortEnterCritical>
    {
        pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
10002f88:	68fb      	ldr	r3, [r7, #12]
10002f8a:	681a      	ldr	r2, [r3, #0]
10002f8c:	68fb      	ldr	r3, [r7, #12]
10002f8e:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
10002f90:	68fb      	ldr	r3, [r7, #12]
10002f92:	6c1b      	ldr	r3, [r3, #64]	; 0x40
10002f94:	434b      	muls	r3, r1
10002f96:	18d2      	adds	r2, r2, r3
10002f98:	68fb      	ldr	r3, [r7, #12]
10002f9a:	609a      	str	r2, [r3, #8]
        pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
10002f9c:	68fb      	ldr	r3, [r7, #12]
10002f9e:	2200      	movs	r2, #0
10002fa0:	639a      	str	r2, [r3, #56]	; 0x38
        pxQueue->pcWriteTo = pxQueue->pcHead;
10002fa2:	68fb      	ldr	r3, [r7, #12]
10002fa4:	681a      	ldr	r2, [r3, #0]
10002fa6:	68fb      	ldr	r3, [r7, #12]
10002fa8:	605a      	str	r2, [r3, #4]
        pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
10002faa:	68fb      	ldr	r3, [r7, #12]
10002fac:	681a      	ldr	r2, [r3, #0]
10002fae:	68fb      	ldr	r3, [r7, #12]
10002fb0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
10002fb2:	1e59      	subs	r1, r3, #1
10002fb4:	68fb      	ldr	r3, [r7, #12]
10002fb6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
10002fb8:	434b      	muls	r3, r1
10002fba:	18d2      	adds	r2, r2, r3
10002fbc:	68fb      	ldr	r3, [r7, #12]
10002fbe:	60da      	str	r2, [r3, #12]
        pxQueue->cRxLock = queueUNLOCKED;
10002fc0:	68fb      	ldr	r3, [r7, #12]
10002fc2:	2244      	movs	r2, #68	; 0x44
10002fc4:	21ff      	movs	r1, #255	; 0xff
10002fc6:	5499      	strb	r1, [r3, r2]
        pxQueue->cTxLock = queueUNLOCKED;
10002fc8:	68fb      	ldr	r3, [r7, #12]
10002fca:	2245      	movs	r2, #69	; 0x45
10002fcc:	21ff      	movs	r1, #255	; 0xff
10002fce:	5499      	strb	r1, [r3, r2]

        if( xNewQueue == pdFALSE )
10002fd0:	683b      	ldr	r3, [r7, #0]
10002fd2:	2b00      	cmp	r3, #0
10002fd4:	d10d      	bne.n	10002ff2 <xQueueGenericReset+0x86>
            /* If there are tasks blocked waiting to read from the queue, then
             * the tasks will remain blocked as after this function exits the queue
             * will still be empty.  If there are tasks blocked waiting to write to
             * the queue, then one should be unblocked as after this function exits
             * it will be possible to write to it. */
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
10002fd6:	68fb      	ldr	r3, [r7, #12]
10002fd8:	691b      	ldr	r3, [r3, #16]
10002fda:	2b00      	cmp	r3, #0
10002fdc:	d013      	beq.n	10003006 <xQueueGenericReset+0x9a>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
10002fde:	68fb      	ldr	r3, [r7, #12]
10002fe0:	3310      	adds	r3, #16
10002fe2:	1c18      	adds	r0, r3, #0
10002fe4:	f001 f968 	bl	100042b8 <xTaskRemoveFromEventList>
10002fe8:	1e03      	subs	r3, r0, #0
10002fea:	d00c      	beq.n	10003006 <xQueueGenericReset+0x9a>
                {
                    queueYIELD_IF_USING_PREEMPTION();
10002fec:	f7ff fe4c 	bl	10002c88 <vPortYield>
10002ff0:	e009      	b.n	10003006 <xQueueGenericReset+0x9a>
            }
        }
        else
        {
            /* Ensure the event queues start in the correct state. */
            vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
10002ff2:	68fb      	ldr	r3, [r7, #12]
10002ff4:	3310      	adds	r3, #16
10002ff6:	1c18      	adds	r0, r3, #0
10002ff8:	f7ff ff10 	bl	10002e1c <vListInitialise>
            vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
10002ffc:	68fb      	ldr	r3, [r7, #12]
10002ffe:	3324      	adds	r3, #36	; 0x24
10003000:	1c18      	adds	r0, r3, #0
10003002:	f7ff ff0b 	bl	10002e1c <vListInitialise>
        }
    }
    taskEXIT_CRITICAL();
10003006:	f7ff fe5d 	bl	10002cc4 <vPortExitCritical>

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return pdPASS;
1000300a:	2301      	movs	r3, #1
}
1000300c:	1c18      	adds	r0, r3, #0
1000300e:	46bd      	mov	sp, r7
10003010:	b004      	add	sp, #16
10003012:	bd80      	pop	{r7, pc}

10003014 <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
10003014:	b590      	push	{r4, r7, lr}
10003016:	b08b      	sub	sp, #44	; 0x2c
10003018:	af02      	add	r7, sp, #8
1000301a:	60f8      	str	r0, [r7, #12]
1000301c:	60b9      	str	r1, [r7, #8]
1000301e:	1dfb      	adds	r3, r7, #7
10003020:	701a      	strb	r2, [r3, #0]
        Queue_t * pxNewQueue;
        size_t xQueueSizeInBytes;
        uint8_t * pucQueueStorage;

        configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
10003022:	68fb      	ldr	r3, [r7, #12]
10003024:	2b00      	cmp	r3, #0
10003026:	d101      	bne.n	1000302c <xQueueGenericCreate+0x18>
10003028:	b672      	cpsid	i
1000302a:	e7fe      	b.n	1000302a <xQueueGenericCreate+0x16>

        /* Allocate enough space to hold the maximum number of items that
         * can be in the queue at any time.  It is valid for uxItemSize to be
         * zero in the case the queue is used as a semaphore. */
        xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
1000302c:	68fb      	ldr	r3, [r7, #12]
1000302e:	68ba      	ldr	r2, [r7, #8]
10003030:	4353      	muls	r3, r2
10003032:	61fb      	str	r3, [r7, #28]

        /* Check for multiplication overflow. */
        configASSERT( ( uxItemSize == 0 ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) ) );
10003034:	68bb      	ldr	r3, [r7, #8]
10003036:	2b00      	cmp	r3, #0
10003038:	d008      	beq.n	1000304c <xQueueGenericCreate+0x38>
1000303a:	69f8      	ldr	r0, [r7, #28]
1000303c:	68b9      	ldr	r1, [r7, #8]
1000303e:	f002 fb1b 	bl	10005678 <__aeabi_uidiv>
10003042:	1c03      	adds	r3, r0, #0
10003044:	1e1a      	subs	r2, r3, #0
10003046:	68fb      	ldr	r3, [r7, #12]
10003048:	429a      	cmp	r2, r3
1000304a:	d101      	bne.n	10003050 <xQueueGenericCreate+0x3c>
1000304c:	2301      	movs	r3, #1
1000304e:	e000      	b.n	10003052 <xQueueGenericCreate+0x3e>
10003050:	2300      	movs	r3, #0
10003052:	2b00      	cmp	r3, #0
10003054:	d101      	bne.n	1000305a <xQueueGenericCreate+0x46>
10003056:	b672      	cpsid	i
10003058:	e7fe      	b.n	10003058 <xQueueGenericCreate+0x44>

        /* Check for addition overflow. */
        configASSERT( ( sizeof( Queue_t ) + xQueueSizeInBytes ) >  xQueueSizeInBytes );
1000305a:	69fb      	ldr	r3, [r7, #28]
1000305c:	3354      	adds	r3, #84	; 0x54
1000305e:	1e1a      	subs	r2, r3, #0
10003060:	69fb      	ldr	r3, [r7, #28]
10003062:	429a      	cmp	r2, r3
10003064:	d801      	bhi.n	1000306a <xQueueGenericCreate+0x56>
10003066:	b672      	cpsid	i
10003068:	e7fe      	b.n	10003068 <xQueueGenericCreate+0x54>
         * alignment requirements of the Queue_t structure - which in this case
         * is an int8_t *.  Therefore, whenever the stack alignment requirements
         * are greater than or equal to the pointer to char requirements the cast
         * is safe.  In other cases alignment requirements are not strict (one or
         * two bytes). */
        pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
1000306a:	69fb      	ldr	r3, [r7, #28]
1000306c:	3354      	adds	r3, #84	; 0x54
1000306e:	1c18      	adds	r0, r3, #0
10003070:	f7ff feae 	bl	10002dd0 <pvPortMalloc>
10003074:	1c03      	adds	r3, r0, #0
10003076:	61bb      	str	r3, [r7, #24]

        if( pxNewQueue != NULL )
10003078:	69bb      	ldr	r3, [r7, #24]
1000307a:	2b00      	cmp	r3, #0
1000307c:	d00e      	beq.n	1000309c <xQueueGenericCreate+0x88>
        {
            /* Jump past the queue structure to find the location of the queue
             * storage area. */
            pucQueueStorage = ( uint8_t * ) pxNewQueue;
1000307e:	69bb      	ldr	r3, [r7, #24]
10003080:	617b      	str	r3, [r7, #20]
            pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
10003082:	697b      	ldr	r3, [r7, #20]
10003084:	3354      	adds	r3, #84	; 0x54
10003086:	617b      	str	r3, [r7, #20]
                     * deleted. */
                    pxNewQueue->ucStaticallyAllocated = pdFALSE;
                }
            #endif /* configSUPPORT_STATIC_ALLOCATION */

            prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
10003088:	68f8      	ldr	r0, [r7, #12]
1000308a:	68b9      	ldr	r1, [r7, #8]
1000308c:	697a      	ldr	r2, [r7, #20]
1000308e:	1dfb      	adds	r3, r7, #7
10003090:	781c      	ldrb	r4, [r3, #0]
10003092:	69bb      	ldr	r3, [r7, #24]
10003094:	9300      	str	r3, [sp, #0]
10003096:	1c23      	adds	r3, r4, #0
10003098:	f000 f806 	bl	100030a8 <prvInitialiseNewQueue>
        {
            traceQUEUE_CREATE_FAILED( ucQueueType );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
1000309c:	69bb      	ldr	r3, [r7, #24]
    }
1000309e:	1c18      	adds	r0, r3, #0
100030a0:	46bd      	mov	sp, r7
100030a2:	b009      	add	sp, #36	; 0x24
100030a4:	bd90      	pop	{r4, r7, pc}
100030a6:	46c0      	nop			; (mov r8, r8)

100030a8 <prvInitialiseNewQueue>:
static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
                                   const UBaseType_t uxItemSize,
                                   uint8_t * pucQueueStorage,
                                   const uint8_t ucQueueType,
                                   Queue_t * pxNewQueue )
{
100030a8:	b580      	push	{r7, lr}
100030aa:	b084      	sub	sp, #16
100030ac:	af00      	add	r7, sp, #0
100030ae:	60f8      	str	r0, [r7, #12]
100030b0:	60b9      	str	r1, [r7, #8]
100030b2:	607a      	str	r2, [r7, #4]
100030b4:	1c1a      	adds	r2, r3, #0
100030b6:	1cfb      	adds	r3, r7, #3
100030b8:	701a      	strb	r2, [r3, #0]
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
100030ba:	68bb      	ldr	r3, [r7, #8]
100030bc:	2b00      	cmp	r3, #0
100030be:	d103      	bne.n	100030c8 <prvInitialiseNewQueue+0x20>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
100030c0:	69bb      	ldr	r3, [r7, #24]
100030c2:	69ba      	ldr	r2, [r7, #24]
100030c4:	601a      	str	r2, [r3, #0]
100030c6:	e002      	b.n	100030ce <prvInitialiseNewQueue+0x26>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
100030c8:	69bb      	ldr	r3, [r7, #24]
100030ca:	687a      	ldr	r2, [r7, #4]
100030cc:	601a      	str	r2, [r3, #0]
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
100030ce:	69bb      	ldr	r3, [r7, #24]
100030d0:	68fa      	ldr	r2, [r7, #12]
100030d2:	63da      	str	r2, [r3, #60]	; 0x3c
    pxNewQueue->uxItemSize = uxItemSize;
100030d4:	69bb      	ldr	r3, [r7, #24]
100030d6:	68ba      	ldr	r2, [r7, #8]
100030d8:	641a      	str	r2, [r3, #64]	; 0x40
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
100030da:	69bb      	ldr	r3, [r7, #24]
100030dc:	1c18      	adds	r0, r3, #0
100030de:	2101      	movs	r1, #1
100030e0:	f7ff ff44 	bl	10002f6c <xQueueGenericReset>

    #if ( configUSE_TRACE_FACILITY == 1 )
        {
            pxNewQueue->ucQueueType = ucQueueType;
100030e4:	69bb      	ldr	r3, [r7, #24]
100030e6:	1cfa      	adds	r2, r7, #3
100030e8:	2150      	movs	r1, #80	; 0x50
100030ea:	7812      	ldrb	r2, [r2, #0]
100030ec:	545a      	strb	r2, [r3, r1]
        }
    #endif /* configUSE_TRACE_FACILITY */

    #if ( configUSE_QUEUE_SETS == 1 )
        {
            pxNewQueue->pxQueueSetContainer = NULL;
100030ee:	69bb      	ldr	r3, [r7, #24]
100030f0:	2200      	movs	r2, #0
100030f2:	649a      	str	r2, [r3, #72]	; 0x48
        }
    #endif /* configUSE_QUEUE_SETS */

    traceQUEUE_CREATE( pxNewQueue );
}
100030f4:	46bd      	mov	sp, r7
100030f6:	b004      	add	sp, #16
100030f8:	bd80      	pop	{r7, pc}
100030fa:	46c0      	nop			; (mov r8, r8)

100030fc <prvInitialiseMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    static void prvInitialiseMutex( Queue_t * pxNewQueue )
    {
100030fc:	b580      	push	{r7, lr}
100030fe:	b082      	sub	sp, #8
10003100:	af00      	add	r7, sp, #0
10003102:	6078      	str	r0, [r7, #4]
        if( pxNewQueue != NULL )
10003104:	687b      	ldr	r3, [r7, #4]
10003106:	2b00      	cmp	r3, #0
10003108:	d00f      	beq.n	1000312a <prvInitialiseMutex+0x2e>
        {
            /* The queue create function will set all the queue structure members
            * correctly for a generic queue, but this function is creating a
            * mutex.  Overwrite those members that need to be set differently -
            * in particular the information required for priority inheritance. */
            pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
1000310a:	687b      	ldr	r3, [r7, #4]
1000310c:	2200      	movs	r2, #0
1000310e:	609a      	str	r2, [r3, #8]
            pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
10003110:	687b      	ldr	r3, [r7, #4]
10003112:	2200      	movs	r2, #0
10003114:	601a      	str	r2, [r3, #0]

            /* In case this is a recursive mutex. */
            pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
10003116:	687b      	ldr	r3, [r7, #4]
10003118:	2200      	movs	r2, #0
1000311a:	60da      	str	r2, [r3, #12]

            traceCREATE_MUTEX( pxNewQueue );

            /* Start with the semaphore in the expected state. */
            ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
1000311c:	687b      	ldr	r3, [r7, #4]
1000311e:	1c18      	adds	r0, r3, #0
10003120:	2100      	movs	r1, #0
10003122:	2200      	movs	r2, #0
10003124:	2300      	movs	r3, #0
10003126:	f000 f821 	bl	1000316c <xQueueGenericSend>
        }
        else
        {
            traceCREATE_MUTEX_FAILED();
        }
    }
1000312a:	46bd      	mov	sp, r7
1000312c:	b002      	add	sp, #8
1000312e:	bd80      	pop	{r7, pc}

10003130 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

    QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
    {
10003130:	b580      	push	{r7, lr}
10003132:	b086      	sub	sp, #24
10003134:	af00      	add	r7, sp, #0
10003136:	1c02      	adds	r2, r0, #0
10003138:	1dfb      	adds	r3, r7, #7
1000313a:	701a      	strb	r2, [r3, #0]
        QueueHandle_t xNewQueue;
        const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
1000313c:	2301      	movs	r3, #1
1000313e:	617b      	str	r3, [r7, #20]
10003140:	2300      	movs	r3, #0
10003142:	613b      	str	r3, [r7, #16]

        xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
10003144:	6979      	ldr	r1, [r7, #20]
10003146:	693a      	ldr	r2, [r7, #16]
10003148:	1dfb      	adds	r3, r7, #7
1000314a:	781b      	ldrb	r3, [r3, #0]
1000314c:	1c08      	adds	r0, r1, #0
1000314e:	1c11      	adds	r1, r2, #0
10003150:	1c1a      	adds	r2, r3, #0
10003152:	f7ff ff5f 	bl	10003014 <xQueueGenericCreate>
10003156:	1c03      	adds	r3, r0, #0
10003158:	60fb      	str	r3, [r7, #12]
        prvInitialiseMutex( ( Queue_t * ) xNewQueue );
1000315a:	68fb      	ldr	r3, [r7, #12]
1000315c:	1c18      	adds	r0, r3, #0
1000315e:	f7ff ffcd 	bl	100030fc <prvInitialiseMutex>

        return xNewQueue;
10003162:	68fb      	ldr	r3, [r7, #12]
    }
10003164:	1c18      	adds	r0, r3, #0
10003166:	46bd      	mov	sp, r7
10003168:	b006      	add	sp, #24
1000316a:	bd80      	pop	{r7, pc}

1000316c <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
1000316c:	b580      	push	{r7, lr}
1000316e:	b08a      	sub	sp, #40	; 0x28
10003170:	af00      	add	r7, sp, #0
10003172:	60f8      	str	r0, [r7, #12]
10003174:	60b9      	str	r1, [r7, #8]
10003176:	607a      	str	r2, [r7, #4]
10003178:	603b      	str	r3, [r7, #0]
    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
1000317a:	2300      	movs	r3, #0
1000317c:	627b      	str	r3, [r7, #36]	; 0x24
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
1000317e:	68fb      	ldr	r3, [r7, #12]
10003180:	623b      	str	r3, [r7, #32]

    configASSERT( pxQueue );
10003182:	6a3b      	ldr	r3, [r7, #32]
10003184:	2b00      	cmp	r3, #0
10003186:	d101      	bne.n	1000318c <xQueueGenericSend+0x20>
10003188:	b672      	cpsid	i
1000318a:	e7fe      	b.n	1000318a <xQueueGenericSend+0x1e>
    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1000318c:	68bb      	ldr	r3, [r7, #8]
1000318e:	2b00      	cmp	r3, #0
10003190:	d103      	bne.n	1000319a <xQueueGenericSend+0x2e>
10003192:	6a3b      	ldr	r3, [r7, #32]
10003194:	6c1b      	ldr	r3, [r3, #64]	; 0x40
10003196:	2b00      	cmp	r3, #0
10003198:	d101      	bne.n	1000319e <xQueueGenericSend+0x32>
1000319a:	2301      	movs	r3, #1
1000319c:	e000      	b.n	100031a0 <xQueueGenericSend+0x34>
1000319e:	2300      	movs	r3, #0
100031a0:	2b00      	cmp	r3, #0
100031a2:	d101      	bne.n	100031a8 <xQueueGenericSend+0x3c>
100031a4:	b672      	cpsid	i
100031a6:	e7fe      	b.n	100031a6 <xQueueGenericSend+0x3a>
    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
100031a8:	683b      	ldr	r3, [r7, #0]
100031aa:	2b02      	cmp	r3, #2
100031ac:	d103      	bne.n	100031b6 <xQueueGenericSend+0x4a>
100031ae:	6a3b      	ldr	r3, [r7, #32]
100031b0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
100031b2:	2b01      	cmp	r3, #1
100031b4:	d101      	bne.n	100031ba <xQueueGenericSend+0x4e>
100031b6:	2301      	movs	r3, #1
100031b8:	e000      	b.n	100031bc <xQueueGenericSend+0x50>
100031ba:	2300      	movs	r3, #0
100031bc:	2b00      	cmp	r3, #0
100031be:	d101      	bne.n	100031c4 <xQueueGenericSend+0x58>
100031c0:	b672      	cpsid	i
100031c2:	e7fe      	b.n	100031c2 <xQueueGenericSend+0x56>
    #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
100031c4:	f001 f9fe 	bl	100045c4 <xTaskGetSchedulerState>
100031c8:	1e03      	subs	r3, r0, #0
100031ca:	d102      	bne.n	100031d2 <xQueueGenericSend+0x66>
100031cc:	687b      	ldr	r3, [r7, #4]
100031ce:	2b00      	cmp	r3, #0
100031d0:	d101      	bne.n	100031d6 <xQueueGenericSend+0x6a>
100031d2:	2301      	movs	r3, #1
100031d4:	e000      	b.n	100031d8 <xQueueGenericSend+0x6c>
100031d6:	2300      	movs	r3, #0
100031d8:	2b00      	cmp	r3, #0
100031da:	d101      	bne.n	100031e0 <xQueueGenericSend+0x74>
100031dc:	b672      	cpsid	i
100031de:	e7fe      	b.n	100031de <xQueueGenericSend+0x72>
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
100031e0:	f7ff fd60 	bl	10002ca4 <vPortEnterCritical>
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
100031e4:	6a3b      	ldr	r3, [r7, #32]
100031e6:	6b9a      	ldr	r2, [r3, #56]	; 0x38
100031e8:	6a3b      	ldr	r3, [r7, #32]
100031ea:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
100031ec:	429a      	cmp	r2, r3
100031ee:	d302      	bcc.n	100031f6 <xQueueGenericSend+0x8a>
100031f0:	683b      	ldr	r3, [r7, #0]
100031f2:	2b02      	cmp	r3, #2
100031f4:	d138      	bne.n	10003268 <xQueueGenericSend+0xfc>
            {
                traceQUEUE_SEND( pxQueue );

                #if ( configUSE_QUEUE_SETS == 1 )
                    {
                        const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
100031f6:	6a3b      	ldr	r3, [r7, #32]
100031f8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
100031fa:	61fb      	str	r3, [r7, #28]

                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
100031fc:	6a39      	ldr	r1, [r7, #32]
100031fe:	68ba      	ldr	r2, [r7, #8]
10003200:	683b      	ldr	r3, [r7, #0]
10003202:	1c08      	adds	r0, r1, #0
10003204:	1c11      	adds	r1, r2, #0
10003206:	1c1a      	adds	r2, r3, #0
10003208:	f000 fada 	bl	100037c0 <prvCopyDataToQueue>
1000320c:	1c03      	adds	r3, r0, #0
1000320e:	61bb      	str	r3, [r7, #24]

                        if( pxQueue->pxQueueSetContainer != NULL )
10003210:	6a3b      	ldr	r3, [r7, #32]
10003212:	6c9b      	ldr	r3, [r3, #72]	; 0x48
10003214:	2b00      	cmp	r3, #0
10003216:	d010      	beq.n	1000323a <xQueueGenericSend+0xce>
                        {
                            if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 ) )
10003218:	683b      	ldr	r3, [r7, #0]
1000321a:	2b02      	cmp	r3, #2
1000321c:	d104      	bne.n	10003228 <xQueueGenericSend+0xbc>
1000321e:	69fb      	ldr	r3, [r7, #28]
10003220:	2b00      	cmp	r3, #0
10003222:	d001      	beq.n	10003228 <xQueueGenericSend+0xbc>
10003224:	46c0      	nop			; (mov r8, r8)
10003226:	e01b      	b.n	10003260 <xQueueGenericSend+0xf4>
                                /* Do not notify the queue set as an existing item
                                 * was overwritten in the queue so the number of items
                                 * in the queue has not changed. */
                                mtCOVERAGE_TEST_MARKER();
                            }
                            else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
10003228:	6a3b      	ldr	r3, [r7, #32]
1000322a:	1c18      	adds	r0, r3, #0
1000322c:	f000 fc58 	bl	10003ae0 <prvNotifyQueueSetContainer>
10003230:	1e03      	subs	r3, r0, #0
10003232:	d015      	beq.n	10003260 <xQueueGenericSend+0xf4>
                            {
                                /* The queue is a member of a queue set, and posting
                                 * to the queue set caused a higher priority task to
                                 * unblock. A context switch is required. */
                                queueYIELD_IF_USING_PREEMPTION();
10003234:	f7ff fd28 	bl	10002c88 <vPortYield>
10003238:	e012      	b.n	10003260 <xQueueGenericSend+0xf4>
                        }
                        else
                        {
                            /* If there was a task waiting for data to arrive on the
                             * queue then unblock it now. */
                            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1000323a:	6a3b      	ldr	r3, [r7, #32]
1000323c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
1000323e:	2b00      	cmp	r3, #0
10003240:	d009      	beq.n	10003256 <xQueueGenericSend+0xea>
                            {
                                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
10003242:	6a3b      	ldr	r3, [r7, #32]
10003244:	3324      	adds	r3, #36	; 0x24
10003246:	1c18      	adds	r0, r3, #0
10003248:	f001 f836 	bl	100042b8 <xTaskRemoveFromEventList>
1000324c:	1e03      	subs	r3, r0, #0
1000324e:	d007      	beq.n	10003260 <xQueueGenericSend+0xf4>
                                {
                                    /* The unblocked task has a priority higher than
                                     * our own so yield immediately.  Yes it is ok to
                                     * do this from within the critical section - the
                                     * kernel takes care of that. */
                                    queueYIELD_IF_USING_PREEMPTION();
10003250:	f7ff fd1a 	bl	10002c88 <vPortYield>
10003254:	e004      	b.n	10003260 <xQueueGenericSend+0xf4>
                                else
                                {
                                    mtCOVERAGE_TEST_MARKER();
                                }
                            }
                            else if( xYieldRequired != pdFALSE )
10003256:	69bb      	ldr	r3, [r7, #24]
10003258:	2b00      	cmp	r3, #0
1000325a:	d001      	beq.n	10003260 <xQueueGenericSend+0xf4>
                            {
                                /* This path is a special case that will only get
                                 * executed if the task was holding multiple mutexes
                                 * and the mutexes were given back in an order that is
                                 * different to that in which they were taken. */
                                queueYIELD_IF_USING_PREEMPTION();
1000325c:	f7ff fd14 	bl	10002c88 <vPortYield>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
10003260:	f7ff fd30 	bl	10002cc4 <vPortExitCritical>
                return pdPASS;
10003264:	2301      	movs	r3, #1
10003266:	e060      	b.n	1000332a <xQueueGenericSend+0x1be>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
10003268:	687b      	ldr	r3, [r7, #4]
1000326a:	2b00      	cmp	r3, #0
1000326c:	d103      	bne.n	10003276 <xQueueGenericSend+0x10a>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
1000326e:	f7ff fd29 	bl	10002cc4 <vPortExitCritical>

                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
10003272:	2300      	movs	r3, #0
10003274:	e059      	b.n	1000332a <xQueueGenericSend+0x1be>
                }
                else if( xEntryTimeSet == pdFALSE )
10003276:	6a7b      	ldr	r3, [r7, #36]	; 0x24
10003278:	2b00      	cmp	r3, #0
1000327a:	d106      	bne.n	1000328a <xQueueGenericSend+0x11e>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
1000327c:	2310      	movs	r3, #16
1000327e:	18fb      	adds	r3, r7, r3
10003280:	1c18      	adds	r0, r3, #0
10003282:	f001 f875 	bl	10004370 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
10003286:	2301      	movs	r3, #1
10003288:	627b      	str	r3, [r7, #36]	; 0x24
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
1000328a:	f7ff fd1b 	bl	10002cc4 <vPortExitCritical>

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
1000328e:	f000 fe2d 	bl	10003eec <vTaskSuspendAll>
        prvLockQueue( pxQueue );
10003292:	f7ff fd07 	bl	10002ca4 <vPortEnterCritical>
10003296:	6a3b      	ldr	r3, [r7, #32]
10003298:	2244      	movs	r2, #68	; 0x44
1000329a:	5c9b      	ldrb	r3, [r3, r2]
1000329c:	b2db      	uxtb	r3, r3
1000329e:	b25b      	sxtb	r3, r3
100032a0:	3301      	adds	r3, #1
100032a2:	d103      	bne.n	100032ac <xQueueGenericSend+0x140>
100032a4:	6a3b      	ldr	r3, [r7, #32]
100032a6:	2244      	movs	r2, #68	; 0x44
100032a8:	2100      	movs	r1, #0
100032aa:	5499      	strb	r1, [r3, r2]
100032ac:	6a3b      	ldr	r3, [r7, #32]
100032ae:	2245      	movs	r2, #69	; 0x45
100032b0:	5c9b      	ldrb	r3, [r3, r2]
100032b2:	b2db      	uxtb	r3, r3
100032b4:	b25b      	sxtb	r3, r3
100032b6:	3301      	adds	r3, #1
100032b8:	d103      	bne.n	100032c2 <xQueueGenericSend+0x156>
100032ba:	6a3b      	ldr	r3, [r7, #32]
100032bc:	2245      	movs	r2, #69	; 0x45
100032be:	2100      	movs	r1, #0
100032c0:	5499      	strb	r1, [r3, r2]
100032c2:	f7ff fcff 	bl	10002cc4 <vPortExitCritical>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
100032c6:	2310      	movs	r3, #16
100032c8:	18fa      	adds	r2, r7, r3
100032ca:	1d3b      	adds	r3, r7, #4
100032cc:	1c10      	adds	r0, r2, #0
100032ce:	1c19      	adds	r1, r3, #0
100032d0:	f001 f862 	bl	10004398 <xTaskCheckForTimeOut>
100032d4:	1e03      	subs	r3, r0, #0
100032d6:	d11f      	bne.n	10003318 <xQueueGenericSend+0x1ac>
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
100032d8:	6a3b      	ldr	r3, [r7, #32]
100032da:	1c18      	adds	r0, r3, #0
100032dc:	f000 fb8a 	bl	100039f4 <prvIsQueueFull>
100032e0:	1e03      	subs	r3, r0, #0
100032e2:	d012      	beq.n	1000330a <xQueueGenericSend+0x19e>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
100032e4:	6a3b      	ldr	r3, [r7, #32]
100032e6:	3310      	adds	r3, #16
100032e8:	1c1a      	adds	r2, r3, #0
100032ea:	687b      	ldr	r3, [r7, #4]
100032ec:	1c10      	adds	r0, r2, #0
100032ee:	1c19      	adds	r1, r3, #0
100032f0:	f000 ffa2 	bl	10004238 <vTaskPlaceOnEventList>
                /* Unlocking the queue means queue events can effect the
                 * event list.  It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready last instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
100032f4:	6a3b      	ldr	r3, [r7, #32]
100032f6:	1c18      	adds	r0, r3, #0
100032f8:	f000 fafa 	bl	100038f0 <prvUnlockQueue>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in a ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
100032fc:	f000 fe02 	bl	10003f04 <xTaskResumeAll>
10003300:	1e03      	subs	r3, r0, #0
10003302:	d111      	bne.n	10003328 <xQueueGenericSend+0x1bc>
                {
                    portYIELD_WITHIN_API();
10003304:	f7ff fcc0 	bl	10002c88 <vPortYield>
10003308:	e00e      	b.n	10003328 <xQueueGenericSend+0x1bc>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
1000330a:	6a3b      	ldr	r3, [r7, #32]
1000330c:	1c18      	adds	r0, r3, #0
1000330e:	f000 faef 	bl	100038f0 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
10003312:	f000 fdf7 	bl	10003f04 <xTaskResumeAll>
10003316:	e763      	b.n	100031e0 <xQueueGenericSend+0x74>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
10003318:	6a3b      	ldr	r3, [r7, #32]
1000331a:	1c18      	adds	r0, r3, #0
1000331c:	f000 fae8 	bl	100038f0 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
10003320:	f000 fdf0 	bl	10003f04 <xTaskResumeAll>

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
10003324:	2300      	movs	r3, #0
10003326:	e000      	b.n	1000332a <xQueueGenericSend+0x1be>
        }
    } /*lint -restore */
10003328:	e75a      	b.n	100031e0 <xQueueGenericSend+0x74>
}
1000332a:	1c18      	adds	r0, r3, #0
1000332c:	46bd      	mov	sp, r7
1000332e:	b00a      	add	sp, #40	; 0x28
10003330:	bd80      	pop	{r7, pc}
10003332:	46c0      	nop			; (mov r8, r8)

10003334 <xQueueGenericSendFromISR>:

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
10003334:	b580      	push	{r7, lr}
10003336:	b08a      	sub	sp, #40	; 0x28
10003338:	af00      	add	r7, sp, #0
1000333a:	60f8      	str	r0, [r7, #12]
1000333c:	60b9      	str	r1, [r7, #8]
1000333e:	607a      	str	r2, [r7, #4]
10003340:	603b      	str	r3, [r7, #0]
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
10003342:	68fb      	ldr	r3, [r7, #12]
10003344:	623b      	str	r3, [r7, #32]

    configASSERT( pxQueue );
10003346:	6a3b      	ldr	r3, [r7, #32]
10003348:	2b00      	cmp	r3, #0
1000334a:	d101      	bne.n	10003350 <xQueueGenericSendFromISR+0x1c>
1000334c:	b672      	cpsid	i
1000334e:	e7fe      	b.n	1000334e <xQueueGenericSendFromISR+0x1a>
    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
10003350:	68bb      	ldr	r3, [r7, #8]
10003352:	2b00      	cmp	r3, #0
10003354:	d103      	bne.n	1000335e <xQueueGenericSendFromISR+0x2a>
10003356:	6a3b      	ldr	r3, [r7, #32]
10003358:	6c1b      	ldr	r3, [r3, #64]	; 0x40
1000335a:	2b00      	cmp	r3, #0
1000335c:	d101      	bne.n	10003362 <xQueueGenericSendFromISR+0x2e>
1000335e:	2301      	movs	r3, #1
10003360:	e000      	b.n	10003364 <xQueueGenericSendFromISR+0x30>
10003362:	2300      	movs	r3, #0
10003364:	2b00      	cmp	r3, #0
10003366:	d101      	bne.n	1000336c <xQueueGenericSendFromISR+0x38>
10003368:	b672      	cpsid	i
1000336a:	e7fe      	b.n	1000336a <xQueueGenericSendFromISR+0x36>
    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
1000336c:	683b      	ldr	r3, [r7, #0]
1000336e:	2b02      	cmp	r3, #2
10003370:	d103      	bne.n	1000337a <xQueueGenericSendFromISR+0x46>
10003372:	6a3b      	ldr	r3, [r7, #32]
10003374:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
10003376:	2b01      	cmp	r3, #1
10003378:	d101      	bne.n	1000337e <xQueueGenericSendFromISR+0x4a>
1000337a:	2301      	movs	r3, #1
1000337c:	e000      	b.n	10003380 <xQueueGenericSendFromISR+0x4c>
1000337e:	2300      	movs	r3, #0
10003380:	2b00      	cmp	r3, #0
10003382:	d101      	bne.n	10003388 <xQueueGenericSendFromISR+0x54>
10003384:	b672      	cpsid	i
10003386:	e7fe      	b.n	10003386 <xQueueGenericSendFromISR+0x52>
    /* Similar to xQueueGenericSend, except without blocking if there is no room
     * in the queue.  Also don't directly wake a task that was blocked on a queue
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
10003388:	f7ff fcb2 	bl	10002cf0 <ulSetInterruptMaskFromISR>
1000338c:	1c03      	adds	r3, r0, #0
1000338e:	61fb      	str	r3, [r7, #28]
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
10003390:	6a3b      	ldr	r3, [r7, #32]
10003392:	6b9a      	ldr	r2, [r3, #56]	; 0x38
10003394:	6a3b      	ldr	r3, [r7, #32]
10003396:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
10003398:	429a      	cmp	r2, r3
1000339a:	d302      	bcc.n	100033a2 <xQueueGenericSendFromISR+0x6e>
1000339c:	683b      	ldr	r3, [r7, #0]
1000339e:	2b02      	cmp	r3, #2
100033a0:	d155      	bne.n	1000344e <xQueueGenericSendFromISR+0x11a>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
100033a2:	231b      	movs	r3, #27
100033a4:	18fb      	adds	r3, r7, r3
100033a6:	6a3a      	ldr	r2, [r7, #32]
100033a8:	2145      	movs	r1, #69	; 0x45
100033aa:	5c52      	ldrb	r2, [r2, r1]
100033ac:	701a      	strb	r2, [r3, #0]
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
100033ae:	6a3b      	ldr	r3, [r7, #32]
100033b0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
100033b2:	617b      	str	r3, [r7, #20]
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
100033b4:	6a39      	ldr	r1, [r7, #32]
100033b6:	68ba      	ldr	r2, [r7, #8]
100033b8:	683b      	ldr	r3, [r7, #0]
100033ba:	1c08      	adds	r0, r1, #0
100033bc:	1c11      	adds	r1, r2, #0
100033be:	1c1a      	adds	r2, r3, #0
100033c0:	f000 f9fe 	bl	100037c0 <prvCopyDataToQueue>

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
100033c4:	231b      	movs	r3, #27
100033c6:	18fb      	adds	r3, r7, r3
100033c8:	781b      	ldrb	r3, [r3, #0]
100033ca:	b25b      	sxtb	r3, r3
100033cc:	3301      	adds	r3, #1
100033ce:	d12a      	bne.n	10003426 <xQueueGenericSendFromISR+0xf2>
            {
                #if ( configUSE_QUEUE_SETS == 1 )
                    {
                        if( pxQueue->pxQueueSetContainer != NULL )
100033d0:	6a3b      	ldr	r3, [r7, #32]
100033d2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
100033d4:	2b00      	cmp	r3, #0
100033d6:	d014      	beq.n	10003402 <xQueueGenericSendFromISR+0xce>
                        {
                            if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 ) )
100033d8:	683b      	ldr	r3, [r7, #0]
100033da:	2b02      	cmp	r3, #2
100033dc:	d104      	bne.n	100033e8 <xQueueGenericSendFromISR+0xb4>
100033de:	697b      	ldr	r3, [r7, #20]
100033e0:	2b00      	cmp	r3, #0
100033e2:	d001      	beq.n	100033e8 <xQueueGenericSendFromISR+0xb4>
100033e4:	46c0      	nop			; (mov r8, r8)
100033e6:	e02f      	b.n	10003448 <xQueueGenericSendFromISR+0x114>
                                /* Do not notify the queue set as an existing item
                                 * was overwritten in the queue so the number of items
                                 * in the queue has not changed. */
                                mtCOVERAGE_TEST_MARKER();
                            }
                            else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
100033e8:	6a3b      	ldr	r3, [r7, #32]
100033ea:	1c18      	adds	r0, r3, #0
100033ec:	f000 fb78 	bl	10003ae0 <prvNotifyQueueSetContainer>
100033f0:	1e03      	subs	r3, r0, #0
100033f2:	d029      	beq.n	10003448 <xQueueGenericSendFromISR+0x114>
                            {
                                /* The queue is a member of a queue set, and posting
                                 * to the queue set caused a higher priority task to
                                 * unblock.  A context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
100033f4:	687b      	ldr	r3, [r7, #4]
100033f6:	2b00      	cmp	r3, #0
100033f8:	d026      	beq.n	10003448 <xQueueGenericSendFromISR+0x114>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
100033fa:	687b      	ldr	r3, [r7, #4]
100033fc:	2201      	movs	r2, #1
100033fe:	601a      	str	r2, [r3, #0]
10003400:	e022      	b.n	10003448 <xQueueGenericSendFromISR+0x114>
                                mtCOVERAGE_TEST_MARKER();
                            }
                        }
                        else
                        {
                            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
10003402:	6a3b      	ldr	r3, [r7, #32]
10003404:	6a5b      	ldr	r3, [r3, #36]	; 0x24
10003406:	2b00      	cmp	r3, #0
10003408:	d01e      	beq.n	10003448 <xQueueGenericSendFromISR+0x114>
                            {
                                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1000340a:	6a3b      	ldr	r3, [r7, #32]
1000340c:	3324      	adds	r3, #36	; 0x24
1000340e:	1c18      	adds	r0, r3, #0
10003410:	f000 ff52 	bl	100042b8 <xTaskRemoveFromEventList>
10003414:	1e03      	subs	r3, r0, #0
10003416:	d017      	beq.n	10003448 <xQueueGenericSendFromISR+0x114>
                                {
                                    /* The task waiting has a higher priority so
                                     *  record that a context switch is required. */
                                    if( pxHigherPriorityTaskWoken != NULL )
10003418:	687b      	ldr	r3, [r7, #4]
1000341a:	2b00      	cmp	r3, #0
1000341c:	d014      	beq.n	10003448 <xQueueGenericSendFromISR+0x114>
                                    {
                                        *pxHigherPriorityTaskWoken = pdTRUE;
1000341e:	687b      	ldr	r3, [r7, #4]
10003420:	2201      	movs	r2, #1
10003422:	601a      	str	r2, [r3, #0]
10003424:	e010      	b.n	10003448 <xQueueGenericSendFromISR+0x114>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );
10003426:	231b      	movs	r3, #27
10003428:	18fb      	adds	r3, r7, r3
1000342a:	781b      	ldrb	r3, [r3, #0]
1000342c:	b25b      	sxtb	r3, r3
1000342e:	2b7f      	cmp	r3, #127	; 0x7f
10003430:	d101      	bne.n	10003436 <xQueueGenericSendFromISR+0x102>
10003432:	b672      	cpsid	i
10003434:	e7fe      	b.n	10003434 <xQueueGenericSendFromISR+0x100>

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
10003436:	231b      	movs	r3, #27
10003438:	18fb      	adds	r3, r7, r3
1000343a:	781b      	ldrb	r3, [r3, #0]
1000343c:	3301      	adds	r3, #1
1000343e:	b2db      	uxtb	r3, r3
10003440:	b2d9      	uxtb	r1, r3
10003442:	6a3b      	ldr	r3, [r7, #32]
10003444:	2245      	movs	r2, #69	; 0x45
10003446:	5499      	strb	r1, [r3, r2]
            }

            xReturn = pdPASS;
10003448:	2301      	movs	r3, #1
1000344a:	627b      	str	r3, [r7, #36]	; 0x24
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
        {
1000344c:	e001      	b.n	10003452 <xQueueGenericSendFromISR+0x11e>
            xReturn = pdPASS;
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
1000344e:	2300      	movs	r3, #0
10003450:	627b      	str	r3, [r7, #36]	; 0x24
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
10003452:	69fb      	ldr	r3, [r7, #28]
10003454:	1c18      	adds	r0, r3, #0
10003456:	f7ff fc51 	bl	10002cfc <vClearInterruptMaskFromISR>

    return xReturn;
1000345a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
1000345c:	1c18      	adds	r0, r3, #0
1000345e:	46bd      	mov	sp, r7
10003460:	b00a      	add	sp, #40	; 0x28
10003462:	bd80      	pop	{r7, pc}

10003464 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
10003464:	b580      	push	{r7, lr}
10003466:	b08a      	sub	sp, #40	; 0x28
10003468:	af00      	add	r7, sp, #0
1000346a:	60f8      	str	r0, [r7, #12]
1000346c:	60b9      	str	r1, [r7, #8]
1000346e:	607a      	str	r2, [r7, #4]
    BaseType_t xEntryTimeSet = pdFALSE;
10003470:	2300      	movs	r3, #0
10003472:	627b      	str	r3, [r7, #36]	; 0x24
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
10003474:	68fb      	ldr	r3, [r7, #12]
10003476:	623b      	str	r3, [r7, #32]

    /* Check the pointer is not NULL. */
    configASSERT( ( pxQueue ) );
10003478:	6a3b      	ldr	r3, [r7, #32]
1000347a:	2b00      	cmp	r3, #0
1000347c:	d101      	bne.n	10003482 <xQueueReceive+0x1e>
1000347e:	b672      	cpsid	i
10003480:	e7fe      	b.n	10003480 <xQueueReceive+0x1c>

    /* The buffer into which data is received can only be NULL if the data size
     * is zero (so no data is copied into the buffer). */
    configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
10003482:	68bb      	ldr	r3, [r7, #8]
10003484:	2b00      	cmp	r3, #0
10003486:	d103      	bne.n	10003490 <xQueueReceive+0x2c>
10003488:	6a3b      	ldr	r3, [r7, #32]
1000348a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
1000348c:	2b00      	cmp	r3, #0
1000348e:	d101      	bne.n	10003494 <xQueueReceive+0x30>
10003490:	2301      	movs	r3, #1
10003492:	e000      	b.n	10003496 <xQueueReceive+0x32>
10003494:	2300      	movs	r3, #0
10003496:	2b00      	cmp	r3, #0
10003498:	d101      	bne.n	1000349e <xQueueReceive+0x3a>
1000349a:	b672      	cpsid	i
1000349c:	e7fe      	b.n	1000349c <xQueueReceive+0x38>

    /* Cannot block if the scheduler is suspended. */
    #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
1000349e:	f001 f891 	bl	100045c4 <xTaskGetSchedulerState>
100034a2:	1e03      	subs	r3, r0, #0
100034a4:	d102      	bne.n	100034ac <xQueueReceive+0x48>
100034a6:	687b      	ldr	r3, [r7, #4]
100034a8:	2b00      	cmp	r3, #0
100034aa:	d101      	bne.n	100034b0 <xQueueReceive+0x4c>
100034ac:	2301      	movs	r3, #1
100034ae:	e000      	b.n	100034b2 <xQueueReceive+0x4e>
100034b0:	2300      	movs	r3, #0
100034b2:	2b00      	cmp	r3, #0
100034b4:	d101      	bne.n	100034ba <xQueueReceive+0x56>
100034b6:	b672      	cpsid	i
100034b8:	e7fe      	b.n	100034b8 <xQueueReceive+0x54>
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
100034ba:	f7ff fbf3 	bl	10002ca4 <vPortEnterCritical>
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
100034be:	6a3b      	ldr	r3, [r7, #32]
100034c0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
100034c2:	61fb      	str	r3, [r7, #28]

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
100034c4:	69fb      	ldr	r3, [r7, #28]
100034c6:	2b00      	cmp	r3, #0
100034c8:	d01a      	beq.n	10003500 <xQueueReceive+0x9c>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
100034ca:	6a3a      	ldr	r2, [r7, #32]
100034cc:	68bb      	ldr	r3, [r7, #8]
100034ce:	1c10      	adds	r0, r2, #0
100034d0:	1c19      	adds	r1, r3, #0
100034d2:	f000 f9e5 	bl	100038a0 <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
100034d6:	69fb      	ldr	r3, [r7, #28]
100034d8:	1e5a      	subs	r2, r3, #1
100034da:	6a3b      	ldr	r3, [r7, #32]
100034dc:	639a      	str	r2, [r3, #56]	; 0x38

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
100034de:	6a3b      	ldr	r3, [r7, #32]
100034e0:	691b      	ldr	r3, [r3, #16]
100034e2:	2b00      	cmp	r3, #0
100034e4:	d008      	beq.n	100034f8 <xQueueReceive+0x94>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
100034e6:	6a3b      	ldr	r3, [r7, #32]
100034e8:	3310      	adds	r3, #16
100034ea:	1c18      	adds	r0, r3, #0
100034ec:	f000 fee4 	bl	100042b8 <xTaskRemoveFromEventList>
100034f0:	1e03      	subs	r3, r0, #0
100034f2:	d001      	beq.n	100034f8 <xQueueReceive+0x94>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
100034f4:	f7ff fbc8 	bl	10002c88 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
100034f8:	f7ff fbe4 	bl	10002cc4 <vPortExitCritical>
                return pdPASS;
100034fc:	2301      	movs	r3, #1
100034fe:	e066      	b.n	100035ce <xQueueReceive+0x16a>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
10003500:	687b      	ldr	r3, [r7, #4]
10003502:	2b00      	cmp	r3, #0
10003504:	d103      	bne.n	1000350e <xQueueReceive+0xaa>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
10003506:	f7ff fbdd 	bl	10002cc4 <vPortExitCritical>
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
1000350a:	2300      	movs	r3, #0
1000350c:	e05f      	b.n	100035ce <xQueueReceive+0x16a>
                }
                else if( xEntryTimeSet == pdFALSE )
1000350e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
10003510:	2b00      	cmp	r3, #0
10003512:	d106      	bne.n	10003522 <xQueueReceive+0xbe>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
10003514:	2314      	movs	r3, #20
10003516:	18fb      	adds	r3, r7, r3
10003518:	1c18      	adds	r0, r3, #0
1000351a:	f000 ff29 	bl	10004370 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
1000351e:	2301      	movs	r3, #1
10003520:	627b      	str	r3, [r7, #36]	; 0x24
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
10003522:	f7ff fbcf 	bl	10002cc4 <vPortExitCritical>

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
10003526:	f000 fce1 	bl	10003eec <vTaskSuspendAll>
        prvLockQueue( pxQueue );
1000352a:	f7ff fbbb 	bl	10002ca4 <vPortEnterCritical>
1000352e:	6a3b      	ldr	r3, [r7, #32]
10003530:	2244      	movs	r2, #68	; 0x44
10003532:	5c9b      	ldrb	r3, [r3, r2]
10003534:	b2db      	uxtb	r3, r3
10003536:	b25b      	sxtb	r3, r3
10003538:	3301      	adds	r3, #1
1000353a:	d103      	bne.n	10003544 <xQueueReceive+0xe0>
1000353c:	6a3b      	ldr	r3, [r7, #32]
1000353e:	2244      	movs	r2, #68	; 0x44
10003540:	2100      	movs	r1, #0
10003542:	5499      	strb	r1, [r3, r2]
10003544:	6a3b      	ldr	r3, [r7, #32]
10003546:	2245      	movs	r2, #69	; 0x45
10003548:	5c9b      	ldrb	r3, [r3, r2]
1000354a:	b2db      	uxtb	r3, r3
1000354c:	b25b      	sxtb	r3, r3
1000354e:	3301      	adds	r3, #1
10003550:	d103      	bne.n	1000355a <xQueueReceive+0xf6>
10003552:	6a3b      	ldr	r3, [r7, #32]
10003554:	2245      	movs	r2, #69	; 0x45
10003556:	2100      	movs	r1, #0
10003558:	5499      	strb	r1, [r3, r2]
1000355a:	f7ff fbb3 	bl	10002cc4 <vPortExitCritical>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
1000355e:	2314      	movs	r3, #20
10003560:	18fa      	adds	r2, r7, r3
10003562:	1d3b      	adds	r3, r7, #4
10003564:	1c10      	adds	r0, r2, #0
10003566:	1c19      	adds	r1, r3, #0
10003568:	f000 ff16 	bl	10004398 <xTaskCheckForTimeOut>
1000356c:	1e03      	subs	r3, r0, #0
1000356e:	d11f      	bne.n	100035b0 <xQueueReceive+0x14c>
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
10003570:	6a3b      	ldr	r3, [r7, #32]
10003572:	1c18      	adds	r0, r3, #0
10003574:	f000 fa28 	bl	100039c8 <prvIsQueueEmpty>
10003578:	1e03      	subs	r3, r0, #0
1000357a:	d012      	beq.n	100035a2 <xQueueReceive+0x13e>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1000357c:	6a3b      	ldr	r3, [r7, #32]
1000357e:	3324      	adds	r3, #36	; 0x24
10003580:	1c1a      	adds	r2, r3, #0
10003582:	687b      	ldr	r3, [r7, #4]
10003584:	1c10      	adds	r0, r2, #0
10003586:	1c19      	adds	r1, r3, #0
10003588:	f000 fe56 	bl	10004238 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
1000358c:	6a3b      	ldr	r3, [r7, #32]
1000358e:	1c18      	adds	r0, r3, #0
10003590:	f000 f9ae 	bl	100038f0 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
10003594:	f000 fcb6 	bl	10003f04 <xTaskResumeAll>
10003598:	1e03      	subs	r3, r0, #0
1000359a:	d117      	bne.n	100035cc <xQueueReceive+0x168>
                {
                    portYIELD_WITHIN_API();
1000359c:	f7ff fb74 	bl	10002c88 <vPortYield>
100035a0:	e014      	b.n	100035cc <xQueueReceive+0x168>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
100035a2:	6a3b      	ldr	r3, [r7, #32]
100035a4:	1c18      	adds	r0, r3, #0
100035a6:	f000 f9a3 	bl	100038f0 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
100035aa:	f000 fcab 	bl	10003f04 <xTaskResumeAll>
100035ae:	e784      	b.n	100034ba <xQueueReceive+0x56>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
100035b0:	6a3b      	ldr	r3, [r7, #32]
100035b2:	1c18      	adds	r0, r3, #0
100035b4:	f000 f99c 	bl	100038f0 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
100035b8:	f000 fca4 	bl	10003f04 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
100035bc:	6a3b      	ldr	r3, [r7, #32]
100035be:	1c18      	adds	r0, r3, #0
100035c0:	f000 fa02 	bl	100039c8 <prvIsQueueEmpty>
100035c4:	1e03      	subs	r3, r0, #0
100035c6:	d001      	beq.n	100035cc <xQueueReceive+0x168>
            {
                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
100035c8:	2300      	movs	r3, #0
100035ca:	e000      	b.n	100035ce <xQueueReceive+0x16a>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
100035cc:	e775      	b.n	100034ba <xQueueReceive+0x56>
}
100035ce:	1c18      	adds	r0, r3, #0
100035d0:	46bd      	mov	sp, r7
100035d2:	b00a      	add	sp, #40	; 0x28
100035d4:	bd80      	pop	{r7, pc}
100035d6:	46c0      	nop			; (mov r8, r8)

100035d8 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
100035d8:	b580      	push	{r7, lr}
100035da:	b08a      	sub	sp, #40	; 0x28
100035dc:	af00      	add	r7, sp, #0
100035de:	6078      	str	r0, [r7, #4]
100035e0:	6039      	str	r1, [r7, #0]
    BaseType_t xEntryTimeSet = pdFALSE;
100035e2:	2300      	movs	r3, #0
100035e4:	627b      	str	r3, [r7, #36]	; 0x24
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
100035e6:	687b      	ldr	r3, [r7, #4]
100035e8:	61fb      	str	r3, [r7, #28]

    #if ( configUSE_MUTEXES == 1 )
        BaseType_t xInheritanceOccurred = pdFALSE;
100035ea:	2300      	movs	r3, #0
100035ec:	623b      	str	r3, [r7, #32]
    #endif

    /* Check the queue pointer is not NULL. */
    configASSERT( ( pxQueue ) );
100035ee:	69fb      	ldr	r3, [r7, #28]
100035f0:	2b00      	cmp	r3, #0
100035f2:	d101      	bne.n	100035f8 <xQueueSemaphoreTake+0x20>
100035f4:	b672      	cpsid	i
100035f6:	e7fe      	b.n	100035f6 <xQueueSemaphoreTake+0x1e>

    /* Check this really is a semaphore, in which case the item size will be
     * 0. */
    configASSERT( pxQueue->uxItemSize == 0 );
100035f8:	69fb      	ldr	r3, [r7, #28]
100035fa:	6c1b      	ldr	r3, [r3, #64]	; 0x40
100035fc:	2b00      	cmp	r3, #0
100035fe:	d001      	beq.n	10003604 <xQueueSemaphoreTake+0x2c>
10003600:	b672      	cpsid	i
10003602:	e7fe      	b.n	10003602 <xQueueSemaphoreTake+0x2a>

    /* Cannot block if the scheduler is suspended. */
    #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
10003604:	f000 ffde 	bl	100045c4 <xTaskGetSchedulerState>
10003608:	1e03      	subs	r3, r0, #0
1000360a:	d102      	bne.n	10003612 <xQueueSemaphoreTake+0x3a>
1000360c:	683b      	ldr	r3, [r7, #0]
1000360e:	2b00      	cmp	r3, #0
10003610:	d101      	bne.n	10003616 <xQueueSemaphoreTake+0x3e>
10003612:	2301      	movs	r3, #1
10003614:	e000      	b.n	10003618 <xQueueSemaphoreTake+0x40>
10003616:	2300      	movs	r3, #0
10003618:	2b00      	cmp	r3, #0
1000361a:	d101      	bne.n	10003620 <xQueueSemaphoreTake+0x48>
1000361c:	b672      	cpsid	i
1000361e:	e7fe      	b.n	1000361e <xQueueSemaphoreTake+0x46>
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
10003620:	f7ff fb40 	bl	10002ca4 <vPortEnterCritical>
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
10003624:	69fb      	ldr	r3, [r7, #28]
10003626:	6b9b      	ldr	r3, [r3, #56]	; 0x38
10003628:	61bb      	str	r3, [r7, #24]

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
1000362a:	69bb      	ldr	r3, [r7, #24]
1000362c:	2b00      	cmp	r3, #0
1000362e:	d01d      	beq.n	1000366c <xQueueSemaphoreTake+0x94>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
10003630:	69bb      	ldr	r3, [r7, #24]
10003632:	1e5a      	subs	r2, r3, #1
10003634:	69fb      	ldr	r3, [r7, #28]
10003636:	639a      	str	r2, [r3, #56]	; 0x38

                #if ( configUSE_MUTEXES == 1 )
                    {
                        if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
10003638:	69fb      	ldr	r3, [r7, #28]
1000363a:	681b      	ldr	r3, [r3, #0]
1000363c:	2b00      	cmp	r3, #0
1000363e:	d104      	bne.n	1000364a <xQueueSemaphoreTake+0x72>
                        {
                            /* Record the information required to implement
                             * priority inheritance should it become necessary. */
                            pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
10003640:	f001 f90e 	bl	10004860 <pvTaskIncrementMutexHeldCount>
10003644:	1c02      	adds	r2, r0, #0
10003646:	69fb      	ldr	r3, [r7, #28]
10003648:	609a      	str	r2, [r3, #8]
                    }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1000364a:	69fb      	ldr	r3, [r7, #28]
1000364c:	691b      	ldr	r3, [r3, #16]
1000364e:	2b00      	cmp	r3, #0
10003650:	d008      	beq.n	10003664 <xQueueSemaphoreTake+0x8c>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
10003652:	69fb      	ldr	r3, [r7, #28]
10003654:	3310      	adds	r3, #16
10003656:	1c18      	adds	r0, r3, #0
10003658:	f000 fe2e 	bl	100042b8 <xTaskRemoveFromEventList>
1000365c:	1e03      	subs	r3, r0, #0
1000365e:	d001      	beq.n	10003664 <xQueueSemaphoreTake+0x8c>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
10003660:	f7ff fb12 	bl	10002c88 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
10003664:	f7ff fb2e 	bl	10002cc4 <vPortExitCritical>
                return pdPASS;
10003668:	2301      	movs	r3, #1
1000366a:	e08e      	b.n	1000378a <xQueueSemaphoreTake+0x1b2>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
1000366c:	683b      	ldr	r3, [r7, #0]
1000366e:	2b00      	cmp	r3, #0
10003670:	d108      	bne.n	10003684 <xQueueSemaphoreTake+0xac>
                    /* For inheritance to have occurred there must have been an
                     * initial timeout, and an adjusted timeout cannot become 0, as
                     * if it were 0 the function would have exited. */
                    #if ( configUSE_MUTEXES == 1 )
                        {
                            configASSERT( xInheritanceOccurred == pdFALSE );
10003672:	6a3b      	ldr	r3, [r7, #32]
10003674:	2b00      	cmp	r3, #0
10003676:	d001      	beq.n	1000367c <xQueueSemaphoreTake+0xa4>
10003678:	b672      	cpsid	i
1000367a:	e7fe      	b.n	1000367a <xQueueSemaphoreTake+0xa2>
                        }
                    #endif /* configUSE_MUTEXES */

                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
1000367c:	f7ff fb22 	bl	10002cc4 <vPortExitCritical>
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
10003680:	2300      	movs	r3, #0
10003682:	e082      	b.n	1000378a <xQueueSemaphoreTake+0x1b2>
                }
                else if( xEntryTimeSet == pdFALSE )
10003684:	6a7b      	ldr	r3, [r7, #36]	; 0x24
10003686:	2b00      	cmp	r3, #0
10003688:	d106      	bne.n	10003698 <xQueueSemaphoreTake+0xc0>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
1000368a:	230c      	movs	r3, #12
1000368c:	18fb      	adds	r3, r7, r3
1000368e:	1c18      	adds	r0, r3, #0
10003690:	f000 fe6e 	bl	10004370 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
10003694:	2301      	movs	r3, #1
10003696:	627b      	str	r3, [r7, #36]	; 0x24
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
10003698:	f7ff fb14 	bl	10002cc4 <vPortExitCritical>

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
1000369c:	f000 fc26 	bl	10003eec <vTaskSuspendAll>
        prvLockQueue( pxQueue );
100036a0:	f7ff fb00 	bl	10002ca4 <vPortEnterCritical>
100036a4:	69fb      	ldr	r3, [r7, #28]
100036a6:	2244      	movs	r2, #68	; 0x44
100036a8:	5c9b      	ldrb	r3, [r3, r2]
100036aa:	b2db      	uxtb	r3, r3
100036ac:	b25b      	sxtb	r3, r3
100036ae:	3301      	adds	r3, #1
100036b0:	d103      	bne.n	100036ba <xQueueSemaphoreTake+0xe2>
100036b2:	69fb      	ldr	r3, [r7, #28]
100036b4:	2244      	movs	r2, #68	; 0x44
100036b6:	2100      	movs	r1, #0
100036b8:	5499      	strb	r1, [r3, r2]
100036ba:	69fb      	ldr	r3, [r7, #28]
100036bc:	2245      	movs	r2, #69	; 0x45
100036be:	5c9b      	ldrb	r3, [r3, r2]
100036c0:	b2db      	uxtb	r3, r3
100036c2:	b25b      	sxtb	r3, r3
100036c4:	3301      	adds	r3, #1
100036c6:	d103      	bne.n	100036d0 <xQueueSemaphoreTake+0xf8>
100036c8:	69fb      	ldr	r3, [r7, #28]
100036ca:	2245      	movs	r2, #69	; 0x45
100036cc:	2100      	movs	r1, #0
100036ce:	5499      	strb	r1, [r3, r2]
100036d0:	f7ff faf8 	bl	10002cc4 <vPortExitCritical>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
100036d4:	230c      	movs	r3, #12
100036d6:	18fa      	adds	r2, r7, r3
100036d8:	1c3b      	adds	r3, r7, #0
100036da:	1c10      	adds	r0, r2, #0
100036dc:	1c19      	adds	r1, r3, #0
100036de:	f000 fe5b 	bl	10004398 <xTaskCheckForTimeOut>
100036e2:	1e03      	subs	r3, r0, #0
100036e4:	d12e      	bne.n	10003744 <xQueueSemaphoreTake+0x16c>
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
100036e6:	69fb      	ldr	r3, [r7, #28]
100036e8:	1c18      	adds	r0, r3, #0
100036ea:	f000 f96d 	bl	100039c8 <prvIsQueueEmpty>
100036ee:	1e03      	subs	r3, r0, #0
100036f0:	d021      	beq.n	10003736 <xQueueSemaphoreTake+0x15e>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

                #if ( configUSE_MUTEXES == 1 )
                    {
                        if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
100036f2:	69fb      	ldr	r3, [r7, #28]
100036f4:	681b      	ldr	r3, [r3, #0]
100036f6:	2b00      	cmp	r3, #0
100036f8:	d10a      	bne.n	10003710 <xQueueSemaphoreTake+0x138>
                        {
                            taskENTER_CRITICAL();
100036fa:	f7ff fad3 	bl	10002ca4 <vPortEnterCritical>
                            {
                                xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
100036fe:	69fb      	ldr	r3, [r7, #28]
10003700:	689b      	ldr	r3, [r3, #8]
10003702:	1c18      	adds	r0, r3, #0
10003704:	f000 ff7a 	bl	100045fc <xTaskPriorityInherit>
10003708:	1c03      	adds	r3, r0, #0
1000370a:	623b      	str	r3, [r7, #32]
                            }
                            taskEXIT_CRITICAL();
1000370c:	f7ff fada 	bl	10002cc4 <vPortExitCritical>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
10003710:	69fb      	ldr	r3, [r7, #28]
10003712:	3324      	adds	r3, #36	; 0x24
10003714:	1c1a      	adds	r2, r3, #0
10003716:	683b      	ldr	r3, [r7, #0]
10003718:	1c10      	adds	r0, r2, #0
1000371a:	1c19      	adds	r1, r3, #0
1000371c:	f000 fd8c 	bl	10004238 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
10003720:	69fb      	ldr	r3, [r7, #28]
10003722:	1c18      	adds	r0, r3, #0
10003724:	f000 f8e4 	bl	100038f0 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
10003728:	f000 fbec 	bl	10003f04 <xTaskResumeAll>
1000372c:	1e03      	subs	r3, r0, #0
1000372e:	d12b      	bne.n	10003788 <xQueueSemaphoreTake+0x1b0>
                {
                    portYIELD_WITHIN_API();
10003730:	f7ff faaa 	bl	10002c88 <vPortYield>
10003734:	e028      	b.n	10003788 <xQueueSemaphoreTake+0x1b0>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
10003736:	69fb      	ldr	r3, [r7, #28]
10003738:	1c18      	adds	r0, r3, #0
1000373a:	f000 f8d9 	bl	100038f0 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
1000373e:	f000 fbe1 	bl	10003f04 <xTaskResumeAll>
10003742:	e76d      	b.n	10003620 <xQueueSemaphoreTake+0x48>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
10003744:	69fb      	ldr	r3, [r7, #28]
10003746:	1c18      	adds	r0, r3, #0
10003748:	f000 f8d2 	bl	100038f0 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
1000374c:	f000 fbda 	bl	10003f04 <xTaskResumeAll>

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
10003750:	69fb      	ldr	r3, [r7, #28]
10003752:	1c18      	adds	r0, r3, #0
10003754:	f000 f938 	bl	100039c8 <prvIsQueueEmpty>
10003758:	1e03      	subs	r3, r0, #0
1000375a:	d015      	beq.n	10003788 <xQueueSemaphoreTake+0x1b0>
                #if ( configUSE_MUTEXES == 1 )
                    {
                        /* xInheritanceOccurred could only have be set if
                         * pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
                         * test the mutex type again to check it is actually a mutex. */
                        if( xInheritanceOccurred != pdFALSE )
1000375c:	6a3b      	ldr	r3, [r7, #32]
1000375e:	2b00      	cmp	r3, #0
10003760:	d010      	beq.n	10003784 <xQueueSemaphoreTake+0x1ac>
                        {
                            taskENTER_CRITICAL();
10003762:	f7ff fa9f 	bl	10002ca4 <vPortEnterCritical>
                                /* This task blocking on the mutex caused another
                                 * task to inherit this task's priority.  Now this task
                                 * has timed out the priority should be disinherited
                                 * again, but only as low as the next highest priority
                                 * task that is waiting for the same mutex. */
                                uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
10003766:	69fb      	ldr	r3, [r7, #28]
10003768:	1c18      	adds	r0, r3, #0
1000376a:	f000 f813 	bl	10003794 <prvGetDisinheritPriorityAfterTimeout>
1000376e:	1c03      	adds	r3, r0, #0
10003770:	617b      	str	r3, [r7, #20]
                                vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
10003772:	69fb      	ldr	r3, [r7, #28]
10003774:	689a      	ldr	r2, [r3, #8]
10003776:	697b      	ldr	r3, [r7, #20]
10003778:	1c10      	adds	r0, r2, #0
1000377a:	1c19      	adds	r1, r3, #0
1000377c:	f001 f802 	bl	10004784 <vTaskPriorityDisinheritAfterTimeout>
                            }
                            taskEXIT_CRITICAL();
10003780:	f7ff faa0 	bl	10002cc4 <vPortExitCritical>
                        }
                    }
                #endif /* configUSE_MUTEXES */

                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
10003784:	2300      	movs	r3, #0
10003786:	e000      	b.n	1000378a <xQueueSemaphoreTake+0x1b2>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
10003788:	e74a      	b.n	10003620 <xQueueSemaphoreTake+0x48>
}
1000378a:	1c18      	adds	r0, r3, #0
1000378c:	46bd      	mov	sp, r7
1000378e:	b00a      	add	sp, #40	; 0x28
10003790:	bd80      	pop	{r7, pc}
10003792:	46c0      	nop			; (mov r8, r8)

10003794 <prvGetDisinheritPriorityAfterTimeout>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
    {
10003794:	b580      	push	{r7, lr}
10003796:	b084      	sub	sp, #16
10003798:	af00      	add	r7, sp, #0
1000379a:	6078      	str	r0, [r7, #4]
         * priority, but the waiting task times out, then the holder should
         * disinherit the priority - but only down to the highest priority of any
         * other tasks that are waiting for the same mutex.  For this purpose,
         * return the priority of the highest priority task that is waiting for the
         * mutex. */
        if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
1000379c:	687b      	ldr	r3, [r7, #4]
1000379e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
100037a0:	2b00      	cmp	r3, #0
100037a2:	d006      	beq.n	100037b2 <prvGetDisinheritPriorityAfterTimeout+0x1e>
        {
            uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
100037a4:	687b      	ldr	r3, [r7, #4]
100037a6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
100037a8:	681b      	ldr	r3, [r3, #0]
100037aa:	2205      	movs	r2, #5
100037ac:	1ad3      	subs	r3, r2, r3
100037ae:	60fb      	str	r3, [r7, #12]
100037b0:	e001      	b.n	100037b6 <prvGetDisinheritPriorityAfterTimeout+0x22>
        }
        else
        {
            uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
100037b2:	2300      	movs	r3, #0
100037b4:	60fb      	str	r3, [r7, #12]
        }

        return uxHighestPriorityOfWaitingTasks;
100037b6:	68fb      	ldr	r3, [r7, #12]
    }
100037b8:	1c18      	adds	r0, r3, #0
100037ba:	46bd      	mov	sp, r7
100037bc:	b004      	add	sp, #16
100037be:	bd80      	pop	{r7, pc}

100037c0 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
100037c0:	b580      	push	{r7, lr}
100037c2:	b086      	sub	sp, #24
100037c4:	af00      	add	r7, sp, #0
100037c6:	60f8      	str	r0, [r7, #12]
100037c8:	60b9      	str	r1, [r7, #8]
100037ca:	607a      	str	r2, [r7, #4]
    BaseType_t xReturn = pdFALSE;
100037cc:	2300      	movs	r3, #0
100037ce:	617b      	str	r3, [r7, #20]
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
100037d0:	68fb      	ldr	r3, [r7, #12]
100037d2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
100037d4:	613b      	str	r3, [r7, #16]

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
100037d6:	68fb      	ldr	r3, [r7, #12]
100037d8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
100037da:	2b00      	cmp	r3, #0
100037dc:	d10e      	bne.n	100037fc <prvCopyDataToQueue+0x3c>
    {
        #if ( configUSE_MUTEXES == 1 )
            {
                if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
100037de:	68fb      	ldr	r3, [r7, #12]
100037e0:	681b      	ldr	r3, [r3, #0]
100037e2:	2b00      	cmp	r3, #0
100037e4:	d152      	bne.n	1000388c <prvCopyDataToQueue+0xcc>
                {
                    /* The mutex is no longer being held. */
                    xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
100037e6:	68fb      	ldr	r3, [r7, #12]
100037e8:	689b      	ldr	r3, [r3, #8]
100037ea:	1c18      	adds	r0, r3, #0
100037ec:	f000 ff6e 	bl	100046cc <xTaskPriorityDisinherit>
100037f0:	1c03      	adds	r3, r0, #0
100037f2:	617b      	str	r3, [r7, #20]
                    pxQueue->u.xSemaphore.xMutexHolder = NULL;
100037f4:	68fb      	ldr	r3, [r7, #12]
100037f6:	2200      	movs	r2, #0
100037f8:	609a      	str	r2, [r3, #8]
100037fa:	e047      	b.n	1000388c <prvCopyDataToQueue+0xcc>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
100037fc:	687b      	ldr	r3, [r7, #4]
100037fe:	2b00      	cmp	r3, #0
10003800:	d11b      	bne.n	1000383a <prvCopyDataToQueue+0x7a>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
10003802:	68fb      	ldr	r3, [r7, #12]
10003804:	6859      	ldr	r1, [r3, #4]
10003806:	68fb      	ldr	r3, [r7, #12]
10003808:	6c1b      	ldr	r3, [r3, #64]	; 0x40
1000380a:	68ba      	ldr	r2, [r7, #8]
1000380c:	1c08      	adds	r0, r1, #0
1000380e:	1c11      	adds	r1, r2, #0
10003810:	1c1a      	adds	r2, r3, #0
10003812:	f002 f8eb 	bl	100059ec <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
10003816:	68fb      	ldr	r3, [r7, #12]
10003818:	685a      	ldr	r2, [r3, #4]
1000381a:	68fb      	ldr	r3, [r7, #12]
1000381c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
1000381e:	18d2      	adds	r2, r2, r3
10003820:	68fb      	ldr	r3, [r7, #12]
10003822:	605a      	str	r2, [r3, #4]

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
10003824:	68fb      	ldr	r3, [r7, #12]
10003826:	685a      	ldr	r2, [r3, #4]
10003828:	68fb      	ldr	r3, [r7, #12]
1000382a:	689b      	ldr	r3, [r3, #8]
1000382c:	429a      	cmp	r2, r3
1000382e:	d32d      	bcc.n	1000388c <prvCopyDataToQueue+0xcc>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
10003830:	68fb      	ldr	r3, [r7, #12]
10003832:	681a      	ldr	r2, [r3, #0]
10003834:	68fb      	ldr	r3, [r7, #12]
10003836:	605a      	str	r2, [r3, #4]
10003838:	e028      	b.n	1000388c <prvCopyDataToQueue+0xcc>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
1000383a:	68fb      	ldr	r3, [r7, #12]
1000383c:	68d9      	ldr	r1, [r3, #12]
1000383e:	68fb      	ldr	r3, [r7, #12]
10003840:	6c1b      	ldr	r3, [r3, #64]	; 0x40
10003842:	68ba      	ldr	r2, [r7, #8]
10003844:	1c08      	adds	r0, r1, #0
10003846:	1c11      	adds	r1, r2, #0
10003848:	1c1a      	adds	r2, r3, #0
1000384a:	f002 f8cf 	bl	100059ec <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
1000384e:	68fb      	ldr	r3, [r7, #12]
10003850:	68da      	ldr	r2, [r3, #12]
10003852:	68fb      	ldr	r3, [r7, #12]
10003854:	6c1b      	ldr	r3, [r3, #64]	; 0x40
10003856:	425b      	negs	r3, r3
10003858:	18d2      	adds	r2, r2, r3
1000385a:	68fb      	ldr	r3, [r7, #12]
1000385c:	60da      	str	r2, [r3, #12]

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
1000385e:	68fb      	ldr	r3, [r7, #12]
10003860:	68da      	ldr	r2, [r3, #12]
10003862:	68fb      	ldr	r3, [r7, #12]
10003864:	681b      	ldr	r3, [r3, #0]
10003866:	429a      	cmp	r2, r3
10003868:	d207      	bcs.n	1000387a <prvCopyDataToQueue+0xba>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
1000386a:	68fb      	ldr	r3, [r7, #12]
1000386c:	689a      	ldr	r2, [r3, #8]
1000386e:	68fb      	ldr	r3, [r7, #12]
10003870:	6c1b      	ldr	r3, [r3, #64]	; 0x40
10003872:	425b      	negs	r3, r3
10003874:	18d2      	adds	r2, r2, r3
10003876:	68fb      	ldr	r3, [r7, #12]
10003878:	60da      	str	r2, [r3, #12]
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
1000387a:	687b      	ldr	r3, [r7, #4]
1000387c:	2b02      	cmp	r3, #2
1000387e:	d105      	bne.n	1000388c <prvCopyDataToQueue+0xcc>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
10003880:	693b      	ldr	r3, [r7, #16]
10003882:	2b00      	cmp	r3, #0
10003884:	d002      	beq.n	1000388c <prvCopyDataToQueue+0xcc>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
10003886:	693b      	ldr	r3, [r7, #16]
10003888:	3b01      	subs	r3, #1
1000388a:	613b      	str	r3, [r7, #16]
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
1000388c:	693b      	ldr	r3, [r7, #16]
1000388e:	1c5a      	adds	r2, r3, #1
10003890:	68fb      	ldr	r3, [r7, #12]
10003892:	639a      	str	r2, [r3, #56]	; 0x38

    return xReturn;
10003894:	697b      	ldr	r3, [r7, #20]
}
10003896:	1c18      	adds	r0, r3, #0
10003898:	46bd      	mov	sp, r7
1000389a:	b006      	add	sp, #24
1000389c:	bd80      	pop	{r7, pc}
1000389e:	46c0      	nop			; (mov r8, r8)

100038a0 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
100038a0:	b580      	push	{r7, lr}
100038a2:	b082      	sub	sp, #8
100038a4:	af00      	add	r7, sp, #0
100038a6:	6078      	str	r0, [r7, #4]
100038a8:	6039      	str	r1, [r7, #0]
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
100038aa:	687b      	ldr	r3, [r7, #4]
100038ac:	6c1b      	ldr	r3, [r3, #64]	; 0x40
100038ae:	2b00      	cmp	r3, #0
100038b0:	d01a      	beq.n	100038e8 <prvCopyDataFromQueue+0x48>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
100038b2:	687b      	ldr	r3, [r7, #4]
100038b4:	68da      	ldr	r2, [r3, #12]
100038b6:	687b      	ldr	r3, [r7, #4]
100038b8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
100038ba:	18d2      	adds	r2, r2, r3
100038bc:	687b      	ldr	r3, [r7, #4]
100038be:	60da      	str	r2, [r3, #12]

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
100038c0:	687b      	ldr	r3, [r7, #4]
100038c2:	68da      	ldr	r2, [r3, #12]
100038c4:	687b      	ldr	r3, [r7, #4]
100038c6:	689b      	ldr	r3, [r3, #8]
100038c8:	429a      	cmp	r2, r3
100038ca:	d303      	bcc.n	100038d4 <prvCopyDataFromQueue+0x34>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
100038cc:	687b      	ldr	r3, [r7, #4]
100038ce:	681a      	ldr	r2, [r3, #0]
100038d0:	687b      	ldr	r3, [r7, #4]
100038d2:	60da      	str	r2, [r3, #12]
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
100038d4:	687b      	ldr	r3, [r7, #4]
100038d6:	68da      	ldr	r2, [r3, #12]
100038d8:	687b      	ldr	r3, [r7, #4]
100038da:	6c1b      	ldr	r3, [r3, #64]	; 0x40
100038dc:	6839      	ldr	r1, [r7, #0]
100038de:	1c08      	adds	r0, r1, #0
100038e0:	1c11      	adds	r1, r2, #0
100038e2:	1c1a      	adds	r2, r3, #0
100038e4:	f002 f882 	bl	100059ec <memcpy>
    }
}
100038e8:	46bd      	mov	sp, r7
100038ea:	b002      	add	sp, #8
100038ec:	bd80      	pop	{r7, pc}
100038ee:	46c0      	nop			; (mov r8, r8)

100038f0 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
100038f0:	b580      	push	{r7, lr}
100038f2:	b084      	sub	sp, #16
100038f4:	af00      	add	r7, sp, #0
100038f6:	6078      	str	r0, [r7, #4]

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
100038f8:	f7ff f9d4 	bl	10002ca4 <vPortEnterCritical>
    {
        int8_t cTxLock = pxQueue->cTxLock;
100038fc:	230f      	movs	r3, #15
100038fe:	18fb      	adds	r3, r7, r3
10003900:	687a      	ldr	r2, [r7, #4]
10003902:	2145      	movs	r1, #69	; 0x45
10003904:	5c52      	ldrb	r2, [r2, r1]
10003906:	701a      	strb	r2, [r3, #0]

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
10003908:	e023      	b.n	10003952 <prvUnlockQueue+0x62>
        {
            /* Data was posted while the queue was locked.  Are any tasks
             * blocked waiting for data to become available? */
            #if ( configUSE_QUEUE_SETS == 1 )
                {
                    if( pxQueue->pxQueueSetContainer != NULL )
1000390a:	687b      	ldr	r3, [r7, #4]
1000390c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
1000390e:	2b00      	cmp	r3, #0
10003910:	d008      	beq.n	10003924 <prvUnlockQueue+0x34>
                    {
                        if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
10003912:	687b      	ldr	r3, [r7, #4]
10003914:	1c18      	adds	r0, r3, #0
10003916:	f000 f8e3 	bl	10003ae0 <prvNotifyQueueSetContainer>
1000391a:	1e03      	subs	r3, r0, #0
1000391c:	d011      	beq.n	10003942 <prvUnlockQueue+0x52>
                        {
                            /* The queue is a member of a queue set, and posting to
                             * the queue set caused a higher priority task to unblock.
                             * A context switch is required. */
                            vTaskMissedYield();
1000391e:	f000 fd9f 	bl	10004460 <vTaskMissedYield>
10003922:	e00e      	b.n	10003942 <prvUnlockQueue+0x52>
                    else
                    {
                        /* Tasks that are removed from the event list will get
                         * added to the pending ready list as the scheduler is still
                         * suspended. */
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
10003924:	687b      	ldr	r3, [r7, #4]
10003926:	6a5b      	ldr	r3, [r3, #36]	; 0x24
10003928:	2b00      	cmp	r3, #0
1000392a:	d009      	beq.n	10003940 <prvUnlockQueue+0x50>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1000392c:	687b      	ldr	r3, [r7, #4]
1000392e:	3324      	adds	r3, #36	; 0x24
10003930:	1c18      	adds	r0, r3, #0
10003932:	f000 fcc1 	bl	100042b8 <xTaskRemoveFromEventList>
10003936:	1e03      	subs	r3, r0, #0
10003938:	d003      	beq.n	10003942 <prvUnlockQueue+0x52>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                vTaskMissedYield();
1000393a:	f000 fd91 	bl	10004460 <vTaskMissedYield>
1000393e:	e000      	b.n	10003942 <prvUnlockQueue+0x52>
                                mtCOVERAGE_TEST_MARKER();
                            }
                        }
                        else
                        {
                            break;
10003940:	e00d      	b.n	1000395e <prvUnlockQueue+0x6e>
                        break;
                    }
                }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
10003942:	230f      	movs	r3, #15
10003944:	18fb      	adds	r3, r7, r3
10003946:	781b      	ldrb	r3, [r3, #0]
10003948:	3b01      	subs	r3, #1
1000394a:	b2da      	uxtb	r2, r3
1000394c:	230f      	movs	r3, #15
1000394e:	18fb      	adds	r3, r7, r3
10003950:	701a      	strb	r2, [r3, #0]
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
10003952:	230f      	movs	r3, #15
10003954:	18fb      	adds	r3, r7, r3
10003956:	781b      	ldrb	r3, [r3, #0]
10003958:	b25b      	sxtb	r3, r3
1000395a:	2b00      	cmp	r3, #0
1000395c:	dcd5      	bgt.n	1000390a <prvUnlockQueue+0x1a>
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
1000395e:	687b      	ldr	r3, [r7, #4]
10003960:	2245      	movs	r2, #69	; 0x45
10003962:	21ff      	movs	r1, #255	; 0xff
10003964:	5499      	strb	r1, [r3, r2]
    }
    taskEXIT_CRITICAL();
10003966:	f7ff f9ad 	bl	10002cc4 <vPortExitCritical>

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
1000396a:	f7ff f99b 	bl	10002ca4 <vPortEnterCritical>
    {
        int8_t cRxLock = pxQueue->cRxLock;
1000396e:	230e      	movs	r3, #14
10003970:	18fb      	adds	r3, r7, r3
10003972:	687a      	ldr	r2, [r7, #4]
10003974:	2144      	movs	r1, #68	; 0x44
10003976:	5c52      	ldrb	r2, [r2, r1]
10003978:	701a      	strb	r2, [r3, #0]

        while( cRxLock > queueLOCKED_UNMODIFIED )
1000397a:	e016      	b.n	100039aa <prvUnlockQueue+0xba>
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1000397c:	687b      	ldr	r3, [r7, #4]
1000397e:	691b      	ldr	r3, [r3, #16]
10003980:	2b00      	cmp	r3, #0
10003982:	d011      	beq.n	100039a8 <prvUnlockQueue+0xb8>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
10003984:	687b      	ldr	r3, [r7, #4]
10003986:	3310      	adds	r3, #16
10003988:	1c18      	adds	r0, r3, #0
1000398a:	f000 fc95 	bl	100042b8 <xTaskRemoveFromEventList>
1000398e:	1e03      	subs	r3, r0, #0
10003990:	d001      	beq.n	10003996 <prvUnlockQueue+0xa6>
                {
                    vTaskMissedYield();
10003992:	f000 fd65 	bl	10004460 <vTaskMissedYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
10003996:	230e      	movs	r3, #14
10003998:	18fb      	adds	r3, r7, r3
1000399a:	781b      	ldrb	r3, [r3, #0]
1000399c:	3b01      	subs	r3, #1
1000399e:	b2da      	uxtb	r2, r3
100039a0:	230e      	movs	r3, #14
100039a2:	18fb      	adds	r3, r7, r3
100039a4:	701a      	strb	r2, [r3, #0]
100039a6:	e000      	b.n	100039aa <prvUnlockQueue+0xba>
            }
            else
            {
                break;
100039a8:	e005      	b.n	100039b6 <prvUnlockQueue+0xc6>
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
100039aa:	230e      	movs	r3, #14
100039ac:	18fb      	adds	r3, r7, r3
100039ae:	781b      	ldrb	r3, [r3, #0]
100039b0:	b25b      	sxtb	r3, r3
100039b2:	2b00      	cmp	r3, #0
100039b4:	dce2      	bgt.n	1000397c <prvUnlockQueue+0x8c>
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
100039b6:	687b      	ldr	r3, [r7, #4]
100039b8:	2244      	movs	r2, #68	; 0x44
100039ba:	21ff      	movs	r1, #255	; 0xff
100039bc:	5499      	strb	r1, [r3, r2]
    }
    taskEXIT_CRITICAL();
100039be:	f7ff f981 	bl	10002cc4 <vPortExitCritical>
}
100039c2:	46bd      	mov	sp, r7
100039c4:	b004      	add	sp, #16
100039c6:	bd80      	pop	{r7, pc}

100039c8 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
100039c8:	b580      	push	{r7, lr}
100039ca:	b084      	sub	sp, #16
100039cc:	af00      	add	r7, sp, #0
100039ce:	6078      	str	r0, [r7, #4]
    BaseType_t xReturn;

    taskENTER_CRITICAL();
100039d0:	f7ff f968 	bl	10002ca4 <vPortEnterCritical>
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
100039d4:	687b      	ldr	r3, [r7, #4]
100039d6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
100039d8:	2b00      	cmp	r3, #0
100039da:	d102      	bne.n	100039e2 <prvIsQueueEmpty+0x1a>
        {
            xReturn = pdTRUE;
100039dc:	2301      	movs	r3, #1
100039de:	60fb      	str	r3, [r7, #12]
100039e0:	e001      	b.n	100039e6 <prvIsQueueEmpty+0x1e>
        }
        else
        {
            xReturn = pdFALSE;
100039e2:	2300      	movs	r3, #0
100039e4:	60fb      	str	r3, [r7, #12]
        }
    }
    taskEXIT_CRITICAL();
100039e6:	f7ff f96d 	bl	10002cc4 <vPortExitCritical>

    return xReturn;
100039ea:	68fb      	ldr	r3, [r7, #12]
}
100039ec:	1c18      	adds	r0, r3, #0
100039ee:	46bd      	mov	sp, r7
100039f0:	b004      	add	sp, #16
100039f2:	bd80      	pop	{r7, pc}

100039f4 <prvIsQueueFull>:
    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
100039f4:	b580      	push	{r7, lr}
100039f6:	b084      	sub	sp, #16
100039f8:	af00      	add	r7, sp, #0
100039fa:	6078      	str	r0, [r7, #4]
    BaseType_t xReturn;

    taskENTER_CRITICAL();
100039fc:	f7ff f952 	bl	10002ca4 <vPortEnterCritical>
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
10003a00:	687b      	ldr	r3, [r7, #4]
10003a02:	6b9a      	ldr	r2, [r3, #56]	; 0x38
10003a04:	687b      	ldr	r3, [r7, #4]
10003a06:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
10003a08:	429a      	cmp	r2, r3
10003a0a:	d102      	bne.n	10003a12 <prvIsQueueFull+0x1e>
        {
            xReturn = pdTRUE;
10003a0c:	2301      	movs	r3, #1
10003a0e:	60fb      	str	r3, [r7, #12]
10003a10:	e001      	b.n	10003a16 <prvIsQueueFull+0x22>
        }
        else
        {
            xReturn = pdFALSE;
10003a12:	2300      	movs	r3, #0
10003a14:	60fb      	str	r3, [r7, #12]
        }
    }
    taskEXIT_CRITICAL();
10003a16:	f7ff f955 	bl	10002cc4 <vPortExitCritical>

    return xReturn;
10003a1a:	68fb      	ldr	r3, [r7, #12]
}
10003a1c:	1c18      	adds	r0, r3, #0
10003a1e:	46bd      	mov	sp, r7
10003a20:	b004      	add	sp, #16
10003a22:	bd80      	pop	{r7, pc}

10003a24 <vQueueAddToRegistry>:

#if ( configQUEUE_REGISTRY_SIZE > 0 )

    void vQueueAddToRegistry( QueueHandle_t xQueue,
                              const char * pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    {
10003a24:	b580      	push	{r7, lr}
10003a26:	b084      	sub	sp, #16
10003a28:	af00      	add	r7, sp, #0
10003a2a:	6078      	str	r0, [r7, #4]
10003a2c:	6039      	str	r1, [r7, #0]
        UBaseType_t ux;

        /* See if there is an empty space in the registry.  A NULL name denotes
         * a free slot. */
        for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
10003a2e:	2300      	movs	r3, #0
10003a30:	60fb      	str	r3, [r7, #12]
10003a32:	e014      	b.n	10003a5e <vQueueAddToRegistry+0x3a>
        {
            if( xQueueRegistry[ ux ].pcQueueName == NULL )
10003a34:	4b0d      	ldr	r3, [pc, #52]	; (10003a6c <vQueueAddToRegistry+0x48>)
10003a36:	68fa      	ldr	r2, [r7, #12]
10003a38:	00d2      	lsls	r2, r2, #3
10003a3a:	58d3      	ldr	r3, [r2, r3]
10003a3c:	2b00      	cmp	r3, #0
10003a3e:	d10b      	bne.n	10003a58 <vQueueAddToRegistry+0x34>
            {
                /* Store the information on this queue. */
                xQueueRegistry[ ux ].pcQueueName = pcQueueName;
10003a40:	4b0a      	ldr	r3, [pc, #40]	; (10003a6c <vQueueAddToRegistry+0x48>)
10003a42:	68fa      	ldr	r2, [r7, #12]
10003a44:	00d2      	lsls	r2, r2, #3
10003a46:	6839      	ldr	r1, [r7, #0]
10003a48:	50d1      	str	r1, [r2, r3]
                xQueueRegistry[ ux ].xHandle = xQueue;
10003a4a:	4a08      	ldr	r2, [pc, #32]	; (10003a6c <vQueueAddToRegistry+0x48>)
10003a4c:	68fb      	ldr	r3, [r7, #12]
10003a4e:	00db      	lsls	r3, r3, #3
10003a50:	18d3      	adds	r3, r2, r3
10003a52:	687a      	ldr	r2, [r7, #4]
10003a54:	605a      	str	r2, [r3, #4]

                traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
                break;
10003a56:	e005      	b.n	10003a64 <vQueueAddToRegistry+0x40>
    {
        UBaseType_t ux;

        /* See if there is an empty space in the registry.  A NULL name denotes
         * a free slot. */
        for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
10003a58:	68fb      	ldr	r3, [r7, #12]
10003a5a:	3301      	adds	r3, #1
10003a5c:	60fb      	str	r3, [r7, #12]
10003a5e:	68fb      	ldr	r3, [r7, #12]
10003a60:	2b07      	cmp	r3, #7
10003a62:	d9e7      	bls.n	10003a34 <vQueueAddToRegistry+0x10>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
10003a64:	46bd      	mov	sp, r7
10003a66:	b004      	add	sp, #16
10003a68:	bd80      	pop	{r7, pc}
10003a6a:	46c0      	nop			; (mov r8, r8)
10003a6c:	200008d4 	.word	0x200008d4

10003a70 <vQueueWaitForMessageRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
10003a70:	b580      	push	{r7, lr}
10003a72:	b086      	sub	sp, #24
10003a74:	af00      	add	r7, sp, #0
10003a76:	60f8      	str	r0, [r7, #12]
10003a78:	60b9      	str	r1, [r7, #8]
10003a7a:	607a      	str	r2, [r7, #4]
        Queue_t * const pxQueue = xQueue;
10003a7c:	68fb      	ldr	r3, [r7, #12]
10003a7e:	617b      	str	r3, [r7, #20]
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
10003a80:	f7ff f910 	bl	10002ca4 <vPortEnterCritical>
10003a84:	697b      	ldr	r3, [r7, #20]
10003a86:	2244      	movs	r2, #68	; 0x44
10003a88:	5c9b      	ldrb	r3, [r3, r2]
10003a8a:	b2db      	uxtb	r3, r3
10003a8c:	b25b      	sxtb	r3, r3
10003a8e:	3301      	adds	r3, #1
10003a90:	d103      	bne.n	10003a9a <vQueueWaitForMessageRestricted+0x2a>
10003a92:	697b      	ldr	r3, [r7, #20]
10003a94:	2244      	movs	r2, #68	; 0x44
10003a96:	2100      	movs	r1, #0
10003a98:	5499      	strb	r1, [r3, r2]
10003a9a:	697b      	ldr	r3, [r7, #20]
10003a9c:	2245      	movs	r2, #69	; 0x45
10003a9e:	5c9b      	ldrb	r3, [r3, r2]
10003aa0:	b2db      	uxtb	r3, r3
10003aa2:	b25b      	sxtb	r3, r3
10003aa4:	3301      	adds	r3, #1
10003aa6:	d103      	bne.n	10003ab0 <vQueueWaitForMessageRestricted+0x40>
10003aa8:	697b      	ldr	r3, [r7, #20]
10003aaa:	2245      	movs	r2, #69	; 0x45
10003aac:	2100      	movs	r1, #0
10003aae:	5499      	strb	r1, [r3, r2]
10003ab0:	f7ff f908 	bl	10002cc4 <vPortExitCritical>

        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
10003ab4:	697b      	ldr	r3, [r7, #20]
10003ab6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
10003ab8:	2b00      	cmp	r3, #0
10003aba:	d109      	bne.n	10003ad0 <vQueueWaitForMessageRestricted+0x60>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
10003abc:	697b      	ldr	r3, [r7, #20]
10003abe:	3324      	adds	r3, #36	; 0x24
10003ac0:	1c19      	adds	r1, r3, #0
10003ac2:	68ba      	ldr	r2, [r7, #8]
10003ac4:	687b      	ldr	r3, [r7, #4]
10003ac6:	1c08      	adds	r0, r1, #0
10003ac8:	1c11      	adds	r1, r2, #0
10003aca:	1c1a      	adds	r2, r3, #0
10003acc:	f000 fbd0 	bl	10004270 <vTaskPlaceOnEventListRestricted>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
10003ad0:	697b      	ldr	r3, [r7, #20]
10003ad2:	1c18      	adds	r0, r3, #0
10003ad4:	f7ff ff0c 	bl	100038f0 <prvUnlockQueue>
    }
10003ad8:	46bd      	mov	sp, r7
10003ada:	b006      	add	sp, #24
10003adc:	bd80      	pop	{r7, pc}
10003ade:	46c0      	nop			; (mov r8, r8)

10003ae0 <prvNotifyQueueSetContainer>:
/*-----------------------------------------------------------*/

#if ( configUSE_QUEUE_SETS == 1 )

    static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue )
    {
10003ae0:	b580      	push	{r7, lr}
10003ae2:	b086      	sub	sp, #24
10003ae4:	af00      	add	r7, sp, #0
10003ae6:	6078      	str	r0, [r7, #4]
        Queue_t * pxQueueSetContainer = pxQueue->pxQueueSetContainer;
10003ae8:	687b      	ldr	r3, [r7, #4]
10003aea:	6c9b      	ldr	r3, [r3, #72]	; 0x48
10003aec:	613b      	str	r3, [r7, #16]
        BaseType_t xReturn = pdFALSE;
10003aee:	2300      	movs	r3, #0
10003af0:	617b      	str	r3, [r7, #20]

        /* This function must be called form a critical section. */

        configASSERT( pxQueueSetContainer );
10003af2:	693b      	ldr	r3, [r7, #16]
10003af4:	2b00      	cmp	r3, #0
10003af6:	d101      	bne.n	10003afc <prvNotifyQueueSetContainer+0x1c>
10003af8:	b672      	cpsid	i
10003afa:	e7fe      	b.n	10003afa <prvNotifyQueueSetContainer+0x1a>
        configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
10003afc:	693b      	ldr	r3, [r7, #16]
10003afe:	6b9a      	ldr	r2, [r3, #56]	; 0x38
10003b00:	693b      	ldr	r3, [r7, #16]
10003b02:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
10003b04:	429a      	cmp	r2, r3
10003b06:	d301      	bcc.n	10003b0c <prvNotifyQueueSetContainer+0x2c>
10003b08:	b672      	cpsid	i
10003b0a:	e7fe      	b.n	10003b0a <prvNotifyQueueSetContainer+0x2a>

        if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
10003b0c:	693b      	ldr	r3, [r7, #16]
10003b0e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
10003b10:	693b      	ldr	r3, [r7, #16]
10003b12:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
10003b14:	429a      	cmp	r2, r3
10003b16:	d234      	bcs.n	10003b82 <prvNotifyQueueSetContainer+0xa2>
        {
            const int8_t cTxLock = pxQueueSetContainer->cTxLock;
10003b18:	230f      	movs	r3, #15
10003b1a:	18fb      	adds	r3, r7, r3
10003b1c:	693a      	ldr	r2, [r7, #16]
10003b1e:	2145      	movs	r1, #69	; 0x45
10003b20:	5c52      	ldrb	r2, [r2, r1]
10003b22:	701a      	strb	r2, [r3, #0]

            traceQUEUE_SET_SEND( pxQueueSetContainer );

            /* The data copied is the handle of the queue that contains data. */
            xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, queueSEND_TO_BACK );
10003b24:	693a      	ldr	r2, [r7, #16]
10003b26:	1d3b      	adds	r3, r7, #4
10003b28:	1c10      	adds	r0, r2, #0
10003b2a:	1c19      	adds	r1, r3, #0
10003b2c:	2200      	movs	r2, #0
10003b2e:	f7ff fe47 	bl	100037c0 <prvCopyDataToQueue>
10003b32:	1c03      	adds	r3, r0, #0
10003b34:	617b      	str	r3, [r7, #20]

            if( cTxLock == queueUNLOCKED )
10003b36:	230f      	movs	r3, #15
10003b38:	18fb      	adds	r3, r7, r3
10003b3a:	781b      	ldrb	r3, [r3, #0]
10003b3c:	b25b      	sxtb	r3, r3
10003b3e:	3301      	adds	r3, #1
10003b40:	d10d      	bne.n	10003b5e <prvNotifyQueueSetContainer+0x7e>
            {
                if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
10003b42:	693b      	ldr	r3, [r7, #16]
10003b44:	6a5b      	ldr	r3, [r3, #36]	; 0x24
10003b46:	2b00      	cmp	r3, #0
10003b48:	d01b      	beq.n	10003b82 <prvNotifyQueueSetContainer+0xa2>
                {
                    if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
10003b4a:	693b      	ldr	r3, [r7, #16]
10003b4c:	3324      	adds	r3, #36	; 0x24
10003b4e:	1c18      	adds	r0, r3, #0
10003b50:	f000 fbb2 	bl	100042b8 <xTaskRemoveFromEventList>
10003b54:	1e03      	subs	r3, r0, #0
10003b56:	d014      	beq.n	10003b82 <prvNotifyQueueSetContainer+0xa2>
                    {
                        /* The task waiting has a higher priority. */
                        xReturn = pdTRUE;
10003b58:	2301      	movs	r3, #1
10003b5a:	617b      	str	r3, [r7, #20]
10003b5c:	e011      	b.n	10003b82 <prvNotifyQueueSetContainer+0xa2>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                configASSERT( cTxLock != queueINT8_MAX );
10003b5e:	230f      	movs	r3, #15
10003b60:	18fb      	adds	r3, r7, r3
10003b62:	781b      	ldrb	r3, [r3, #0]
10003b64:	b25b      	sxtb	r3, r3
10003b66:	2b7f      	cmp	r3, #127	; 0x7f
10003b68:	d101      	bne.n	10003b6e <prvNotifyQueueSetContainer+0x8e>
10003b6a:	b672      	cpsid	i
10003b6c:	e7fe      	b.n	10003b6c <prvNotifyQueueSetContainer+0x8c>

                pxQueueSetContainer->cTxLock = ( int8_t ) ( cTxLock + 1 );
10003b6e:	230f      	movs	r3, #15
10003b70:	18fb      	adds	r3, r7, r3
10003b72:	781b      	ldrb	r3, [r3, #0]
10003b74:	3301      	adds	r3, #1
10003b76:	b2db      	uxtb	r3, r3
10003b78:	b2d9      	uxtb	r1, r3
10003b7a:	693b      	ldr	r3, [r7, #16]
10003b7c:	2245      	movs	r2, #69	; 0x45
10003b7e:	5499      	strb	r1, [r3, r2]
10003b80:	e7ff      	b.n	10003b82 <prvNotifyQueueSetContainer+0xa2>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
10003b82:	697b      	ldr	r3, [r7, #20]
    }
10003b84:	1c18      	adds	r0, r3, #0
10003b86:	46bd      	mov	sp, r7
10003b88:	b006      	add	sp, #24
10003b8a:	bd80      	pop	{r7, pc}

10003b8c <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
10003b8c:	b590      	push	{r4, r7, lr}
10003b8e:	b08d      	sub	sp, #52	; 0x34
10003b90:	af04      	add	r7, sp, #16
10003b92:	60f8      	str	r0, [r7, #12]
10003b94:	60b9      	str	r1, [r7, #8]
10003b96:	603b      	str	r3, [r7, #0]
10003b98:	1dbb      	adds	r3, r7, #6
10003b9a:	801a      	strh	r2, [r3, #0]
        #else /* portSTACK_GROWTH */
            {
                StackType_t * pxStack;

                /* Allocate space for the stack used by the task being created. */
                pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
10003b9c:	1dbb      	adds	r3, r7, #6
10003b9e:	881b      	ldrh	r3, [r3, #0]
10003ba0:	009b      	lsls	r3, r3, #2
10003ba2:	1c18      	adds	r0, r3, #0
10003ba4:	f7ff f914 	bl	10002dd0 <pvPortMalloc>
10003ba8:	1c03      	adds	r3, r0, #0
10003baa:	617b      	str	r3, [r7, #20]

                if( pxStack != NULL )
10003bac:	697b      	ldr	r3, [r7, #20]
10003bae:	2b00      	cmp	r3, #0
10003bb0:	d010      	beq.n	10003bd4 <xTaskCreate+0x48>
                {
                    /* Allocate space for the TCB. */
                    pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
10003bb2:	2070      	movs	r0, #112	; 0x70
10003bb4:	f7ff f90c 	bl	10002dd0 <pvPortMalloc>
10003bb8:	1c03      	adds	r3, r0, #0
10003bba:	61fb      	str	r3, [r7, #28]

                    if( pxNewTCB != NULL )
10003bbc:	69fb      	ldr	r3, [r7, #28]
10003bbe:	2b00      	cmp	r3, #0
10003bc0:	d003      	beq.n	10003bca <xTaskCreate+0x3e>
                    {
                        /* Store the stack location in the TCB. */
                        pxNewTCB->pxStack = pxStack;
10003bc2:	69fb      	ldr	r3, [r7, #28]
10003bc4:	697a      	ldr	r2, [r7, #20]
10003bc6:	631a      	str	r2, [r3, #48]	; 0x30
10003bc8:	e006      	b.n	10003bd8 <xTaskCreate+0x4c>
                    }
                    else
                    {
                        /* The stack cannot be used as the TCB was not created.  Free
                         * it again. */
                        vPortFree( pxStack );
10003bca:	697b      	ldr	r3, [r7, #20]
10003bcc:	1c18      	adds	r0, r3, #0
10003bce:	f7ff f913 	bl	10002df8 <vPortFree>
10003bd2:	e001      	b.n	10003bd8 <xTaskCreate+0x4c>
                    }
                }
                else
                {
                    pxNewTCB = NULL;
10003bd4:	2300      	movs	r3, #0
10003bd6:	61fb      	str	r3, [r7, #28]
                }
            }
        #endif /* portSTACK_GROWTH */

        if( pxNewTCB != NULL )
10003bd8:	69fb      	ldr	r3, [r7, #28]
10003bda:	2b00      	cmp	r3, #0
10003bdc:	d016      	beq.n	10003c0c <xTaskCreate+0x80>
                     * task was created dynamically in case it is later deleted. */
                    pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
                }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

            prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
10003bde:	1dbb      	adds	r3, r7, #6
10003be0:	881a      	ldrh	r2, [r3, #0]
10003be2:	68f8      	ldr	r0, [r7, #12]
10003be4:	68b9      	ldr	r1, [r7, #8]
10003be6:	683c      	ldr	r4, [r7, #0]
10003be8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
10003bea:	9300      	str	r3, [sp, #0]
10003bec:	6b7b      	ldr	r3, [r7, #52]	; 0x34
10003bee:	9301      	str	r3, [sp, #4]
10003bf0:	69fb      	ldr	r3, [r7, #28]
10003bf2:	9302      	str	r3, [sp, #8]
10003bf4:	2300      	movs	r3, #0
10003bf6:	9303      	str	r3, [sp, #12]
10003bf8:	1c23      	adds	r3, r4, #0
10003bfa:	f000 f80f 	bl	10003c1c <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB );
10003bfe:	69fb      	ldr	r3, [r7, #28]
10003c00:	1c18      	adds	r0, r3, #0
10003c02:	f000 f8a7 	bl	10003d54 <prvAddNewTaskToReadyList>
            xReturn = pdPASS;
10003c06:	2301      	movs	r3, #1
10003c08:	61bb      	str	r3, [r7, #24]
10003c0a:	e002      	b.n	10003c12 <xTaskCreate+0x86>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
10003c0c:	2301      	movs	r3, #1
10003c0e:	425b      	negs	r3, r3
10003c10:	61bb      	str	r3, [r7, #24]
        }

        return xReturn;
10003c12:	69bb      	ldr	r3, [r7, #24]
    }
10003c14:	1c18      	adds	r0, r3, #0
10003c16:	46bd      	mov	sp, r7
10003c18:	b009      	add	sp, #36	; 0x24
10003c1a:	bd90      	pop	{r4, r7, pc}

10003c1c <prvInitialiseNewTask>:
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask,
                                  TCB_t * pxNewTCB,
                                  const MemoryRegion_t * const xRegions )
{
10003c1c:	b580      	push	{r7, lr}
10003c1e:	b086      	sub	sp, #24
10003c20:	af00      	add	r7, sp, #0
10003c22:	60f8      	str	r0, [r7, #12]
10003c24:	60b9      	str	r1, [r7, #8]
10003c26:	607a      	str	r2, [r7, #4]
10003c28:	603b      	str	r3, [r7, #0]

    /* Avoid dependency on memset() if it is not required. */
    #if ( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
        {
            /* Fill the stack with a known value to assist debugging. */
            ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
10003c2a:	6abb      	ldr	r3, [r7, #40]	; 0x28
10003c2c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
10003c2e:	687b      	ldr	r3, [r7, #4]
10003c30:	009b      	lsls	r3, r3, #2
10003c32:	1c10      	adds	r0, r2, #0
10003c34:	21a5      	movs	r1, #165	; 0xa5
10003c36:	1c1a      	adds	r2, r3, #0
10003c38:	f001 fee1 	bl	100059fe <memset>
     * grows from high memory to low (as per the 80x86) or vice versa.
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
        {
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
10003c3c:	6abb      	ldr	r3, [r7, #40]	; 0x28
10003c3e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
10003c40:	687b      	ldr	r3, [r7, #4]
10003c42:	4943      	ldr	r1, [pc, #268]	; (10003d50 <prvInitialiseNewTask+0x134>)
10003c44:	468c      	mov	ip, r1
10003c46:	4463      	add	r3, ip
10003c48:	009b      	lsls	r3, r3, #2
10003c4a:	18d3      	adds	r3, r2, r3
10003c4c:	613b      	str	r3, [r7, #16]
            pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
10003c4e:	693b      	ldr	r3, [r7, #16]
10003c50:	2207      	movs	r2, #7
10003c52:	4393      	bics	r3, r2
10003c54:	613b      	str	r3, [r7, #16]

            /* Check the alignment of the calculated top of stack is correct. */
            configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
10003c56:	693b      	ldr	r3, [r7, #16]
10003c58:	2207      	movs	r2, #7
10003c5a:	4013      	ands	r3, r2
10003c5c:	d001      	beq.n	10003c62 <prvInitialiseNewTask+0x46>
10003c5e:	b672      	cpsid	i
10003c60:	e7fe      	b.n	10003c60 <prvInitialiseNewTask+0x44>
            pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
        }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
10003c62:	68bb      	ldr	r3, [r7, #8]
10003c64:	2b00      	cmp	r3, #0
10003c66:	d01f      	beq.n	10003ca8 <prvInitialiseNewTask+0x8c>
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
10003c68:	2300      	movs	r3, #0
10003c6a:	617b      	str	r3, [r7, #20]
10003c6c:	e014      	b.n	10003c98 <prvInitialiseNewTask+0x7c>
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
10003c6e:	68ba      	ldr	r2, [r7, #8]
10003c70:	697b      	ldr	r3, [r7, #20]
10003c72:	18d3      	adds	r3, r2, r3
10003c74:	7818      	ldrb	r0, [r3, #0]
10003c76:	6aba      	ldr	r2, [r7, #40]	; 0x28
10003c78:	2130      	movs	r1, #48	; 0x30
10003c7a:	697b      	ldr	r3, [r7, #20]
10003c7c:	18d3      	adds	r3, r2, r3
10003c7e:	185b      	adds	r3, r3, r1
10003c80:	1c02      	adds	r2, r0, #0
10003c82:	711a      	strb	r2, [r3, #4]

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
10003c84:	68ba      	ldr	r2, [r7, #8]
10003c86:	697b      	ldr	r3, [r7, #20]
10003c88:	18d3      	adds	r3, r2, r3
10003c8a:	781b      	ldrb	r3, [r3, #0]
10003c8c:	2b00      	cmp	r3, #0
10003c8e:	d100      	bne.n	10003c92 <prvInitialiseNewTask+0x76>
            {
                break;
10003c90:	e005      	b.n	10003c9e <prvInitialiseNewTask+0x82>
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
10003c92:	697b      	ldr	r3, [r7, #20]
10003c94:	3301      	adds	r3, #1
10003c96:	617b      	str	r3, [r7, #20]
10003c98:	697b      	ldr	r3, [r7, #20]
10003c9a:	2b0f      	cmp	r3, #15
10003c9c:	d9e7      	bls.n	10003c6e <prvInitialiseNewTask+0x52>
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
10003c9e:	6abb      	ldr	r3, [r7, #40]	; 0x28
10003ca0:	2243      	movs	r2, #67	; 0x43
10003ca2:	2100      	movs	r1, #0
10003ca4:	5499      	strb	r1, [r3, r2]
10003ca6:	e003      	b.n	10003cb0 <prvInitialiseNewTask+0x94>
    }
    else
    {
        /* The task has not been given a name, so just ensure there is a NULL
         * terminator when it is read out. */
        pxNewTCB->pcTaskName[ 0 ] = 0x00;
10003ca8:	6abb      	ldr	r3, [r7, #40]	; 0x28
10003caa:	2234      	movs	r2, #52	; 0x34
10003cac:	2100      	movs	r1, #0
10003cae:	5499      	strb	r1, [r3, r2]
    }

    /* This is used as an array index so must ensure it's not too large.  First
     * remove the privilege bit if one is present. */
    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
10003cb0:	6a3b      	ldr	r3, [r7, #32]
10003cb2:	2b04      	cmp	r3, #4
10003cb4:	d901      	bls.n	10003cba <prvInitialiseNewTask+0x9e>
    {
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
10003cb6:	2304      	movs	r3, #4
10003cb8:	623b      	str	r3, [r7, #32]
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
10003cba:	6abb      	ldr	r3, [r7, #40]	; 0x28
10003cbc:	6a3a      	ldr	r2, [r7, #32]
10003cbe:	62da      	str	r2, [r3, #44]	; 0x2c
    #if ( configUSE_MUTEXES == 1 )
        {
            pxNewTCB->uxBasePriority = uxPriority;
10003cc0:	6abb      	ldr	r3, [r7, #40]	; 0x28
10003cc2:	6a3a      	ldr	r2, [r7, #32]
10003cc4:	64da      	str	r2, [r3, #76]	; 0x4c
            pxNewTCB->uxMutexesHeld = 0;
10003cc6:	6abb      	ldr	r3, [r7, #40]	; 0x28
10003cc8:	2200      	movs	r2, #0
10003cca:	651a      	str	r2, [r3, #80]	; 0x50
        }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
10003ccc:	6abb      	ldr	r3, [r7, #40]	; 0x28
10003cce:	3304      	adds	r3, #4
10003cd0:	1c18      	adds	r0, r3, #0
10003cd2:	f7ff f8c1 	bl	10002e58 <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
10003cd6:	6abb      	ldr	r3, [r7, #40]	; 0x28
10003cd8:	3318      	adds	r3, #24
10003cda:	1c18      	adds	r0, r3, #0
10003cdc:	f7ff f8bc 	bl	10002e58 <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
10003ce0:	6abb      	ldr	r3, [r7, #40]	; 0x28
10003ce2:	6aba      	ldr	r2, [r7, #40]	; 0x28
10003ce4:	611a      	str	r2, [r3, #16]

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
10003ce6:	6a3b      	ldr	r3, [r7, #32]
10003ce8:	2205      	movs	r2, #5
10003cea:	1ad2      	subs	r2, r2, r3
10003cec:	6abb      	ldr	r3, [r7, #40]	; 0x28
10003cee:	619a      	str	r2, [r3, #24]
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
10003cf0:	6abb      	ldr	r3, [r7, #40]	; 0x28
10003cf2:	6aba      	ldr	r2, [r7, #40]	; 0x28
10003cf4:	625a      	str	r2, [r3, #36]	; 0x24
        }
    #endif

    #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
        {
            memset( ( void * ) &( pxNewTCB->pvThreadLocalStoragePointers[ 0 ] ), 0x00, sizeof( pxNewTCB->pvThreadLocalStoragePointers ) );
10003cf6:	6abb      	ldr	r3, [r7, #40]	; 0x28
10003cf8:	3354      	adds	r3, #84	; 0x54
10003cfa:	1c18      	adds	r0, r3, #0
10003cfc:	2100      	movs	r1, #0
10003cfe:	2214      	movs	r2, #20
10003d00:	f001 fe7d 	bl	100059fe <memset>
        }
    #endif

    #if ( configUSE_TASK_NOTIFICATIONS == 1 )
        {
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
10003d04:	6abb      	ldr	r3, [r7, #40]	; 0x28
10003d06:	3368      	adds	r3, #104	; 0x68
10003d08:	1c18      	adds	r0, r3, #0
10003d0a:	2100      	movs	r1, #0
10003d0c:	2204      	movs	r2, #4
10003d0e:	f001 fe76 	bl	100059fe <memset>
            memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyState ) );
10003d12:	6abb      	ldr	r3, [r7, #40]	; 0x28
10003d14:	336c      	adds	r3, #108	; 0x6c
10003d16:	1c18      	adds	r0, r3, #0
10003d18:	2100      	movs	r1, #0
10003d1a:	2201      	movs	r2, #1
10003d1c:	f001 fe6f 	bl	100059fe <memset>
        }
    #endif

    #if ( INCLUDE_xTaskAbortDelay == 1 )
        {
            pxNewTCB->ucDelayAborted = pdFALSE;
10003d20:	6abb      	ldr	r3, [r7, #40]	; 0x28
10003d22:	226d      	movs	r2, #109	; 0x6d
10003d24:	2100      	movs	r1, #0
10003d26:	5499      	strb	r1, [r3, r2]
                        }
                    #endif /* portSTACK_GROWTH */
                }
            #else /* portHAS_STACK_OVERFLOW_CHECKING */
                {
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
10003d28:	6939      	ldr	r1, [r7, #16]
10003d2a:	68fa      	ldr	r2, [r7, #12]
10003d2c:	683b      	ldr	r3, [r7, #0]
10003d2e:	1c08      	adds	r0, r1, #0
10003d30:	1c11      	adds	r1, r2, #0
10003d32:	1c1a      	adds	r2, r3, #0
10003d34:	f7fe ff1e 	bl	10002b74 <pxPortInitialiseStack>
10003d38:	1c02      	adds	r2, r0, #0
10003d3a:	6abb      	ldr	r3, [r7, #40]	; 0x28
10003d3c:	601a      	str	r2, [r3, #0]
                }
            #endif /* portHAS_STACK_OVERFLOW_CHECKING */
        }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
10003d3e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
10003d40:	2b00      	cmp	r3, #0
10003d42:	d002      	beq.n	10003d4a <prvInitialiseNewTask+0x12e>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
10003d44:	6a7b      	ldr	r3, [r7, #36]	; 0x24
10003d46:	6aba      	ldr	r2, [r7, #40]	; 0x28
10003d48:	601a      	str	r2, [r3, #0]
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
10003d4a:	46bd      	mov	sp, r7
10003d4c:	b006      	add	sp, #24
10003d4e:	bd80      	pop	{r7, pc}
10003d50:	3fffffff 	.word	0x3fffffff

10003d54 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
10003d54:	b580      	push	{r7, lr}
10003d56:	b082      	sub	sp, #8
10003d58:	af00      	add	r7, sp, #0
10003d5a:	6078      	str	r0, [r7, #4]
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
10003d5c:	f7fe ffa2 	bl	10002ca4 <vPortEnterCritical>
    {
        uxCurrentNumberOfTasks++;
10003d60:	4b29      	ldr	r3, [pc, #164]	; (10003e08 <prvAddNewTaskToReadyList+0xb4>)
10003d62:	681b      	ldr	r3, [r3, #0]
10003d64:	1c5a      	adds	r2, r3, #1
10003d66:	4b28      	ldr	r3, [pc, #160]	; (10003e08 <prvAddNewTaskToReadyList+0xb4>)
10003d68:	601a      	str	r2, [r3, #0]

        if( pxCurrentTCB == NULL )
10003d6a:	4b28      	ldr	r3, [pc, #160]	; (10003e0c <prvAddNewTaskToReadyList+0xb8>)
10003d6c:	681b      	ldr	r3, [r3, #0]
10003d6e:	2b00      	cmp	r3, #0
10003d70:	d109      	bne.n	10003d86 <prvAddNewTaskToReadyList+0x32>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
10003d72:	4b26      	ldr	r3, [pc, #152]	; (10003e0c <prvAddNewTaskToReadyList+0xb8>)
10003d74:	687a      	ldr	r2, [r7, #4]
10003d76:	601a      	str	r2, [r3, #0]

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
10003d78:	4b23      	ldr	r3, [pc, #140]	; (10003e08 <prvAddNewTaskToReadyList+0xb4>)
10003d7a:	681b      	ldr	r3, [r3, #0]
10003d7c:	2b01      	cmp	r3, #1
10003d7e:	d110      	bne.n	10003da2 <prvAddNewTaskToReadyList+0x4e>
            {
                /* This is the first task to be created so do the preliminary
                 * initialisation required.  We will not recover if this call
                 * fails, but we will report the failure. */
                prvInitialiseTaskLists();
10003d80:	f000 fb88 	bl	10004494 <prvInitialiseTaskLists>
10003d84:	e00d      	b.n	10003da2 <prvAddNewTaskToReadyList+0x4e>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
10003d86:	4b22      	ldr	r3, [pc, #136]	; (10003e10 <prvAddNewTaskToReadyList+0xbc>)
10003d88:	681b      	ldr	r3, [r3, #0]
10003d8a:	2b00      	cmp	r3, #0
10003d8c:	d109      	bne.n	10003da2 <prvAddNewTaskToReadyList+0x4e>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
10003d8e:	4b1f      	ldr	r3, [pc, #124]	; (10003e0c <prvAddNewTaskToReadyList+0xb8>)
10003d90:	681b      	ldr	r3, [r3, #0]
10003d92:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10003d94:	687b      	ldr	r3, [r7, #4]
10003d96:	6adb      	ldr	r3, [r3, #44]	; 0x2c
10003d98:	429a      	cmp	r2, r3
10003d9a:	d802      	bhi.n	10003da2 <prvAddNewTaskToReadyList+0x4e>
                {
                    pxCurrentTCB = pxNewTCB;
10003d9c:	4b1b      	ldr	r3, [pc, #108]	; (10003e0c <prvAddNewTaskToReadyList+0xb8>)
10003d9e:	687a      	ldr	r2, [r7, #4]
10003da0:	601a      	str	r2, [r3, #0]
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
10003da2:	4b1c      	ldr	r3, [pc, #112]	; (10003e14 <prvAddNewTaskToReadyList+0xc0>)
10003da4:	681b      	ldr	r3, [r3, #0]
10003da6:	1c5a      	adds	r2, r3, #1
10003da8:	4b1a      	ldr	r3, [pc, #104]	; (10003e14 <prvAddNewTaskToReadyList+0xc0>)
10003daa:	601a      	str	r2, [r3, #0]

        #if ( configUSE_TRACE_FACILITY == 1 )
            {
                /* Add a counter into the TCB for tracing only. */
                pxNewTCB->uxTCBNumber = uxTaskNumber;
10003dac:	4b19      	ldr	r3, [pc, #100]	; (10003e14 <prvAddNewTaskToReadyList+0xc0>)
10003dae:	681a      	ldr	r2, [r3, #0]
10003db0:	687b      	ldr	r3, [r7, #4]
10003db2:	645a      	str	r2, [r3, #68]	; 0x44
            }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
10003db4:	687b      	ldr	r3, [r7, #4]
10003db6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10003db8:	4b17      	ldr	r3, [pc, #92]	; (10003e18 <prvAddNewTaskToReadyList+0xc4>)
10003dba:	681b      	ldr	r3, [r3, #0]
10003dbc:	429a      	cmp	r2, r3
10003dbe:	d903      	bls.n	10003dc8 <prvAddNewTaskToReadyList+0x74>
10003dc0:	687b      	ldr	r3, [r7, #4]
10003dc2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10003dc4:	4b14      	ldr	r3, [pc, #80]	; (10003e18 <prvAddNewTaskToReadyList+0xc4>)
10003dc6:	601a      	str	r2, [r3, #0]
10003dc8:	687b      	ldr	r3, [r7, #4]
10003dca:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10003dcc:	1c13      	adds	r3, r2, #0
10003dce:	009b      	lsls	r3, r3, #2
10003dd0:	189b      	adds	r3, r3, r2
10003dd2:	009b      	lsls	r3, r3, #2
10003dd4:	4a11      	ldr	r2, [pc, #68]	; (10003e1c <prvAddNewTaskToReadyList+0xc8>)
10003dd6:	189a      	adds	r2, r3, r2
10003dd8:	687b      	ldr	r3, [r7, #4]
10003dda:	3304      	adds	r3, #4
10003ddc:	1c10      	adds	r0, r2, #0
10003dde:	1c19      	adds	r1, r3, #0
10003de0:	f7ff f844 	bl	10002e6c <vListInsertEnd>

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
10003de4:	f7fe ff6e 	bl	10002cc4 <vPortExitCritical>

    if( xSchedulerRunning != pdFALSE )
10003de8:	4b09      	ldr	r3, [pc, #36]	; (10003e10 <prvAddNewTaskToReadyList+0xbc>)
10003dea:	681b      	ldr	r3, [r3, #0]
10003dec:	2b00      	cmp	r3, #0
10003dee:	d008      	beq.n	10003e02 <prvAddNewTaskToReadyList+0xae>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
10003df0:	4b06      	ldr	r3, [pc, #24]	; (10003e0c <prvAddNewTaskToReadyList+0xb8>)
10003df2:	681b      	ldr	r3, [r3, #0]
10003df4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10003df6:	687b      	ldr	r3, [r7, #4]
10003df8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
10003dfa:	429a      	cmp	r2, r3
10003dfc:	d201      	bcs.n	10003e02 <prvAddNewTaskToReadyList+0xae>
        {
            taskYIELD_IF_USING_PREEMPTION();
10003dfe:	f7fe ff43 	bl	10002c88 <vPortYield>
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
10003e02:	46bd      	mov	sp, r7
10003e04:	b002      	add	sp, #8
10003e06:	bd80      	pop	{r7, pc}
10003e08:	200007b0 	.word	0x200007b0
10003e0c:	200006d8 	.word	0x200006d8
10003e10:	200007bc 	.word	0x200007bc
10003e14:	200007cc 	.word	0x200007cc
10003e18:	200007b8 	.word	0x200007b8
10003e1c:	200006dc 	.word	0x200006dc

10003e20 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
10003e20:	b580      	push	{r7, lr}
10003e22:	b084      	sub	sp, #16
10003e24:	af00      	add	r7, sp, #0
10003e26:	6078      	str	r0, [r7, #4]
        BaseType_t xAlreadyYielded = pdFALSE;
10003e28:	2300      	movs	r3, #0
10003e2a:	60fb      	str	r3, [r7, #12]

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
10003e2c:	687b      	ldr	r3, [r7, #4]
10003e2e:	2b00      	cmp	r3, #0
10003e30:	d010      	beq.n	10003e54 <vTaskDelay+0x34>
        {
            configASSERT( uxSchedulerSuspended == 0 );
10003e32:	4b0c      	ldr	r3, [pc, #48]	; (10003e64 <vTaskDelay+0x44>)
10003e34:	681b      	ldr	r3, [r3, #0]
10003e36:	2b00      	cmp	r3, #0
10003e38:	d001      	beq.n	10003e3e <vTaskDelay+0x1e>
10003e3a:	b672      	cpsid	i
10003e3c:	e7fe      	b.n	10003e3c <vTaskDelay+0x1c>
            vTaskSuspendAll();
10003e3e:	f000 f855 	bl	10003eec <vTaskSuspendAll>
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
10003e42:	687b      	ldr	r3, [r7, #4]
10003e44:	1c18      	adds	r0, r3, #0
10003e46:	2100      	movs	r1, #0
10003e48:	f000 fd1c 	bl	10004884 <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
10003e4c:	f000 f85a 	bl	10003f04 <xTaskResumeAll>
10003e50:	1c03      	adds	r3, r0, #0
10003e52:	60fb      	str	r3, [r7, #12]
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
10003e54:	68fb      	ldr	r3, [r7, #12]
10003e56:	2b00      	cmp	r3, #0
10003e58:	d101      	bne.n	10003e5e <vTaskDelay+0x3e>
        {
            portYIELD_WITHIN_API();
10003e5a:	f7fe ff15 	bl	10002c88 <vPortYield>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
10003e5e:	46bd      	mov	sp, r7
10003e60:	b004      	add	sp, #16
10003e62:	bd80      	pop	{r7, pc}
10003e64:	200007d8 	.word	0x200007d8

10003e68 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
10003e68:	b580      	push	{r7, lr}
10003e6a:	b084      	sub	sp, #16
10003e6c:	af02      	add	r7, sp, #8
            }
        }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
        {
            /* The Idle task is being created using dynamically allocated RAM. */
            xReturn = xTaskCreate( prvIdleTask,
10003e6e:	4918      	ldr	r1, [pc, #96]	; (10003ed0 <vTaskStartScheduler+0x68>)
10003e70:	4a18      	ldr	r2, [pc, #96]	; (10003ed4 <vTaskStartScheduler+0x6c>)
10003e72:	2300      	movs	r3, #0
10003e74:	9300      	str	r3, [sp, #0]
10003e76:	4b18      	ldr	r3, [pc, #96]	; (10003ed8 <vTaskStartScheduler+0x70>)
10003e78:	9301      	str	r3, [sp, #4]
10003e7a:	1c08      	adds	r0, r1, #0
10003e7c:	1c11      	adds	r1, r2, #0
10003e7e:	223c      	movs	r2, #60	; 0x3c
10003e80:	2300      	movs	r3, #0
10003e82:	f7ff fe83 	bl	10003b8c <xTaskCreate>
10003e86:	1c03      	adds	r3, r0, #0
10003e88:	607b      	str	r3, [r7, #4]
        }
    #endif /* configSUPPORT_STATIC_ALLOCATION */

    #if ( configUSE_TIMERS == 1 )
        {
            if( xReturn == pdPASS )
10003e8a:	687b      	ldr	r3, [r7, #4]
10003e8c:	2b01      	cmp	r3, #1
10003e8e:	d103      	bne.n	10003e98 <vTaskStartScheduler+0x30>
            {
                xReturn = xTimerCreateTimerTask();
10003e90:	f000 fd50 	bl	10004934 <xTimerCreateTimerTask>
10003e94:	1c03      	adds	r3, r0, #0
10003e96:	607b      	str	r3, [r7, #4]
                mtCOVERAGE_TEST_MARKER();
            }
        }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
10003e98:	687b      	ldr	r3, [r7, #4]
10003e9a:	2b01      	cmp	r3, #1
10003e9c:	d10d      	bne.n	10003eba <vTaskStartScheduler+0x52>
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
10003e9e:	b672      	cpsid	i
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */

        xNextTaskUnblockTime = portMAX_DELAY;
10003ea0:	4b0e      	ldr	r3, [pc, #56]	; (10003edc <vTaskStartScheduler+0x74>)
10003ea2:	2201      	movs	r2, #1
10003ea4:	4252      	negs	r2, r2
10003ea6:	601a      	str	r2, [r3, #0]
        xSchedulerRunning = pdTRUE;
10003ea8:	4b0d      	ldr	r3, [pc, #52]	; (10003ee0 <vTaskStartScheduler+0x78>)
10003eaa:	2201      	movs	r2, #1
10003eac:	601a      	str	r2, [r3, #0]
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
10003eae:	4b0d      	ldr	r3, [pc, #52]	; (10003ee4 <vTaskStartScheduler+0x7c>)
10003eb0:	2200      	movs	r2, #0
10003eb2:	601a      	str	r2, [r3, #0]

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        if( xPortStartScheduler() != pdFALSE )
10003eb4:	f7fe fec4 	bl	10002c40 <xPortStartScheduler>
10003eb8:	e004      	b.n	10003ec4 <vTaskStartScheduler+0x5c>
    else
    {
        /* This line will only be reached if the kernel could not be started,
         * because there was not enough FreeRTOS heap to create the idle task
         * or the timer task. */
        configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
10003eba:	687b      	ldr	r3, [r7, #4]
10003ebc:	3301      	adds	r3, #1
10003ebe:	d101      	bne.n	10003ec4 <vTaskStartScheduler+0x5c>
10003ec0:	b672      	cpsid	i
10003ec2:	e7fe      	b.n	10003ec2 <vTaskStartScheduler+0x5a>
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
10003ec4:	4b08      	ldr	r3, [pc, #32]	; (10003ee8 <vTaskStartScheduler+0x80>)
10003ec6:	681b      	ldr	r3, [r3, #0]
}
10003ec8:	46bd      	mov	sp, r7
10003eca:	b002      	add	sp, #8
10003ecc:	bd80      	pop	{r7, pc}
10003ece:	46c0      	nop			; (mov r8, r8)
10003ed0:	10004475 	.word	0x10004475
10003ed4:	1000a60c 	.word	0x1000a60c
10003ed8:	200007d4 	.word	0x200007d4
10003edc:	200007d0 	.word	0x200007d0
10003ee0:	200007bc 	.word	0x200007bc
10003ee4:	200007b4 	.word	0x200007b4
10003ee8:	200005f8 	.word	0x200005f8

10003eec <vTaskSuspendAll>:
    vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
10003eec:	b580      	push	{r7, lr}
10003eee:	af00      	add	r7, sp, #0
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
10003ef0:	4b03      	ldr	r3, [pc, #12]	; (10003f00 <vTaskSuspendAll+0x14>)
10003ef2:	681b      	ldr	r3, [r3, #0]
10003ef4:	1c5a      	adds	r2, r3, #1
10003ef6:	4b02      	ldr	r3, [pc, #8]	; (10003f00 <vTaskSuspendAll+0x14>)
10003ef8:	601a      	str	r2, [r3, #0]

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
10003efa:	46bd      	mov	sp, r7
10003efc:	bd80      	pop	{r7, pc}
10003efe:	46c0      	nop			; (mov r8, r8)
10003f00:	200007d8 	.word	0x200007d8

10003f04 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
10003f04:	b580      	push	{r7, lr}
10003f06:	b084      	sub	sp, #16
10003f08:	af00      	add	r7, sp, #0
    TCB_t * pxTCB = NULL;
10003f0a:	2300      	movs	r3, #0
10003f0c:	60fb      	str	r3, [r7, #12]
    BaseType_t xAlreadyYielded = pdFALSE;
10003f0e:	2300      	movs	r3, #0
10003f10:	60bb      	str	r3, [r7, #8]

    /* If uxSchedulerSuspended is zero then this function does not match a
     * previous call to vTaskSuspendAll(). */
    configASSERT( uxSchedulerSuspended );
10003f12:	4b3a      	ldr	r3, [pc, #232]	; (10003ffc <xTaskResumeAll+0xf8>)
10003f14:	681b      	ldr	r3, [r3, #0]
10003f16:	2b00      	cmp	r3, #0
10003f18:	d101      	bne.n	10003f1e <xTaskResumeAll+0x1a>
10003f1a:	b672      	cpsid	i
10003f1c:	e7fe      	b.n	10003f1c <xTaskResumeAll+0x18>
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
10003f1e:	f7fe fec1 	bl	10002ca4 <vPortEnterCritical>
    {
        --uxSchedulerSuspended;
10003f22:	4b36      	ldr	r3, [pc, #216]	; (10003ffc <xTaskResumeAll+0xf8>)
10003f24:	681b      	ldr	r3, [r3, #0]
10003f26:	1e5a      	subs	r2, r3, #1
10003f28:	4b34      	ldr	r3, [pc, #208]	; (10003ffc <xTaskResumeAll+0xf8>)
10003f2a:	601a      	str	r2, [r3, #0]

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
10003f2c:	4b33      	ldr	r3, [pc, #204]	; (10003ffc <xTaskResumeAll+0xf8>)
10003f2e:	681b      	ldr	r3, [r3, #0]
10003f30:	2b00      	cmp	r3, #0
10003f32:	d15b      	bne.n	10003fec <xTaskResumeAll+0xe8>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
10003f34:	4b32      	ldr	r3, [pc, #200]	; (10004000 <xTaskResumeAll+0xfc>)
10003f36:	681b      	ldr	r3, [r3, #0]
10003f38:	2b00      	cmp	r3, #0
10003f3a:	d057      	beq.n	10003fec <xTaskResumeAll+0xe8>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
10003f3c:	e02f      	b.n	10003f9e <xTaskResumeAll+0x9a>
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
10003f3e:	4b31      	ldr	r3, [pc, #196]	; (10004004 <xTaskResumeAll+0x100>)
10003f40:	68db      	ldr	r3, [r3, #12]
10003f42:	68db      	ldr	r3, [r3, #12]
10003f44:	60fb      	str	r3, [r7, #12]
                    ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
10003f46:	68fb      	ldr	r3, [r7, #12]
10003f48:	3318      	adds	r3, #24
10003f4a:	1c18      	adds	r0, r3, #0
10003f4c:	f7fe ffe6 	bl	10002f1c <uxListRemove>
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
10003f50:	68fb      	ldr	r3, [r7, #12]
10003f52:	3304      	adds	r3, #4
10003f54:	1c18      	adds	r0, r3, #0
10003f56:	f7fe ffe1 	bl	10002f1c <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
10003f5a:	68fb      	ldr	r3, [r7, #12]
10003f5c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10003f5e:	4b2a      	ldr	r3, [pc, #168]	; (10004008 <xTaskResumeAll+0x104>)
10003f60:	681b      	ldr	r3, [r3, #0]
10003f62:	429a      	cmp	r2, r3
10003f64:	d903      	bls.n	10003f6e <xTaskResumeAll+0x6a>
10003f66:	68fb      	ldr	r3, [r7, #12]
10003f68:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10003f6a:	4b27      	ldr	r3, [pc, #156]	; (10004008 <xTaskResumeAll+0x104>)
10003f6c:	601a      	str	r2, [r3, #0]
10003f6e:	68fb      	ldr	r3, [r7, #12]
10003f70:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10003f72:	1c13      	adds	r3, r2, #0
10003f74:	009b      	lsls	r3, r3, #2
10003f76:	189b      	adds	r3, r3, r2
10003f78:	009b      	lsls	r3, r3, #2
10003f7a:	4a24      	ldr	r2, [pc, #144]	; (1000400c <xTaskResumeAll+0x108>)
10003f7c:	189a      	adds	r2, r3, r2
10003f7e:	68fb      	ldr	r3, [r7, #12]
10003f80:	3304      	adds	r3, #4
10003f82:	1c10      	adds	r0, r2, #0
10003f84:	1c19      	adds	r1, r3, #0
10003f86:	f7fe ff71 	bl	10002e6c <vListInsertEnd>

                    /* If the moved task has a priority higher than the current
                     * task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
10003f8a:	68fb      	ldr	r3, [r7, #12]
10003f8c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10003f8e:	4b20      	ldr	r3, [pc, #128]	; (10004010 <xTaskResumeAll+0x10c>)
10003f90:	681b      	ldr	r3, [r3, #0]
10003f92:	6adb      	ldr	r3, [r3, #44]	; 0x2c
10003f94:	429a      	cmp	r2, r3
10003f96:	d302      	bcc.n	10003f9e <xTaskResumeAll+0x9a>
                    {
                        xYieldPending = pdTRUE;
10003f98:	4b1e      	ldr	r3, [pc, #120]	; (10004014 <xTaskResumeAll+0x110>)
10003f9a:	2201      	movs	r2, #1
10003f9c:	601a      	str	r2, [r3, #0]
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
10003f9e:	4b19      	ldr	r3, [pc, #100]	; (10004004 <xTaskResumeAll+0x100>)
10003fa0:	681b      	ldr	r3, [r3, #0]
10003fa2:	2b00      	cmp	r3, #0
10003fa4:	d1cb      	bne.n	10003f3e <xTaskResumeAll+0x3a>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
10003fa6:	68fb      	ldr	r3, [r7, #12]
10003fa8:	2b00      	cmp	r3, #0
10003faa:	d001      	beq.n	10003fb0 <xTaskResumeAll+0xac>
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
10003fac:	f000 faf2 	bl	10004594 <prvResetNextTaskUnblockTime>
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
10003fb0:	4b19      	ldr	r3, [pc, #100]	; (10004018 <xTaskResumeAll+0x114>)
10003fb2:	681b      	ldr	r3, [r3, #0]
10003fb4:	607b      	str	r3, [r7, #4]

                    if( xPendedCounts > ( TickType_t ) 0U )
10003fb6:	687b      	ldr	r3, [r7, #4]
10003fb8:	2b00      	cmp	r3, #0
10003fba:	d00f      	beq.n	10003fdc <xTaskResumeAll+0xd8>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
10003fbc:	f000 f83c 	bl	10004038 <xTaskIncrementTick>
10003fc0:	1e03      	subs	r3, r0, #0
10003fc2:	d002      	beq.n	10003fca <xTaskResumeAll+0xc6>
                            {
                                xYieldPending = pdTRUE;
10003fc4:	4b13      	ldr	r3, [pc, #76]	; (10004014 <xTaskResumeAll+0x110>)
10003fc6:	2201      	movs	r2, #1
10003fc8:	601a      	str	r2, [r3, #0]
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
10003fca:	687b      	ldr	r3, [r7, #4]
10003fcc:	3b01      	subs	r3, #1
10003fce:	607b      	str	r3, [r7, #4]
                        } while( xPendedCounts > ( TickType_t ) 0U );
10003fd0:	687b      	ldr	r3, [r7, #4]
10003fd2:	2b00      	cmp	r3, #0
10003fd4:	d1f2      	bne.n	10003fbc <xTaskResumeAll+0xb8>

                        xPendedTicks = 0;
10003fd6:	4b10      	ldr	r3, [pc, #64]	; (10004018 <xTaskResumeAll+0x114>)
10003fd8:	2200      	movs	r2, #0
10003fda:	601a      	str	r2, [r3, #0]
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
10003fdc:	4b0d      	ldr	r3, [pc, #52]	; (10004014 <xTaskResumeAll+0x110>)
10003fde:	681b      	ldr	r3, [r3, #0]
10003fe0:	2b00      	cmp	r3, #0
10003fe2:	d003      	beq.n	10003fec <xTaskResumeAll+0xe8>
                {
                    #if ( configUSE_PREEMPTION != 0 )
                        {
                            xAlreadyYielded = pdTRUE;
10003fe4:	2301      	movs	r3, #1
10003fe6:	60bb      	str	r3, [r7, #8]
                        }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
10003fe8:	f7fe fe4e 	bl	10002c88 <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
10003fec:	f7fe fe6a 	bl	10002cc4 <vPortExitCritical>

    return xAlreadyYielded;
10003ff0:	68bb      	ldr	r3, [r7, #8]
}
10003ff2:	1c18      	adds	r0, r3, #0
10003ff4:	46bd      	mov	sp, r7
10003ff6:	b004      	add	sp, #16
10003ff8:	bd80      	pop	{r7, pc}
10003ffa:	46c0      	nop			; (mov r8, r8)
10003ffc:	200007d8 	.word	0x200007d8
10004000:	200007b0 	.word	0x200007b0
10004004:	20000770 	.word	0x20000770
10004008:	200007b8 	.word	0x200007b8
1000400c:	200006dc 	.word	0x200006dc
10004010:	200006d8 	.word	0x200006d8
10004014:	200007c4 	.word	0x200007c4
10004018:	200007c0 	.word	0x200007c0

1000401c <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
1000401c:	b580      	push	{r7, lr}
1000401e:	b082      	sub	sp, #8
10004020:	af00      	add	r7, sp, #0
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    {
        xTicks = xTickCount;
10004022:	4b04      	ldr	r3, [pc, #16]	; (10004034 <xTaskGetTickCount+0x18>)
10004024:	681b      	ldr	r3, [r3, #0]
10004026:	607b      	str	r3, [r7, #4]
    }
    portTICK_TYPE_EXIT_CRITICAL();

    return xTicks;
10004028:	687b      	ldr	r3, [r7, #4]
}
1000402a:	1c18      	adds	r0, r3, #0
1000402c:	46bd      	mov	sp, r7
1000402e:	b002      	add	sp, #8
10004030:	bd80      	pop	{r7, pc}
10004032:	46c0      	nop			; (mov r8, r8)
10004034:	200007b4 	.word	0x200007b4

10004038 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
10004038:	b580      	push	{r7, lr}
1000403a:	b086      	sub	sp, #24
1000403c:	af00      	add	r7, sp, #0
    TCB_t * pxTCB;
    TickType_t xItemValue;
    BaseType_t xSwitchRequired = pdFALSE;
1000403e:	2300      	movs	r3, #0
10004040:	617b      	str	r3, [r7, #20]
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
10004042:	4b4a      	ldr	r3, [pc, #296]	; (1000416c <xTaskIncrementTick+0x134>)
10004044:	681b      	ldr	r3, [r3, #0]
10004046:	2b00      	cmp	r3, #0
10004048:	d000      	beq.n	1000404c <xTaskIncrementTick+0x14>
1000404a:	e084      	b.n	10004156 <xTaskIncrementTick+0x11e>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
1000404c:	4b48      	ldr	r3, [pc, #288]	; (10004170 <xTaskIncrementTick+0x138>)
1000404e:	681b      	ldr	r3, [r3, #0]
10004050:	3301      	adds	r3, #1
10004052:	613b      	str	r3, [r7, #16]

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
10004054:	4b46      	ldr	r3, [pc, #280]	; (10004170 <xTaskIncrementTick+0x138>)
10004056:	693a      	ldr	r2, [r7, #16]
10004058:	601a      	str	r2, [r3, #0]

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
1000405a:	693b      	ldr	r3, [r7, #16]
1000405c:	2b00      	cmp	r3, #0
1000405e:	d117      	bne.n	10004090 <xTaskIncrementTick+0x58>
        {
            taskSWITCH_DELAYED_LISTS();
10004060:	4b44      	ldr	r3, [pc, #272]	; (10004174 <xTaskIncrementTick+0x13c>)
10004062:	681b      	ldr	r3, [r3, #0]
10004064:	681b      	ldr	r3, [r3, #0]
10004066:	2b00      	cmp	r3, #0
10004068:	d001      	beq.n	1000406e <xTaskIncrementTick+0x36>
1000406a:	b672      	cpsid	i
1000406c:	e7fe      	b.n	1000406c <xTaskIncrementTick+0x34>
1000406e:	4b41      	ldr	r3, [pc, #260]	; (10004174 <xTaskIncrementTick+0x13c>)
10004070:	681b      	ldr	r3, [r3, #0]
10004072:	60fb      	str	r3, [r7, #12]
10004074:	4b40      	ldr	r3, [pc, #256]	; (10004178 <xTaskIncrementTick+0x140>)
10004076:	681a      	ldr	r2, [r3, #0]
10004078:	4b3e      	ldr	r3, [pc, #248]	; (10004174 <xTaskIncrementTick+0x13c>)
1000407a:	601a      	str	r2, [r3, #0]
1000407c:	4b3e      	ldr	r3, [pc, #248]	; (10004178 <xTaskIncrementTick+0x140>)
1000407e:	68fa      	ldr	r2, [r7, #12]
10004080:	601a      	str	r2, [r3, #0]
10004082:	4b3e      	ldr	r3, [pc, #248]	; (1000417c <xTaskIncrementTick+0x144>)
10004084:	681b      	ldr	r3, [r3, #0]
10004086:	1c5a      	adds	r2, r3, #1
10004088:	4b3c      	ldr	r3, [pc, #240]	; (1000417c <xTaskIncrementTick+0x144>)
1000408a:	601a      	str	r2, [r3, #0]
1000408c:	f000 fa82 	bl	10004594 <prvResetNextTaskUnblockTime>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
10004090:	4b3b      	ldr	r3, [pc, #236]	; (10004180 <xTaskIncrementTick+0x148>)
10004092:	681b      	ldr	r3, [r3, #0]
10004094:	693a      	ldr	r2, [r7, #16]
10004096:	429a      	cmp	r2, r3
10004098:	d349      	bcc.n	1000412e <xTaskIncrementTick+0xf6>
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
1000409a:	4b36      	ldr	r3, [pc, #216]	; (10004174 <xTaskIncrementTick+0x13c>)
1000409c:	681b      	ldr	r3, [r3, #0]
1000409e:	681b      	ldr	r3, [r3, #0]
100040a0:	2b00      	cmp	r3, #0
100040a2:	d104      	bne.n	100040ae <xTaskIncrementTick+0x76>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
100040a4:	4b36      	ldr	r3, [pc, #216]	; (10004180 <xTaskIncrementTick+0x148>)
100040a6:	2201      	movs	r2, #1
100040a8:	4252      	negs	r2, r2
100040aa:	601a      	str	r2, [r3, #0]
                    break;
100040ac:	e03f      	b.n	1000412e <xTaskIncrementTick+0xf6>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
100040ae:	4b31      	ldr	r3, [pc, #196]	; (10004174 <xTaskIncrementTick+0x13c>)
100040b0:	681b      	ldr	r3, [r3, #0]
100040b2:	68db      	ldr	r3, [r3, #12]
100040b4:	68db      	ldr	r3, [r3, #12]
100040b6:	60bb      	str	r3, [r7, #8]
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
100040b8:	68bb      	ldr	r3, [r7, #8]
100040ba:	685b      	ldr	r3, [r3, #4]
100040bc:	607b      	str	r3, [r7, #4]

                    if( xConstTickCount < xItemValue )
100040be:	693a      	ldr	r2, [r7, #16]
100040c0:	687b      	ldr	r3, [r7, #4]
100040c2:	429a      	cmp	r2, r3
100040c4:	d203      	bcs.n	100040ce <xTaskIncrementTick+0x96>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
100040c6:	4b2e      	ldr	r3, [pc, #184]	; (10004180 <xTaskIncrementTick+0x148>)
100040c8:	687a      	ldr	r2, [r7, #4]
100040ca:	601a      	str	r2, [r3, #0]
                        break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
100040cc:	e02f      	b.n	1000412e <xTaskIncrementTick+0xf6>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
100040ce:	68bb      	ldr	r3, [r7, #8]
100040d0:	3304      	adds	r3, #4
100040d2:	1c18      	adds	r0, r3, #0
100040d4:	f7fe ff22 	bl	10002f1c <uxListRemove>

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
100040d8:	68bb      	ldr	r3, [r7, #8]
100040da:	6a9b      	ldr	r3, [r3, #40]	; 0x28
100040dc:	2b00      	cmp	r3, #0
100040de:	d004      	beq.n	100040ea <xTaskIncrementTick+0xb2>
                    {
                        ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
100040e0:	68bb      	ldr	r3, [r7, #8]
100040e2:	3318      	adds	r3, #24
100040e4:	1c18      	adds	r0, r3, #0
100040e6:	f7fe ff19 	bl	10002f1c <uxListRemove>
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
100040ea:	68bb      	ldr	r3, [r7, #8]
100040ec:	6ada      	ldr	r2, [r3, #44]	; 0x2c
100040ee:	4b25      	ldr	r3, [pc, #148]	; (10004184 <xTaskIncrementTick+0x14c>)
100040f0:	681b      	ldr	r3, [r3, #0]
100040f2:	429a      	cmp	r2, r3
100040f4:	d903      	bls.n	100040fe <xTaskIncrementTick+0xc6>
100040f6:	68bb      	ldr	r3, [r7, #8]
100040f8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
100040fa:	4b22      	ldr	r3, [pc, #136]	; (10004184 <xTaskIncrementTick+0x14c>)
100040fc:	601a      	str	r2, [r3, #0]
100040fe:	68bb      	ldr	r3, [r7, #8]
10004100:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10004102:	1c13      	adds	r3, r2, #0
10004104:	009b      	lsls	r3, r3, #2
10004106:	189b      	adds	r3, r3, r2
10004108:	009b      	lsls	r3, r3, #2
1000410a:	4a1f      	ldr	r2, [pc, #124]	; (10004188 <xTaskIncrementTick+0x150>)
1000410c:	189a      	adds	r2, r3, r2
1000410e:	68bb      	ldr	r3, [r7, #8]
10004110:	3304      	adds	r3, #4
10004112:	1c10      	adds	r0, r2, #0
10004114:	1c19      	adds	r1, r3, #0
10004116:	f7fe fea9 	bl	10002e6c <vListInsertEnd>
                        {
                            /* Preemption is on, but a context switch should
                             * only be performed if the unblocked task has a
                             * priority that is equal to or higher than the
                             * currently executing task. */
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1000411a:	68bb      	ldr	r3, [r7, #8]
1000411c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
1000411e:	4b1b      	ldr	r3, [pc, #108]	; (1000418c <xTaskIncrementTick+0x154>)
10004120:	681b      	ldr	r3, [r3, #0]
10004122:	6adb      	ldr	r3, [r3, #44]	; 0x2c
10004124:	429a      	cmp	r2, r3
10004126:	d301      	bcc.n	1000412c <xTaskIncrementTick+0xf4>
                            {
                                xSwitchRequired = pdTRUE;
10004128:	2301      	movs	r3, #1
1000412a:	617b      	str	r3, [r7, #20]
                                mtCOVERAGE_TEST_MARKER();
                            }
                        }
                    #endif /* configUSE_PREEMPTION */
                }
            }
1000412c:	e7b5      	b.n	1000409a <xTaskIncrementTick+0x62>
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
            {
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
1000412e:	4b17      	ldr	r3, [pc, #92]	; (1000418c <xTaskIncrementTick+0x154>)
10004130:	681b      	ldr	r3, [r3, #0]
10004132:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10004134:	4914      	ldr	r1, [pc, #80]	; (10004188 <xTaskIncrementTick+0x150>)
10004136:	1c13      	adds	r3, r2, #0
10004138:	009b      	lsls	r3, r3, #2
1000413a:	189b      	adds	r3, r3, r2
1000413c:	009b      	lsls	r3, r3, #2
1000413e:	585b      	ldr	r3, [r3, r1]
10004140:	2b01      	cmp	r3, #1
10004142:	d901      	bls.n	10004148 <xTaskIncrementTick+0x110>
                {
                    xSwitchRequired = pdTRUE;
10004144:	2301      	movs	r3, #1
10004146:	617b      	str	r3, [r7, #20]
            }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
            {
                if( xYieldPending != pdFALSE )
10004148:	4b11      	ldr	r3, [pc, #68]	; (10004190 <xTaskIncrementTick+0x158>)
1000414a:	681b      	ldr	r3, [r3, #0]
1000414c:	2b00      	cmp	r3, #0
1000414e:	d001      	beq.n	10004154 <xTaskIncrementTick+0x11c>
                {
                    xSwitchRequired = pdTRUE;
10004150:	2301      	movs	r3, #1
10004152:	617b      	str	r3, [r7, #20]
10004154:	e004      	b.n	10004160 <xTaskIncrementTick+0x128>
            }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
10004156:	4b0f      	ldr	r3, [pc, #60]	; (10004194 <xTaskIncrementTick+0x15c>)
10004158:	681b      	ldr	r3, [r3, #0]
1000415a:	1c5a      	adds	r2, r3, #1
1000415c:	4b0d      	ldr	r3, [pc, #52]	; (10004194 <xTaskIncrementTick+0x15c>)
1000415e:	601a      	str	r2, [r3, #0]
                vApplicationTickHook();
            }
        #endif
    }

    return xSwitchRequired;
10004160:	697b      	ldr	r3, [r7, #20]
}
10004162:	1c18      	adds	r0, r3, #0
10004164:	46bd      	mov	sp, r7
10004166:	b006      	add	sp, #24
10004168:	bd80      	pop	{r7, pc}
1000416a:	46c0      	nop			; (mov r8, r8)
1000416c:	200007d8 	.word	0x200007d8
10004170:	200007b4 	.word	0x200007b4
10004174:	20000768 	.word	0x20000768
10004178:	2000076c 	.word	0x2000076c
1000417c:	200007c8 	.word	0x200007c8
10004180:	200007d0 	.word	0x200007d0
10004184:	200007b8 	.word	0x200007b8
10004188:	200006dc 	.word	0x200006dc
1000418c:	200006d8 	.word	0x200006d8
10004190:	200007c4 	.word	0x200007c4
10004194:	200007c0 	.word	0x200007c0

10004198 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
10004198:	b580      	push	{r7, lr}
1000419a:	b082      	sub	sp, #8
1000419c:	af00      	add	r7, sp, #0
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
1000419e:	4b21      	ldr	r3, [pc, #132]	; (10004224 <vTaskSwitchContext+0x8c>)
100041a0:	681b      	ldr	r3, [r3, #0]
100041a2:	2b00      	cmp	r3, #0
100041a4:	d003      	beq.n	100041ae <vTaskSwitchContext+0x16>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
100041a6:	4b20      	ldr	r3, [pc, #128]	; (10004228 <vTaskSwitchContext+0x90>)
100041a8:	2201      	movs	r2, #1
100041aa:	601a      	str	r2, [r3, #0]
100041ac:	e037      	b.n	1000421e <vTaskSwitchContext+0x86>
    }
    else
    {
        xYieldPending = pdFALSE;
100041ae:	4b1e      	ldr	r3, [pc, #120]	; (10004228 <vTaskSwitchContext+0x90>)
100041b0:	2200      	movs	r2, #0
100041b2:	601a      	str	r2, [r3, #0]
            }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
100041b4:	4b1d      	ldr	r3, [pc, #116]	; (1000422c <vTaskSwitchContext+0x94>)
100041b6:	681b      	ldr	r3, [r3, #0]
100041b8:	607b      	str	r3, [r7, #4]
100041ba:	e007      	b.n	100041cc <vTaskSwitchContext+0x34>
100041bc:	687b      	ldr	r3, [r7, #4]
100041be:	2b00      	cmp	r3, #0
100041c0:	d101      	bne.n	100041c6 <vTaskSwitchContext+0x2e>
100041c2:	b672      	cpsid	i
100041c4:	e7fe      	b.n	100041c4 <vTaskSwitchContext+0x2c>
100041c6:	687b      	ldr	r3, [r7, #4]
100041c8:	3b01      	subs	r3, #1
100041ca:	607b      	str	r3, [r7, #4]
100041cc:	4918      	ldr	r1, [pc, #96]	; (10004230 <vTaskSwitchContext+0x98>)
100041ce:	687a      	ldr	r2, [r7, #4]
100041d0:	1c13      	adds	r3, r2, #0
100041d2:	009b      	lsls	r3, r3, #2
100041d4:	189b      	adds	r3, r3, r2
100041d6:	009b      	lsls	r3, r3, #2
100041d8:	585b      	ldr	r3, [r3, r1]
100041da:	2b00      	cmp	r3, #0
100041dc:	d0ee      	beq.n	100041bc <vTaskSwitchContext+0x24>
100041de:	687a      	ldr	r2, [r7, #4]
100041e0:	1c13      	adds	r3, r2, #0
100041e2:	009b      	lsls	r3, r3, #2
100041e4:	189b      	adds	r3, r3, r2
100041e6:	009b      	lsls	r3, r3, #2
100041e8:	4a11      	ldr	r2, [pc, #68]	; (10004230 <vTaskSwitchContext+0x98>)
100041ea:	189b      	adds	r3, r3, r2
100041ec:	603b      	str	r3, [r7, #0]
100041ee:	683b      	ldr	r3, [r7, #0]
100041f0:	685b      	ldr	r3, [r3, #4]
100041f2:	685a      	ldr	r2, [r3, #4]
100041f4:	683b      	ldr	r3, [r7, #0]
100041f6:	605a      	str	r2, [r3, #4]
100041f8:	683b      	ldr	r3, [r7, #0]
100041fa:	685a      	ldr	r2, [r3, #4]
100041fc:	683b      	ldr	r3, [r7, #0]
100041fe:	3308      	adds	r3, #8
10004200:	429a      	cmp	r2, r3
10004202:	d104      	bne.n	1000420e <vTaskSwitchContext+0x76>
10004204:	683b      	ldr	r3, [r7, #0]
10004206:	685b      	ldr	r3, [r3, #4]
10004208:	685a      	ldr	r2, [r3, #4]
1000420a:	683b      	ldr	r3, [r7, #0]
1000420c:	605a      	str	r2, [r3, #4]
1000420e:	683b      	ldr	r3, [r7, #0]
10004210:	685b      	ldr	r3, [r3, #4]
10004212:	68da      	ldr	r2, [r3, #12]
10004214:	4b07      	ldr	r3, [pc, #28]	; (10004234 <vTaskSwitchContext+0x9c>)
10004216:	601a      	str	r2, [r3, #0]
10004218:	4b04      	ldr	r3, [pc, #16]	; (1000422c <vTaskSwitchContext+0x94>)
1000421a:	687a      	ldr	r2, [r7, #4]
1000421c:	601a      	str	r2, [r3, #0]
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */
    }
}
1000421e:	46bd      	mov	sp, r7
10004220:	b002      	add	sp, #8
10004222:	bd80      	pop	{r7, pc}
10004224:	200007d8 	.word	0x200007d8
10004228:	200007c4 	.word	0x200007c4
1000422c:	200007b8 	.word	0x200007b8
10004230:	200006dc 	.word	0x200006dc
10004234:	200006d8 	.word	0x200006d8

10004238 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
10004238:	b580      	push	{r7, lr}
1000423a:	b082      	sub	sp, #8
1000423c:	af00      	add	r7, sp, #0
1000423e:	6078      	str	r0, [r7, #4]
10004240:	6039      	str	r1, [r7, #0]
    configASSERT( pxEventList );
10004242:	687b      	ldr	r3, [r7, #4]
10004244:	2b00      	cmp	r3, #0
10004246:	d101      	bne.n	1000424c <vTaskPlaceOnEventList+0x14>
10004248:	b672      	cpsid	i
1000424a:	e7fe      	b.n	1000424a <vTaskPlaceOnEventList+0x12>

    /* Place the event list item of the TCB in the appropriate event list.
     * This is placed in the list in priority order so the highest priority task
     * is the first to be woken by the event.  The queue that contains the event
     * list is locked, preventing simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
1000424c:	4b07      	ldr	r3, [pc, #28]	; (1000426c <vTaskPlaceOnEventList+0x34>)
1000424e:	681b      	ldr	r3, [r3, #0]
10004250:	3318      	adds	r3, #24
10004252:	687a      	ldr	r2, [r7, #4]
10004254:	1c10      	adds	r0, r2, #0
10004256:	1c19      	adds	r1, r3, #0
10004258:	f7fe fe2a 	bl	10002eb0 <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
1000425c:	683b      	ldr	r3, [r7, #0]
1000425e:	1c18      	adds	r0, r3, #0
10004260:	2101      	movs	r1, #1
10004262:	f000 fb0f 	bl	10004884 <prvAddCurrentTaskToDelayedList>
}
10004266:	46bd      	mov	sp, r7
10004268:	b002      	add	sp, #8
1000426a:	bd80      	pop	{r7, pc}
1000426c:	200006d8 	.word	0x200006d8

10004270 <vTaskPlaceOnEventListRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vTaskPlaceOnEventListRestricted( List_t * const pxEventList,
                                          TickType_t xTicksToWait,
                                          const BaseType_t xWaitIndefinitely )
    {
10004270:	b580      	push	{r7, lr}
10004272:	b084      	sub	sp, #16
10004274:	af00      	add	r7, sp, #0
10004276:	60f8      	str	r0, [r7, #12]
10004278:	60b9      	str	r1, [r7, #8]
1000427a:	607a      	str	r2, [r7, #4]
        configASSERT( pxEventList );
1000427c:	68fb      	ldr	r3, [r7, #12]
1000427e:	2b00      	cmp	r3, #0
10004280:	d101      	bne.n	10004286 <vTaskPlaceOnEventListRestricted+0x16>
10004282:	b672      	cpsid	i
10004284:	e7fe      	b.n	10004284 <vTaskPlaceOnEventListRestricted+0x14>

        /* Place the event list item of the TCB in the appropriate event list.
         * In this case it is assume that this is the only task that is going to
         * be waiting on this event list, so the faster vListInsertEnd() function
         * can be used in place of vListInsert. */
        vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
10004286:	4b0b      	ldr	r3, [pc, #44]	; (100042b4 <vTaskPlaceOnEventListRestricted+0x44>)
10004288:	681b      	ldr	r3, [r3, #0]
1000428a:	3318      	adds	r3, #24
1000428c:	68fa      	ldr	r2, [r7, #12]
1000428e:	1c10      	adds	r0, r2, #0
10004290:	1c19      	adds	r1, r3, #0
10004292:	f7fe fdeb 	bl	10002e6c <vListInsertEnd>

        /* If the task should block indefinitely then set the block time to a
         * value that will be recognised as an indefinite delay inside the
         * prvAddCurrentTaskToDelayedList() function. */
        if( xWaitIndefinitely != pdFALSE )
10004296:	687b      	ldr	r3, [r7, #4]
10004298:	2b00      	cmp	r3, #0
1000429a:	d002      	beq.n	100042a2 <vTaskPlaceOnEventListRestricted+0x32>
        {
            xTicksToWait = portMAX_DELAY;
1000429c:	2301      	movs	r3, #1
1000429e:	425b      	negs	r3, r3
100042a0:	60bb      	str	r3, [r7, #8]
        }

        traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
        prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
100042a2:	68ba      	ldr	r2, [r7, #8]
100042a4:	687b      	ldr	r3, [r7, #4]
100042a6:	1c10      	adds	r0, r2, #0
100042a8:	1c19      	adds	r1, r3, #0
100042aa:	f000 faeb 	bl	10004884 <prvAddCurrentTaskToDelayedList>
    }
100042ae:	46bd      	mov	sp, r7
100042b0:	b004      	add	sp, #16
100042b2:	bd80      	pop	{r7, pc}
100042b4:	200006d8 	.word	0x200006d8

100042b8 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
100042b8:	b580      	push	{r7, lr}
100042ba:	b084      	sub	sp, #16
100042bc:	af00      	add	r7, sp, #0
100042be:	6078      	str	r0, [r7, #4]
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
100042c0:	687b      	ldr	r3, [r7, #4]
100042c2:	68db      	ldr	r3, [r3, #12]
100042c4:	68db      	ldr	r3, [r3, #12]
100042c6:	60bb      	str	r3, [r7, #8]
    configASSERT( pxUnblockedTCB );
100042c8:	68bb      	ldr	r3, [r7, #8]
100042ca:	2b00      	cmp	r3, #0
100042cc:	d101      	bne.n	100042d2 <xTaskRemoveFromEventList+0x1a>
100042ce:	b672      	cpsid	i
100042d0:	e7fe      	b.n	100042d0 <xTaskRemoveFromEventList+0x18>
    ( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
100042d2:	68bb      	ldr	r3, [r7, #8]
100042d4:	3318      	adds	r3, #24
100042d6:	1c18      	adds	r0, r3, #0
100042d8:	f7fe fe20 	bl	10002f1c <uxListRemove>

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
100042dc:	4b1e      	ldr	r3, [pc, #120]	; (10004358 <xTaskRemoveFromEventList+0xa0>)
100042de:	681b      	ldr	r3, [r3, #0]
100042e0:	2b00      	cmp	r3, #0
100042e2:	d11d      	bne.n	10004320 <xTaskRemoveFromEventList+0x68>
    {
        ( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
100042e4:	68bb      	ldr	r3, [r7, #8]
100042e6:	3304      	adds	r3, #4
100042e8:	1c18      	adds	r0, r3, #0
100042ea:	f7fe fe17 	bl	10002f1c <uxListRemove>
        prvAddTaskToReadyList( pxUnblockedTCB );
100042ee:	68bb      	ldr	r3, [r7, #8]
100042f0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
100042f2:	4b1a      	ldr	r3, [pc, #104]	; (1000435c <xTaskRemoveFromEventList+0xa4>)
100042f4:	681b      	ldr	r3, [r3, #0]
100042f6:	429a      	cmp	r2, r3
100042f8:	d903      	bls.n	10004302 <xTaskRemoveFromEventList+0x4a>
100042fa:	68bb      	ldr	r3, [r7, #8]
100042fc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
100042fe:	4b17      	ldr	r3, [pc, #92]	; (1000435c <xTaskRemoveFromEventList+0xa4>)
10004300:	601a      	str	r2, [r3, #0]
10004302:	68bb      	ldr	r3, [r7, #8]
10004304:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10004306:	1c13      	adds	r3, r2, #0
10004308:	009b      	lsls	r3, r3, #2
1000430a:	189b      	adds	r3, r3, r2
1000430c:	009b      	lsls	r3, r3, #2
1000430e:	4a14      	ldr	r2, [pc, #80]	; (10004360 <xTaskRemoveFromEventList+0xa8>)
10004310:	189a      	adds	r2, r3, r2
10004312:	68bb      	ldr	r3, [r7, #8]
10004314:	3304      	adds	r3, #4
10004316:	1c10      	adds	r0, r2, #0
10004318:	1c19      	adds	r1, r3, #0
1000431a:	f7fe fda7 	bl	10002e6c <vListInsertEnd>
1000431e:	e006      	b.n	1000432e <xTaskRemoveFromEventList+0x76>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
10004320:	68bb      	ldr	r3, [r7, #8]
10004322:	3318      	adds	r3, #24
10004324:	4a0f      	ldr	r2, [pc, #60]	; (10004364 <xTaskRemoveFromEventList+0xac>)
10004326:	1c10      	adds	r0, r2, #0
10004328:	1c19      	adds	r1, r3, #0
1000432a:	f7fe fd9f 	bl	10002e6c <vListInsertEnd>
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
1000432e:	68bb      	ldr	r3, [r7, #8]
10004330:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10004332:	4b0d      	ldr	r3, [pc, #52]	; (10004368 <xTaskRemoveFromEventList+0xb0>)
10004334:	681b      	ldr	r3, [r3, #0]
10004336:	6adb      	ldr	r3, [r3, #44]	; 0x2c
10004338:	429a      	cmp	r2, r3
1000433a:	d905      	bls.n	10004348 <xTaskRemoveFromEventList+0x90>
    {
        /* Return true if the task removed from the event list has a higher
         * priority than the calling task.  This allows the calling task to know if
         * it should force a context switch now. */
        xReturn = pdTRUE;
1000433c:	2301      	movs	r3, #1
1000433e:	60fb      	str	r3, [r7, #12]

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
10004340:	4b0a      	ldr	r3, [pc, #40]	; (1000436c <xTaskRemoveFromEventList+0xb4>)
10004342:	2201      	movs	r2, #1
10004344:	601a      	str	r2, [r3, #0]
10004346:	e001      	b.n	1000434c <xTaskRemoveFromEventList+0x94>
    }
    else
    {
        xReturn = pdFALSE;
10004348:	2300      	movs	r3, #0
1000434a:	60fb      	str	r3, [r7, #12]
    }

    return xReturn;
1000434c:	68fb      	ldr	r3, [r7, #12]
}
1000434e:	1c18      	adds	r0, r3, #0
10004350:	46bd      	mov	sp, r7
10004352:	b004      	add	sp, #16
10004354:	bd80      	pop	{r7, pc}
10004356:	46c0      	nop			; (mov r8, r8)
10004358:	200007d8 	.word	0x200007d8
1000435c:	200007b8 	.word	0x200007b8
10004360:	200006dc 	.word	0x200006dc
10004364:	20000770 	.word	0x20000770
10004368:	200006d8 	.word	0x200006d8
1000436c:	200007c4 	.word	0x200007c4

10004370 <vTaskInternalSetTimeOutState>:
    taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
10004370:	b580      	push	{r7, lr}
10004372:	b082      	sub	sp, #8
10004374:	af00      	add	r7, sp, #0
10004376:	6078      	str	r0, [r7, #4]
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
10004378:	4b05      	ldr	r3, [pc, #20]	; (10004390 <vTaskInternalSetTimeOutState+0x20>)
1000437a:	681a      	ldr	r2, [r3, #0]
1000437c:	687b      	ldr	r3, [r7, #4]
1000437e:	601a      	str	r2, [r3, #0]
    pxTimeOut->xTimeOnEntering = xTickCount;
10004380:	4b04      	ldr	r3, [pc, #16]	; (10004394 <vTaskInternalSetTimeOutState+0x24>)
10004382:	681a      	ldr	r2, [r3, #0]
10004384:	687b      	ldr	r3, [r7, #4]
10004386:	605a      	str	r2, [r3, #4]
}
10004388:	46bd      	mov	sp, r7
1000438a:	b002      	add	sp, #8
1000438c:	bd80      	pop	{r7, pc}
1000438e:	46c0      	nop			; (mov r8, r8)
10004390:	200007c8 	.word	0x200007c8
10004394:	200007b4 	.word	0x200007b4

10004398 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
10004398:	b580      	push	{r7, lr}
1000439a:	b086      	sub	sp, #24
1000439c:	af00      	add	r7, sp, #0
1000439e:	6078      	str	r0, [r7, #4]
100043a0:	6039      	str	r1, [r7, #0]
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
100043a2:	687b      	ldr	r3, [r7, #4]
100043a4:	2b00      	cmp	r3, #0
100043a6:	d101      	bne.n	100043ac <xTaskCheckForTimeOut+0x14>
100043a8:	b672      	cpsid	i
100043aa:	e7fe      	b.n	100043aa <xTaskCheckForTimeOut+0x12>
    configASSERT( pxTicksToWait );
100043ac:	683b      	ldr	r3, [r7, #0]
100043ae:	2b00      	cmp	r3, #0
100043b0:	d101      	bne.n	100043b6 <xTaskCheckForTimeOut+0x1e>
100043b2:	b672      	cpsid	i
100043b4:	e7fe      	b.n	100043b4 <xTaskCheckForTimeOut+0x1c>

    taskENTER_CRITICAL();
100043b6:	f7fe fc75 	bl	10002ca4 <vPortEnterCritical>
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
100043ba:	4b26      	ldr	r3, [pc, #152]	; (10004454 <xTaskCheckForTimeOut+0xbc>)
100043bc:	681b      	ldr	r3, [r3, #0]
100043be:	613b      	str	r3, [r7, #16]
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
100043c0:	687b      	ldr	r3, [r7, #4]
100043c2:	685b      	ldr	r3, [r3, #4]
100043c4:	693a      	ldr	r2, [r7, #16]
100043c6:	1ad3      	subs	r3, r2, r3
100043c8:	60fb      	str	r3, [r7, #12]

        #if ( INCLUDE_xTaskAbortDelay == 1 )
            if( pxCurrentTCB->ucDelayAborted != ( uint8_t ) pdFALSE )
100043ca:	4b23      	ldr	r3, [pc, #140]	; (10004458 <xTaskCheckForTimeOut+0xc0>)
100043cc:	681b      	ldr	r3, [r3, #0]
100043ce:	226d      	movs	r2, #109	; 0x6d
100043d0:	5c9b      	ldrb	r3, [r3, r2]
100043d2:	2b00      	cmp	r3, #0
100043d4:	d007      	beq.n	100043e6 <xTaskCheckForTimeOut+0x4e>
            {
                /* The delay was aborted, which is not the same as a time out,
                 * but has the same result. */
                pxCurrentTCB->ucDelayAborted = pdFALSE;
100043d6:	4b20      	ldr	r3, [pc, #128]	; (10004458 <xTaskCheckForTimeOut+0xc0>)
100043d8:	681b      	ldr	r3, [r3, #0]
100043da:	226d      	movs	r2, #109	; 0x6d
100043dc:	2100      	movs	r1, #0
100043de:	5499      	strb	r1, [r3, r2]
                xReturn = pdTRUE;
100043e0:	2301      	movs	r3, #1
100043e2:	617b      	str	r3, [r7, #20]
100043e4:	e02e      	b.n	10004444 <xTaskCheckForTimeOut+0xac>
            }
            else
        #endif

        #if ( INCLUDE_vTaskSuspend == 1 )
            if( *pxTicksToWait == portMAX_DELAY )
100043e6:	683b      	ldr	r3, [r7, #0]
100043e8:	681b      	ldr	r3, [r3, #0]
100043ea:	3301      	adds	r3, #1
100043ec:	d102      	bne.n	100043f4 <xTaskCheckForTimeOut+0x5c>
            {
                /* If INCLUDE_vTaskSuspend is set to 1 and the block time
                 * specified is the maximum block time then the task should block
                 * indefinitely, and therefore never time out. */
                xReturn = pdFALSE;
100043ee:	2300      	movs	r3, #0
100043f0:	617b      	str	r3, [r7, #20]
100043f2:	e027      	b.n	10004444 <xTaskCheckForTimeOut+0xac>
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
100043f4:	687b      	ldr	r3, [r7, #4]
100043f6:	681a      	ldr	r2, [r3, #0]
100043f8:	4b18      	ldr	r3, [pc, #96]	; (1000445c <xTaskCheckForTimeOut+0xc4>)
100043fa:	681b      	ldr	r3, [r3, #0]
100043fc:	429a      	cmp	r2, r3
100043fe:	d00a      	beq.n	10004416 <xTaskCheckForTimeOut+0x7e>
10004400:	687b      	ldr	r3, [r7, #4]
10004402:	685a      	ldr	r2, [r3, #4]
10004404:	693b      	ldr	r3, [r7, #16]
10004406:	429a      	cmp	r2, r3
10004408:	d805      	bhi.n	10004416 <xTaskCheckForTimeOut+0x7e>
            /* The tick count is greater than the time at which
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
1000440a:	2301      	movs	r3, #1
1000440c:	617b      	str	r3, [r7, #20]
            *pxTicksToWait = ( TickType_t ) 0;
1000440e:	683b      	ldr	r3, [r7, #0]
10004410:	2200      	movs	r2, #0
10004412:	601a      	str	r2, [r3, #0]
10004414:	e016      	b.n	10004444 <xTaskCheckForTimeOut+0xac>
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
10004416:	683b      	ldr	r3, [r7, #0]
10004418:	681a      	ldr	r2, [r3, #0]
1000441a:	68fb      	ldr	r3, [r7, #12]
1000441c:	429a      	cmp	r2, r3
1000441e:	d90c      	bls.n	1000443a <xTaskCheckForTimeOut+0xa2>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
10004420:	683b      	ldr	r3, [r7, #0]
10004422:	681a      	ldr	r2, [r3, #0]
10004424:	68fb      	ldr	r3, [r7, #12]
10004426:	1ad2      	subs	r2, r2, r3
10004428:	683b      	ldr	r3, [r7, #0]
1000442a:	601a      	str	r2, [r3, #0]
            vTaskInternalSetTimeOutState( pxTimeOut );
1000442c:	687b      	ldr	r3, [r7, #4]
1000442e:	1c18      	adds	r0, r3, #0
10004430:	f7ff ff9e 	bl	10004370 <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
10004434:	2300      	movs	r3, #0
10004436:	617b      	str	r3, [r7, #20]
10004438:	e004      	b.n	10004444 <xTaskCheckForTimeOut+0xac>
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
1000443a:	683b      	ldr	r3, [r7, #0]
1000443c:	2200      	movs	r2, #0
1000443e:	601a      	str	r2, [r3, #0]
            xReturn = pdTRUE;
10004440:	2301      	movs	r3, #1
10004442:	617b      	str	r3, [r7, #20]
        }
    }
    taskEXIT_CRITICAL();
10004444:	f7fe fc3e 	bl	10002cc4 <vPortExitCritical>

    return xReturn;
10004448:	697b      	ldr	r3, [r7, #20]
}
1000444a:	1c18      	adds	r0, r3, #0
1000444c:	46bd      	mov	sp, r7
1000444e:	b006      	add	sp, #24
10004450:	bd80      	pop	{r7, pc}
10004452:	46c0      	nop			; (mov r8, r8)
10004454:	200007b4 	.word	0x200007b4
10004458:	200006d8 	.word	0x200006d8
1000445c:	200007c8 	.word	0x200007c8

10004460 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
10004460:	b580      	push	{r7, lr}
10004462:	af00      	add	r7, sp, #0
    xYieldPending = pdTRUE;
10004464:	4b02      	ldr	r3, [pc, #8]	; (10004470 <vTaskMissedYield+0x10>)
10004466:	2201      	movs	r2, #1
10004468:	601a      	str	r2, [r3, #0]
}
1000446a:	46bd      	mov	sp, r7
1000446c:	bd80      	pop	{r7, pc}
1000446e:	46c0      	nop			; (mov r8, r8)
10004470:	200007c4 	.word	0x200007c4

10004474 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
10004474:	b580      	push	{r7, lr}
10004476:	b082      	sub	sp, #8
10004478:	af00      	add	r7, sp, #0
1000447a:	6078      	str	r0, [r7, #4]

    for( ; ; )
    {
        /* See if any tasks have deleted themselves - if so then the idle task
         * is responsible for freeing the deleted task's TCB and stack. */
        prvCheckTasksWaitingTermination();
1000447c:	f000 f84e 	bl	1000451c <prvCheckTasksWaitingTermination>
                 *
                 * A critical region is not required here as we are just reading from
                 * the list, and an occasional incorrect value will not matter.  If
                 * the ready list at the idle priority contains more than one task
                 * then a task other than the idle task is ready to execute. */
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
10004480:	4b03      	ldr	r3, [pc, #12]	; (10004490 <prvIdleTask+0x1c>)
10004482:	681b      	ldr	r3, [r3, #0]
10004484:	2b01      	cmp	r3, #1
10004486:	d901      	bls.n	1000448c <prvIdleTask+0x18>
                {
                    taskYIELD();
10004488:	f7fe fbfe 	bl	10002c88 <vPortYield>
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configUSE_TICKLESS_IDLE */
    }
1000448c:	e7f6      	b.n	1000447c <prvIdleTask+0x8>
1000448e:	46c0      	nop			; (mov r8, r8)
10004490:	200006dc 	.word	0x200006dc

10004494 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
10004494:	b580      	push	{r7, lr}
10004496:	b082      	sub	sp, #8
10004498:	af00      	add	r7, sp, #0
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
1000449a:	2300      	movs	r3, #0
1000449c:	607b      	str	r3, [r7, #4]
1000449e:	e00c      	b.n	100044ba <prvInitialiseTaskLists+0x26>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
100044a0:	687a      	ldr	r2, [r7, #4]
100044a2:	1c13      	adds	r3, r2, #0
100044a4:	009b      	lsls	r3, r3, #2
100044a6:	189b      	adds	r3, r3, r2
100044a8:	009b      	lsls	r3, r3, #2
100044aa:	4a14      	ldr	r2, [pc, #80]	; (100044fc <prvInitialiseTaskLists+0x68>)
100044ac:	189b      	adds	r3, r3, r2
100044ae:	1c18      	adds	r0, r3, #0
100044b0:	f7fe fcb4 	bl	10002e1c <vListInitialise>

static void prvInitialiseTaskLists( void )
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
100044b4:	687b      	ldr	r3, [r7, #4]
100044b6:	3301      	adds	r3, #1
100044b8:	607b      	str	r3, [r7, #4]
100044ba:	687b      	ldr	r3, [r7, #4]
100044bc:	2b04      	cmp	r3, #4
100044be:	d9ef      	bls.n	100044a0 <prvInitialiseTaskLists+0xc>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    }

    vListInitialise( &xDelayedTaskList1 );
100044c0:	4b0f      	ldr	r3, [pc, #60]	; (10004500 <prvInitialiseTaskLists+0x6c>)
100044c2:	1c18      	adds	r0, r3, #0
100044c4:	f7fe fcaa 	bl	10002e1c <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
100044c8:	4b0e      	ldr	r3, [pc, #56]	; (10004504 <prvInitialiseTaskLists+0x70>)
100044ca:	1c18      	adds	r0, r3, #0
100044cc:	f7fe fca6 	bl	10002e1c <vListInitialise>
    vListInitialise( &xPendingReadyList );
100044d0:	4b0d      	ldr	r3, [pc, #52]	; (10004508 <prvInitialiseTaskLists+0x74>)
100044d2:	1c18      	adds	r0, r3, #0
100044d4:	f7fe fca2 	bl	10002e1c <vListInitialise>

    #if ( INCLUDE_vTaskDelete == 1 )
        {
            vListInitialise( &xTasksWaitingTermination );
100044d8:	4b0c      	ldr	r3, [pc, #48]	; (1000450c <prvInitialiseTaskLists+0x78>)
100044da:	1c18      	adds	r0, r3, #0
100044dc:	f7fe fc9e 	bl	10002e1c <vListInitialise>
        }
    #endif /* INCLUDE_vTaskDelete */

    #if ( INCLUDE_vTaskSuspend == 1 )
        {
            vListInitialise( &xSuspendedTaskList );
100044e0:	4b0b      	ldr	r3, [pc, #44]	; (10004510 <prvInitialiseTaskLists+0x7c>)
100044e2:	1c18      	adds	r0, r3, #0
100044e4:	f7fe fc9a 	bl	10002e1c <vListInitialise>
        }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
100044e8:	4b0a      	ldr	r3, [pc, #40]	; (10004514 <prvInitialiseTaskLists+0x80>)
100044ea:	4a05      	ldr	r2, [pc, #20]	; (10004500 <prvInitialiseTaskLists+0x6c>)
100044ec:	601a      	str	r2, [r3, #0]
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
100044ee:	4b0a      	ldr	r3, [pc, #40]	; (10004518 <prvInitialiseTaskLists+0x84>)
100044f0:	4a04      	ldr	r2, [pc, #16]	; (10004504 <prvInitialiseTaskLists+0x70>)
100044f2:	601a      	str	r2, [r3, #0]
}
100044f4:	46bd      	mov	sp, r7
100044f6:	b002      	add	sp, #8
100044f8:	bd80      	pop	{r7, pc}
100044fa:	46c0      	nop			; (mov r8, r8)
100044fc:	200006dc 	.word	0x200006dc
10004500:	20000740 	.word	0x20000740
10004504:	20000754 	.word	0x20000754
10004508:	20000770 	.word	0x20000770
1000450c:	20000784 	.word	0x20000784
10004510:	2000079c 	.word	0x2000079c
10004514:	20000768 	.word	0x20000768
10004518:	2000076c 	.word	0x2000076c

1000451c <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
1000451c:	b580      	push	{r7, lr}
1000451e:	b082      	sub	sp, #8
10004520:	af00      	add	r7, sp, #0
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
10004522:	e01a      	b.n	1000455a <prvCheckTasksWaitingTermination+0x3e>
            {
                taskENTER_CRITICAL();
10004524:	f7fe fbbe 	bl	10002ca4 <vPortEnterCritical>
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
10004528:	4b0f      	ldr	r3, [pc, #60]	; (10004568 <prvCheckTasksWaitingTermination+0x4c>)
1000452a:	68db      	ldr	r3, [r3, #12]
1000452c:	68db      	ldr	r3, [r3, #12]
1000452e:	607b      	str	r3, [r7, #4]
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
10004530:	687b      	ldr	r3, [r7, #4]
10004532:	3304      	adds	r3, #4
10004534:	1c18      	adds	r0, r3, #0
10004536:	f7fe fcf1 	bl	10002f1c <uxListRemove>
                    --uxCurrentNumberOfTasks;
1000453a:	4b0c      	ldr	r3, [pc, #48]	; (1000456c <prvCheckTasksWaitingTermination+0x50>)
1000453c:	681b      	ldr	r3, [r3, #0]
1000453e:	1e5a      	subs	r2, r3, #1
10004540:	4b0a      	ldr	r3, [pc, #40]	; (1000456c <prvCheckTasksWaitingTermination+0x50>)
10004542:	601a      	str	r2, [r3, #0]
                    --uxDeletedTasksWaitingCleanUp;
10004544:	4b0a      	ldr	r3, [pc, #40]	; (10004570 <prvCheckTasksWaitingTermination+0x54>)
10004546:	681b      	ldr	r3, [r3, #0]
10004548:	1e5a      	subs	r2, r3, #1
1000454a:	4b09      	ldr	r3, [pc, #36]	; (10004570 <prvCheckTasksWaitingTermination+0x54>)
1000454c:	601a      	str	r2, [r3, #0]
                }
                taskEXIT_CRITICAL();
1000454e:	f7fe fbb9 	bl	10002cc4 <vPortExitCritical>

                prvDeleteTCB( pxTCB );
10004552:	687b      	ldr	r3, [r7, #4]
10004554:	1c18      	adds	r0, r3, #0
10004556:	f000 f80d 	bl	10004574 <prvDeleteTCB>
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
1000455a:	4b05      	ldr	r3, [pc, #20]	; (10004570 <prvCheckTasksWaitingTermination+0x54>)
1000455c:	681b      	ldr	r3, [r3, #0]
1000455e:	2b00      	cmp	r3, #0
10004560:	d1e0      	bne.n	10004524 <prvCheckTasksWaitingTermination+0x8>

                prvDeleteTCB( pxTCB );
            }
        }
    #endif /* INCLUDE_vTaskDelete */
}
10004562:	46bd      	mov	sp, r7
10004564:	b002      	add	sp, #8
10004566:	bd80      	pop	{r7, pc}
10004568:	20000784 	.word	0x20000784
1000456c:	200007b0 	.word	0x200007b0
10004570:	20000798 	.word	0x20000798

10004574 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    static void prvDeleteTCB( TCB_t * pxTCB )
    {
10004574:	b580      	push	{r7, lr}
10004576:	b082      	sub	sp, #8
10004578:	af00      	add	r7, sp, #0
1000457a:	6078      	str	r0, [r7, #4]

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
            {
                /* The task can only have been allocated dynamically - free both
                 * the stack and TCB. */
                vPortFree( pxTCB->pxStack );
1000457c:	687b      	ldr	r3, [r7, #4]
1000457e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
10004580:	1c18      	adds	r0, r3, #0
10004582:	f7fe fc39 	bl	10002df8 <vPortFree>
                vPortFree( pxTCB );
10004586:	687b      	ldr	r3, [r7, #4]
10004588:	1c18      	adds	r0, r3, #0
1000458a:	f7fe fc35 	bl	10002df8 <vPortFree>
                    configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
1000458e:	46bd      	mov	sp, r7
10004590:	b002      	add	sp, #8
10004592:	bd80      	pop	{r7, pc}

10004594 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
10004594:	b580      	push	{r7, lr}
10004596:	af00      	add	r7, sp, #0
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
10004598:	4b08      	ldr	r3, [pc, #32]	; (100045bc <prvResetNextTaskUnblockTime+0x28>)
1000459a:	681b      	ldr	r3, [r3, #0]
1000459c:	681b      	ldr	r3, [r3, #0]
1000459e:	2b00      	cmp	r3, #0
100045a0:	d104      	bne.n	100045ac <prvResetNextTaskUnblockTime+0x18>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
100045a2:	4b07      	ldr	r3, [pc, #28]	; (100045c0 <prvResetNextTaskUnblockTime+0x2c>)
100045a4:	2201      	movs	r2, #1
100045a6:	4252      	negs	r2, r2
100045a8:	601a      	str	r2, [r3, #0]
100045aa:	e005      	b.n	100045b8 <prvResetNextTaskUnblockTime+0x24>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
100045ac:	4b03      	ldr	r3, [pc, #12]	; (100045bc <prvResetNextTaskUnblockTime+0x28>)
100045ae:	681b      	ldr	r3, [r3, #0]
100045b0:	68db      	ldr	r3, [r3, #12]
100045b2:	681a      	ldr	r2, [r3, #0]
100045b4:	4b02      	ldr	r3, [pc, #8]	; (100045c0 <prvResetNextTaskUnblockTime+0x2c>)
100045b6:	601a      	str	r2, [r3, #0]
    }
}
100045b8:	46bd      	mov	sp, r7
100045ba:	bd80      	pop	{r7, pc}
100045bc:	20000768 	.word	0x20000768
100045c0:	200007d0 	.word	0x200007d0

100045c4 <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

    BaseType_t xTaskGetSchedulerState( void )
    {
100045c4:	b580      	push	{r7, lr}
100045c6:	b082      	sub	sp, #8
100045c8:	af00      	add	r7, sp, #0
        BaseType_t xReturn;

        if( xSchedulerRunning == pdFALSE )
100045ca:	4b0a      	ldr	r3, [pc, #40]	; (100045f4 <xTaskGetSchedulerState+0x30>)
100045cc:	681b      	ldr	r3, [r3, #0]
100045ce:	2b00      	cmp	r3, #0
100045d0:	d102      	bne.n	100045d8 <xTaskGetSchedulerState+0x14>
        {
            xReturn = taskSCHEDULER_NOT_STARTED;
100045d2:	2301      	movs	r3, #1
100045d4:	607b      	str	r3, [r7, #4]
100045d6:	e008      	b.n	100045ea <xTaskGetSchedulerState+0x26>
        }
        else
        {
            if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
100045d8:	4b07      	ldr	r3, [pc, #28]	; (100045f8 <xTaskGetSchedulerState+0x34>)
100045da:	681b      	ldr	r3, [r3, #0]
100045dc:	2b00      	cmp	r3, #0
100045de:	d102      	bne.n	100045e6 <xTaskGetSchedulerState+0x22>
            {
                xReturn = taskSCHEDULER_RUNNING;
100045e0:	2302      	movs	r3, #2
100045e2:	607b      	str	r3, [r7, #4]
100045e4:	e001      	b.n	100045ea <xTaskGetSchedulerState+0x26>
            }
            else
            {
                xReturn = taskSCHEDULER_SUSPENDED;
100045e6:	2300      	movs	r3, #0
100045e8:	607b      	str	r3, [r7, #4]
            }
        }

        return xReturn;
100045ea:	687b      	ldr	r3, [r7, #4]
    }
100045ec:	1c18      	adds	r0, r3, #0
100045ee:	46bd      	mov	sp, r7
100045f0:	b002      	add	sp, #8
100045f2:	bd80      	pop	{r7, pc}
100045f4:	200007bc 	.word	0x200007bc
100045f8:	200007d8 	.word	0x200007d8

100045fc <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
    {
100045fc:	b580      	push	{r7, lr}
100045fe:	b084      	sub	sp, #16
10004600:	af00      	add	r7, sp, #0
10004602:	6078      	str	r0, [r7, #4]
        TCB_t * const pxMutexHolderTCB = pxMutexHolder;
10004604:	687b      	ldr	r3, [r7, #4]
10004606:	60bb      	str	r3, [r7, #8]
        BaseType_t xReturn = pdFALSE;
10004608:	2300      	movs	r3, #0
1000460a:	60fb      	str	r3, [r7, #12]

        /* If the mutex was given back by an interrupt while the queue was
         * locked then the mutex holder might now be NULL.  _RB_ Is this still
         * needed as interrupts can no longer use mutexes? */
        if( pxMutexHolder != NULL )
1000460c:	687b      	ldr	r3, [r7, #4]
1000460e:	2b00      	cmp	r3, #0
10004610:	d051      	beq.n	100046b6 <xTaskPriorityInherit+0xba>
        {
            /* If the holder of the mutex has a priority below the priority of
             * the task attempting to obtain the mutex then it will temporarily
             * inherit the priority of the task attempting to obtain the mutex. */
            if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
10004612:	68bb      	ldr	r3, [r7, #8]
10004614:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10004616:	4b2a      	ldr	r3, [pc, #168]	; (100046c0 <xTaskPriorityInherit+0xc4>)
10004618:	681b      	ldr	r3, [r3, #0]
1000461a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
1000461c:	429a      	cmp	r2, r3
1000461e:	d241      	bcs.n	100046a4 <xTaskPriorityInherit+0xa8>
            {
                /* Adjust the mutex holder state to account for its new
                 * priority.  Only reset the event list item value if the value is
                 * not being used for anything else. */
                if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
10004620:	68bb      	ldr	r3, [r7, #8]
10004622:	699b      	ldr	r3, [r3, #24]
10004624:	2b00      	cmp	r3, #0
10004626:	db06      	blt.n	10004636 <xTaskPriorityInherit+0x3a>
                {
                    listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
10004628:	4b25      	ldr	r3, [pc, #148]	; (100046c0 <xTaskPriorityInherit+0xc4>)
1000462a:	681b      	ldr	r3, [r3, #0]
1000462c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
1000462e:	2205      	movs	r2, #5
10004630:	1ad2      	subs	r2, r2, r3
10004632:	68bb      	ldr	r3, [r7, #8]
10004634:	619a      	str	r2, [r3, #24]
                    mtCOVERAGE_TEST_MARKER();
                }

                /* If the task being modified is in the ready state it will need
                 * to be moved into a new list. */
                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
10004636:	68bb      	ldr	r3, [r7, #8]
10004638:	6959      	ldr	r1, [r3, #20]
1000463a:	68bb      	ldr	r3, [r7, #8]
1000463c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
1000463e:	1c13      	adds	r3, r2, #0
10004640:	009b      	lsls	r3, r3, #2
10004642:	189b      	adds	r3, r3, r2
10004644:	009b      	lsls	r3, r3, #2
10004646:	4a1f      	ldr	r2, [pc, #124]	; (100046c4 <xTaskPriorityInherit+0xc8>)
10004648:	189b      	adds	r3, r3, r2
1000464a:	4299      	cmp	r1, r3
1000464c:	d122      	bne.n	10004694 <xTaskPriorityInherit+0x98>
                {
                    if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
1000464e:	68bb      	ldr	r3, [r7, #8]
10004650:	3304      	adds	r3, #4
10004652:	1c18      	adds	r0, r3, #0
10004654:	f7fe fc62 	bl	10002f1c <uxListRemove>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Inherit the priority before being moved into the new list. */
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
10004658:	4b19      	ldr	r3, [pc, #100]	; (100046c0 <xTaskPriorityInherit+0xc4>)
1000465a:	681b      	ldr	r3, [r3, #0]
1000465c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
1000465e:	68bb      	ldr	r3, [r7, #8]
10004660:	62da      	str	r2, [r3, #44]	; 0x2c
                    prvAddTaskToReadyList( pxMutexHolderTCB );
10004662:	68bb      	ldr	r3, [r7, #8]
10004664:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10004666:	4b18      	ldr	r3, [pc, #96]	; (100046c8 <xTaskPriorityInherit+0xcc>)
10004668:	681b      	ldr	r3, [r3, #0]
1000466a:	429a      	cmp	r2, r3
1000466c:	d903      	bls.n	10004676 <xTaskPriorityInherit+0x7a>
1000466e:	68bb      	ldr	r3, [r7, #8]
10004670:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10004672:	4b15      	ldr	r3, [pc, #84]	; (100046c8 <xTaskPriorityInherit+0xcc>)
10004674:	601a      	str	r2, [r3, #0]
10004676:	68bb      	ldr	r3, [r7, #8]
10004678:	6ada      	ldr	r2, [r3, #44]	; 0x2c
1000467a:	1c13      	adds	r3, r2, #0
1000467c:	009b      	lsls	r3, r3, #2
1000467e:	189b      	adds	r3, r3, r2
10004680:	009b      	lsls	r3, r3, #2
10004682:	4a10      	ldr	r2, [pc, #64]	; (100046c4 <xTaskPriorityInherit+0xc8>)
10004684:	189a      	adds	r2, r3, r2
10004686:	68bb      	ldr	r3, [r7, #8]
10004688:	3304      	adds	r3, #4
1000468a:	1c10      	adds	r0, r2, #0
1000468c:	1c19      	adds	r1, r3, #0
1000468e:	f7fe fbed 	bl	10002e6c <vListInsertEnd>
10004692:	e004      	b.n	1000469e <xTaskPriorityInherit+0xa2>
                }
                else
                {
                    /* Just inherit the priority. */
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
10004694:	4b0a      	ldr	r3, [pc, #40]	; (100046c0 <xTaskPriorityInherit+0xc4>)
10004696:	681b      	ldr	r3, [r3, #0]
10004698:	6ada      	ldr	r2, [r3, #44]	; 0x2c
1000469a:	68bb      	ldr	r3, [r7, #8]
1000469c:	62da      	str	r2, [r3, #44]	; 0x2c
                }

                traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

                /* Inheritance occurred. */
                xReturn = pdTRUE;
1000469e:	2301      	movs	r3, #1
100046a0:	60fb      	str	r3, [r7, #12]
100046a2:	e008      	b.n	100046b6 <xTaskPriorityInherit+0xba>
            }
            else
            {
                if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
100046a4:	68bb      	ldr	r3, [r7, #8]
100046a6:	6cda      	ldr	r2, [r3, #76]	; 0x4c
100046a8:	4b05      	ldr	r3, [pc, #20]	; (100046c0 <xTaskPriorityInherit+0xc4>)
100046aa:	681b      	ldr	r3, [r3, #0]
100046ac:	6adb      	ldr	r3, [r3, #44]	; 0x2c
100046ae:	429a      	cmp	r2, r3
100046b0:	d201      	bcs.n	100046b6 <xTaskPriorityInherit+0xba>
                     * current priority of the mutex holder is not lower than the
                     * priority of the task attempting to take the mutex.
                     * Therefore the mutex holder must have already inherited a
                     * priority, but inheritance would have occurred if that had
                     * not been the case. */
                    xReturn = pdTRUE;
100046b2:	2301      	movs	r3, #1
100046b4:	60fb      	str	r3, [r7, #12]
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
100046b6:	68fb      	ldr	r3, [r7, #12]
    }
100046b8:	1c18      	adds	r0, r3, #0
100046ba:	46bd      	mov	sp, r7
100046bc:	b004      	add	sp, #16
100046be:	bd80      	pop	{r7, pc}
100046c0:	200006d8 	.word	0x200006d8
100046c4:	200006dc 	.word	0x200006dc
100046c8:	200007b8 	.word	0x200007b8

100046cc <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
100046cc:	b580      	push	{r7, lr}
100046ce:	b084      	sub	sp, #16
100046d0:	af00      	add	r7, sp, #0
100046d2:	6078      	str	r0, [r7, #4]
        TCB_t * const pxTCB = pxMutexHolder;
100046d4:	687b      	ldr	r3, [r7, #4]
100046d6:	60bb      	str	r3, [r7, #8]
        BaseType_t xReturn = pdFALSE;
100046d8:	2300      	movs	r3, #0
100046da:	60fb      	str	r3, [r7, #12]

        if( pxMutexHolder != NULL )
100046dc:	687b      	ldr	r3, [r7, #4]
100046de:	2b00      	cmp	r3, #0
100046e0:	d044      	beq.n	1000476c <xTaskPriorityDisinherit+0xa0>
        {
            /* A task can only have an inherited priority if it holds the mutex.
             * If the mutex is held by a task then it cannot be given from an
             * interrupt, and if a mutex is given by the holding task then it must
             * be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
100046e2:	4b25      	ldr	r3, [pc, #148]	; (10004778 <xTaskPriorityDisinherit+0xac>)
100046e4:	681b      	ldr	r3, [r3, #0]
100046e6:	68ba      	ldr	r2, [r7, #8]
100046e8:	429a      	cmp	r2, r3
100046ea:	d001      	beq.n	100046f0 <xTaskPriorityDisinherit+0x24>
100046ec:	b672      	cpsid	i
100046ee:	e7fe      	b.n	100046ee <xTaskPriorityDisinherit+0x22>
            configASSERT( pxTCB->uxMutexesHeld );
100046f0:	68bb      	ldr	r3, [r7, #8]
100046f2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
100046f4:	2b00      	cmp	r3, #0
100046f6:	d101      	bne.n	100046fc <xTaskPriorityDisinherit+0x30>
100046f8:	b672      	cpsid	i
100046fa:	e7fe      	b.n	100046fa <xTaskPriorityDisinherit+0x2e>
            ( pxTCB->uxMutexesHeld )--;
100046fc:	68bb      	ldr	r3, [r7, #8]
100046fe:	6d1b      	ldr	r3, [r3, #80]	; 0x50
10004700:	1e5a      	subs	r2, r3, #1
10004702:	68bb      	ldr	r3, [r7, #8]
10004704:	651a      	str	r2, [r3, #80]	; 0x50

            /* Has the holder of the mutex inherited the priority of another
             * task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
10004706:	68bb      	ldr	r3, [r7, #8]
10004708:	6ada      	ldr	r2, [r3, #44]	; 0x2c
1000470a:	68bb      	ldr	r3, [r7, #8]
1000470c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
1000470e:	429a      	cmp	r2, r3
10004710:	d02c      	beq.n	1000476c <xTaskPriorityDisinherit+0xa0>
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
10004712:	68bb      	ldr	r3, [r7, #8]
10004714:	6d1b      	ldr	r3, [r3, #80]	; 0x50
10004716:	2b00      	cmp	r3, #0
10004718:	d128      	bne.n	1000476c <xTaskPriorityDisinherit+0xa0>
                    /* A task can only have an inherited priority if it holds
                     * the mutex.  If the mutex is held by a task then it cannot be
                     * given from an interrupt, and if a mutex is given by the
                     * holding task then it must be the running state task.  Remove
                     * the holding task from the ready list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
1000471a:	68bb      	ldr	r3, [r7, #8]
1000471c:	3304      	adds	r3, #4
1000471e:	1c18      	adds	r0, r3, #0
10004720:	f7fe fbfc 	bl	10002f1c <uxListRemove>
                    }

                    /* Disinherit the priority before adding the task into the
                     * new  ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
10004724:	68bb      	ldr	r3, [r7, #8]
10004726:	6cda      	ldr	r2, [r3, #76]	; 0x4c
10004728:	68bb      	ldr	r3, [r7, #8]
1000472a:	62da      	str	r2, [r3, #44]	; 0x2c

                    /* Reset the event list item value.  It cannot be in use for
                     * any other purpose if this task is running, and it must be
                     * running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
1000472c:	68bb      	ldr	r3, [r7, #8]
1000472e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
10004730:	2205      	movs	r2, #5
10004732:	1ad2      	subs	r2, r2, r3
10004734:	68bb      	ldr	r3, [r7, #8]
10004736:	619a      	str	r2, [r3, #24]
                    prvAddTaskToReadyList( pxTCB );
10004738:	68bb      	ldr	r3, [r7, #8]
1000473a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
1000473c:	4b0f      	ldr	r3, [pc, #60]	; (1000477c <xTaskPriorityDisinherit+0xb0>)
1000473e:	681b      	ldr	r3, [r3, #0]
10004740:	429a      	cmp	r2, r3
10004742:	d903      	bls.n	1000474c <xTaskPriorityDisinherit+0x80>
10004744:	68bb      	ldr	r3, [r7, #8]
10004746:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10004748:	4b0c      	ldr	r3, [pc, #48]	; (1000477c <xTaskPriorityDisinherit+0xb0>)
1000474a:	601a      	str	r2, [r3, #0]
1000474c:	68bb      	ldr	r3, [r7, #8]
1000474e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10004750:	1c13      	adds	r3, r2, #0
10004752:	009b      	lsls	r3, r3, #2
10004754:	189b      	adds	r3, r3, r2
10004756:	009b      	lsls	r3, r3, #2
10004758:	4a09      	ldr	r2, [pc, #36]	; (10004780 <xTaskPriorityDisinherit+0xb4>)
1000475a:	189a      	adds	r2, r3, r2
1000475c:	68bb      	ldr	r3, [r7, #8]
1000475e:	3304      	adds	r3, #4
10004760:	1c10      	adds	r0, r2, #0
10004762:	1c19      	adds	r1, r3, #0
10004764:	f7fe fb82 	bl	10002e6c <vListInsertEnd>
                     * in an order different to that in which they were taken.
                     * If a context switch did not occur when the first mutex was
                     * returned, even if a task was waiting on it, then a context
                     * switch should occur when the last mutex is returned whether
                     * a task is waiting on it or not. */
                    xReturn = pdTRUE;
10004768:	2301      	movs	r3, #1
1000476a:	60fb      	str	r3, [r7, #12]
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
1000476c:	68fb      	ldr	r3, [r7, #12]
    }
1000476e:	1c18      	adds	r0, r3, #0
10004770:	46bd      	mov	sp, r7
10004772:	b004      	add	sp, #16
10004774:	bd80      	pop	{r7, pc}
10004776:	46c0      	nop			; (mov r8, r8)
10004778:	200006d8 	.word	0x200006d8
1000477c:	200007b8 	.word	0x200007b8
10004780:	200006dc 	.word	0x200006dc

10004784 <vTaskPriorityDisinheritAfterTimeout>:

#if ( configUSE_MUTEXES == 1 )

    void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder,
                                              UBaseType_t uxHighestPriorityWaitingTask )
    {
10004784:	b580      	push	{r7, lr}
10004786:	b086      	sub	sp, #24
10004788:	af00      	add	r7, sp, #0
1000478a:	6078      	str	r0, [r7, #4]
1000478c:	6039      	str	r1, [r7, #0]
        TCB_t * const pxTCB = pxMutexHolder;
1000478e:	687b      	ldr	r3, [r7, #4]
10004790:	613b      	str	r3, [r7, #16]
        UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
        const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
10004792:	2301      	movs	r3, #1
10004794:	60fb      	str	r3, [r7, #12]

        if( pxMutexHolder != NULL )
10004796:	687b      	ldr	r3, [r7, #4]
10004798:	2b00      	cmp	r3, #0
1000479a:	d058      	beq.n	1000484e <vTaskPriorityDisinheritAfterTimeout+0xca>
        {
            /* If pxMutexHolder is not NULL then the holder must hold at least
             * one mutex. */
            configASSERT( pxTCB->uxMutexesHeld );
1000479c:	693b      	ldr	r3, [r7, #16]
1000479e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
100047a0:	2b00      	cmp	r3, #0
100047a2:	d101      	bne.n	100047a8 <vTaskPriorityDisinheritAfterTimeout+0x24>
100047a4:	b672      	cpsid	i
100047a6:	e7fe      	b.n	100047a6 <vTaskPriorityDisinheritAfterTimeout+0x22>

            /* Determine the priority to which the priority of the task that
             * holds the mutex should be set.  This will be the greater of the
             * holding task's base priority and the priority of the highest
             * priority task that is waiting to obtain the mutex. */
            if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
100047a8:	693b      	ldr	r3, [r7, #16]
100047aa:	6cda      	ldr	r2, [r3, #76]	; 0x4c
100047ac:	683b      	ldr	r3, [r7, #0]
100047ae:	429a      	cmp	r2, r3
100047b0:	d202      	bcs.n	100047b8 <vTaskPriorityDisinheritAfterTimeout+0x34>
            {
                uxPriorityToUse = uxHighestPriorityWaitingTask;
100047b2:	683b      	ldr	r3, [r7, #0]
100047b4:	617b      	str	r3, [r7, #20]
100047b6:	e002      	b.n	100047be <vTaskPriorityDisinheritAfterTimeout+0x3a>
            }
            else
            {
                uxPriorityToUse = pxTCB->uxBasePriority;
100047b8:	693b      	ldr	r3, [r7, #16]
100047ba:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
100047bc:	617b      	str	r3, [r7, #20]
            }

            /* Does the priority need to change? */
            if( pxTCB->uxPriority != uxPriorityToUse )
100047be:	693b      	ldr	r3, [r7, #16]
100047c0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
100047c2:	697b      	ldr	r3, [r7, #20]
100047c4:	429a      	cmp	r2, r3
100047c6:	d042      	beq.n	1000484e <vTaskPriorityDisinheritAfterTimeout+0xca>
            {
                /* Only disinherit if no other mutexes are held.  This is a
                 * simplification in the priority inheritance implementation.  If
                 * the task that holds the mutex is also holding other mutexes then
                 * the other mutexes may have caused the priority inheritance. */
                if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
100047c8:	693b      	ldr	r3, [r7, #16]
100047ca:	6d1a      	ldr	r2, [r3, #80]	; 0x50
100047cc:	68fb      	ldr	r3, [r7, #12]
100047ce:	429a      	cmp	r2, r3
100047d0:	d13d      	bne.n	1000484e <vTaskPriorityDisinheritAfterTimeout+0xca>
                {
                    /* If a task has timed out because it already holds the
                     * mutex it was trying to obtain then it cannot of inherited
                     * its own priority. */
                    configASSERT( pxTCB != pxCurrentTCB );
100047d2:	4b20      	ldr	r3, [pc, #128]	; (10004854 <vTaskPriorityDisinheritAfterTimeout+0xd0>)
100047d4:	681b      	ldr	r3, [r3, #0]
100047d6:	693a      	ldr	r2, [r7, #16]
100047d8:	429a      	cmp	r2, r3
100047da:	d101      	bne.n	100047e0 <vTaskPriorityDisinheritAfterTimeout+0x5c>
100047dc:	b672      	cpsid	i
100047de:	e7fe      	b.n	100047de <vTaskPriorityDisinheritAfterTimeout+0x5a>

                    /* Disinherit the priority, remembering the previous
                     * priority to facilitate determining the subject task's
                     * state. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, uxPriorityToUse );
                    uxPriorityUsedOnEntry = pxTCB->uxPriority;
100047e0:	693b      	ldr	r3, [r7, #16]
100047e2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
100047e4:	60bb      	str	r3, [r7, #8]
                    pxTCB->uxPriority = uxPriorityToUse;
100047e6:	693b      	ldr	r3, [r7, #16]
100047e8:	697a      	ldr	r2, [r7, #20]
100047ea:	62da      	str	r2, [r3, #44]	; 0x2c

                    /* Only reset the event list item value if the value is not
                     * being used for anything else. */
                    if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
100047ec:	693b      	ldr	r3, [r7, #16]
100047ee:	699b      	ldr	r3, [r3, #24]
100047f0:	2b00      	cmp	r3, #0
100047f2:	db04      	blt.n	100047fe <vTaskPriorityDisinheritAfterTimeout+0x7a>
                    {
                        listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
100047f4:	697b      	ldr	r3, [r7, #20]
100047f6:	2205      	movs	r2, #5
100047f8:	1ad2      	subs	r2, r2, r3
100047fa:	693b      	ldr	r3, [r7, #16]
100047fc:	619a      	str	r2, [r3, #24]
                     * then the task that holds the mutex could be in either the
                     * Ready, Blocked or Suspended states.  Only remove the task
                     * from its current state list if it is in the Ready state as
                     * the task's priority is going to change and there is one
                     * Ready list per priority. */
                    if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
100047fe:	693b      	ldr	r3, [r7, #16]
10004800:	6959      	ldr	r1, [r3, #20]
10004802:	68ba      	ldr	r2, [r7, #8]
10004804:	1c13      	adds	r3, r2, #0
10004806:	009b      	lsls	r3, r3, #2
10004808:	189b      	adds	r3, r3, r2
1000480a:	009b      	lsls	r3, r3, #2
1000480c:	4a12      	ldr	r2, [pc, #72]	; (10004858 <vTaskPriorityDisinheritAfterTimeout+0xd4>)
1000480e:	189b      	adds	r3, r3, r2
10004810:	4299      	cmp	r1, r3
10004812:	d11c      	bne.n	1000484e <vTaskPriorityDisinheritAfterTimeout+0xca>
                    {
                        if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
10004814:	693b      	ldr	r3, [r7, #16]
10004816:	3304      	adds	r3, #4
10004818:	1c18      	adds	r0, r3, #0
1000481a:	f7fe fb7f 	bl	10002f1c <uxListRemove>
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }

                        prvAddTaskToReadyList( pxTCB );
1000481e:	693b      	ldr	r3, [r7, #16]
10004820:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10004822:	4b0e      	ldr	r3, [pc, #56]	; (1000485c <vTaskPriorityDisinheritAfterTimeout+0xd8>)
10004824:	681b      	ldr	r3, [r3, #0]
10004826:	429a      	cmp	r2, r3
10004828:	d903      	bls.n	10004832 <vTaskPriorityDisinheritAfterTimeout+0xae>
1000482a:	693b      	ldr	r3, [r7, #16]
1000482c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
1000482e:	4b0b      	ldr	r3, [pc, #44]	; (1000485c <vTaskPriorityDisinheritAfterTimeout+0xd8>)
10004830:	601a      	str	r2, [r3, #0]
10004832:	693b      	ldr	r3, [r7, #16]
10004834:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10004836:	1c13      	adds	r3, r2, #0
10004838:	009b      	lsls	r3, r3, #2
1000483a:	189b      	adds	r3, r3, r2
1000483c:	009b      	lsls	r3, r3, #2
1000483e:	4a06      	ldr	r2, [pc, #24]	; (10004858 <vTaskPriorityDisinheritAfterTimeout+0xd4>)
10004840:	189a      	adds	r2, r3, r2
10004842:	693b      	ldr	r3, [r7, #16]
10004844:	3304      	adds	r3, #4
10004846:	1c10      	adds	r0, r2, #0
10004848:	1c19      	adds	r1, r3, #0
1000484a:	f7fe fb0f 	bl	10002e6c <vListInsertEnd>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
1000484e:	46bd      	mov	sp, r7
10004850:	b006      	add	sp, #24
10004852:	bd80      	pop	{r7, pc}
10004854:	200006d8 	.word	0x200006d8
10004858:	200006dc 	.word	0x200006dc
1000485c:	200007b8 	.word	0x200007b8

10004860 <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    TaskHandle_t pvTaskIncrementMutexHeldCount( void )
    {
10004860:	b580      	push	{r7, lr}
10004862:	af00      	add	r7, sp, #0
        /* If xSemaphoreCreateMutex() is called before any tasks have been created
         * then pxCurrentTCB will be NULL. */
        if( pxCurrentTCB != NULL )
10004864:	4b06      	ldr	r3, [pc, #24]	; (10004880 <pvTaskIncrementMutexHeldCount+0x20>)
10004866:	681b      	ldr	r3, [r3, #0]
10004868:	2b00      	cmp	r3, #0
1000486a:	d004      	beq.n	10004876 <pvTaskIncrementMutexHeldCount+0x16>
        {
            ( pxCurrentTCB->uxMutexesHeld )++;
1000486c:	4b04      	ldr	r3, [pc, #16]	; (10004880 <pvTaskIncrementMutexHeldCount+0x20>)
1000486e:	681b      	ldr	r3, [r3, #0]
10004870:	6d1a      	ldr	r2, [r3, #80]	; 0x50
10004872:	3201      	adds	r2, #1
10004874:	651a      	str	r2, [r3, #80]	; 0x50
        }

        return pxCurrentTCB;
10004876:	4b02      	ldr	r3, [pc, #8]	; (10004880 <pvTaskIncrementMutexHeldCount+0x20>)
10004878:	681b      	ldr	r3, [r3, #0]
    }
1000487a:	1c18      	adds	r0, r3, #0
1000487c:	46bd      	mov	sp, r7
1000487e:	bd80      	pop	{r7, pc}
10004880:	200006d8 	.word	0x200006d8

10004884 <prvAddCurrentTaskToDelayedList>:
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
10004884:	b580      	push	{r7, lr}
10004886:	b084      	sub	sp, #16
10004888:	af00      	add	r7, sp, #0
1000488a:	6078      	str	r0, [r7, #4]
1000488c:	6039      	str	r1, [r7, #0]
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
1000488e:	4b23      	ldr	r3, [pc, #140]	; (1000491c <prvAddCurrentTaskToDelayedList+0x98>)
10004890:	681b      	ldr	r3, [r3, #0]
10004892:	60fb      	str	r3, [r7, #12]
    #if ( INCLUDE_xTaskAbortDelay == 1 )
        {
            /* About to enter a delayed list, so ensure the ucDelayAborted flag is
             * reset to pdFALSE so it can be detected as having been set to pdTRUE
             * when the task leaves the Blocked state. */
            pxCurrentTCB->ucDelayAborted = pdFALSE;
10004894:	4b22      	ldr	r3, [pc, #136]	; (10004920 <prvAddCurrentTaskToDelayedList+0x9c>)
10004896:	681b      	ldr	r3, [r3, #0]
10004898:	226d      	movs	r2, #109	; 0x6d
1000489a:	2100      	movs	r1, #0
1000489c:	5499      	strb	r1, [r3, r2]
        }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
1000489e:	4b20      	ldr	r3, [pc, #128]	; (10004920 <prvAddCurrentTaskToDelayedList+0x9c>)
100048a0:	681b      	ldr	r3, [r3, #0]
100048a2:	3304      	adds	r3, #4
100048a4:	1c18      	adds	r0, r3, #0
100048a6:	f7fe fb39 	bl	10002f1c <uxListRemove>
        mtCOVERAGE_TEST_MARKER();
    }

    #if ( INCLUDE_vTaskSuspend == 1 )
        {
            if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
100048aa:	687b      	ldr	r3, [r7, #4]
100048ac:	3301      	adds	r3, #1
100048ae:	d10b      	bne.n	100048c8 <prvAddCurrentTaskToDelayedList+0x44>
100048b0:	683b      	ldr	r3, [r7, #0]
100048b2:	2b00      	cmp	r3, #0
100048b4:	d008      	beq.n	100048c8 <prvAddCurrentTaskToDelayedList+0x44>
            {
                /* Add the task to the suspended task list instead of a delayed task
                 * list to ensure it is not woken by a timing event.  It will block
                 * indefinitely. */
                vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
100048b6:	4b1a      	ldr	r3, [pc, #104]	; (10004920 <prvAddCurrentTaskToDelayedList+0x9c>)
100048b8:	681b      	ldr	r3, [r3, #0]
100048ba:	3304      	adds	r3, #4
100048bc:	4a19      	ldr	r2, [pc, #100]	; (10004924 <prvAddCurrentTaskToDelayedList+0xa0>)
100048be:	1c10      	adds	r0, r2, #0
100048c0:	1c19      	adds	r1, r3, #0
100048c2:	f7fe fad3 	bl	10002e6c <vListInsertEnd>
100048c6:	e026      	b.n	10004916 <prvAddCurrentTaskToDelayedList+0x92>
            else
            {
                /* Calculate the time at which the task should be woken if the event
                 * does not occur.  This may overflow but this doesn't matter, the
                 * kernel will manage it correctly. */
                xTimeToWake = xConstTickCount + xTicksToWait;
100048c8:	68fa      	ldr	r2, [r7, #12]
100048ca:	687b      	ldr	r3, [r7, #4]
100048cc:	18d3      	adds	r3, r2, r3
100048ce:	60bb      	str	r3, [r7, #8]

                /* The list item will be inserted in wake time order. */
                listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
100048d0:	4b13      	ldr	r3, [pc, #76]	; (10004920 <prvAddCurrentTaskToDelayedList+0x9c>)
100048d2:	681b      	ldr	r3, [r3, #0]
100048d4:	68ba      	ldr	r2, [r7, #8]
100048d6:	605a      	str	r2, [r3, #4]

                if( xTimeToWake < xConstTickCount )
100048d8:	68ba      	ldr	r2, [r7, #8]
100048da:	68fb      	ldr	r3, [r7, #12]
100048dc:	429a      	cmp	r2, r3
100048de:	d209      	bcs.n	100048f4 <prvAddCurrentTaskToDelayedList+0x70>
                {
                    /* Wake time has overflowed.  Place this item in the overflow
                     * list. */
                    vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
100048e0:	4b11      	ldr	r3, [pc, #68]	; (10004928 <prvAddCurrentTaskToDelayedList+0xa4>)
100048e2:	681a      	ldr	r2, [r3, #0]
100048e4:	4b0e      	ldr	r3, [pc, #56]	; (10004920 <prvAddCurrentTaskToDelayedList+0x9c>)
100048e6:	681b      	ldr	r3, [r3, #0]
100048e8:	3304      	adds	r3, #4
100048ea:	1c10      	adds	r0, r2, #0
100048ec:	1c19      	adds	r1, r3, #0
100048ee:	f7fe fadf 	bl	10002eb0 <vListInsert>
100048f2:	e010      	b.n	10004916 <prvAddCurrentTaskToDelayedList+0x92>
                }
                else
                {
                    /* The wake time has not overflowed, so the current block list
                     * is used. */
                    vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
100048f4:	4b0d      	ldr	r3, [pc, #52]	; (1000492c <prvAddCurrentTaskToDelayedList+0xa8>)
100048f6:	681a      	ldr	r2, [r3, #0]
100048f8:	4b09      	ldr	r3, [pc, #36]	; (10004920 <prvAddCurrentTaskToDelayedList+0x9c>)
100048fa:	681b      	ldr	r3, [r3, #0]
100048fc:	3304      	adds	r3, #4
100048fe:	1c10      	adds	r0, r2, #0
10004900:	1c19      	adds	r1, r3, #0
10004902:	f7fe fad5 	bl	10002eb0 <vListInsert>

                    /* If the task entering the blocked state was placed at the
                     * head of the list of blocked tasks then xNextTaskUnblockTime
                     * needs to be updated too. */
                    if( xTimeToWake < xNextTaskUnblockTime )
10004906:	4b0a      	ldr	r3, [pc, #40]	; (10004930 <prvAddCurrentTaskToDelayedList+0xac>)
10004908:	681b      	ldr	r3, [r3, #0]
1000490a:	68ba      	ldr	r2, [r7, #8]
1000490c:	429a      	cmp	r2, r3
1000490e:	d202      	bcs.n	10004916 <prvAddCurrentTaskToDelayedList+0x92>
                    {
                        xNextTaskUnblockTime = xTimeToWake;
10004910:	4b07      	ldr	r3, [pc, #28]	; (10004930 <prvAddCurrentTaskToDelayedList+0xac>)
10004912:	68ba      	ldr	r2, [r7, #8]
10004914:	601a      	str	r2, [r3, #0]

            /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
            ( void ) xCanBlockIndefinitely;
        }
    #endif /* INCLUDE_vTaskSuspend */
}
10004916:	46bd      	mov	sp, r7
10004918:	b004      	add	sp, #16
1000491a:	bd80      	pop	{r7, pc}
1000491c:	200007b4 	.word	0x200007b4
10004920:	200006d8 	.word	0x200006d8
10004924:	2000079c 	.word	0x2000079c
10004928:	2000076c 	.word	0x2000076c
1000492c:	20000768 	.word	0x20000768
10004930:	200007d0 	.word	0x200007d0

10004934 <xTimerCreateTimerTask>:
                                       TimerCallbackFunction_t pxCallbackFunction,
                                       Timer_t * pxNewTimer ) PRIVILEGED_FUNCTION;
/*-----------------------------------------------------------*/

    BaseType_t xTimerCreateTimerTask( void )
    {
10004934:	b580      	push	{r7, lr}
10004936:	b084      	sub	sp, #16
10004938:	af02      	add	r7, sp, #8
        BaseType_t xReturn = pdFAIL;
1000493a:	2300      	movs	r3, #0
1000493c:	607b      	str	r3, [r7, #4]

        /* This function is called when the scheduler is started if
         * configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
         * timer service task has been created/initialised.  If timers have already
         * been created then the initialisation will already have been performed. */
        prvCheckForValidListAndQueue();
1000493e:	f000 fac9 	bl	10004ed4 <prvCheckForValidListAndQueue>

        if( xTimerQueue != NULL )
10004942:	4b0e      	ldr	r3, [pc, #56]	; (1000497c <xTimerCreateTimerTask+0x48>)
10004944:	681b      	ldr	r3, [r3, #0]
10004946:	2b00      	cmp	r3, #0
10004948:	d00d      	beq.n	10004966 <xTimerCreateTimerTask+0x32>
                        xReturn = pdPASS;
                    }
                }
            #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
                {
                    xReturn = xTaskCreate( prvTimerTask,
1000494a:	490d      	ldr	r1, [pc, #52]	; (10004980 <xTimerCreateTimerTask+0x4c>)
1000494c:	4a0d      	ldr	r2, [pc, #52]	; (10004984 <xTimerCreateTimerTask+0x50>)
1000494e:	2302      	movs	r3, #2
10004950:	9300      	str	r3, [sp, #0]
10004952:	4b0d      	ldr	r3, [pc, #52]	; (10004988 <xTimerCreateTimerTask+0x54>)
10004954:	9301      	str	r3, [sp, #4]
10004956:	1c08      	adds	r0, r1, #0
10004958:	1c11      	adds	r1, r2, #0
1000495a:	2278      	movs	r2, #120	; 0x78
1000495c:	2300      	movs	r3, #0
1000495e:	f7ff f915 	bl	10003b8c <xTaskCreate>
10004962:	1c03      	adds	r3, r0, #0
10004964:	607b      	str	r3, [r7, #4]
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        configASSERT( xReturn );
10004966:	687b      	ldr	r3, [r7, #4]
10004968:	2b00      	cmp	r3, #0
1000496a:	d101      	bne.n	10004970 <xTimerCreateTimerTask+0x3c>
1000496c:	b672      	cpsid	i
1000496e:	e7fe      	b.n	1000496e <xTimerCreateTimerTask+0x3a>
        return xReturn;
10004970:	687b      	ldr	r3, [r7, #4]
    }
10004972:	1c18      	adds	r0, r3, #0
10004974:	46bd      	mov	sp, r7
10004976:	b002      	add	sp, #8
10004978:	bd80      	pop	{r7, pc}
1000497a:	46c0      	nop			; (mov r8, r8)
1000497c:	2000080c 	.word	0x2000080c
10004980:	10004ac1 	.word	0x10004ac1
10004984:	1000a624 	.word	0x1000a624
10004988:	20000810 	.word	0x20000810

1000498c <xTimerGenericCommand>:
    BaseType_t xTimerGenericCommand( TimerHandle_t xTimer,
                                     const BaseType_t xCommandID,
                                     const TickType_t xOptionalValue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const TickType_t xTicksToWait )
    {
1000498c:	b580      	push	{r7, lr}
1000498e:	b08a      	sub	sp, #40	; 0x28
10004990:	af00      	add	r7, sp, #0
10004992:	60f8      	str	r0, [r7, #12]
10004994:	60b9      	str	r1, [r7, #8]
10004996:	607a      	str	r2, [r7, #4]
10004998:	603b      	str	r3, [r7, #0]
        BaseType_t xReturn = pdFAIL;
1000499a:	2300      	movs	r3, #0
1000499c:	627b      	str	r3, [r7, #36]	; 0x24
        DaemonTaskMessage_t xMessage;

        configASSERT( xTimer );
1000499e:	68fb      	ldr	r3, [r7, #12]
100049a0:	2b00      	cmp	r3, #0
100049a2:	d101      	bne.n	100049a8 <xTimerGenericCommand+0x1c>
100049a4:	b672      	cpsid	i
100049a6:	e7fe      	b.n	100049a6 <xTimerGenericCommand+0x1a>

        /* Send a message to the timer service task to perform a particular action
         * on a particular timer definition. */
        if( xTimerQueue != NULL )
100049a8:	4b22      	ldr	r3, [pc, #136]	; (10004a34 <xTimerGenericCommand+0xa8>)
100049aa:	681b      	ldr	r3, [r3, #0]
100049ac:	2b00      	cmp	r3, #0
100049ae:	d03b      	beq.n	10004a28 <xTimerGenericCommand+0x9c>
        {
            /* Send a command to the timer service task to start the xTimer timer. */
            xMessage.xMessageID = xCommandID;
100049b0:	2314      	movs	r3, #20
100049b2:	18fb      	adds	r3, r7, r3
100049b4:	68ba      	ldr	r2, [r7, #8]
100049b6:	601a      	str	r2, [r3, #0]
            xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
100049b8:	2314      	movs	r3, #20
100049ba:	18fb      	adds	r3, r7, r3
100049bc:	687a      	ldr	r2, [r7, #4]
100049be:	605a      	str	r2, [r3, #4]
            xMessage.u.xTimerParameters.pxTimer = xTimer;
100049c0:	2314      	movs	r3, #20
100049c2:	18fb      	adds	r3, r7, r3
100049c4:	68fa      	ldr	r2, [r7, #12]
100049c6:	609a      	str	r2, [r3, #8]

            if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
100049c8:	68bb      	ldr	r3, [r7, #8]
100049ca:	2b05      	cmp	r3, #5
100049cc:	dc1f      	bgt.n	10004a0e <xTimerGenericCommand+0x82>
            {
                if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
100049ce:	f7ff fdf9 	bl	100045c4 <xTaskGetSchedulerState>
100049d2:	1e03      	subs	r3, r0, #0
100049d4:	2b02      	cmp	r3, #2
100049d6:	d10d      	bne.n	100049f4 <xTimerGenericCommand+0x68>
                {
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
100049d8:	4b16      	ldr	r3, [pc, #88]	; (10004a34 <xTimerGenericCommand+0xa8>)
100049da:	6819      	ldr	r1, [r3, #0]
100049dc:	2314      	movs	r3, #20
100049de:	18fa      	adds	r2, r7, r3
100049e0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
100049e2:	1c08      	adds	r0, r1, #0
100049e4:	1c11      	adds	r1, r2, #0
100049e6:	1c1a      	adds	r2, r3, #0
100049e8:	2300      	movs	r3, #0
100049ea:	f7fe fbbf 	bl	1000316c <xQueueGenericSend>
100049ee:	1c03      	adds	r3, r0, #0
100049f0:	627b      	str	r3, [r7, #36]	; 0x24
100049f2:	e019      	b.n	10004a28 <xTimerGenericCommand+0x9c>
                }
                else
                {
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
100049f4:	4b0f      	ldr	r3, [pc, #60]	; (10004a34 <xTimerGenericCommand+0xa8>)
100049f6:	681a      	ldr	r2, [r3, #0]
100049f8:	2314      	movs	r3, #20
100049fa:	18fb      	adds	r3, r7, r3
100049fc:	1c10      	adds	r0, r2, #0
100049fe:	1c19      	adds	r1, r3, #0
10004a00:	2200      	movs	r2, #0
10004a02:	2300      	movs	r3, #0
10004a04:	f7fe fbb2 	bl	1000316c <xQueueGenericSend>
10004a08:	1c03      	adds	r3, r0, #0
10004a0a:	627b      	str	r3, [r7, #36]	; 0x24
10004a0c:	e00c      	b.n	10004a28 <xTimerGenericCommand+0x9c>
                }
            }
            else
            {
                xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
10004a0e:	4b09      	ldr	r3, [pc, #36]	; (10004a34 <xTimerGenericCommand+0xa8>)
10004a10:	6819      	ldr	r1, [r3, #0]
10004a12:	2314      	movs	r3, #20
10004a14:	18fa      	adds	r2, r7, r3
10004a16:	683b      	ldr	r3, [r7, #0]
10004a18:	1c08      	adds	r0, r1, #0
10004a1a:	1c11      	adds	r1, r2, #0
10004a1c:	1c1a      	adds	r2, r3, #0
10004a1e:	2300      	movs	r3, #0
10004a20:	f7fe fc88 	bl	10003334 <xQueueGenericSendFromISR>
10004a24:	1c03      	adds	r3, r0, #0
10004a26:	627b      	str	r3, [r7, #36]	; 0x24
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
10004a28:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    }
10004a2a:	1c18      	adds	r0, r3, #0
10004a2c:	46bd      	mov	sp, r7
10004a2e:	b00a      	add	sp, #40	; 0x28
10004a30:	bd80      	pop	{r7, pc}
10004a32:	46c0      	nop			; (mov r8, r8)
10004a34:	2000080c 	.word	0x2000080c

10004a38 <prvProcessExpiredTimer>:
    }
/*-----------------------------------------------------------*/

    static void prvProcessExpiredTimer( const TickType_t xNextExpireTime,
                                        const TickType_t xTimeNow )
    {
10004a38:	b580      	push	{r7, lr}
10004a3a:	b086      	sub	sp, #24
10004a3c:	af02      	add	r7, sp, #8
10004a3e:	6078      	str	r0, [r7, #4]
10004a40:	6039      	str	r1, [r7, #0]
        BaseType_t xResult;
        Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
10004a42:	4b1e      	ldr	r3, [pc, #120]	; (10004abc <prvProcessExpiredTimer+0x84>)
10004a44:	681b      	ldr	r3, [r3, #0]
10004a46:	68db      	ldr	r3, [r3, #12]
10004a48:	68db      	ldr	r3, [r3, #12]
10004a4a:	60fb      	str	r3, [r7, #12]

        /* Remove the timer from the list of active timers.  A check has already
         * been performed to ensure the list is not empty. */

        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
10004a4c:	68fb      	ldr	r3, [r7, #12]
10004a4e:	3304      	adds	r3, #4
10004a50:	1c18      	adds	r0, r3, #0
10004a52:	f7fe fa63 	bl	10002f1c <uxListRemove>
        traceTIMER_EXPIRED( pxTimer );

        /* If the timer is an auto-reload timer then calculate the next
         * expiry time and re-insert the timer in the list of active timers. */
        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
10004a56:	68fb      	ldr	r3, [r7, #12]
10004a58:	2228      	movs	r2, #40	; 0x28
10004a5a:	5c9b      	ldrb	r3, [r3, r2]
10004a5c:	1c1a      	adds	r2, r3, #0
10004a5e:	2304      	movs	r3, #4
10004a60:	4013      	ands	r3, r2
10004a62:	d01a      	beq.n	10004a9a <prvProcessExpiredTimer+0x62>
        {
            /* The timer is inserted into a list using a time relative to anything
             * other than the current time.  It will therefore be inserted into the
             * correct list relative to the time this task thinks it is now. */
            if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
10004a64:	68fb      	ldr	r3, [r7, #12]
10004a66:	699a      	ldr	r2, [r3, #24]
10004a68:	687b      	ldr	r3, [r7, #4]
10004a6a:	18d1      	adds	r1, r2, r3
10004a6c:	68f8      	ldr	r0, [r7, #12]
10004a6e:	683a      	ldr	r2, [r7, #0]
10004a70:	687b      	ldr	r3, [r7, #4]
10004a72:	f000 f8c3 	bl	10004bfc <prvInsertTimerInActiveList>
10004a76:	1e03      	subs	r3, r0, #0
10004a78:	d018      	beq.n	10004aac <prvProcessExpiredTimer+0x74>
            {
                /* The timer expired before it was added to the active timer
                 * list.  Reload it now.  */
                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
10004a7a:	68f9      	ldr	r1, [r7, #12]
10004a7c:	687a      	ldr	r2, [r7, #4]
10004a7e:	2300      	movs	r3, #0
10004a80:	9300      	str	r3, [sp, #0]
10004a82:	1c08      	adds	r0, r1, #0
10004a84:	2100      	movs	r1, #0
10004a86:	2300      	movs	r3, #0
10004a88:	f7ff ff80 	bl	1000498c <xTimerGenericCommand>
10004a8c:	1c03      	adds	r3, r0, #0
10004a8e:	60bb      	str	r3, [r7, #8]
                configASSERT( xResult );
10004a90:	68bb      	ldr	r3, [r7, #8]
10004a92:	2b00      	cmp	r3, #0
10004a94:	d10a      	bne.n	10004aac <prvProcessExpiredTimer+0x74>
10004a96:	b672      	cpsid	i
10004a98:	e7fe      	b.n	10004a98 <prvProcessExpiredTimer+0x60>
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else
        {
            pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
10004a9a:	68fb      	ldr	r3, [r7, #12]
10004a9c:	2228      	movs	r2, #40	; 0x28
10004a9e:	5c9b      	ldrb	r3, [r3, r2]
10004aa0:	2201      	movs	r2, #1
10004aa2:	4393      	bics	r3, r2
10004aa4:	b2d9      	uxtb	r1, r3
10004aa6:	68fb      	ldr	r3, [r7, #12]
10004aa8:	2228      	movs	r2, #40	; 0x28
10004aaa:	5499      	strb	r1, [r3, r2]
            mtCOVERAGE_TEST_MARKER();
        }

        /* Call the timer callback. */
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
10004aac:	68fb      	ldr	r3, [r7, #12]
10004aae:	6a1b      	ldr	r3, [r3, #32]
10004ab0:	68fa      	ldr	r2, [r7, #12]
10004ab2:	1c10      	adds	r0, r2, #0
10004ab4:	4798      	blx	r3
    }
10004ab6:	46bd      	mov	sp, r7
10004ab8:	b004      	add	sp, #16
10004aba:	bd80      	pop	{r7, pc}
10004abc:	20000804 	.word	0x20000804

10004ac0 <prvTimerTask>:
/*-----------------------------------------------------------*/

    static portTASK_FUNCTION( prvTimerTask, pvParameters )
    {
10004ac0:	b580      	push	{r7, lr}
10004ac2:	b084      	sub	sp, #16
10004ac4:	af00      	add	r7, sp, #0
10004ac6:	6078      	str	r0, [r7, #4]

        for( ; ; )
        {
            /* Query the timers list to see if it contains any timers, and if so,
             * obtain the time at which the next timer will expire. */
            xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
10004ac8:	2308      	movs	r3, #8
10004aca:	18fb      	adds	r3, r7, r3
10004acc:	1c18      	adds	r0, r3, #0
10004ace:	f000 f853 	bl	10004b78 <prvGetNextExpireTime>
10004ad2:	1c03      	adds	r3, r0, #0
10004ad4:	60fb      	str	r3, [r7, #12]

            /* If a timer has expired, process it.  Otherwise, block this task
             * until either a timer does expire, or a command is received. */
            prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
10004ad6:	68bb      	ldr	r3, [r7, #8]
10004ad8:	68fa      	ldr	r2, [r7, #12]
10004ada:	1c10      	adds	r0, r2, #0
10004adc:	1c19      	adds	r1, r3, #0
10004ade:	f000 f803 	bl	10004ae8 <prvProcessTimerOrBlockTask>

            /* Empty the command queue. */
            prvProcessReceivedCommands();
10004ae2:	f000 f8cd 	bl	10004c80 <prvProcessReceivedCommands>
        }
10004ae6:	e7ef      	b.n	10004ac8 <prvTimerTask+0x8>

10004ae8 <prvProcessTimerOrBlockTask>:
    }
/*-----------------------------------------------------------*/

    static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime,
                                            BaseType_t xListWasEmpty )
    {
10004ae8:	b580      	push	{r7, lr}
10004aea:	b084      	sub	sp, #16
10004aec:	af00      	add	r7, sp, #0
10004aee:	6078      	str	r0, [r7, #4]
10004af0:	6039      	str	r1, [r7, #0]
        TickType_t xTimeNow;
        BaseType_t xTimerListsWereSwitched;

        vTaskSuspendAll();
10004af2:	f7ff f9fb 	bl	10003eec <vTaskSuspendAll>
            /* Obtain the time now to make an assessment as to whether the timer
             * has expired or not.  If obtaining the time causes the lists to switch
             * then don't process this timer as any timers that remained in the list
             * when the lists were switched will have been processed within the
             * prvSampleTimeNow() function. */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
10004af6:	2308      	movs	r3, #8
10004af8:	18fb      	adds	r3, r7, r3
10004afa:	1c18      	adds	r0, r3, #0
10004afc:	f000 f85e 	bl	10004bbc <prvSampleTimeNow>
10004b00:	1c03      	adds	r3, r0, #0
10004b02:	60fb      	str	r3, [r7, #12]

            if( xTimerListsWereSwitched == pdFALSE )
10004b04:	68bb      	ldr	r3, [r7, #8]
10004b06:	2b00      	cmp	r3, #0
10004b08:	d12d      	bne.n	10004b66 <prvProcessTimerOrBlockTask+0x7e>
            {
                /* The tick count has not overflowed, has the timer expired? */
                if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
10004b0a:	683b      	ldr	r3, [r7, #0]
10004b0c:	2b00      	cmp	r3, #0
10004b0e:	d10c      	bne.n	10004b2a <prvProcessTimerOrBlockTask+0x42>
10004b10:	687a      	ldr	r2, [r7, #4]
10004b12:	68fb      	ldr	r3, [r7, #12]
10004b14:	429a      	cmp	r2, r3
10004b16:	d808      	bhi.n	10004b2a <prvProcessTimerOrBlockTask+0x42>
                {
                    ( void ) xTaskResumeAll();
10004b18:	f7ff f9f4 	bl	10003f04 <xTaskResumeAll>
                    prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
10004b1c:	687a      	ldr	r2, [r7, #4]
10004b1e:	68fb      	ldr	r3, [r7, #12]
10004b20:	1c10      	adds	r0, r2, #0
10004b22:	1c19      	adds	r1, r3, #0
10004b24:	f7ff ff88 	bl	10004a38 <prvProcessExpiredTimer>
10004b28:	e01f      	b.n	10004b6a <prvProcessTimerOrBlockTask+0x82>
                     * time has not been reached yet.  This task should therefore
                     * block to wait for the next expire time or a command to be
                     * received - whichever comes first.  The following line cannot
                     * be reached unless xNextExpireTime > xTimeNow, except in the
                     * case when the current timer list is empty. */
                    if( xListWasEmpty != pdFALSE )
10004b2a:	683b      	ldr	r3, [r7, #0]
10004b2c:	2b00      	cmp	r3, #0
10004b2e:	d008      	beq.n	10004b42 <prvProcessTimerOrBlockTask+0x5a>
                    {
                        /* The current timer list is empty - is the overflow list
                         * also empty? */
                        xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
10004b30:	4b0f      	ldr	r3, [pc, #60]	; (10004b70 <prvProcessTimerOrBlockTask+0x88>)
10004b32:	681b      	ldr	r3, [r3, #0]
10004b34:	681b      	ldr	r3, [r3, #0]
10004b36:	2b00      	cmp	r3, #0
10004b38:	d101      	bne.n	10004b3e <prvProcessTimerOrBlockTask+0x56>
10004b3a:	2301      	movs	r3, #1
10004b3c:	e000      	b.n	10004b40 <prvProcessTimerOrBlockTask+0x58>
10004b3e:	2300      	movs	r3, #0
10004b40:	603b      	str	r3, [r7, #0]
                    }

                    vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
10004b42:	4b0c      	ldr	r3, [pc, #48]	; (10004b74 <prvProcessTimerOrBlockTask+0x8c>)
10004b44:	6819      	ldr	r1, [r3, #0]
10004b46:	687a      	ldr	r2, [r7, #4]
10004b48:	68fb      	ldr	r3, [r7, #12]
10004b4a:	1ad2      	subs	r2, r2, r3
10004b4c:	683b      	ldr	r3, [r7, #0]
10004b4e:	1c08      	adds	r0, r1, #0
10004b50:	1c11      	adds	r1, r2, #0
10004b52:	1c1a      	adds	r2, r3, #0
10004b54:	f7fe ff8c 	bl	10003a70 <vQueueWaitForMessageRestricted>

                    if( xTaskResumeAll() == pdFALSE )
10004b58:	f7ff f9d4 	bl	10003f04 <xTaskResumeAll>
10004b5c:	1e03      	subs	r3, r0, #0
10004b5e:	d104      	bne.n	10004b6a <prvProcessTimerOrBlockTask+0x82>
                    {
                        /* Yield to wait for either a command to arrive, or the
                         * block time to expire.  If a command arrived between the
                         * critical section being exited and this yield then the yield
                         * will not cause the task to block. */
                        portYIELD_WITHIN_API();
10004b60:	f7fe f892 	bl	10002c88 <vPortYield>
10004b64:	e001      	b.n	10004b6a <prvProcessTimerOrBlockTask+0x82>
                    }
                }
            }
            else
            {
                ( void ) xTaskResumeAll();
10004b66:	f7ff f9cd 	bl	10003f04 <xTaskResumeAll>
            }
        }
    }
10004b6a:	46bd      	mov	sp, r7
10004b6c:	b004      	add	sp, #16
10004b6e:	bd80      	pop	{r7, pc}
10004b70:	20000808 	.word	0x20000808
10004b74:	2000080c 	.word	0x2000080c

10004b78 <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

    static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
    {
10004b78:	b580      	push	{r7, lr}
10004b7a:	b084      	sub	sp, #16
10004b7c:	af00      	add	r7, sp, #0
10004b7e:	6078      	str	r0, [r7, #4]
         * the timer with the nearest expiry time will expire.  If there are no
         * active timers then just set the next expire time to 0.  That will cause
         * this task to unblock when the tick count overflows, at which point the
         * timer lists will be switched and the next expiry time can be
         * re-assessed.  */
        *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
10004b80:	4b0d      	ldr	r3, [pc, #52]	; (10004bb8 <prvGetNextExpireTime+0x40>)
10004b82:	681b      	ldr	r3, [r3, #0]
10004b84:	681b      	ldr	r3, [r3, #0]
10004b86:	2b00      	cmp	r3, #0
10004b88:	d101      	bne.n	10004b8e <prvGetNextExpireTime+0x16>
10004b8a:	2201      	movs	r2, #1
10004b8c:	e000      	b.n	10004b90 <prvGetNextExpireTime+0x18>
10004b8e:	2200      	movs	r2, #0
10004b90:	687b      	ldr	r3, [r7, #4]
10004b92:	601a      	str	r2, [r3, #0]

        if( *pxListWasEmpty == pdFALSE )
10004b94:	687b      	ldr	r3, [r7, #4]
10004b96:	681b      	ldr	r3, [r3, #0]
10004b98:	2b00      	cmp	r3, #0
10004b9a:	d105      	bne.n	10004ba8 <prvGetNextExpireTime+0x30>
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
10004b9c:	4b06      	ldr	r3, [pc, #24]	; (10004bb8 <prvGetNextExpireTime+0x40>)
10004b9e:	681b      	ldr	r3, [r3, #0]
10004ba0:	68db      	ldr	r3, [r3, #12]
10004ba2:	681b      	ldr	r3, [r3, #0]
10004ba4:	60fb      	str	r3, [r7, #12]
10004ba6:	e001      	b.n	10004bac <prvGetNextExpireTime+0x34>
        }
        else
        {
            /* Ensure the task unblocks when the tick count rolls over. */
            xNextExpireTime = ( TickType_t ) 0U;
10004ba8:	2300      	movs	r3, #0
10004baa:	60fb      	str	r3, [r7, #12]
        }

        return xNextExpireTime;
10004bac:	68fb      	ldr	r3, [r7, #12]
    }
10004bae:	1c18      	adds	r0, r3, #0
10004bb0:	46bd      	mov	sp, r7
10004bb2:	b004      	add	sp, #16
10004bb4:	bd80      	pop	{r7, pc}
10004bb6:	46c0      	nop			; (mov r8, r8)
10004bb8:	20000804 	.word	0x20000804

10004bbc <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

    static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
    {
10004bbc:	b580      	push	{r7, lr}
10004bbe:	b084      	sub	sp, #16
10004bc0:	af00      	add	r7, sp, #0
10004bc2:	6078      	str	r0, [r7, #4]
        TickType_t xTimeNow;
        PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

        xTimeNow = xTaskGetTickCount();
10004bc4:	f7ff fa2a 	bl	1000401c <xTaskGetTickCount>
10004bc8:	1c03      	adds	r3, r0, #0
10004bca:	60fb      	str	r3, [r7, #12]

        if( xTimeNow < xLastTime )
10004bcc:	4b0a      	ldr	r3, [pc, #40]	; (10004bf8 <prvSampleTimeNow+0x3c>)
10004bce:	681b      	ldr	r3, [r3, #0]
10004bd0:	68fa      	ldr	r2, [r7, #12]
10004bd2:	429a      	cmp	r2, r3
10004bd4:	d205      	bcs.n	10004be2 <prvSampleTimeNow+0x26>
        {
            prvSwitchTimerLists();
10004bd6:	f000 f91f 	bl	10004e18 <prvSwitchTimerLists>
            *pxTimerListsWereSwitched = pdTRUE;
10004bda:	687b      	ldr	r3, [r7, #4]
10004bdc:	2201      	movs	r2, #1
10004bde:	601a      	str	r2, [r3, #0]
10004be0:	e002      	b.n	10004be8 <prvSampleTimeNow+0x2c>
        }
        else
        {
            *pxTimerListsWereSwitched = pdFALSE;
10004be2:	687b      	ldr	r3, [r7, #4]
10004be4:	2200      	movs	r2, #0
10004be6:	601a      	str	r2, [r3, #0]
        }

        xLastTime = xTimeNow;
10004be8:	4b03      	ldr	r3, [pc, #12]	; (10004bf8 <prvSampleTimeNow+0x3c>)
10004bea:	68fa      	ldr	r2, [r7, #12]
10004bec:	601a      	str	r2, [r3, #0]

        return xTimeNow;
10004bee:	68fb      	ldr	r3, [r7, #12]
    }
10004bf0:	1c18      	adds	r0, r3, #0
10004bf2:	46bd      	mov	sp, r7
10004bf4:	b004      	add	sp, #16
10004bf6:	bd80      	pop	{r7, pc}
10004bf8:	20000814 	.word	0x20000814

10004bfc <prvInsertTimerInActiveList>:

    static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer,
                                                  const TickType_t xNextExpiryTime,
                                                  const TickType_t xTimeNow,
                                                  const TickType_t xCommandTime )
    {
10004bfc:	b580      	push	{r7, lr}
10004bfe:	b086      	sub	sp, #24
10004c00:	af00      	add	r7, sp, #0
10004c02:	60f8      	str	r0, [r7, #12]
10004c04:	60b9      	str	r1, [r7, #8]
10004c06:	607a      	str	r2, [r7, #4]
10004c08:	603b      	str	r3, [r7, #0]
        BaseType_t xProcessTimerNow = pdFALSE;
10004c0a:	2300      	movs	r3, #0
10004c0c:	617b      	str	r3, [r7, #20]

        listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
10004c0e:	68fb      	ldr	r3, [r7, #12]
10004c10:	68ba      	ldr	r2, [r7, #8]
10004c12:	605a      	str	r2, [r3, #4]
        listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
10004c14:	68fb      	ldr	r3, [r7, #12]
10004c16:	68fa      	ldr	r2, [r7, #12]
10004c18:	611a      	str	r2, [r3, #16]

        if( xNextExpiryTime <= xTimeNow )
10004c1a:	68ba      	ldr	r2, [r7, #8]
10004c1c:	687b      	ldr	r3, [r7, #4]
10004c1e:	429a      	cmp	r2, r3
10004c20:	d812      	bhi.n	10004c48 <prvInsertTimerInActiveList+0x4c>
        {
            /* Has the expiry time elapsed between the command to start/reset a
             * timer was issued, and the time the command was processed? */
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
10004c22:	687a      	ldr	r2, [r7, #4]
10004c24:	683b      	ldr	r3, [r7, #0]
10004c26:	1ad2      	subs	r2, r2, r3
10004c28:	68fb      	ldr	r3, [r7, #12]
10004c2a:	699b      	ldr	r3, [r3, #24]
10004c2c:	429a      	cmp	r2, r3
10004c2e:	d302      	bcc.n	10004c36 <prvInsertTimerInActiveList+0x3a>
            {
                /* The time between a command being issued and the command being
                 * processed actually exceeds the timers period.  */
                xProcessTimerNow = pdTRUE;
10004c30:	2301      	movs	r3, #1
10004c32:	617b      	str	r3, [r7, #20]
10004c34:	e01b      	b.n	10004c6e <prvInsertTimerInActiveList+0x72>
            }
            else
            {
                vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
10004c36:	4b10      	ldr	r3, [pc, #64]	; (10004c78 <prvInsertTimerInActiveList+0x7c>)
10004c38:	681a      	ldr	r2, [r3, #0]
10004c3a:	68fb      	ldr	r3, [r7, #12]
10004c3c:	3304      	adds	r3, #4
10004c3e:	1c10      	adds	r0, r2, #0
10004c40:	1c19      	adds	r1, r3, #0
10004c42:	f7fe f935 	bl	10002eb0 <vListInsert>
10004c46:	e012      	b.n	10004c6e <prvInsertTimerInActiveList+0x72>
            }
        }
        else
        {
            if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
10004c48:	687a      	ldr	r2, [r7, #4]
10004c4a:	683b      	ldr	r3, [r7, #0]
10004c4c:	429a      	cmp	r2, r3
10004c4e:	d206      	bcs.n	10004c5e <prvInsertTimerInActiveList+0x62>
10004c50:	68ba      	ldr	r2, [r7, #8]
10004c52:	683b      	ldr	r3, [r7, #0]
10004c54:	429a      	cmp	r2, r3
10004c56:	d302      	bcc.n	10004c5e <prvInsertTimerInActiveList+0x62>
            {
                /* If, since the command was issued, the tick count has overflowed
                 * but the expiry time has not, then the timer must have already passed
                 * its expiry time and should be processed immediately. */
                xProcessTimerNow = pdTRUE;
10004c58:	2301      	movs	r3, #1
10004c5a:	617b      	str	r3, [r7, #20]
10004c5c:	e007      	b.n	10004c6e <prvInsertTimerInActiveList+0x72>
            }
            else
            {
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
10004c5e:	4b07      	ldr	r3, [pc, #28]	; (10004c7c <prvInsertTimerInActiveList+0x80>)
10004c60:	681a      	ldr	r2, [r3, #0]
10004c62:	68fb      	ldr	r3, [r7, #12]
10004c64:	3304      	adds	r3, #4
10004c66:	1c10      	adds	r0, r2, #0
10004c68:	1c19      	adds	r1, r3, #0
10004c6a:	f7fe f921 	bl	10002eb0 <vListInsert>
            }
        }

        return xProcessTimerNow;
10004c6e:	697b      	ldr	r3, [r7, #20]
    }
10004c70:	1c18      	adds	r0, r3, #0
10004c72:	46bd      	mov	sp, r7
10004c74:	b006      	add	sp, #24
10004c76:	bd80      	pop	{r7, pc}
10004c78:	20000808 	.word	0x20000808
10004c7c:	20000804 	.word	0x20000804

10004c80 <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

    static void prvProcessReceivedCommands( void )
    {
10004c80:	b580      	push	{r7, lr}
10004c82:	b08c      	sub	sp, #48	; 0x30
10004c84:	af02      	add	r7, sp, #8
        DaemonTaskMessage_t xMessage;
        Timer_t * pxTimer;
        BaseType_t xTimerListsWereSwitched, xResult;
        TickType_t xTimeNow;

        while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
10004c86:	e0b3      	b.n	10004df0 <prvProcessReceivedCommands+0x170>
        {
            #if ( INCLUDE_xTimerPendFunctionCall == 1 )
                {
                    /* Negative commands are pended function calls rather than timer
                     * commands. */
                    if( xMessage.xMessageID < ( BaseType_t ) 0 )
10004c88:	2308      	movs	r3, #8
10004c8a:	18fb      	adds	r3, r7, r3
10004c8c:	681b      	ldr	r3, [r3, #0]
10004c8e:	2b00      	cmp	r3, #0
10004c90:	da11      	bge.n	10004cb6 <prvProcessReceivedCommands+0x36>
                    {
                        const CallbackParameters_t * const pxCallback = &( xMessage.u.xCallbackParameters );
10004c92:	2308      	movs	r3, #8
10004c94:	18fb      	adds	r3, r7, r3
10004c96:	3304      	adds	r3, #4
10004c98:	627b      	str	r3, [r7, #36]	; 0x24

                        /* The timer uses the xCallbackParameters member to request a
                         * callback be executed.  Check the callback is not NULL. */
                        configASSERT( pxCallback );
10004c9a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
10004c9c:	2b00      	cmp	r3, #0
10004c9e:	d101      	bne.n	10004ca4 <prvProcessReceivedCommands+0x24>
10004ca0:	b672      	cpsid	i
10004ca2:	e7fe      	b.n	10004ca2 <prvProcessReceivedCommands+0x22>

                        /* Call the function. */
                        pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
10004ca4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
10004ca6:	681a      	ldr	r2, [r3, #0]
10004ca8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
10004caa:	6859      	ldr	r1, [r3, #4]
10004cac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
10004cae:	689b      	ldr	r3, [r3, #8]
10004cb0:	1c08      	adds	r0, r1, #0
10004cb2:	1c19      	adds	r1, r3, #0
10004cb4:	4790      	blx	r2
                }
            #endif /* INCLUDE_xTimerPendFunctionCall */

            /* Commands that are positive are timer commands rather than pended
             * function calls. */
            if( xMessage.xMessageID >= ( BaseType_t ) 0 )
10004cb6:	2308      	movs	r3, #8
10004cb8:	18fb      	adds	r3, r7, r3
10004cba:	681b      	ldr	r3, [r3, #0]
10004cbc:	2b00      	cmp	r3, #0
10004cbe:	da00      	bge.n	10004cc2 <prvProcessReceivedCommands+0x42>
10004cc0:	e096      	b.n	10004df0 <prvProcessReceivedCommands+0x170>
            {
                /* The messages uses the xTimerParameters member to work on a
                 * software timer. */
                pxTimer = xMessage.u.xTimerParameters.pxTimer;
10004cc2:	2308      	movs	r3, #8
10004cc4:	18fb      	adds	r3, r7, r3
10004cc6:	689b      	ldr	r3, [r3, #8]
10004cc8:	623b      	str	r3, [r7, #32]

                if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
10004cca:	6a3b      	ldr	r3, [r7, #32]
10004ccc:	695b      	ldr	r3, [r3, #20]
10004cce:	2b00      	cmp	r3, #0
10004cd0:	d004      	beq.n	10004cdc <prvProcessReceivedCommands+0x5c>
                {
                    /* The timer is in a list, remove it. */
                    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
10004cd2:	6a3b      	ldr	r3, [r7, #32]
10004cd4:	3304      	adds	r3, #4
10004cd6:	1c18      	adds	r0, r3, #0
10004cd8:	f7fe f920 	bl	10002f1c <uxListRemove>
                 *  it must be present in the function call.  prvSampleTimeNow() must be
                 *  called after the message is received from xTimerQueue so there is no
                 *  possibility of a higher priority task adding a message to the message
                 *  queue with a time that is ahead of the timer daemon task (because it
                 *  pre-empted the timer daemon task after the xTimeNow value was set). */
                xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
10004cdc:	1d3b      	adds	r3, r7, #4
10004cde:	1c18      	adds	r0, r3, #0
10004ce0:	f7ff ff6c 	bl	10004bbc <prvSampleTimeNow>
10004ce4:	1c03      	adds	r3, r0, #0
10004ce6:	61fb      	str	r3, [r7, #28]

                switch( xMessage.xMessageID )
10004ce8:	2308      	movs	r3, #8
10004cea:	18fb      	adds	r3, r7, r3
10004cec:	681b      	ldr	r3, [r3, #0]
10004cee:	2b09      	cmp	r3, #9
10004cf0:	d900      	bls.n	10004cf4 <prvProcessReceivedCommands+0x74>
10004cf2:	e07c      	b.n	10004dee <prvProcessReceivedCommands+0x16e>
10004cf4:	009a      	lsls	r2, r3, #2
10004cf6:	4b46      	ldr	r3, [pc, #280]	; (10004e10 <prvProcessReceivedCommands+0x190>)
10004cf8:	18d3      	adds	r3, r2, r3
10004cfa:	681b      	ldr	r3, [r3, #0]
10004cfc:	469f      	mov	pc, r3
                    case tmrCOMMAND_START_FROM_ISR:
                    case tmrCOMMAND_RESET:
                    case tmrCOMMAND_RESET_FROM_ISR:
                    case tmrCOMMAND_START_DONT_TRACE:
                        /* Start or restart a timer. */
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
10004cfe:	6a3b      	ldr	r3, [r7, #32]
10004d00:	2228      	movs	r2, #40	; 0x28
10004d02:	5c9b      	ldrb	r3, [r3, r2]
10004d04:	2201      	movs	r2, #1
10004d06:	4313      	orrs	r3, r2
10004d08:	b2d9      	uxtb	r1, r3
10004d0a:	6a3b      	ldr	r3, [r7, #32]
10004d0c:	2228      	movs	r2, #40	; 0x28
10004d0e:	5499      	strb	r1, [r3, r2]

                        if( prvInsertTimerInActiveList( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
10004d10:	2308      	movs	r3, #8
10004d12:	18fb      	adds	r3, r7, r3
10004d14:	685a      	ldr	r2, [r3, #4]
10004d16:	6a3b      	ldr	r3, [r7, #32]
10004d18:	699b      	ldr	r3, [r3, #24]
10004d1a:	18d1      	adds	r1, r2, r3
10004d1c:	2308      	movs	r3, #8
10004d1e:	18fb      	adds	r3, r7, r3
10004d20:	685b      	ldr	r3, [r3, #4]
10004d22:	6a38      	ldr	r0, [r7, #32]
10004d24:	69fa      	ldr	r2, [r7, #28]
10004d26:	f7ff ff69 	bl	10004bfc <prvInsertTimerInActiveList>
10004d2a:	1e03      	subs	r3, r0, #0
10004d2c:	d020      	beq.n	10004d70 <prvProcessReceivedCommands+0xf0>
                        {
                            /* The timer expired before it was added to the active
                             * timer list.  Process it now. */
                            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
10004d2e:	6a3b      	ldr	r3, [r7, #32]
10004d30:	6a1b      	ldr	r3, [r3, #32]
10004d32:	6a3a      	ldr	r2, [r7, #32]
10004d34:	1c10      	adds	r0, r2, #0
10004d36:	4798      	blx	r3
                            traceTIMER_EXPIRED( pxTimer );

                            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
10004d38:	6a3b      	ldr	r3, [r7, #32]
10004d3a:	2228      	movs	r2, #40	; 0x28
10004d3c:	5c9b      	ldrb	r3, [r3, r2]
10004d3e:	1c1a      	adds	r2, r3, #0
10004d40:	2304      	movs	r3, #4
10004d42:	4013      	ands	r3, r2
10004d44:	d014      	beq.n	10004d70 <prvProcessReceivedCommands+0xf0>
                            {
                                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
10004d46:	2308      	movs	r3, #8
10004d48:	18fb      	adds	r3, r7, r3
10004d4a:	685a      	ldr	r2, [r3, #4]
10004d4c:	6a3b      	ldr	r3, [r7, #32]
10004d4e:	699b      	ldr	r3, [r3, #24]
10004d50:	18d2      	adds	r2, r2, r3
10004d52:	6a39      	ldr	r1, [r7, #32]
10004d54:	2300      	movs	r3, #0
10004d56:	9300      	str	r3, [sp, #0]
10004d58:	1c08      	adds	r0, r1, #0
10004d5a:	2100      	movs	r1, #0
10004d5c:	2300      	movs	r3, #0
10004d5e:	f7ff fe15 	bl	1000498c <xTimerGenericCommand>
10004d62:	1c03      	adds	r3, r0, #0
10004d64:	61bb      	str	r3, [r7, #24]
                                configASSERT( xResult );
10004d66:	69bb      	ldr	r3, [r7, #24]
10004d68:	2b00      	cmp	r3, #0
10004d6a:	d101      	bne.n	10004d70 <prvProcessReceivedCommands+0xf0>
10004d6c:	b672      	cpsid	i
10004d6e:	e7fe      	b.n	10004d6e <prvProcessReceivedCommands+0xee>
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }

                        break;
10004d70:	e03e      	b.n	10004df0 <prvProcessReceivedCommands+0x170>

                    case tmrCOMMAND_STOP:
                    case tmrCOMMAND_STOP_FROM_ISR:
                        /* The timer has already been removed from the active list. */
                        pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
10004d72:	6a3b      	ldr	r3, [r7, #32]
10004d74:	2228      	movs	r2, #40	; 0x28
10004d76:	5c9b      	ldrb	r3, [r3, r2]
10004d78:	2201      	movs	r2, #1
10004d7a:	4393      	bics	r3, r2
10004d7c:	b2d9      	uxtb	r1, r3
10004d7e:	6a3b      	ldr	r3, [r7, #32]
10004d80:	2228      	movs	r2, #40	; 0x28
10004d82:	5499      	strb	r1, [r3, r2]
                        break;
10004d84:	e034      	b.n	10004df0 <prvProcessReceivedCommands+0x170>

                    case tmrCOMMAND_CHANGE_PERIOD:
                    case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR:
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
10004d86:	6a3b      	ldr	r3, [r7, #32]
10004d88:	2228      	movs	r2, #40	; 0x28
10004d8a:	5c9b      	ldrb	r3, [r3, r2]
10004d8c:	2201      	movs	r2, #1
10004d8e:	4313      	orrs	r3, r2
10004d90:	b2d9      	uxtb	r1, r3
10004d92:	6a3b      	ldr	r3, [r7, #32]
10004d94:	2228      	movs	r2, #40	; 0x28
10004d96:	5499      	strb	r1, [r3, r2]
                        pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
10004d98:	2308      	movs	r3, #8
10004d9a:	18fb      	adds	r3, r7, r3
10004d9c:	685a      	ldr	r2, [r3, #4]
10004d9e:	6a3b      	ldr	r3, [r7, #32]
10004da0:	619a      	str	r2, [r3, #24]
                        configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
10004da2:	6a3b      	ldr	r3, [r7, #32]
10004da4:	699b      	ldr	r3, [r3, #24]
10004da6:	2b00      	cmp	r3, #0
10004da8:	d101      	bne.n	10004dae <prvProcessReceivedCommands+0x12e>
10004daa:	b672      	cpsid	i
10004dac:	e7fe      	b.n	10004dac <prvProcessReceivedCommands+0x12c>
                         * be longer or shorter than the old one.  The command time is
                         * therefore set to the current time, and as the period cannot
                         * be zero the next expiry time can only be in the future,
                         * meaning (unlike for the xTimerStart() case above) there is
                         * no fail case that needs to be handled here. */
                        ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
10004dae:	6a3b      	ldr	r3, [r7, #32]
10004db0:	699a      	ldr	r2, [r3, #24]
10004db2:	69fb      	ldr	r3, [r7, #28]
10004db4:	18d1      	adds	r1, r2, r3
10004db6:	6a38      	ldr	r0, [r7, #32]
10004db8:	69fa      	ldr	r2, [r7, #28]
10004dba:	69fb      	ldr	r3, [r7, #28]
10004dbc:	f7ff ff1e 	bl	10004bfc <prvInsertTimerInActiveList>
                        break;
10004dc0:	e016      	b.n	10004df0 <prvProcessReceivedCommands+0x170>
                        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
                            {
                                /* The timer has already been removed from the active list,
                                 * just free up the memory if the memory was dynamically
                                 * allocated. */
                                if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
10004dc2:	6a3b      	ldr	r3, [r7, #32]
10004dc4:	2228      	movs	r2, #40	; 0x28
10004dc6:	5c9b      	ldrb	r3, [r3, r2]
10004dc8:	1c1a      	adds	r2, r3, #0
10004dca:	2302      	movs	r3, #2
10004dcc:	4013      	ands	r3, r2
10004dce:	d104      	bne.n	10004dda <prvProcessReceivedCommands+0x15a>
                                {
                                    vPortFree( pxTimer );
10004dd0:	6a3b      	ldr	r3, [r7, #32]
10004dd2:	1c18      	adds	r0, r3, #0
10004dd4:	f7fe f810 	bl	10002df8 <vPortFree>
10004dd8:	e008      	b.n	10004dec <prvProcessReceivedCommands+0x16c>
                                }
                                else
                                {
                                    pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
10004dda:	6a3b      	ldr	r3, [r7, #32]
10004ddc:	2228      	movs	r2, #40	; 0x28
10004dde:	5c9b      	ldrb	r3, [r3, r2]
10004de0:	2201      	movs	r2, #1
10004de2:	4393      	bics	r3, r2
10004de4:	b2d9      	uxtb	r1, r3
10004de6:	6a3b      	ldr	r3, [r7, #32]
10004de8:	2228      	movs	r2, #40	; 0x28
10004dea:	5499      	strb	r1, [r3, r2]
                                 * no need to free the memory - just mark the timer as
                                 * "not active". */
                                pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
                            }
                        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
                        break;
10004dec:	e000      	b.n	10004df0 <prvProcessReceivedCommands+0x170>

                    default:
                        /* Don't expect to get here. */
                        break;
10004dee:	46c0      	nop			; (mov r8, r8)
        DaemonTaskMessage_t xMessage;
        Timer_t * pxTimer;
        BaseType_t xTimerListsWereSwitched, xResult;
        TickType_t xTimeNow;

        while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
10004df0:	4b08      	ldr	r3, [pc, #32]	; (10004e14 <prvProcessReceivedCommands+0x194>)
10004df2:	681a      	ldr	r2, [r3, #0]
10004df4:	2308      	movs	r3, #8
10004df6:	18fb      	adds	r3, r7, r3
10004df8:	1c10      	adds	r0, r2, #0
10004dfa:	1c19      	adds	r1, r3, #0
10004dfc:	2200      	movs	r2, #0
10004dfe:	f7fe fb31 	bl	10003464 <xQueueReceive>
10004e02:	1e03      	subs	r3, r0, #0
10004e04:	d000      	beq.n	10004e08 <prvProcessReceivedCommands+0x188>
10004e06:	e73f      	b.n	10004c88 <prvProcessReceivedCommands+0x8>
                        /* Don't expect to get here. */
                        break;
                }
            }
        }
    }
10004e08:	46bd      	mov	sp, r7
10004e0a:	b00a      	add	sp, #40	; 0x28
10004e0c:	bd80      	pop	{r7, pc}
10004e0e:	46c0      	nop			; (mov r8, r8)
10004e10:	1000a634 	.word	0x1000a634
10004e14:	2000080c 	.word	0x2000080c

10004e18 <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

    static void prvSwitchTimerLists( void )
    {
10004e18:	b580      	push	{r7, lr}
10004e1a:	b088      	sub	sp, #32
10004e1c:	af02      	add	r7, sp, #8

        /* The tick count has overflowed.  The timer lists must be switched.
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
10004e1e:	e042      	b.n	10004ea6 <prvSwitchTimerLists+0x8e>
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
10004e20:	4b2a      	ldr	r3, [pc, #168]	; (10004ecc <prvSwitchTimerLists+0xb4>)
10004e22:	681b      	ldr	r3, [r3, #0]
10004e24:	68db      	ldr	r3, [r3, #12]
10004e26:	681b      	ldr	r3, [r3, #0]
10004e28:	617b      	str	r3, [r7, #20]

            /* Remove the timer from the list. */
            pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
10004e2a:	4b28      	ldr	r3, [pc, #160]	; (10004ecc <prvSwitchTimerLists+0xb4>)
10004e2c:	681b      	ldr	r3, [r3, #0]
10004e2e:	68db      	ldr	r3, [r3, #12]
10004e30:	68db      	ldr	r3, [r3, #12]
10004e32:	613b      	str	r3, [r7, #16]
            ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
10004e34:	693b      	ldr	r3, [r7, #16]
10004e36:	3304      	adds	r3, #4
10004e38:	1c18      	adds	r0, r3, #0
10004e3a:	f7fe f86f 	bl	10002f1c <uxListRemove>
            traceTIMER_EXPIRED( pxTimer );

            /* Execute its callback, then send a command to restart the timer if
             * it is an auto-reload timer.  It cannot be restarted here as the lists
             * have not yet been switched. */
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
10004e3e:	693b      	ldr	r3, [r7, #16]
10004e40:	6a1b      	ldr	r3, [r3, #32]
10004e42:	693a      	ldr	r2, [r7, #16]
10004e44:	1c10      	adds	r0, r2, #0
10004e46:	4798      	blx	r3

            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
10004e48:	693b      	ldr	r3, [r7, #16]
10004e4a:	2228      	movs	r2, #40	; 0x28
10004e4c:	5c9b      	ldrb	r3, [r3, r2]
10004e4e:	1c1a      	adds	r2, r3, #0
10004e50:	2304      	movs	r3, #4
10004e52:	4013      	ands	r3, r2
10004e54:	d027      	beq.n	10004ea6 <prvSwitchTimerLists+0x8e>
                 * the timer going into the same timer list then it has already expired
                 * and the timer should be re-inserted into the current list so it is
                 * processed again within this loop.  Otherwise a command should be sent
                 * to restart the timer to ensure it is only inserted into a list after
                 * the lists have been swapped. */
                xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
10004e56:	693b      	ldr	r3, [r7, #16]
10004e58:	699a      	ldr	r2, [r3, #24]
10004e5a:	697b      	ldr	r3, [r7, #20]
10004e5c:	18d3      	adds	r3, r2, r3
10004e5e:	60fb      	str	r3, [r7, #12]

                if( xReloadTime > xNextExpireTime )
10004e60:	68fa      	ldr	r2, [r7, #12]
10004e62:	697b      	ldr	r3, [r7, #20]
10004e64:	429a      	cmp	r2, r3
10004e66:	d90e      	bls.n	10004e86 <prvSwitchTimerLists+0x6e>
                {
                    listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
10004e68:	693b      	ldr	r3, [r7, #16]
10004e6a:	68fa      	ldr	r2, [r7, #12]
10004e6c:	605a      	str	r2, [r3, #4]
                    listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
10004e6e:	693b      	ldr	r3, [r7, #16]
10004e70:	693a      	ldr	r2, [r7, #16]
10004e72:	611a      	str	r2, [r3, #16]
                    vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
10004e74:	4b15      	ldr	r3, [pc, #84]	; (10004ecc <prvSwitchTimerLists+0xb4>)
10004e76:	681a      	ldr	r2, [r3, #0]
10004e78:	693b      	ldr	r3, [r7, #16]
10004e7a:	3304      	adds	r3, #4
10004e7c:	1c10      	adds	r0, r2, #0
10004e7e:	1c19      	adds	r1, r3, #0
10004e80:	f7fe f816 	bl	10002eb0 <vListInsert>
10004e84:	e00f      	b.n	10004ea6 <prvSwitchTimerLists+0x8e>
                }
                else
                {
                    xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
10004e86:	6939      	ldr	r1, [r7, #16]
10004e88:	697a      	ldr	r2, [r7, #20]
10004e8a:	2300      	movs	r3, #0
10004e8c:	9300      	str	r3, [sp, #0]
10004e8e:	1c08      	adds	r0, r1, #0
10004e90:	2100      	movs	r1, #0
10004e92:	2300      	movs	r3, #0
10004e94:	f7ff fd7a 	bl	1000498c <xTimerGenericCommand>
10004e98:	1c03      	adds	r3, r0, #0
10004e9a:	60bb      	str	r3, [r7, #8]
                    configASSERT( xResult );
10004e9c:	68bb      	ldr	r3, [r7, #8]
10004e9e:	2b00      	cmp	r3, #0
10004ea0:	d101      	bne.n	10004ea6 <prvSwitchTimerLists+0x8e>
10004ea2:	b672      	cpsid	i
10004ea4:	e7fe      	b.n	10004ea4 <prvSwitchTimerLists+0x8c>

        /* The tick count has overflowed.  The timer lists must be switched.
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
10004ea6:	4b09      	ldr	r3, [pc, #36]	; (10004ecc <prvSwitchTimerLists+0xb4>)
10004ea8:	681b      	ldr	r3, [r3, #0]
10004eaa:	681b      	ldr	r3, [r3, #0]
10004eac:	2b00      	cmp	r3, #0
10004eae:	d1b7      	bne.n	10004e20 <prvSwitchTimerLists+0x8>
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        pxTemp = pxCurrentTimerList;
10004eb0:	4b06      	ldr	r3, [pc, #24]	; (10004ecc <prvSwitchTimerLists+0xb4>)
10004eb2:	681b      	ldr	r3, [r3, #0]
10004eb4:	607b      	str	r3, [r7, #4]
        pxCurrentTimerList = pxOverflowTimerList;
10004eb6:	4b06      	ldr	r3, [pc, #24]	; (10004ed0 <prvSwitchTimerLists+0xb8>)
10004eb8:	681a      	ldr	r2, [r3, #0]
10004eba:	4b04      	ldr	r3, [pc, #16]	; (10004ecc <prvSwitchTimerLists+0xb4>)
10004ebc:	601a      	str	r2, [r3, #0]
        pxOverflowTimerList = pxTemp;
10004ebe:	4b04      	ldr	r3, [pc, #16]	; (10004ed0 <prvSwitchTimerLists+0xb8>)
10004ec0:	687a      	ldr	r2, [r7, #4]
10004ec2:	601a      	str	r2, [r3, #0]
    }
10004ec4:	46bd      	mov	sp, r7
10004ec6:	b006      	add	sp, #24
10004ec8:	bd80      	pop	{r7, pc}
10004eca:	46c0      	nop			; (mov r8, r8)
10004ecc:	20000804 	.word	0x20000804
10004ed0:	20000808 	.word	0x20000808

10004ed4 <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

    static void prvCheckForValidListAndQueue( void )
    {
10004ed4:	b580      	push	{r7, lr}
10004ed6:	af00      	add	r7, sp, #0
        /* Check that the list from which active timers are referenced, and the
         * queue used to communicate with the timer service, have been
         * initialised. */
        taskENTER_CRITICAL();
10004ed8:	f7fd fee4 	bl	10002ca4 <vPortEnterCritical>
        {
            if( xTimerQueue == NULL )
10004edc:	4b14      	ldr	r3, [pc, #80]	; (10004f30 <prvCheckForValidListAndQueue+0x5c>)
10004ede:	681b      	ldr	r3, [r3, #0]
10004ee0:	2b00      	cmp	r3, #0
10004ee2:	d120      	bne.n	10004f26 <prvCheckForValidListAndQueue+0x52>
            {
                vListInitialise( &xActiveTimerList1 );
10004ee4:	4b13      	ldr	r3, [pc, #76]	; (10004f34 <prvCheckForValidListAndQueue+0x60>)
10004ee6:	1c18      	adds	r0, r3, #0
10004ee8:	f7fd ff98 	bl	10002e1c <vListInitialise>
                vListInitialise( &xActiveTimerList2 );
10004eec:	4b12      	ldr	r3, [pc, #72]	; (10004f38 <prvCheckForValidListAndQueue+0x64>)
10004eee:	1c18      	adds	r0, r3, #0
10004ef0:	f7fd ff94 	bl	10002e1c <vListInitialise>
                pxCurrentTimerList = &xActiveTimerList1;
10004ef4:	4b11      	ldr	r3, [pc, #68]	; (10004f3c <prvCheckForValidListAndQueue+0x68>)
10004ef6:	4a0f      	ldr	r2, [pc, #60]	; (10004f34 <prvCheckForValidListAndQueue+0x60>)
10004ef8:	601a      	str	r2, [r3, #0]
                pxOverflowTimerList = &xActiveTimerList2;
10004efa:	4b11      	ldr	r3, [pc, #68]	; (10004f40 <prvCheckForValidListAndQueue+0x6c>)
10004efc:	4a0e      	ldr	r2, [pc, #56]	; (10004f38 <prvCheckForValidListAndQueue+0x64>)
10004efe:	601a      	str	r2, [r3, #0]

                        xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
                    }
                #else
                    {
                        xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
10004f00:	2005      	movs	r0, #5
10004f02:	2110      	movs	r1, #16
10004f04:	2200      	movs	r2, #0
10004f06:	f7fe f885 	bl	10003014 <xQueueGenericCreate>
10004f0a:	1c02      	adds	r2, r0, #0
10004f0c:	4b08      	ldr	r3, [pc, #32]	; (10004f30 <prvCheckForValidListAndQueue+0x5c>)
10004f0e:	601a      	str	r2, [r3, #0]
                    }
                #endif /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */

                #if ( configQUEUE_REGISTRY_SIZE > 0 )
                    {
                        if( xTimerQueue != NULL )
10004f10:	4b07      	ldr	r3, [pc, #28]	; (10004f30 <prvCheckForValidListAndQueue+0x5c>)
10004f12:	681b      	ldr	r3, [r3, #0]
10004f14:	2b00      	cmp	r3, #0
10004f16:	d006      	beq.n	10004f26 <prvCheckForValidListAndQueue+0x52>
                        {
                            vQueueAddToRegistry( xTimerQueue, "TmrQ" );
10004f18:	4b05      	ldr	r3, [pc, #20]	; (10004f30 <prvCheckForValidListAndQueue+0x5c>)
10004f1a:	681a      	ldr	r2, [r3, #0]
10004f1c:	4b09      	ldr	r3, [pc, #36]	; (10004f44 <prvCheckForValidListAndQueue+0x70>)
10004f1e:	1c10      	adds	r0, r2, #0
10004f20:	1c19      	adds	r1, r3, #0
10004f22:	f7fe fd7f 	bl	10003a24 <vQueueAddToRegistry>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
10004f26:	f7fd fecd 	bl	10002cc4 <vPortExitCritical>
    }
10004f2a:	46bd      	mov	sp, r7
10004f2c:	bd80      	pop	{r7, pc}
10004f2e:	46c0      	nop			; (mov r8, r8)
10004f30:	2000080c 	.word	0x2000080c
10004f34:	200007dc 	.word	0x200007dc
10004f38:	200007f0 	.word	0x200007f0
10004f3c:	20000804 	.word	0x20000804
10004f40:	20000808 	.word	0x20000808
10004f44:	1000a62c 	.word	0x1000a62c

10004f48 <DIGITAL_IO_Init>:
* @param handler Pointer pointing to APP data structure.
* @return DIGITAL_IO_STATUS_t DIGITAL_IO APP status.
*/

DIGITAL_IO_STATUS_t DIGITAL_IO_Init(const DIGITAL_IO_t *const handler)
{
10004f48:	b580      	push	{r7, lr}
10004f4a:	b082      	sub	sp, #8
10004f4c:	af00      	add	r7, sp, #0
10004f4e:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("DIGITAL_IO_Init: handler null pointer", handler != NULL);

  /* Initializes input / output characteristics */
  XMC_GPIO_Init(handler->gpio_port, handler->gpio_pin, &handler->gpio_config);
10004f50:	687b      	ldr	r3, [r7, #4]
10004f52:	6819      	ldr	r1, [r3, #0]
10004f54:	687b      	ldr	r3, [r7, #4]
10004f56:	7b1a      	ldrb	r2, [r3, #12]
10004f58:	687b      	ldr	r3, [r7, #4]
10004f5a:	3304      	adds	r3, #4
10004f5c:	1c08      	adds	r0, r1, #0
10004f5e:	1c11      	adds	r1, r2, #0
10004f60:	1c1a      	adds	r2, r3, #0
10004f62:	f7fc f8d3 	bl	1000110c <XMC_GPIO_Init>

  /*Configure hardware port control*/
  XMC_GPIO_SetHardwareControl(handler->gpio_port, handler->gpio_pin, handler->hwctrl);
10004f66:	687b      	ldr	r3, [r7, #4]
10004f68:	6819      	ldr	r1, [r3, #0]
10004f6a:	687b      	ldr	r3, [r7, #4]
10004f6c:	7b1a      	ldrb	r2, [r3, #12]
10004f6e:	687b      	ldr	r3, [r7, #4]
10004f70:	7b5b      	ldrb	r3, [r3, #13]
10004f72:	1c08      	adds	r0, r1, #0
10004f74:	1c11      	adds	r1, r2, #0
10004f76:	1c1a      	adds	r2, r3, #0
10004f78:	f7fc fb7e 	bl	10001678 <XMC_GPIO_SetHardwareControl>

  return (DIGITAL_IO_STATUS_OK);
10004f7c:	2300      	movs	r3, #0
}
10004f7e:	1c18      	adds	r0, r3, #0
10004f80:	46bd      	mov	sp, r7
10004f82:	b002      	add	sp, #8
10004f84:	bd80      	pop	{r7, pc}
10004f86:	46c0      	nop			; (mov r8, r8)

10004f88 <SystemCoreSetup>:
{
  .initialized = false
};
 
void SystemCoreSetup(void)
{
10004f88:	b580      	push	{r7, lr}
10004f8a:	af00      	add	r7, sp, #0
#if UC_SERIES == XMC14
  /* Enable Prefetch unit */
  SCU_GENERAL->PFUCR &= ~SCU_GENERAL_PFUCR_PFUBYP_Msk;
#endif
}
10004f8c:	46bd      	mov	sp, r7
10004f8e:	bd80      	pop	{r7, pc}

10004f90 <CLOCK_XMC1_Init>:

/*
 * API to initialize the CLOCK_XMC1 APP Interrupts
 */
CLOCK_XMC1_STATUS_t CLOCK_XMC1_Init(CLOCK_XMC1_t *handle)
{
10004f90:	b580      	push	{r7, lr}
10004f92:	b084      	sub	sp, #16
10004f94:	af00      	add	r7, sp, #0
10004f96:	6078      	str	r0, [r7, #4]
  CLOCK_XMC1_STATUS_t status = CLOCK_XMC1_STATUS_SUCCESS;
10004f98:	230f      	movs	r3, #15
10004f9a:	18fb      	adds	r3, r7, r3
10004f9c:	2200      	movs	r2, #0
10004f9e:	701a      	strb	r2, [r3, #0]
  CLOCK_XMC1_STATUS_t loci_event_status = CLOCK_XMC1_STATUS_SUCCESS;
10004fa0:	230e      	movs	r3, #14
10004fa2:	18fb      	adds	r3, r7, r3
10004fa4:	2200      	movs	r2, #0
10004fa6:	701a      	strb	r2, [r3, #0]
  CLOCK_XMC1_STATUS_t stdbyclkfail_status = CLOCK_XMC1_STATUS_SUCCESS;
10004fa8:	230d      	movs	r3, #13
10004faa:	18fb      	adds	r3, r7, r3
10004fac:	2200      	movs	r2, #0
10004fae:	701a      	strb	r2, [r3, #0]
  CLOCK_XMC1_STATUS_t loss_ext_clock_event_status = CLOCK_XMC1_STATUS_SUCCESS;
10004fb0:	230c      	movs	r3, #12
10004fb2:	18fb      	adds	r3, r7, r3
10004fb4:	2200      	movs	r2, #0
10004fb6:	701a      	strb	r2, [r3, #0]
  CLOCK_XMC1_STATUS_t dco1_out_sync_status = CLOCK_XMC1_STATUS_SUCCESS;
10004fb8:	230b      	movs	r3, #11
10004fba:	18fb      	adds	r3, r7, r3
10004fbc:	2200      	movs	r2, #0
10004fbe:	701a      	strb	r2, [r3, #0]

  XMC_ASSERT("CLOCK_XMC1_Init: CLOCK_XMC1 APP handle pointer uninitialized", (handle != NULL));

  if (handle->init_status == false)
10004fc0:	687b      	ldr	r3, [r7, #4]
10004fc2:	781b      	ldrb	r3, [r3, #0]
10004fc4:	2201      	movs	r2, #1
10004fc6:	4053      	eors	r3, r2
10004fc8:	b2db      	uxtb	r3, r3
10004fca:	2b00      	cmp	r3, #0
10004fcc:	d01b      	beq.n	10005006 <CLOCK_XMC1_Init+0x76>

#endif
    }

#endif
    status = (CLOCK_XMC1_STATUS_t)(((uint32_t)loci_event_status) | ((uint32_t)stdbyclkfail_status) |
10004fce:	230e      	movs	r3, #14
10004fd0:	18fa      	adds	r2, r7, r3
10004fd2:	230d      	movs	r3, #13
10004fd4:	18fb      	adds	r3, r7, r3
10004fd6:	7812      	ldrb	r2, [r2, #0]
10004fd8:	781b      	ldrb	r3, [r3, #0]
10004fda:	4313      	orrs	r3, r2
10004fdc:	b2da      	uxtb	r2, r3
10004fde:	230c      	movs	r3, #12
10004fe0:	18fb      	adds	r3, r7, r3
10004fe2:	781b      	ldrb	r3, [r3, #0]
10004fe4:	4313      	orrs	r3, r2
10004fe6:	b2d9      	uxtb	r1, r3
10004fe8:	230f      	movs	r3, #15
10004fea:	18fb      	adds	r3, r7, r3
10004fec:	220b      	movs	r2, #11
10004fee:	18ba      	adds	r2, r7, r2
10004ff0:	7812      	ldrb	r2, [r2, #0]
10004ff2:	430a      	orrs	r2, r1
10004ff4:	701a      	strb	r2, [r3, #0]
    		                       ((uint32_t)loss_ext_clock_event_status) | ((uint32_t)dco1_out_sync_status));
    if (CLOCK_XMC1_STATUS_SUCCESS == status)
10004ff6:	230f      	movs	r3, #15
10004ff8:	18fb      	adds	r3, r7, r3
10004ffa:	781b      	ldrb	r3, [r3, #0]
10004ffc:	2b00      	cmp	r3, #0
10004ffe:	d102      	bne.n	10005006 <CLOCK_XMC1_Init+0x76>
    {
      handle->init_status = true;
10005000:	687b      	ldr	r3, [r7, #4]
10005002:	2201      	movs	r2, #1
10005004:	701a      	strb	r2, [r3, #0]
    }
  }
  return (status);
10005006:	230f      	movs	r3, #15
10005008:	18fb      	adds	r3, r7, r3
1000500a:	781b      	ldrb	r3, [r3, #0]
}
1000500c:	1c18      	adds	r0, r3, #0
1000500e:	46bd      	mov	sp, r7
10005010:	b004      	add	sp, #16
10005012:	bd80      	pop	{r7, pc}

10005014 <SystemCoreClockSetup>:

/**********************************************************************************************************************
* API IMPLEMENTATION
**********************************************************************************************************************/
void SystemCoreClockSetup(void)
{
10005014:	b590      	push	{r4, r7, lr}
10005016:	b085      	sub	sp, #20
10005018:	af00      	add	r7, sp, #0
/* LOCAL DATA STRUCTURES */
const XMC_SCU_CLOCK_CONFIG_t CLOCK_XMC1_0_CONFIG =
1000501a:	1d3b      	adds	r3, r7, #4
1000501c:	4a04      	ldr	r2, [pc, #16]	; (10005030 <SystemCoreClockSetup+0x1c>)
1000501e:	ca13      	ldmia	r2!, {r0, r1, r4}
10005020:	c313      	stmia	r3!, {r0, r1, r4}
  .idiv = 1U,  /**< 8 Bit integer divider */

};

  /* Configure FDIV, IDIV, PCLKSEL dividers*/
  XMC_SCU_CLOCK_Init(&CLOCK_XMC1_0_CONFIG);
10005022:	1d3b      	adds	r3, r7, #4
10005024:	1c18      	adds	r0, r3, #0
10005026:	f7fc f949 	bl	100012bc <XMC_SCU_CLOCK_Init>
}
1000502a:	46bd      	mov	sp, r7
1000502c:	b005      	add	sp, #20
1000502e:	bd90      	pop	{r4, r7, pc}
10005030:	1000a69c 	.word	0x1000a69c

10005034 <DAVE_Init>:
 * @param[in]  None
 *
 * @return  DAVE_STATUS_t <BR>
 ******************************************************************************/
__WEAK DAVE_STATUS_t DAVE_Init(void)
{
10005034:	b590      	push	{r4, r7, lr}
10005036:	b083      	sub	sp, #12
10005038:	af00      	add	r7, sp, #0
  DAVE_STATUS_t init_status;
  
  init_status = DAVE_STATUS_SUCCESS;
1000503a:	1dfb      	adds	r3, r7, #7
1000503c:	2200      	movs	r2, #0
1000503e:	701a      	strb	r2, [r3, #0]
     /** @Initialization of APPs Init Functions */
     init_status = (DAVE_STATUS_t)CLOCK_XMC1_Init(&CLOCK_XMC1_0);
10005040:	1dfc      	adds	r4, r7, #7
10005042:	4b42      	ldr	r3, [pc, #264]	; (1000514c <DAVE_Init+0x118>)
10005044:	1c18      	adds	r0, r3, #0
10005046:	f7ff ffa3 	bl	10004f90 <CLOCK_XMC1_Init>
1000504a:	1c03      	adds	r3, r0, #0
1000504c:	7023      	strb	r3, [r4, #0]

  if (init_status == DAVE_STATUS_SUCCESS)
1000504e:	1dfb      	adds	r3, r7, #7
10005050:	781b      	ldrb	r3, [r3, #0]
10005052:	2b00      	cmp	r3, #0
10005054:	d106      	bne.n	10005064 <DAVE_Init+0x30>
  {
	 /**  Initialization of TIMER APP instance TIMER_ECHO_IN */
	 init_status = (DAVE_STATUS_t)TIMER_Init(&TIMER_ECHO_IN); 
10005056:	1dfc      	adds	r4, r7, #7
10005058:	4b3d      	ldr	r3, [pc, #244]	; (10005150 <DAVE_Init+0x11c>)
1000505a:	1c18      	adds	r0, r3, #0
1000505c:	f7fd fab6 	bl	100025cc <TIMER_Init>
10005060:	1c03      	adds	r3, r0, #0
10005062:	7023      	strb	r3, [r4, #0]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
10005064:	1dfb      	adds	r3, r7, #7
10005066:	781b      	ldrb	r3, [r3, #0]
10005068:	2b00      	cmp	r3, #0
1000506a:	d106      	bne.n	1000507a <DAVE_Init+0x46>
  {
	 /**  Initialization of INTERRUPT APP instance INTERRUPT_ECHO_IN */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&INTERRUPT_ECHO_IN); 
1000506c:	1dfc      	adds	r4, r7, #7
1000506e:	4b39      	ldr	r3, [pc, #228]	; (10005154 <DAVE_Init+0x120>)
10005070:	1c18      	adds	r0, r3, #0
10005072:	f7fd fd39 	bl	10002ae8 <INTERRUPT_Init>
10005076:	1c03      	adds	r3, r0, #0
10005078:	7023      	strb	r3, [r4, #0]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
1000507a:	1dfb      	adds	r3, r7, #7
1000507c:	781b      	ldrb	r3, [r3, #0]
1000507e:	2b00      	cmp	r3, #0
10005080:	d106      	bne.n	10005090 <DAVE_Init+0x5c>
  {
	 /**  Initialization of DIGITAL_IO APP instance ECHO_OUT */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&ECHO_OUT); 
10005082:	1dfc      	adds	r4, r7, #7
10005084:	4b34      	ldr	r3, [pc, #208]	; (10005158 <DAVE_Init+0x124>)
10005086:	1c18      	adds	r0, r3, #0
10005088:	f7ff ff5e 	bl	10004f48 <DIGITAL_IO_Init>
1000508c:	1c03      	adds	r3, r0, #0
1000508e:	7023      	strb	r3, [r4, #0]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
10005090:	1dfb      	adds	r3, r7, #7
10005092:	781b      	ldrb	r3, [r3, #0]
10005094:	2b00      	cmp	r3, #0
10005096:	d106      	bne.n	100050a6 <DAVE_Init+0x72>
  {
	 /**  Initialization of PWM APP instance TRIGGER_IN */
	 init_status = (DAVE_STATUS_t)PWM_Init(&TRIGGER_IN); 
10005098:	1dfc      	adds	r4, r7, #7
1000509a:	4b30      	ldr	r3, [pc, #192]	; (1000515c <DAVE_Init+0x128>)
1000509c:	1c18      	adds	r0, r3, #0
1000509e:	f7fd fc65 	bl	1000296c <PWM_Init>
100050a2:	1c03      	adds	r3, r0, #0
100050a4:	7023      	strb	r3, [r4, #0]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
100050a6:	1dfb      	adds	r3, r7, #7
100050a8:	781b      	ldrb	r3, [r3, #0]
100050aa:	2b00      	cmp	r3, #0
100050ac:	d106      	bne.n	100050bc <DAVE_Init+0x88>
  {
	 /**  Initialization of DIGITAL_IO APP instance ECHO_IN */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&ECHO_IN); 
100050ae:	1dfc      	adds	r4, r7, #7
100050b0:	4b2b      	ldr	r3, [pc, #172]	; (10005160 <DAVE_Init+0x12c>)
100050b2:	1c18      	adds	r0, r3, #0
100050b4:	f7ff ff48 	bl	10004f48 <DIGITAL_IO_Init>
100050b8:	1c03      	adds	r3, r0, #0
100050ba:	7023      	strb	r3, [r4, #0]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
100050bc:	1dfb      	adds	r3, r7, #7
100050be:	781b      	ldrb	r3, [r3, #0]
100050c0:	2b00      	cmp	r3, #0
100050c2:	d106      	bne.n	100050d2 <DAVE_Init+0x9e>
  {
	 /**  Initialization of UART APP instance UART_BLUETOOTH */
	 init_status = (DAVE_STATUS_t)UART_Init(&UART_BLUETOOTH); 
100050c4:	1dfc      	adds	r4, r7, #7
100050c6:	4b27      	ldr	r3, [pc, #156]	; (10005164 <DAVE_Init+0x130>)
100050c8:	1c18      	adds	r0, r3, #0
100050ca:	f7fc fee1 	bl	10001e90 <UART_Init>
100050ce:	1c03      	adds	r3, r0, #0
100050d0:	7023      	strb	r3, [r4, #0]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
100050d2:	1dfb      	adds	r3, r7, #7
100050d4:	781b      	ldrb	r3, [r3, #0]
100050d6:	2b00      	cmp	r3, #0
100050d8:	d106      	bne.n	100050e8 <DAVE_Init+0xb4>
  {
	 /**  Initialization of PWM APP instance TRIGGER_OUT */
	 init_status = (DAVE_STATUS_t)PWM_Init(&TRIGGER_OUT); 
100050da:	1dfc      	adds	r4, r7, #7
100050dc:	4b22      	ldr	r3, [pc, #136]	; (10005168 <DAVE_Init+0x134>)
100050de:	1c18      	adds	r0, r3, #0
100050e0:	f7fd fc44 	bl	1000296c <PWM_Init>
100050e4:	1c03      	adds	r3, r0, #0
100050e6:	7023      	strb	r3, [r4, #0]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
100050e8:	1dfb      	adds	r3, r7, #7
100050ea:	781b      	ldrb	r3, [r3, #0]
100050ec:	2b00      	cmp	r3, #0
100050ee:	d106      	bne.n	100050fe <DAVE_Init+0xca>
  {
	 /**  Initialization of TIMER APP instance TIMER_ECHO_OUT */
	 init_status = (DAVE_STATUS_t)TIMER_Init(&TIMER_ECHO_OUT); 
100050f0:	1dfc      	adds	r4, r7, #7
100050f2:	4b1e      	ldr	r3, [pc, #120]	; (1000516c <DAVE_Init+0x138>)
100050f4:	1c18      	adds	r0, r3, #0
100050f6:	f7fd fa69 	bl	100025cc <TIMER_Init>
100050fa:	1c03      	adds	r3, r0, #0
100050fc:	7023      	strb	r3, [r4, #0]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
100050fe:	1dfb      	adds	r3, r7, #7
10005100:	781b      	ldrb	r3, [r3, #0]
10005102:	2b00      	cmp	r3, #0
10005104:	d106      	bne.n	10005114 <DAVE_Init+0xe0>
  {
	 /**  Initialization of INTERRUPT APP instance INTERRUPT_ECHO_OUT */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&INTERRUPT_ECHO_OUT); 
10005106:	1dfc      	adds	r4, r7, #7
10005108:	4b19      	ldr	r3, [pc, #100]	; (10005170 <DAVE_Init+0x13c>)
1000510a:	1c18      	adds	r0, r3, #0
1000510c:	f7fd fcec 	bl	10002ae8 <INTERRUPT_Init>
10005110:	1c03      	adds	r3, r0, #0
10005112:	7023      	strb	r3, [r4, #0]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
10005114:	1dfb      	adds	r3, r7, #7
10005116:	781b      	ldrb	r3, [r3, #0]
10005118:	2b00      	cmp	r3, #0
1000511a:	d106      	bne.n	1000512a <DAVE_Init+0xf6>
  {
	 /**  Initialization of DIGITAL_IO APP instance GREEN_LED */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&GREEN_LED); 
1000511c:	1dfc      	adds	r4, r7, #7
1000511e:	4b15      	ldr	r3, [pc, #84]	; (10005174 <DAVE_Init+0x140>)
10005120:	1c18      	adds	r0, r3, #0
10005122:	f7ff ff11 	bl	10004f48 <DIGITAL_IO_Init>
10005126:	1c03      	adds	r3, r0, #0
10005128:	7023      	strb	r3, [r4, #0]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
1000512a:	1dfb      	adds	r3, r7, #7
1000512c:	781b      	ldrb	r3, [r3, #0]
1000512e:	2b00      	cmp	r3, #0
10005130:	d106      	bne.n	10005140 <DAVE_Init+0x10c>
  {
	 /**  Initialization of DIGITAL_IO APP instance RED_LED */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&RED_LED); 
10005132:	1dfc      	adds	r4, r7, #7
10005134:	4b10      	ldr	r3, [pc, #64]	; (10005178 <DAVE_Init+0x144>)
10005136:	1c18      	adds	r0, r3, #0
10005138:	f7ff ff06 	bl	10004f48 <DIGITAL_IO_Init>
1000513c:	1c03      	adds	r3, r0, #0
1000513e:	7023      	strb	r3, [r4, #0]
   }  
  return init_status;
10005140:	1dfb      	adds	r3, r7, #7
10005142:	781b      	ldrb	r3, [r3, #0]
} /**  End of function DAVE_Init */
10005144:	1c18      	adds	r0, r3, #0
10005146:	46bd      	mov	sp, r7
10005148:	b003      	add	sp, #12
1000514a:	bd90      	pop	{r4, r7, pc}
1000514c:	20000818 	.word	0x20000818
10005150:	2000052c 	.word	0x2000052c
10005154:	1000a604 	.word	0x1000a604
10005158:	1000a65c 	.word	0x1000a65c
1000515c:	2000057c 	.word	0x2000057c
10005160:	1000a66c 	.word	0x1000a66c
10005164:	20000520 	.word	0x20000520
10005168:	200005b0 	.word	0x200005b0
1000516c:	20000554 	.word	0x20000554
10005170:	1000a608 	.word	0x1000a608
10005174:	1000a67c 	.word	0x1000a67c
10005178:	1000a68c 	.word	0x1000a68c

1000517c <XMC_GPIO_SetOutputHigh>:
 * Register Pn_OMR is virtual and does not contain any flip-flop. A read action delivers the value of 0.
 *
 */

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
1000517c:	b580      	push	{r7, lr}
1000517e:	b082      	sub	sp, #8
10005180:	af00      	add	r7, sp, #0
10005182:	6078      	str	r0, [r7, #4]
10005184:	1c0a      	adds	r2, r1, #0
10005186:	1cfb      	adds	r3, r7, #3
10005188:	701a      	strb	r2, [r3, #0]
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
1000518a:	1cfb      	adds	r3, r7, #3
1000518c:	781b      	ldrb	r3, [r3, #0]
1000518e:	2201      	movs	r2, #1
10005190:	409a      	lsls	r2, r3
10005192:	687b      	ldr	r3, [r7, #4]
10005194:	605a      	str	r2, [r3, #4]
}
10005196:	46bd      	mov	sp, r7
10005198:	b002      	add	sp, #8
1000519a:	bd80      	pop	{r7, pc}

1000519c <XMC_GPIO_SetOutputLow>:
 * Register Pn_OMR is virtual and does not contain any flip-flop. A read action delivers the value of 0.\n
 *
 */

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
1000519c:	b580      	push	{r7, lr}
1000519e:	b082      	sub	sp, #8
100051a0:	af00      	add	r7, sp, #0
100051a2:	6078      	str	r0, [r7, #4]
100051a4:	1c0a      	adds	r2, r1, #0
100051a6:	1cfb      	adds	r3, r7, #3
100051a8:	701a      	strb	r2, [r3, #0]
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
100051aa:	1cfb      	adds	r3, r7, #3
100051ac:	781b      	ldrb	r3, [r3, #0]
100051ae:	2280      	movs	r2, #128	; 0x80
100051b0:	0252      	lsls	r2, r2, #9
100051b2:	409a      	lsls	r2, r3
100051b4:	687b      	ldr	r3, [r7, #4]
100051b6:	605a      	str	r2, [r3, #4]
}
100051b8:	46bd      	mov	sp, r7
100051ba:	b002      	add	sp, #8
100051bc:	bd80      	pop	{r7, pc}
100051be:	46c0      	nop			; (mov r8, r8)

100051c0 <XMC_GPIO_GetInput>:
 * Prior to this api, user has to configure port pin to input mode using XMC_GPIO_SetMode().
 *
 */

__STATIC_INLINE uint32_t XMC_GPIO_GetInput(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
100051c0:	b580      	push	{r7, lr}
100051c2:	b082      	sub	sp, #8
100051c4:	af00      	add	r7, sp, #0
100051c6:	6078      	str	r0, [r7, #4]
100051c8:	1c0a      	adds	r2, r1, #0
100051ca:	1cfb      	adds	r3, r7, #3
100051cc:	701a      	strb	r2, [r3, #0]
  XMC_ASSERT("XMC_GPIO_GetInput: Invalid port", XMC_GPIO_CHECK_PORT(port));

  return (((port->IN) >> pin) & 0x1U);
100051ce:	687b      	ldr	r3, [r7, #4]
100051d0:	6a5a      	ldr	r2, [r3, #36]	; 0x24
100051d2:	1cfb      	adds	r3, r7, #3
100051d4:	781b      	ldrb	r3, [r3, #0]
100051d6:	40da      	lsrs	r2, r3
100051d8:	1c13      	adds	r3, r2, #0
100051da:	2201      	movs	r2, #1
100051dc:	4013      	ands	r3, r2
}
100051de:	1c18      	adds	r0, r3, #0
100051e0:	46bd      	mov	sp, r7
100051e2:	b002      	add	sp, #8
100051e4:	bd80      	pop	{r7, pc}
100051e6:	46c0      	nop			; (mov r8, r8)

100051e8 <DIGITAL_IO_SetOutputHigh>:
* }
*  @endcode
*/

__STATIC_INLINE void DIGITAL_IO_SetOutputHigh(const DIGITAL_IO_t *const handler)
{
100051e8:	b580      	push	{r7, lr}
100051ea:	b082      	sub	sp, #8
100051ec:	af00      	add	r7, sp, #0
100051ee:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("DIGITAL_IO_SetOutputHigh: handler null pointer", handler != NULL);
  XMC_GPIO_SetOutputHigh(handler->gpio_port, handler->gpio_pin);
100051f0:	687b      	ldr	r3, [r7, #4]
100051f2:	681a      	ldr	r2, [r3, #0]
100051f4:	687b      	ldr	r3, [r7, #4]
100051f6:	7b1b      	ldrb	r3, [r3, #12]
100051f8:	1c10      	adds	r0, r2, #0
100051fa:	1c19      	adds	r1, r3, #0
100051fc:	f7ff ffbe 	bl	1000517c <XMC_GPIO_SetOutputHigh>
}
10005200:	46bd      	mov	sp, r7
10005202:	b002      	add	sp, #8
10005204:	bd80      	pop	{r7, pc}
10005206:	46c0      	nop			; (mov r8, r8)

10005208 <DIGITAL_IO_SetOutputLow>:
* }
*  @endcode
*/

__STATIC_INLINE void DIGITAL_IO_SetOutputLow(const DIGITAL_IO_t *const handler)
{
10005208:	b580      	push	{r7, lr}
1000520a:	b082      	sub	sp, #8
1000520c:	af00      	add	r7, sp, #0
1000520e:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("DIGITAL_IO_SetOutputLow: handler null pointer", handler != NULL);
  XMC_GPIO_SetOutputLow(handler->gpio_port,handler->gpio_pin);
10005210:	687b      	ldr	r3, [r7, #4]
10005212:	681a      	ldr	r2, [r3, #0]
10005214:	687b      	ldr	r3, [r7, #4]
10005216:	7b1b      	ldrb	r3, [r3, #12]
10005218:	1c10      	adds	r0, r2, #0
1000521a:	1c19      	adds	r1, r3, #0
1000521c:	f7ff ffbe 	bl	1000519c <XMC_GPIO_SetOutputLow>
}
10005220:	46bd      	mov	sp, r7
10005222:	b002      	add	sp, #8
10005224:	bd80      	pop	{r7, pc}
10005226:	46c0      	nop			; (mov r8, r8)

10005228 <DIGITAL_IO_GetInput>:
* }
*  @endcode
*/

__STATIC_INLINE uint32_t DIGITAL_IO_GetInput(const DIGITAL_IO_t *const handler)
{
10005228:	b580      	push	{r7, lr}
1000522a:	b082      	sub	sp, #8
1000522c:	af00      	add	r7, sp, #0
1000522e:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("DIGITAL_IO_GetInput: handler null pointer", handler != NULL);
  return XMC_GPIO_GetInput(handler->gpio_port, handler->gpio_pin);
10005230:	687b      	ldr	r3, [r7, #4]
10005232:	681a      	ldr	r2, [r3, #0]
10005234:	687b      	ldr	r3, [r7, #4]
10005236:	7b1b      	ldrb	r3, [r3, #12]
10005238:	1c10      	adds	r0, r2, #0
1000523a:	1c19      	adds	r1, r3, #0
1000523c:	f7ff ffc0 	bl	100051c0 <XMC_GPIO_GetInput>
10005240:	1c03      	adds	r3, r0, #0
}
10005242:	1c18      	adds	r0, r3, #0
10005244:	46bd      	mov	sp, r7
10005246:	b002      	add	sp, #8
10005248:	bd80      	pop	{r7, pc}
1000524a:	46c0      	nop			; (mov r8, r8)

1000524c <main>:

void ProcessingTask(void *pvParameters);
void CommunicationTask(void *pvParameters);

int main(void)
{
1000524c:	b590      	push	{r4, r7, lr}
1000524e:	b085      	sub	sp, #20
10005250:	af02      	add	r7, sp, #8
  initialise_monitor_handles();
10005252:	f005 f81d 	bl	1000a290 <initialise_monitor_handles>
  DAVE_STATUS_t status;

  status = DAVE_Init();
10005256:	1dfc      	adds	r4, r7, #7
10005258:	f7ff feec 	bl	10005034 <DAVE_Init>
1000525c:	1c03      	adds	r3, r0, #0
1000525e:	7023      	strb	r3, [r4, #0]

  if (status != DAVE_STATUS_SUCCESS)
10005260:	1dfb      	adds	r3, r7, #7
10005262:	781b      	ldrb	r3, [r3, #0]
10005264:	2b00      	cmp	r3, #0
10005266:	d004      	beq.n	10005272 <main+0x26>
  {
	  printf("DAVE APPs initialization failed\n");
10005268:	4b1c      	ldr	r3, [pc, #112]	; (100052dc <main+0x90>)
1000526a:	1c18      	adds	r0, r3, #0
1000526c:	f001 f93e 	bl	100064ec <puts>

	  while(1U);
10005270:	e7fe      	b.n	10005270 <main+0x24>
  }
  printf("Start\n");
10005272:	4b1b      	ldr	r3, [pc, #108]	; (100052e0 <main+0x94>)
10005274:	1c18      	adds	r0, r3, #0
10005276:	f001 f939 	bl	100064ec <puts>
  TIMER_Start(&TIMER_ECHO_IN);
1000527a:	4b1a      	ldr	r3, [pc, #104]	; (100052e4 <main+0x98>)
1000527c:	1c18      	adds	r0, r3, #0
1000527e:	f7fd f9c9 	bl	10002614 <TIMER_Start>
  TIMER_Start(&TIMER_ECHO_OUT);
10005282:	4b19      	ldr	r3, [pc, #100]	; (100052e8 <main+0x9c>)
10005284:	1c18      	adds	r0, r3, #0
10005286:	f7fd f9c5 	bl	10002614 <TIMER_Start>

  xSemaphore = xSemaphoreCreateMutex();
1000528a:	2001      	movs	r0, #1
1000528c:	f7fd ff50 	bl	10003130 <xQueueCreateMutex>
10005290:	1c02      	adds	r2, r0, #0
10005292:	4b16      	ldr	r3, [pc, #88]	; (100052ec <main+0xa0>)
10005294:	601a      	str	r2, [r3, #0]
  xQueue = xQueueCreate(5, sizeof(uint8_t));
10005296:	2005      	movs	r0, #5
10005298:	2101      	movs	r1, #1
1000529a:	2200      	movs	r2, #0
1000529c:	f7fd feba 	bl	10003014 <xQueueGenericCreate>
100052a0:	1c02      	adds	r2, r0, #0
100052a2:	4b13      	ldr	r3, [pc, #76]	; (100052f0 <main+0xa4>)
100052a4:	601a      	str	r2, [r3, #0]

  xTaskCreate(ProcessingTask, "Processing Task", 200, NULL, 2, NULL);
100052a6:	4913      	ldr	r1, [pc, #76]	; (100052f4 <main+0xa8>)
100052a8:	4a13      	ldr	r2, [pc, #76]	; (100052f8 <main+0xac>)
100052aa:	2302      	movs	r3, #2
100052ac:	9300      	str	r3, [sp, #0]
100052ae:	2300      	movs	r3, #0
100052b0:	9301      	str	r3, [sp, #4]
100052b2:	1c08      	adds	r0, r1, #0
100052b4:	1c11      	adds	r1, r2, #0
100052b6:	22c8      	movs	r2, #200	; 0xc8
100052b8:	2300      	movs	r3, #0
100052ba:	f7fe fc67 	bl	10003b8c <xTaskCreate>
  xTaskCreate(CommunicationTask, "Communication Task", 200, NULL, 1, NULL);
100052be:	490f      	ldr	r1, [pc, #60]	; (100052fc <main+0xb0>)
100052c0:	4a0f      	ldr	r2, [pc, #60]	; (10005300 <main+0xb4>)
100052c2:	2301      	movs	r3, #1
100052c4:	9300      	str	r3, [sp, #0]
100052c6:	2300      	movs	r3, #0
100052c8:	9301      	str	r3, [sp, #4]
100052ca:	1c08      	adds	r0, r1, #0
100052cc:	1c11      	adds	r1, r2, #0
100052ce:	22c8      	movs	r2, #200	; 0xc8
100052d0:	2300      	movs	r3, #0
100052d2:	f7fe fc5b 	bl	10003b8c <xTaskCreate>

  vTaskStartScheduler();
100052d6:	f7fe fdc7 	bl	10003e68 <vTaskStartScheduler>

  while(1U);
100052da:	e7fe      	b.n	100052da <main+0x8e>
100052dc:	1000a6a8 	.word	0x1000a6a8
100052e0:	1000a6c8 	.word	0x1000a6c8
100052e4:	2000052c 	.word	0x2000052c
100052e8:	20000554 	.word	0x20000554
100052ec:	20000914 	.word	0x20000914
100052f0:	20000920 	.word	0x20000920
100052f4:	10005305 	.word	0x10005305
100052f8:	1000a6d0 	.word	0x1000a6d0
100052fc:	1000534d 	.word	0x1000534d
10005300:	1000a6e0 	.word	0x1000a6e0

10005304 <ProcessingTask>:
}

void ProcessingTask(void *pvParameters)
{
10005304:	b580      	push	{r7, lr}
10005306:	b084      	sub	sp, #16
10005308:	af00      	add	r7, sp, #0
1000530a:	6078      	str	r0, [r7, #4]
    uint32_t start_time, end_time;
    task_timer_counter = 0;
1000530c:	4b0d      	ldr	r3, [pc, #52]	; (10005344 <ProcessingTask+0x40>)
1000530e:	2200      	movs	r2, #0
10005310:	601a      	str	r2, [r3, #0]
	while (1)
	{
        start_time = task_timer_counter;
10005312:	4b0c      	ldr	r3, [pc, #48]	; (10005344 <ProcessingTask+0x40>)
10005314:	681b      	ldr	r3, [r3, #0]
10005316:	60fb      	str	r3, [r7, #12]
		check_entrance();
10005318:	f000 f87c 	bl	10005414 <check_entrance>
		check_exit();
1000531c:	f000 f8f4 	bl	10005508 <check_exit>
		update_leds();
10005320:	f000 f96c 	bl	100055fc <update_leds>

		end_time = task_timer_counter;
10005324:	4b07      	ldr	r3, [pc, #28]	; (10005344 <ProcessingTask+0x40>)
10005326:	681b      	ldr	r3, [r3, #0]
10005328:	60bb      	str	r3, [r7, #8]

        printf("ProcessingTask duration: %lu us\n", (end_time - start_time)*1000);
1000532a:	68ba      	ldr	r2, [r7, #8]
1000532c:	68fb      	ldr	r3, [r7, #12]
1000532e:	1ad3      	subs	r3, r2, r3
10005330:	22fa      	movs	r2, #250	; 0xfa
10005332:	0092      	lsls	r2, r2, #2
10005334:	4353      	muls	r3, r2
10005336:	4a04      	ldr	r2, [pc, #16]	; (10005348 <ProcessingTask+0x44>)
10005338:	1c10      	adds	r0, r2, #0
1000533a:	1c19      	adds	r1, r3, #0
1000533c:	f001 f85a 	bl	100063f4 <iprintf>

	}
10005340:	e7e7      	b.n	10005312 <ProcessingTask+0xe>
10005342:	46c0      	nop			; (mov r8, r8)
10005344:	20000924 	.word	0x20000924
10005348:	1000a6f4 	.word	0x1000a6f4

1000534c <CommunicationTask>:
}

void CommunicationTask(void *pvParameters)
{
1000534c:	b590      	push	{r4, r7, lr}
1000534e:	b09d      	sub	sp, #116	; 0x74
10005350:	af00      	add	r7, sp, #0
10005352:	6078      	str	r0, [r7, #4]
    uint8_t occupied_spaces;
    char message[100];

    while (1)
    {
        if (xQueueReceive(xQueue, &occupied_spaces, portMAX_DELAY) == pdPASS)
10005354:	4b2a      	ldr	r3, [pc, #168]	; (10005400 <CommunicationTask+0xb4>)
10005356:	6819      	ldr	r1, [r3, #0]
10005358:	236f      	movs	r3, #111	; 0x6f
1000535a:	18fa      	adds	r2, r7, r3
1000535c:	2301      	movs	r3, #1
1000535e:	425b      	negs	r3, r3
10005360:	1c08      	adds	r0, r1, #0
10005362:	1c11      	adds	r1, r2, #0
10005364:	1c1a      	adds	r2, r3, #0
10005366:	f7fe f87d 	bl	10003464 <xQueueReceive>
1000536a:	1e03      	subs	r3, r0, #0
1000536c:	2b01      	cmp	r3, #1
1000536e:	d145      	bne.n	100053fc <CommunicationTask+0xb0>
        {
        	printf("occupied_spaces = %lu\n", occupied_spaces);
10005370:	236f      	movs	r3, #111	; 0x6f
10005372:	18fb      	adds	r3, r7, r3
10005374:	781b      	ldrb	r3, [r3, #0]
10005376:	1c1a      	adds	r2, r3, #0
10005378:	4b22      	ldr	r3, [pc, #136]	; (10005404 <CommunicationTask+0xb8>)
1000537a:	1c18      	adds	r0, r3, #0
1000537c:	1c11      	adds	r1, r2, #0
1000537e:	f001 f839 	bl	100063f4 <iprintf>
            sprintf(message, "Free spaces: %d\n", (PARK_SPACES - occupied_spaces));
10005382:	236f      	movs	r3, #111	; 0x6f
10005384:	18fb      	adds	r3, r7, r3
10005386:	781b      	ldrb	r3, [r3, #0]
10005388:	1c1a      	adds	r2, r3, #0
1000538a:	2305      	movs	r3, #5
1000538c:	1a9b      	subs	r3, r3, r2
1000538e:	2208      	movs	r2, #8
10005390:	18b9      	adds	r1, r7, r2
10005392:	4a1d      	ldr	r2, [pc, #116]	; (10005408 <CommunicationTask+0xbc>)
10005394:	1c08      	adds	r0, r1, #0
10005396:	1c11      	adds	r1, r2, #0
10005398:	1c1a      	adds	r2, r3, #0
1000539a:	f001 f8eb 	bl	10006574 <siprintf>
            UART_Transmit(&UART_BLUETOOTH, (uint8_t *)message, strlen(message));
1000539e:	2308      	movs	r3, #8
100053a0:	18fb      	adds	r3, r7, r3
100053a2:	1c18      	adds	r0, r3, #0
100053a4:	f001 f908 	bl	100065b8 <strlen>
100053a8:	1c04      	adds	r4, r0, #0
100053aa:	4a18      	ldr	r2, [pc, #96]	; (1000540c <CommunicationTask+0xc0>)
100053ac:	2308      	movs	r3, #8
100053ae:	18fb      	adds	r3, r7, r3
100053b0:	1c10      	adds	r0, r2, #0
100053b2:	1c19      	adds	r1, r3, #0
100053b4:	1c22      	adds	r2, r4, #0
100053b6:	f7fc fd83 	bl	10001ec0 <UART_Transmit>
            if(occupied_spaces == PARK_SPACES)
100053ba:	236f      	movs	r3, #111	; 0x6f
100053bc:	18fb      	adds	r3, r7, r3
100053be:	781b      	ldrb	r3, [r3, #0]
100053c0:	2b05      	cmp	r3, #5
100053c2:	d11b      	bne.n	100053fc <CommunicationTask+0xb0>
            {
            	sprintf(message, "Entrance blocked!\n");
100053c4:	2308      	movs	r3, #8
100053c6:	18fb      	adds	r3, r7, r3
100053c8:	4a11      	ldr	r2, [pc, #68]	; (10005410 <CommunicationTask+0xc4>)
100053ca:	ca13      	ldmia	r2!, {r0, r1, r4}
100053cc:	c313      	stmia	r3!, {r0, r1, r4}
100053ce:	6811      	ldr	r1, [r2, #0]
100053d0:	6019      	str	r1, [r3, #0]
100053d2:	8891      	ldrh	r1, [r2, #4]
100053d4:	8099      	strh	r1, [r3, #4]
100053d6:	7992      	ldrb	r2, [r2, #6]
100053d8:	719a      	strb	r2, [r3, #6]
            	vTaskDelay(pdMS_TO_TICKS(10));
100053da:	200a      	movs	r0, #10
100053dc:	f7fe fd20 	bl	10003e20 <vTaskDelay>
                UART_Transmit(&UART_BLUETOOTH, (uint8_t *)message, strlen(message));
100053e0:	2308      	movs	r3, #8
100053e2:	18fb      	adds	r3, r7, r3
100053e4:	1c18      	adds	r0, r3, #0
100053e6:	f001 f8e7 	bl	100065b8 <strlen>
100053ea:	1c04      	adds	r4, r0, #0
100053ec:	4a07      	ldr	r2, [pc, #28]	; (1000540c <CommunicationTask+0xc0>)
100053ee:	2308      	movs	r3, #8
100053f0:	18fb      	adds	r3, r7, r3
100053f2:	1c10      	adds	r0, r2, #0
100053f4:	1c19      	adds	r1, r3, #0
100053f6:	1c22      	adds	r2, r4, #0
100053f8:	f7fc fd62 	bl	10001ec0 <UART_Transmit>
            }
        }
    }
100053fc:	e7aa      	b.n	10005354 <CommunicationTask+0x8>
100053fe:	46c0      	nop			; (mov r8, r8)
10005400:	20000920 	.word	0x20000920
10005404:	1000a718 	.word	0x1000a718
10005408:	1000a730 	.word	0x1000a730
1000540c:	20000520 	.word	0x20000520
10005410:	1000a744 	.word	0x1000a744

10005414 <check_entrance>:
}

void check_entrance(void)
{
10005414:	b580      	push	{r7, lr}
10005416:	b082      	sub	sp, #8
10005418:	af00      	add	r7, sp, #0
	uint32_t pulse_start = 0, pulse_stop = 0;
1000541a:	2300      	movs	r3, #0
1000541c:	607b      	str	r3, [r7, #4]
1000541e:	2300      	movs	r3, #0
10005420:	603b      	str	r3, [r7, #0]
	echo_in_counter = 0;
10005422:	4b31      	ldr	r3, [pc, #196]	; (100054e8 <check_entrance+0xd4>)
10005424:	2200      	movs	r2, #0
10005426:	601a      	str	r2, [r3, #0]

	while (DIGITAL_IO_GetInput(&ECHO_IN) == 0);
10005428:	46c0      	nop			; (mov r8, r8)
1000542a:	4b30      	ldr	r3, [pc, #192]	; (100054ec <check_entrance+0xd8>)
1000542c:	1c18      	adds	r0, r3, #0
1000542e:	f7ff fefb 	bl	10005228 <DIGITAL_IO_GetInput>
10005432:	1e03      	subs	r3, r0, #0
10005434:	d0f9      	beq.n	1000542a <check_entrance+0x16>
	pulse_start = echo_in_counter;
10005436:	4b2c      	ldr	r3, [pc, #176]	; (100054e8 <check_entrance+0xd4>)
10005438:	681b      	ldr	r3, [r3, #0]
1000543a:	607b      	str	r3, [r7, #4]
	while (DIGITAL_IO_GetInput(&ECHO_IN) == 1 && (echo_in_counter - pulse_start) < 3);
1000543c:	46c0      	nop			; (mov r8, r8)
1000543e:	4b2b      	ldr	r3, [pc, #172]	; (100054ec <check_entrance+0xd8>)
10005440:	1c18      	adds	r0, r3, #0
10005442:	f7ff fef1 	bl	10005228 <DIGITAL_IO_GetInput>
10005446:	1e03      	subs	r3, r0, #0
10005448:	2b01      	cmp	r3, #1
1000544a:	d105      	bne.n	10005458 <check_entrance+0x44>
1000544c:	4b26      	ldr	r3, [pc, #152]	; (100054e8 <check_entrance+0xd4>)
1000544e:	681a      	ldr	r2, [r3, #0]
10005450:	687b      	ldr	r3, [r7, #4]
10005452:	1ad3      	subs	r3, r2, r3
10005454:	2b02      	cmp	r3, #2
10005456:	d9f2      	bls.n	1000543e <check_entrance+0x2a>
	pulse_stop = echo_in_counter;
10005458:	4b23      	ldr	r3, [pc, #140]	; (100054e8 <check_entrance+0xd4>)
1000545a:	681b      	ldr	r3, [r3, #0]
1000545c:	603b      	str	r3, [r7, #0]

	printf("distance_in = %lu\n", pulse_stop - pulse_start);
1000545e:	683a      	ldr	r2, [r7, #0]
10005460:	687b      	ldr	r3, [r7, #4]
10005462:	1ad3      	subs	r3, r2, r3
10005464:	4a22      	ldr	r2, [pc, #136]	; (100054f0 <check_entrance+0xdc>)
10005466:	1c10      	adds	r0, r2, #0
10005468:	1c19      	adds	r1, r3, #0
1000546a:	f000 ffc3 	bl	100063f4 <iprintf>

	if ((pulse_stop - pulse_start) < 2 && last_distance_in >= 2)
1000546e:	683a      	ldr	r2, [r7, #0]
10005470:	687b      	ldr	r3, [r7, #4]
10005472:	1ad3      	subs	r3, r2, r3
10005474:	2b01      	cmp	r3, #1
10005476:	d82f      	bhi.n	100054d8 <check_entrance+0xc4>
10005478:	4b1e      	ldr	r3, [pc, #120]	; (100054f4 <check_entrance+0xe0>)
1000547a:	681b      	ldr	r3, [r3, #0]
1000547c:	2b01      	cmp	r3, #1
1000547e:	d92b      	bls.n	100054d8 <check_entrance+0xc4>
	{
		printf("\nCar In detected\n");
10005480:	4b1d      	ldr	r3, [pc, #116]	; (100054f8 <check_entrance+0xe4>)
10005482:	1c18      	adds	r0, r3, #0
10005484:	f001 f832 	bl	100064ec <puts>
		if (parked_cars < PARK_SPACES)
10005488:	4b1c      	ldr	r3, [pc, #112]	; (100054fc <check_entrance+0xe8>)
1000548a:	781b      	ldrb	r3, [r3, #0]
1000548c:	2b04      	cmp	r3, #4
1000548e:	d823      	bhi.n	100054d8 <check_entrance+0xc4>
		{
			if (xSemaphoreTake(xSemaphore, portMAX_DELAY) == pdTRUE)
10005490:	4b1b      	ldr	r3, [pc, #108]	; (10005500 <check_entrance+0xec>)
10005492:	681a      	ldr	r2, [r3, #0]
10005494:	2301      	movs	r3, #1
10005496:	425b      	negs	r3, r3
10005498:	1c10      	adds	r0, r2, #0
1000549a:	1c19      	adds	r1, r3, #0
1000549c:	f7fe f89c 	bl	100035d8 <xQueueSemaphoreTake>
100054a0:	1e03      	subs	r3, r0, #0
100054a2:	2b01      	cmp	r3, #1
100054a4:	d10d      	bne.n	100054c2 <check_entrance+0xae>
			{
				parked_cars++;
100054a6:	4b15      	ldr	r3, [pc, #84]	; (100054fc <check_entrance+0xe8>)
100054a8:	781b      	ldrb	r3, [r3, #0]
100054aa:	3301      	adds	r3, #1
100054ac:	b2da      	uxtb	r2, r3
100054ae:	4b13      	ldr	r3, [pc, #76]	; (100054fc <check_entrance+0xe8>)
100054b0:	701a      	strb	r2, [r3, #0]
				xSemaphoreGive(xSemaphore);
100054b2:	4b13      	ldr	r3, [pc, #76]	; (10005500 <check_entrance+0xec>)
100054b4:	681b      	ldr	r3, [r3, #0]
100054b6:	1c18      	adds	r0, r3, #0
100054b8:	2100      	movs	r1, #0
100054ba:	2200      	movs	r2, #0
100054bc:	2300      	movs	r3, #0
100054be:	f7fd fe55 	bl	1000316c <xQueueGenericSend>
			}
			xQueueSend(xQueue, &parked_cars, portMAX_DELAY);
100054c2:	4b10      	ldr	r3, [pc, #64]	; (10005504 <check_entrance+0xf0>)
100054c4:	6819      	ldr	r1, [r3, #0]
100054c6:	4a0d      	ldr	r2, [pc, #52]	; (100054fc <check_entrance+0xe8>)
100054c8:	2301      	movs	r3, #1
100054ca:	425b      	negs	r3, r3
100054cc:	1c08      	adds	r0, r1, #0
100054ce:	1c11      	adds	r1, r2, #0
100054d0:	1c1a      	adds	r2, r3, #0
100054d2:	2300      	movs	r3, #0
100054d4:	f7fd fe4a 	bl	1000316c <xQueueGenericSend>
		}
	}

	last_distance_in = pulse_stop - pulse_start;
100054d8:	683a      	ldr	r2, [r7, #0]
100054da:	687b      	ldr	r3, [r7, #4]
100054dc:	1ad2      	subs	r2, r2, r3
100054de:	4b05      	ldr	r3, [pc, #20]	; (100054f4 <check_entrance+0xe0>)
100054e0:	601a      	str	r2, [r3, #0]
}
100054e2:	46bd      	mov	sp, r7
100054e4:	b002      	add	sp, #8
100054e6:	bd80      	pop	{r7, pc}
100054e8:	2000091c 	.word	0x2000091c
100054ec:	1000a66c 	.word	0x1000a66c
100054f0:	1000a758 	.word	0x1000a758
100054f4:	200005fc 	.word	0x200005fc
100054f8:	1000a76c 	.word	0x1000a76c
100054fc:	2000081c 	.word	0x2000081c
10005500:	20000914 	.word	0x20000914
10005504:	20000920 	.word	0x20000920

10005508 <check_exit>:

void check_exit(void)
{
10005508:	b580      	push	{r7, lr}
1000550a:	b082      	sub	sp, #8
1000550c:	af00      	add	r7, sp, #0
	uint32_t pulse_start = 0, pulse_stop = 0;
1000550e:	2300      	movs	r3, #0
10005510:	607b      	str	r3, [r7, #4]
10005512:	2300      	movs	r3, #0
10005514:	603b      	str	r3, [r7, #0]
	echo_out_counter = 0;
10005516:	4b31      	ldr	r3, [pc, #196]	; (100055dc <check_exit+0xd4>)
10005518:	2200      	movs	r2, #0
1000551a:	601a      	str	r2, [r3, #0]

	while (DIGITAL_IO_GetInput(&ECHO_OUT) == 0);
1000551c:	46c0      	nop			; (mov r8, r8)
1000551e:	4b30      	ldr	r3, [pc, #192]	; (100055e0 <check_exit+0xd8>)
10005520:	1c18      	adds	r0, r3, #0
10005522:	f7ff fe81 	bl	10005228 <DIGITAL_IO_GetInput>
10005526:	1e03      	subs	r3, r0, #0
10005528:	d0f9      	beq.n	1000551e <check_exit+0x16>
	pulse_start = echo_out_counter;
1000552a:	4b2c      	ldr	r3, [pc, #176]	; (100055dc <check_exit+0xd4>)
1000552c:	681b      	ldr	r3, [r3, #0]
1000552e:	607b      	str	r3, [r7, #4]
	while (DIGITAL_IO_GetInput(&ECHO_OUT) == 1 && (echo_out_counter - pulse_start) < 3);
10005530:	46c0      	nop			; (mov r8, r8)
10005532:	4b2b      	ldr	r3, [pc, #172]	; (100055e0 <check_exit+0xd8>)
10005534:	1c18      	adds	r0, r3, #0
10005536:	f7ff fe77 	bl	10005228 <DIGITAL_IO_GetInput>
1000553a:	1e03      	subs	r3, r0, #0
1000553c:	2b01      	cmp	r3, #1
1000553e:	d105      	bne.n	1000554c <check_exit+0x44>
10005540:	4b26      	ldr	r3, [pc, #152]	; (100055dc <check_exit+0xd4>)
10005542:	681a      	ldr	r2, [r3, #0]
10005544:	687b      	ldr	r3, [r7, #4]
10005546:	1ad3      	subs	r3, r2, r3
10005548:	2b02      	cmp	r3, #2
1000554a:	d9f2      	bls.n	10005532 <check_exit+0x2a>
	pulse_stop = echo_out_counter;
1000554c:	4b23      	ldr	r3, [pc, #140]	; (100055dc <check_exit+0xd4>)
1000554e:	681b      	ldr	r3, [r3, #0]
10005550:	603b      	str	r3, [r7, #0]

	printf("distance_out = %lu\n", pulse_stop - pulse_start);
10005552:	683a      	ldr	r2, [r7, #0]
10005554:	687b      	ldr	r3, [r7, #4]
10005556:	1ad3      	subs	r3, r2, r3
10005558:	4a22      	ldr	r2, [pc, #136]	; (100055e4 <check_exit+0xdc>)
1000555a:	1c10      	adds	r0, r2, #0
1000555c:	1c19      	adds	r1, r3, #0
1000555e:	f000 ff49 	bl	100063f4 <iprintf>

	if ((pulse_stop - pulse_start) < 2 && last_distance_out >= 2)
10005562:	683a      	ldr	r2, [r7, #0]
10005564:	687b      	ldr	r3, [r7, #4]
10005566:	1ad3      	subs	r3, r2, r3
10005568:	2b01      	cmp	r3, #1
1000556a:	d82f      	bhi.n	100055cc <check_exit+0xc4>
1000556c:	4b1e      	ldr	r3, [pc, #120]	; (100055e8 <check_exit+0xe0>)
1000556e:	681b      	ldr	r3, [r3, #0]
10005570:	2b01      	cmp	r3, #1
10005572:	d92b      	bls.n	100055cc <check_exit+0xc4>
	{
		printf("\nCar Out detected\n");
10005574:	4b1d      	ldr	r3, [pc, #116]	; (100055ec <check_exit+0xe4>)
10005576:	1c18      	adds	r0, r3, #0
10005578:	f000 ffb8 	bl	100064ec <puts>
		if (parked_cars > 0) {
1000557c:	4b1c      	ldr	r3, [pc, #112]	; (100055f0 <check_exit+0xe8>)
1000557e:	781b      	ldrb	r3, [r3, #0]
10005580:	2b00      	cmp	r3, #0
10005582:	d023      	beq.n	100055cc <check_exit+0xc4>
			if (xSemaphoreTake(xSemaphore, portMAX_DELAY) == pdTRUE)
10005584:	4b1b      	ldr	r3, [pc, #108]	; (100055f4 <check_exit+0xec>)
10005586:	681a      	ldr	r2, [r3, #0]
10005588:	2301      	movs	r3, #1
1000558a:	425b      	negs	r3, r3
1000558c:	1c10      	adds	r0, r2, #0
1000558e:	1c19      	adds	r1, r3, #0
10005590:	f7fe f822 	bl	100035d8 <xQueueSemaphoreTake>
10005594:	1e03      	subs	r3, r0, #0
10005596:	2b01      	cmp	r3, #1
10005598:	d10d      	bne.n	100055b6 <check_exit+0xae>
			{
				parked_cars--;
1000559a:	4b15      	ldr	r3, [pc, #84]	; (100055f0 <check_exit+0xe8>)
1000559c:	781b      	ldrb	r3, [r3, #0]
1000559e:	3b01      	subs	r3, #1
100055a0:	b2da      	uxtb	r2, r3
100055a2:	4b13      	ldr	r3, [pc, #76]	; (100055f0 <check_exit+0xe8>)
100055a4:	701a      	strb	r2, [r3, #0]
				xSemaphoreGive(xSemaphore);
100055a6:	4b13      	ldr	r3, [pc, #76]	; (100055f4 <check_exit+0xec>)
100055a8:	681b      	ldr	r3, [r3, #0]
100055aa:	1c18      	adds	r0, r3, #0
100055ac:	2100      	movs	r1, #0
100055ae:	2200      	movs	r2, #0
100055b0:	2300      	movs	r3, #0
100055b2:	f7fd fddb 	bl	1000316c <xQueueGenericSend>
			}
			xQueueSend(xQueue, &parked_cars, portMAX_DELAY);
100055b6:	4b10      	ldr	r3, [pc, #64]	; (100055f8 <check_exit+0xf0>)
100055b8:	6819      	ldr	r1, [r3, #0]
100055ba:	4a0d      	ldr	r2, [pc, #52]	; (100055f0 <check_exit+0xe8>)
100055bc:	2301      	movs	r3, #1
100055be:	425b      	negs	r3, r3
100055c0:	1c08      	adds	r0, r1, #0
100055c2:	1c11      	adds	r1, r2, #0
100055c4:	1c1a      	adds	r2, r3, #0
100055c6:	2300      	movs	r3, #0
100055c8:	f7fd fdd0 	bl	1000316c <xQueueGenericSend>
		}
	}
	last_distance_out = pulse_stop - pulse_start;
100055cc:	683a      	ldr	r2, [r7, #0]
100055ce:	687b      	ldr	r3, [r7, #4]
100055d0:	1ad2      	subs	r2, r2, r3
100055d2:	4b05      	ldr	r3, [pc, #20]	; (100055e8 <check_exit+0xe0>)
100055d4:	601a      	str	r2, [r3, #0]
}
100055d6:	46bd      	mov	sp, r7
100055d8:	b002      	add	sp, #8
100055da:	bd80      	pop	{r7, pc}
100055dc:	20000918 	.word	0x20000918
100055e0:	1000a65c 	.word	0x1000a65c
100055e4:	1000a780 	.word	0x1000a780
100055e8:	20000600 	.word	0x20000600
100055ec:	1000a794 	.word	0x1000a794
100055f0:	2000081c 	.word	0x2000081c
100055f4:	20000914 	.word	0x20000914
100055f8:	20000920 	.word	0x20000920

100055fc <update_leds>:

void update_leds(void)
{
100055fc:	b580      	push	{r7, lr}
100055fe:	af00      	add	r7, sp, #0
	if(parked_cars == PARK_SPACES)
10005600:	4b0b      	ldr	r3, [pc, #44]	; (10005630 <update_leds+0x34>)
10005602:	781b      	ldrb	r3, [r3, #0]
10005604:	2b05      	cmp	r3, #5
10005606:	d108      	bne.n	1000561a <update_leds+0x1e>
	{
		DIGITAL_IO_SetOutputHigh(&RED_LED);
10005608:	4b0a      	ldr	r3, [pc, #40]	; (10005634 <update_leds+0x38>)
1000560a:	1c18      	adds	r0, r3, #0
1000560c:	f7ff fdec 	bl	100051e8 <DIGITAL_IO_SetOutputHigh>
		DIGITAL_IO_SetOutputLow(&GREEN_LED);
10005610:	4b09      	ldr	r3, [pc, #36]	; (10005638 <update_leds+0x3c>)
10005612:	1c18      	adds	r0, r3, #0
10005614:	f7ff fdf8 	bl	10005208 <DIGITAL_IO_SetOutputLow>
10005618:	e007      	b.n	1000562a <update_leds+0x2e>
	}
	else
	{
		DIGITAL_IO_SetOutputHigh(&GREEN_LED);
1000561a:	4b07      	ldr	r3, [pc, #28]	; (10005638 <update_leds+0x3c>)
1000561c:	1c18      	adds	r0, r3, #0
1000561e:	f7ff fde3 	bl	100051e8 <DIGITAL_IO_SetOutputHigh>
		DIGITAL_IO_SetOutputLow(&RED_LED);
10005622:	4b04      	ldr	r3, [pc, #16]	; (10005634 <update_leds+0x38>)
10005624:	1c18      	adds	r0, r3, #0
10005626:	f7ff fdef 	bl	10005208 <DIGITAL_IO_SetOutputLow>
	}
}
1000562a:	46bd      	mov	sp, r7
1000562c:	bd80      	pop	{r7, pc}
1000562e:	46c0      	nop			; (mov r8, r8)
10005630:	2000081c 	.word	0x2000081c
10005634:	1000a68c 	.word	0x1000a68c
10005638:	1000a67c 	.word	0x1000a67c

1000563c <CCU40_2_IRQHandler>:

void EchoInPulse(void)
{
1000563c:	b580      	push	{r7, lr}
1000563e:	af00      	add	r7, sp, #0
	echo_in_counter++;
10005640:	4b05      	ldr	r3, [pc, #20]	; (10005658 <CCU40_2_IRQHandler+0x1c>)
10005642:	681b      	ldr	r3, [r3, #0]
10005644:	1c5a      	adds	r2, r3, #1
10005646:	4b04      	ldr	r3, [pc, #16]	; (10005658 <CCU40_2_IRQHandler+0x1c>)
10005648:	601a      	str	r2, [r3, #0]
	task_timer_counter++;
1000564a:	4b04      	ldr	r3, [pc, #16]	; (1000565c <CCU40_2_IRQHandler+0x20>)
1000564c:	681b      	ldr	r3, [r3, #0]
1000564e:	1c5a      	adds	r2, r3, #1
10005650:	4b02      	ldr	r3, [pc, #8]	; (1000565c <CCU40_2_IRQHandler+0x20>)
10005652:	601a      	str	r2, [r3, #0]
}
10005654:	46bd      	mov	sp, r7
10005656:	bd80      	pop	{r7, pc}
10005658:	2000091c 	.word	0x2000091c
1000565c:	20000924 	.word	0x20000924

10005660 <CCU40_3_IRQHandler>:

void EchoOutPulse(void)
{
10005660:	b580      	push	{r7, lr}
10005662:	af00      	add	r7, sp, #0
	echo_out_counter++;
10005664:	4b03      	ldr	r3, [pc, #12]	; (10005674 <CCU40_3_IRQHandler+0x14>)
10005666:	681b      	ldr	r3, [r3, #0]
10005668:	1c5a      	adds	r2, r3, #1
1000566a:	4b02      	ldr	r3, [pc, #8]	; (10005674 <CCU40_3_IRQHandler+0x14>)
1000566c:	601a      	str	r2, [r3, #0]
}
1000566e:	46bd      	mov	sp, r7
10005670:	bd80      	pop	{r7, pc}
10005672:	46c0      	nop			; (mov r8, r8)
10005674:	20000918 	.word	0x20000918

10005678 <__aeabi_uidiv>:
10005678:	2200      	movs	r2, #0
1000567a:	0843      	lsrs	r3, r0, #1
1000567c:	428b      	cmp	r3, r1
1000567e:	d374      	bcc.n	1000576a <__aeabi_uidiv+0xf2>
10005680:	0903      	lsrs	r3, r0, #4
10005682:	428b      	cmp	r3, r1
10005684:	d35f      	bcc.n	10005746 <__aeabi_uidiv+0xce>
10005686:	0a03      	lsrs	r3, r0, #8
10005688:	428b      	cmp	r3, r1
1000568a:	d344      	bcc.n	10005716 <__aeabi_uidiv+0x9e>
1000568c:	0b03      	lsrs	r3, r0, #12
1000568e:	428b      	cmp	r3, r1
10005690:	d328      	bcc.n	100056e4 <__aeabi_uidiv+0x6c>
10005692:	0c03      	lsrs	r3, r0, #16
10005694:	428b      	cmp	r3, r1
10005696:	d30d      	bcc.n	100056b4 <__aeabi_uidiv+0x3c>
10005698:	22ff      	movs	r2, #255	; 0xff
1000569a:	0209      	lsls	r1, r1, #8
1000569c:	ba12      	rev	r2, r2
1000569e:	0c03      	lsrs	r3, r0, #16
100056a0:	428b      	cmp	r3, r1
100056a2:	d302      	bcc.n	100056aa <__aeabi_uidiv+0x32>
100056a4:	1212      	asrs	r2, r2, #8
100056a6:	0209      	lsls	r1, r1, #8
100056a8:	d065      	beq.n	10005776 <__aeabi_uidiv+0xfe>
100056aa:	0b03      	lsrs	r3, r0, #12
100056ac:	428b      	cmp	r3, r1
100056ae:	d319      	bcc.n	100056e4 <__aeabi_uidiv+0x6c>
100056b0:	e000      	b.n	100056b4 <__aeabi_uidiv+0x3c>
100056b2:	0a09      	lsrs	r1, r1, #8
100056b4:	0bc3      	lsrs	r3, r0, #15
100056b6:	428b      	cmp	r3, r1
100056b8:	d301      	bcc.n	100056be <__aeabi_uidiv+0x46>
100056ba:	03cb      	lsls	r3, r1, #15
100056bc:	1ac0      	subs	r0, r0, r3
100056be:	4152      	adcs	r2, r2
100056c0:	0b83      	lsrs	r3, r0, #14
100056c2:	428b      	cmp	r3, r1
100056c4:	d301      	bcc.n	100056ca <__aeabi_uidiv+0x52>
100056c6:	038b      	lsls	r3, r1, #14
100056c8:	1ac0      	subs	r0, r0, r3
100056ca:	4152      	adcs	r2, r2
100056cc:	0b43      	lsrs	r3, r0, #13
100056ce:	428b      	cmp	r3, r1
100056d0:	d301      	bcc.n	100056d6 <__aeabi_uidiv+0x5e>
100056d2:	034b      	lsls	r3, r1, #13
100056d4:	1ac0      	subs	r0, r0, r3
100056d6:	4152      	adcs	r2, r2
100056d8:	0b03      	lsrs	r3, r0, #12
100056da:	428b      	cmp	r3, r1
100056dc:	d301      	bcc.n	100056e2 <__aeabi_uidiv+0x6a>
100056de:	030b      	lsls	r3, r1, #12
100056e0:	1ac0      	subs	r0, r0, r3
100056e2:	4152      	adcs	r2, r2
100056e4:	0ac3      	lsrs	r3, r0, #11
100056e6:	428b      	cmp	r3, r1
100056e8:	d301      	bcc.n	100056ee <__aeabi_uidiv+0x76>
100056ea:	02cb      	lsls	r3, r1, #11
100056ec:	1ac0      	subs	r0, r0, r3
100056ee:	4152      	adcs	r2, r2
100056f0:	0a83      	lsrs	r3, r0, #10
100056f2:	428b      	cmp	r3, r1
100056f4:	d301      	bcc.n	100056fa <__aeabi_uidiv+0x82>
100056f6:	028b      	lsls	r3, r1, #10
100056f8:	1ac0      	subs	r0, r0, r3
100056fa:	4152      	adcs	r2, r2
100056fc:	0a43      	lsrs	r3, r0, #9
100056fe:	428b      	cmp	r3, r1
10005700:	d301      	bcc.n	10005706 <__aeabi_uidiv+0x8e>
10005702:	024b      	lsls	r3, r1, #9
10005704:	1ac0      	subs	r0, r0, r3
10005706:	4152      	adcs	r2, r2
10005708:	0a03      	lsrs	r3, r0, #8
1000570a:	428b      	cmp	r3, r1
1000570c:	d301      	bcc.n	10005712 <__aeabi_uidiv+0x9a>
1000570e:	020b      	lsls	r3, r1, #8
10005710:	1ac0      	subs	r0, r0, r3
10005712:	4152      	adcs	r2, r2
10005714:	d2cd      	bcs.n	100056b2 <__aeabi_uidiv+0x3a>
10005716:	09c3      	lsrs	r3, r0, #7
10005718:	428b      	cmp	r3, r1
1000571a:	d301      	bcc.n	10005720 <__aeabi_uidiv+0xa8>
1000571c:	01cb      	lsls	r3, r1, #7
1000571e:	1ac0      	subs	r0, r0, r3
10005720:	4152      	adcs	r2, r2
10005722:	0983      	lsrs	r3, r0, #6
10005724:	428b      	cmp	r3, r1
10005726:	d301      	bcc.n	1000572c <__aeabi_uidiv+0xb4>
10005728:	018b      	lsls	r3, r1, #6
1000572a:	1ac0      	subs	r0, r0, r3
1000572c:	4152      	adcs	r2, r2
1000572e:	0943      	lsrs	r3, r0, #5
10005730:	428b      	cmp	r3, r1
10005732:	d301      	bcc.n	10005738 <__aeabi_uidiv+0xc0>
10005734:	014b      	lsls	r3, r1, #5
10005736:	1ac0      	subs	r0, r0, r3
10005738:	4152      	adcs	r2, r2
1000573a:	0903      	lsrs	r3, r0, #4
1000573c:	428b      	cmp	r3, r1
1000573e:	d301      	bcc.n	10005744 <__aeabi_uidiv+0xcc>
10005740:	010b      	lsls	r3, r1, #4
10005742:	1ac0      	subs	r0, r0, r3
10005744:	4152      	adcs	r2, r2
10005746:	08c3      	lsrs	r3, r0, #3
10005748:	428b      	cmp	r3, r1
1000574a:	d301      	bcc.n	10005750 <__aeabi_uidiv+0xd8>
1000574c:	00cb      	lsls	r3, r1, #3
1000574e:	1ac0      	subs	r0, r0, r3
10005750:	4152      	adcs	r2, r2
10005752:	0883      	lsrs	r3, r0, #2
10005754:	428b      	cmp	r3, r1
10005756:	d301      	bcc.n	1000575c <__aeabi_uidiv+0xe4>
10005758:	008b      	lsls	r3, r1, #2
1000575a:	1ac0      	subs	r0, r0, r3
1000575c:	4152      	adcs	r2, r2
1000575e:	0843      	lsrs	r3, r0, #1
10005760:	428b      	cmp	r3, r1
10005762:	d301      	bcc.n	10005768 <__aeabi_uidiv+0xf0>
10005764:	004b      	lsls	r3, r1, #1
10005766:	1ac0      	subs	r0, r0, r3
10005768:	4152      	adcs	r2, r2
1000576a:	1a41      	subs	r1, r0, r1
1000576c:	d200      	bcs.n	10005770 <__aeabi_uidiv+0xf8>
1000576e:	4601      	mov	r1, r0
10005770:	4152      	adcs	r2, r2
10005772:	4610      	mov	r0, r2
10005774:	4770      	bx	lr
10005776:	e7ff      	b.n	10005778 <__aeabi_uidiv+0x100>
10005778:	b501      	push	{r0, lr}
1000577a:	2000      	movs	r0, #0
1000577c:	f000 f8fc 	bl	10005978 <__aeabi_idiv0>
10005780:	bd02      	pop	{r1, pc}
10005782:	46c0      	nop			; (mov r8, r8)

10005784 <__aeabi_uidivmod>:
10005784:	2900      	cmp	r1, #0
10005786:	d0f7      	beq.n	10005778 <__aeabi_uidiv+0x100>
10005788:	b503      	push	{r0, r1, lr}
1000578a:	f7ff ff75 	bl	10005678 <__aeabi_uidiv>
1000578e:	bc0e      	pop	{r1, r2, r3}
10005790:	4342      	muls	r2, r0
10005792:	1a89      	subs	r1, r1, r2
10005794:	4718      	bx	r3
10005796:	46c0      	nop			; (mov r8, r8)

10005798 <__aeabi_idiv>:
10005798:	4603      	mov	r3, r0
1000579a:	430b      	orrs	r3, r1
1000579c:	d47f      	bmi.n	1000589e <__aeabi_idiv+0x106>
1000579e:	2200      	movs	r2, #0
100057a0:	0843      	lsrs	r3, r0, #1
100057a2:	428b      	cmp	r3, r1
100057a4:	d374      	bcc.n	10005890 <__aeabi_idiv+0xf8>
100057a6:	0903      	lsrs	r3, r0, #4
100057a8:	428b      	cmp	r3, r1
100057aa:	d35f      	bcc.n	1000586c <__aeabi_idiv+0xd4>
100057ac:	0a03      	lsrs	r3, r0, #8
100057ae:	428b      	cmp	r3, r1
100057b0:	d344      	bcc.n	1000583c <__aeabi_idiv+0xa4>
100057b2:	0b03      	lsrs	r3, r0, #12
100057b4:	428b      	cmp	r3, r1
100057b6:	d328      	bcc.n	1000580a <__aeabi_idiv+0x72>
100057b8:	0c03      	lsrs	r3, r0, #16
100057ba:	428b      	cmp	r3, r1
100057bc:	d30d      	bcc.n	100057da <__aeabi_idiv+0x42>
100057be:	22ff      	movs	r2, #255	; 0xff
100057c0:	0209      	lsls	r1, r1, #8
100057c2:	ba12      	rev	r2, r2
100057c4:	0c03      	lsrs	r3, r0, #16
100057c6:	428b      	cmp	r3, r1
100057c8:	d302      	bcc.n	100057d0 <__aeabi_idiv+0x38>
100057ca:	1212      	asrs	r2, r2, #8
100057cc:	0209      	lsls	r1, r1, #8
100057ce:	d065      	beq.n	1000589c <__aeabi_idiv+0x104>
100057d0:	0b03      	lsrs	r3, r0, #12
100057d2:	428b      	cmp	r3, r1
100057d4:	d319      	bcc.n	1000580a <__aeabi_idiv+0x72>
100057d6:	e000      	b.n	100057da <__aeabi_idiv+0x42>
100057d8:	0a09      	lsrs	r1, r1, #8
100057da:	0bc3      	lsrs	r3, r0, #15
100057dc:	428b      	cmp	r3, r1
100057de:	d301      	bcc.n	100057e4 <__aeabi_idiv+0x4c>
100057e0:	03cb      	lsls	r3, r1, #15
100057e2:	1ac0      	subs	r0, r0, r3
100057e4:	4152      	adcs	r2, r2
100057e6:	0b83      	lsrs	r3, r0, #14
100057e8:	428b      	cmp	r3, r1
100057ea:	d301      	bcc.n	100057f0 <__aeabi_idiv+0x58>
100057ec:	038b      	lsls	r3, r1, #14
100057ee:	1ac0      	subs	r0, r0, r3
100057f0:	4152      	adcs	r2, r2
100057f2:	0b43      	lsrs	r3, r0, #13
100057f4:	428b      	cmp	r3, r1
100057f6:	d301      	bcc.n	100057fc <__aeabi_idiv+0x64>
100057f8:	034b      	lsls	r3, r1, #13
100057fa:	1ac0      	subs	r0, r0, r3
100057fc:	4152      	adcs	r2, r2
100057fe:	0b03      	lsrs	r3, r0, #12
10005800:	428b      	cmp	r3, r1
10005802:	d301      	bcc.n	10005808 <__aeabi_idiv+0x70>
10005804:	030b      	lsls	r3, r1, #12
10005806:	1ac0      	subs	r0, r0, r3
10005808:	4152      	adcs	r2, r2
1000580a:	0ac3      	lsrs	r3, r0, #11
1000580c:	428b      	cmp	r3, r1
1000580e:	d301      	bcc.n	10005814 <__aeabi_idiv+0x7c>
10005810:	02cb      	lsls	r3, r1, #11
10005812:	1ac0      	subs	r0, r0, r3
10005814:	4152      	adcs	r2, r2
10005816:	0a83      	lsrs	r3, r0, #10
10005818:	428b      	cmp	r3, r1
1000581a:	d301      	bcc.n	10005820 <__aeabi_idiv+0x88>
1000581c:	028b      	lsls	r3, r1, #10
1000581e:	1ac0      	subs	r0, r0, r3
10005820:	4152      	adcs	r2, r2
10005822:	0a43      	lsrs	r3, r0, #9
10005824:	428b      	cmp	r3, r1
10005826:	d301      	bcc.n	1000582c <__aeabi_idiv+0x94>
10005828:	024b      	lsls	r3, r1, #9
1000582a:	1ac0      	subs	r0, r0, r3
1000582c:	4152      	adcs	r2, r2
1000582e:	0a03      	lsrs	r3, r0, #8
10005830:	428b      	cmp	r3, r1
10005832:	d301      	bcc.n	10005838 <__aeabi_idiv+0xa0>
10005834:	020b      	lsls	r3, r1, #8
10005836:	1ac0      	subs	r0, r0, r3
10005838:	4152      	adcs	r2, r2
1000583a:	d2cd      	bcs.n	100057d8 <__aeabi_idiv+0x40>
1000583c:	09c3      	lsrs	r3, r0, #7
1000583e:	428b      	cmp	r3, r1
10005840:	d301      	bcc.n	10005846 <__aeabi_idiv+0xae>
10005842:	01cb      	lsls	r3, r1, #7
10005844:	1ac0      	subs	r0, r0, r3
10005846:	4152      	adcs	r2, r2
10005848:	0983      	lsrs	r3, r0, #6
1000584a:	428b      	cmp	r3, r1
1000584c:	d301      	bcc.n	10005852 <__aeabi_idiv+0xba>
1000584e:	018b      	lsls	r3, r1, #6
10005850:	1ac0      	subs	r0, r0, r3
10005852:	4152      	adcs	r2, r2
10005854:	0943      	lsrs	r3, r0, #5
10005856:	428b      	cmp	r3, r1
10005858:	d301      	bcc.n	1000585e <__aeabi_idiv+0xc6>
1000585a:	014b      	lsls	r3, r1, #5
1000585c:	1ac0      	subs	r0, r0, r3
1000585e:	4152      	adcs	r2, r2
10005860:	0903      	lsrs	r3, r0, #4
10005862:	428b      	cmp	r3, r1
10005864:	d301      	bcc.n	1000586a <__aeabi_idiv+0xd2>
10005866:	010b      	lsls	r3, r1, #4
10005868:	1ac0      	subs	r0, r0, r3
1000586a:	4152      	adcs	r2, r2
1000586c:	08c3      	lsrs	r3, r0, #3
1000586e:	428b      	cmp	r3, r1
10005870:	d301      	bcc.n	10005876 <__aeabi_idiv+0xde>
10005872:	00cb      	lsls	r3, r1, #3
10005874:	1ac0      	subs	r0, r0, r3
10005876:	4152      	adcs	r2, r2
10005878:	0883      	lsrs	r3, r0, #2
1000587a:	428b      	cmp	r3, r1
1000587c:	d301      	bcc.n	10005882 <__aeabi_idiv+0xea>
1000587e:	008b      	lsls	r3, r1, #2
10005880:	1ac0      	subs	r0, r0, r3
10005882:	4152      	adcs	r2, r2
10005884:	0843      	lsrs	r3, r0, #1
10005886:	428b      	cmp	r3, r1
10005888:	d301      	bcc.n	1000588e <__aeabi_idiv+0xf6>
1000588a:	004b      	lsls	r3, r1, #1
1000588c:	1ac0      	subs	r0, r0, r3
1000588e:	4152      	adcs	r2, r2
10005890:	1a41      	subs	r1, r0, r1
10005892:	d200      	bcs.n	10005896 <__aeabi_idiv+0xfe>
10005894:	4601      	mov	r1, r0
10005896:	4152      	adcs	r2, r2
10005898:	4610      	mov	r0, r2
1000589a:	4770      	bx	lr
1000589c:	e05d      	b.n	1000595a <__aeabi_idiv+0x1c2>
1000589e:	0fca      	lsrs	r2, r1, #31
100058a0:	d000      	beq.n	100058a4 <__aeabi_idiv+0x10c>
100058a2:	4249      	negs	r1, r1
100058a4:	1003      	asrs	r3, r0, #32
100058a6:	d300      	bcc.n	100058aa <__aeabi_idiv+0x112>
100058a8:	4240      	negs	r0, r0
100058aa:	4053      	eors	r3, r2
100058ac:	2200      	movs	r2, #0
100058ae:	469c      	mov	ip, r3
100058b0:	0903      	lsrs	r3, r0, #4
100058b2:	428b      	cmp	r3, r1
100058b4:	d32d      	bcc.n	10005912 <__aeabi_idiv+0x17a>
100058b6:	0a03      	lsrs	r3, r0, #8
100058b8:	428b      	cmp	r3, r1
100058ba:	d312      	bcc.n	100058e2 <__aeabi_idiv+0x14a>
100058bc:	22fc      	movs	r2, #252	; 0xfc
100058be:	0189      	lsls	r1, r1, #6
100058c0:	ba12      	rev	r2, r2
100058c2:	0a03      	lsrs	r3, r0, #8
100058c4:	428b      	cmp	r3, r1
100058c6:	d30c      	bcc.n	100058e2 <__aeabi_idiv+0x14a>
100058c8:	0189      	lsls	r1, r1, #6
100058ca:	1192      	asrs	r2, r2, #6
100058cc:	428b      	cmp	r3, r1
100058ce:	d308      	bcc.n	100058e2 <__aeabi_idiv+0x14a>
100058d0:	0189      	lsls	r1, r1, #6
100058d2:	1192      	asrs	r2, r2, #6
100058d4:	428b      	cmp	r3, r1
100058d6:	d304      	bcc.n	100058e2 <__aeabi_idiv+0x14a>
100058d8:	0189      	lsls	r1, r1, #6
100058da:	d03a      	beq.n	10005952 <__aeabi_idiv+0x1ba>
100058dc:	1192      	asrs	r2, r2, #6
100058de:	e000      	b.n	100058e2 <__aeabi_idiv+0x14a>
100058e0:	0989      	lsrs	r1, r1, #6
100058e2:	09c3      	lsrs	r3, r0, #7
100058e4:	428b      	cmp	r3, r1
100058e6:	d301      	bcc.n	100058ec <__aeabi_idiv+0x154>
100058e8:	01cb      	lsls	r3, r1, #7
100058ea:	1ac0      	subs	r0, r0, r3
100058ec:	4152      	adcs	r2, r2
100058ee:	0983      	lsrs	r3, r0, #6
100058f0:	428b      	cmp	r3, r1
100058f2:	d301      	bcc.n	100058f8 <__aeabi_idiv+0x160>
100058f4:	018b      	lsls	r3, r1, #6
100058f6:	1ac0      	subs	r0, r0, r3
100058f8:	4152      	adcs	r2, r2
100058fa:	0943      	lsrs	r3, r0, #5
100058fc:	428b      	cmp	r3, r1
100058fe:	d301      	bcc.n	10005904 <__aeabi_idiv+0x16c>
10005900:	014b      	lsls	r3, r1, #5
10005902:	1ac0      	subs	r0, r0, r3
10005904:	4152      	adcs	r2, r2
10005906:	0903      	lsrs	r3, r0, #4
10005908:	428b      	cmp	r3, r1
1000590a:	d301      	bcc.n	10005910 <__aeabi_idiv+0x178>
1000590c:	010b      	lsls	r3, r1, #4
1000590e:	1ac0      	subs	r0, r0, r3
10005910:	4152      	adcs	r2, r2
10005912:	08c3      	lsrs	r3, r0, #3
10005914:	428b      	cmp	r3, r1
10005916:	d301      	bcc.n	1000591c <__aeabi_idiv+0x184>
10005918:	00cb      	lsls	r3, r1, #3
1000591a:	1ac0      	subs	r0, r0, r3
1000591c:	4152      	adcs	r2, r2
1000591e:	0883      	lsrs	r3, r0, #2
10005920:	428b      	cmp	r3, r1
10005922:	d301      	bcc.n	10005928 <__aeabi_idiv+0x190>
10005924:	008b      	lsls	r3, r1, #2
10005926:	1ac0      	subs	r0, r0, r3
10005928:	4152      	adcs	r2, r2
1000592a:	d2d9      	bcs.n	100058e0 <__aeabi_idiv+0x148>
1000592c:	0843      	lsrs	r3, r0, #1
1000592e:	428b      	cmp	r3, r1
10005930:	d301      	bcc.n	10005936 <__aeabi_idiv+0x19e>
10005932:	004b      	lsls	r3, r1, #1
10005934:	1ac0      	subs	r0, r0, r3
10005936:	4152      	adcs	r2, r2
10005938:	1a41      	subs	r1, r0, r1
1000593a:	d200      	bcs.n	1000593e <__aeabi_idiv+0x1a6>
1000593c:	4601      	mov	r1, r0
1000593e:	4663      	mov	r3, ip
10005940:	4152      	adcs	r2, r2
10005942:	105b      	asrs	r3, r3, #1
10005944:	4610      	mov	r0, r2
10005946:	d301      	bcc.n	1000594c <__aeabi_idiv+0x1b4>
10005948:	4240      	negs	r0, r0
1000594a:	2b00      	cmp	r3, #0
1000594c:	d500      	bpl.n	10005950 <__aeabi_idiv+0x1b8>
1000594e:	4249      	negs	r1, r1
10005950:	4770      	bx	lr
10005952:	4663      	mov	r3, ip
10005954:	105b      	asrs	r3, r3, #1
10005956:	d300      	bcc.n	1000595a <__aeabi_idiv+0x1c2>
10005958:	4240      	negs	r0, r0
1000595a:	b501      	push	{r0, lr}
1000595c:	2000      	movs	r0, #0
1000595e:	f000 f80b 	bl	10005978 <__aeabi_idiv0>
10005962:	bd02      	pop	{r1, pc}

10005964 <__aeabi_idivmod>:
10005964:	2900      	cmp	r1, #0
10005966:	d0f8      	beq.n	1000595a <__aeabi_idiv+0x1c2>
10005968:	b503      	push	{r0, r1, lr}
1000596a:	f7ff ff15 	bl	10005798 <__aeabi_idiv>
1000596e:	bc0e      	pop	{r1, r2, r3}
10005970:	4342      	muls	r2, r0
10005972:	1a89      	subs	r1, r1, r2
10005974:	4718      	bx	r3
10005976:	46c0      	nop			; (mov r8, r8)

10005978 <__aeabi_idiv0>:
10005978:	4770      	bx	lr
1000597a:	46c0      	nop			; (mov r8, r8)

1000597c <__clzsi2>:
1000597c:	211c      	movs	r1, #28
1000597e:	2301      	movs	r3, #1
10005980:	041b      	lsls	r3, r3, #16
10005982:	4298      	cmp	r0, r3
10005984:	d301      	bcc.n	1000598a <__clzsi2+0xe>
10005986:	0c00      	lsrs	r0, r0, #16
10005988:	3910      	subs	r1, #16
1000598a:	0a1b      	lsrs	r3, r3, #8
1000598c:	4298      	cmp	r0, r3
1000598e:	d301      	bcc.n	10005994 <__clzsi2+0x18>
10005990:	0a00      	lsrs	r0, r0, #8
10005992:	3908      	subs	r1, #8
10005994:	091b      	lsrs	r3, r3, #4
10005996:	4298      	cmp	r0, r3
10005998:	d301      	bcc.n	1000599e <__clzsi2+0x22>
1000599a:	0900      	lsrs	r0, r0, #4
1000599c:	3904      	subs	r1, #4
1000599e:	a202      	add	r2, pc, #8	; (adr r2, 100059a8 <__clzsi2+0x2c>)
100059a0:	5c10      	ldrb	r0, [r2, r0]
100059a2:	1840      	adds	r0, r0, r1
100059a4:	4770      	bx	lr
100059a6:	46c0      	nop			; (mov r8, r8)
100059a8:	02020304 	.word	0x02020304
100059ac:	01010101 	.word	0x01010101
	...

100059b8 <__errno>:
100059b8:	4b01      	ldr	r3, [pc, #4]	; (100059c0 <__errno+0x8>)
100059ba:	6818      	ldr	r0, [r3, #0]
100059bc:	4770      	bx	lr
100059be:	46c0      	nop			; (mov r8, r8)
100059c0:	20000664 	.word	0x20000664

100059c4 <malloc>:
100059c4:	b508      	push	{r3, lr}
100059c6:	4b03      	ldr	r3, [pc, #12]	; (100059d4 <malloc+0x10>)
100059c8:	1c01      	adds	r1, r0, #0
100059ca:	6818      	ldr	r0, [r3, #0]
100059cc:	f000 f866 	bl	10005a9c <_malloc_r>
100059d0:	bd08      	pop	{r3, pc}
100059d2:	46c0      	nop			; (mov r8, r8)
100059d4:	20000664 	.word	0x20000664

100059d8 <free>:
100059d8:	b508      	push	{r3, lr}
100059da:	4b03      	ldr	r3, [pc, #12]	; (100059e8 <free+0x10>)
100059dc:	1c01      	adds	r1, r0, #0
100059de:	6818      	ldr	r0, [r3, #0]
100059e0:	f000 f816 	bl	10005a10 <_free_r>
100059e4:	bd08      	pop	{r3, pc}
100059e6:	46c0      	nop			; (mov r8, r8)
100059e8:	20000664 	.word	0x20000664

100059ec <memcpy>:
100059ec:	2300      	movs	r3, #0
100059ee:	b510      	push	{r4, lr}
100059f0:	4293      	cmp	r3, r2
100059f2:	d003      	beq.n	100059fc <memcpy+0x10>
100059f4:	5ccc      	ldrb	r4, [r1, r3]
100059f6:	54c4      	strb	r4, [r0, r3]
100059f8:	3301      	adds	r3, #1
100059fa:	e7f9      	b.n	100059f0 <memcpy+0x4>
100059fc:	bd10      	pop	{r4, pc}

100059fe <memset>:
100059fe:	1c03      	adds	r3, r0, #0
10005a00:	1882      	adds	r2, r0, r2
10005a02:	4293      	cmp	r3, r2
10005a04:	d002      	beq.n	10005a0c <memset+0xe>
10005a06:	7019      	strb	r1, [r3, #0]
10005a08:	3301      	adds	r3, #1
10005a0a:	e7fa      	b.n	10005a02 <memset+0x4>
10005a0c:	4770      	bx	lr
	...

10005a10 <_free_r>:
10005a10:	b530      	push	{r4, r5, lr}
10005a12:	2900      	cmp	r1, #0
10005a14:	d03e      	beq.n	10005a94 <_free_r+0x84>
10005a16:	3904      	subs	r1, #4
10005a18:	680b      	ldr	r3, [r1, #0]
10005a1a:	2b00      	cmp	r3, #0
10005a1c:	da00      	bge.n	10005a20 <_free_r+0x10>
10005a1e:	18c9      	adds	r1, r1, r3
10005a20:	4a1d      	ldr	r2, [pc, #116]	; (10005a98 <_free_r+0x88>)
10005a22:	6813      	ldr	r3, [r2, #0]
10005a24:	1c14      	adds	r4, r2, #0
10005a26:	2b00      	cmp	r3, #0
10005a28:	d102      	bne.n	10005a30 <_free_r+0x20>
10005a2a:	604b      	str	r3, [r1, #4]
10005a2c:	6011      	str	r1, [r2, #0]
10005a2e:	e031      	b.n	10005a94 <_free_r+0x84>
10005a30:	4299      	cmp	r1, r3
10005a32:	d20d      	bcs.n	10005a50 <_free_r+0x40>
10005a34:	6808      	ldr	r0, [r1, #0]
10005a36:	180a      	adds	r2, r1, r0
10005a38:	429a      	cmp	r2, r3
10005a3a:	d103      	bne.n	10005a44 <_free_r+0x34>
10005a3c:	6813      	ldr	r3, [r2, #0]
10005a3e:	18c3      	adds	r3, r0, r3
10005a40:	600b      	str	r3, [r1, #0]
10005a42:	6853      	ldr	r3, [r2, #4]
10005a44:	604b      	str	r3, [r1, #4]
10005a46:	6021      	str	r1, [r4, #0]
10005a48:	e024      	b.n	10005a94 <_free_r+0x84>
10005a4a:	428a      	cmp	r2, r1
10005a4c:	d803      	bhi.n	10005a56 <_free_r+0x46>
10005a4e:	1c13      	adds	r3, r2, #0
10005a50:	685a      	ldr	r2, [r3, #4]
10005a52:	2a00      	cmp	r2, #0
10005a54:	d1f9      	bne.n	10005a4a <_free_r+0x3a>
10005a56:	681d      	ldr	r5, [r3, #0]
10005a58:	195c      	adds	r4, r3, r5
10005a5a:	428c      	cmp	r4, r1
10005a5c:	d10b      	bne.n	10005a76 <_free_r+0x66>
10005a5e:	6809      	ldr	r1, [r1, #0]
10005a60:	1869      	adds	r1, r5, r1
10005a62:	1858      	adds	r0, r3, r1
10005a64:	6019      	str	r1, [r3, #0]
10005a66:	4290      	cmp	r0, r2
10005a68:	d114      	bne.n	10005a94 <_free_r+0x84>
10005a6a:	6810      	ldr	r0, [r2, #0]
10005a6c:	6852      	ldr	r2, [r2, #4]
10005a6e:	1809      	adds	r1, r1, r0
10005a70:	6019      	str	r1, [r3, #0]
10005a72:	605a      	str	r2, [r3, #4]
10005a74:	e00e      	b.n	10005a94 <_free_r+0x84>
10005a76:	428c      	cmp	r4, r1
10005a78:	d902      	bls.n	10005a80 <_free_r+0x70>
10005a7a:	230c      	movs	r3, #12
10005a7c:	6003      	str	r3, [r0, #0]
10005a7e:	e009      	b.n	10005a94 <_free_r+0x84>
10005a80:	6808      	ldr	r0, [r1, #0]
10005a82:	180c      	adds	r4, r1, r0
10005a84:	4294      	cmp	r4, r2
10005a86:	d103      	bne.n	10005a90 <_free_r+0x80>
10005a88:	6814      	ldr	r4, [r2, #0]
10005a8a:	6852      	ldr	r2, [r2, #4]
10005a8c:	1900      	adds	r0, r0, r4
10005a8e:	6008      	str	r0, [r1, #0]
10005a90:	604a      	str	r2, [r1, #4]
10005a92:	6059      	str	r1, [r3, #4]
10005a94:	bd30      	pop	{r4, r5, pc}
10005a96:	46c0      	nop			; (mov r8, r8)
10005a98:	20000824 	.word	0x20000824

10005a9c <_malloc_r>:
10005a9c:	2303      	movs	r3, #3
10005a9e:	b570      	push	{r4, r5, r6, lr}
10005aa0:	1ccc      	adds	r4, r1, #3
10005aa2:	439c      	bics	r4, r3
10005aa4:	3408      	adds	r4, #8
10005aa6:	1c05      	adds	r5, r0, #0
10005aa8:	2c0c      	cmp	r4, #12
10005aaa:	d201      	bcs.n	10005ab0 <_malloc_r+0x14>
10005aac:	240c      	movs	r4, #12
10005aae:	e005      	b.n	10005abc <_malloc_r+0x20>
10005ab0:	2c00      	cmp	r4, #0
10005ab2:	da03      	bge.n	10005abc <_malloc_r+0x20>
10005ab4:	230c      	movs	r3, #12
10005ab6:	2000      	movs	r0, #0
10005ab8:	602b      	str	r3, [r5, #0]
10005aba:	e042      	b.n	10005b42 <_malloc_r+0xa6>
10005abc:	428c      	cmp	r4, r1
10005abe:	d3f9      	bcc.n	10005ab4 <_malloc_r+0x18>
10005ac0:	4a20      	ldr	r2, [pc, #128]	; (10005b44 <_malloc_r+0xa8>)
10005ac2:	6813      	ldr	r3, [r2, #0]
10005ac4:	1c10      	adds	r0, r2, #0
10005ac6:	1c19      	adds	r1, r3, #0
10005ac8:	2900      	cmp	r1, #0
10005aca:	d013      	beq.n	10005af4 <_malloc_r+0x58>
10005acc:	680a      	ldr	r2, [r1, #0]
10005ace:	1b12      	subs	r2, r2, r4
10005ad0:	d40d      	bmi.n	10005aee <_malloc_r+0x52>
10005ad2:	2a0b      	cmp	r2, #11
10005ad4:	d902      	bls.n	10005adc <_malloc_r+0x40>
10005ad6:	600a      	str	r2, [r1, #0]
10005ad8:	188b      	adds	r3, r1, r2
10005ada:	e01f      	b.n	10005b1c <_malloc_r+0x80>
10005adc:	428b      	cmp	r3, r1
10005ade:	d102      	bne.n	10005ae6 <_malloc_r+0x4a>
10005ae0:	685a      	ldr	r2, [r3, #4]
10005ae2:	6002      	str	r2, [r0, #0]
10005ae4:	e01b      	b.n	10005b1e <_malloc_r+0x82>
10005ae6:	684a      	ldr	r2, [r1, #4]
10005ae8:	605a      	str	r2, [r3, #4]
10005aea:	1c0b      	adds	r3, r1, #0
10005aec:	e017      	b.n	10005b1e <_malloc_r+0x82>
10005aee:	1c0b      	adds	r3, r1, #0
10005af0:	6849      	ldr	r1, [r1, #4]
10005af2:	e7e9      	b.n	10005ac8 <_malloc_r+0x2c>
10005af4:	4e14      	ldr	r6, [pc, #80]	; (10005b48 <_malloc_r+0xac>)
10005af6:	6833      	ldr	r3, [r6, #0]
10005af8:	2b00      	cmp	r3, #0
10005afa:	d103      	bne.n	10005b04 <_malloc_r+0x68>
10005afc:	1c28      	adds	r0, r5, #0
10005afe:	f000 fd27 	bl	10006550 <_sbrk_r>
10005b02:	6030      	str	r0, [r6, #0]
10005b04:	1c28      	adds	r0, r5, #0
10005b06:	1c21      	adds	r1, r4, #0
10005b08:	f000 fd22 	bl	10006550 <_sbrk_r>
10005b0c:	1c03      	adds	r3, r0, #0
10005b0e:	1c42      	adds	r2, r0, #1
10005b10:	d0d0      	beq.n	10005ab4 <_malloc_r+0x18>
10005b12:	2203      	movs	r2, #3
10005b14:	1cc6      	adds	r6, r0, #3
10005b16:	4396      	bics	r6, r2
10005b18:	4286      	cmp	r6, r0
10005b1a:	d10a      	bne.n	10005b32 <_malloc_r+0x96>
10005b1c:	601c      	str	r4, [r3, #0]
10005b1e:	1c18      	adds	r0, r3, #0
10005b20:	2107      	movs	r1, #7
10005b22:	300b      	adds	r0, #11
10005b24:	1d1a      	adds	r2, r3, #4
10005b26:	4388      	bics	r0, r1
10005b28:	1a82      	subs	r2, r0, r2
10005b2a:	d00a      	beq.n	10005b42 <_malloc_r+0xa6>
10005b2c:	4251      	negs	r1, r2
10005b2e:	5099      	str	r1, [r3, r2]
10005b30:	e007      	b.n	10005b42 <_malloc_r+0xa6>
10005b32:	1a31      	subs	r1, r6, r0
10005b34:	1c28      	adds	r0, r5, #0
10005b36:	f000 fd0b 	bl	10006550 <_sbrk_r>
10005b3a:	1c43      	adds	r3, r0, #1
10005b3c:	d0ba      	beq.n	10005ab4 <_malloc_r+0x18>
10005b3e:	1c33      	adds	r3, r6, #0
10005b40:	e7ec      	b.n	10005b1c <_malloc_r+0x80>
10005b42:	bd70      	pop	{r4, r5, r6, pc}
10005b44:	20000824 	.word	0x20000824
10005b48:	20000820 	.word	0x20000820

10005b4c <__cvt>:
10005b4c:	b5f0      	push	{r4, r5, r6, r7, lr}
10005b4e:	b08b      	sub	sp, #44	; 0x2c
10005b50:	1c14      	adds	r4, r2, #0
10005b52:	1e1d      	subs	r5, r3, #0
10005b54:	9912      	ldr	r1, [sp, #72]	; 0x48
10005b56:	da06      	bge.n	10005b66 <__cvt+0x1a>
10005b58:	2480      	movs	r4, #128	; 0x80
10005b5a:	0624      	lsls	r4, r4, #24
10005b5c:	192b      	adds	r3, r5, r4
10005b5e:	1c1d      	adds	r5, r3, #0
10005b60:	1c14      	adds	r4, r2, #0
10005b62:	232d      	movs	r3, #45	; 0x2d
10005b64:	e000      	b.n	10005b68 <__cvt+0x1c>
10005b66:	2300      	movs	r3, #0
10005b68:	700b      	strb	r3, [r1, #0]
10005b6a:	2320      	movs	r3, #32
10005b6c:	9e14      	ldr	r6, [sp, #80]	; 0x50
10005b6e:	2203      	movs	r2, #3
10005b70:	439e      	bics	r6, r3
10005b72:	2e46      	cmp	r6, #70	; 0x46
10005b74:	d007      	beq.n	10005b86 <__cvt+0x3a>
10005b76:	1c33      	adds	r3, r6, #0
10005b78:	3b45      	subs	r3, #69	; 0x45
10005b7a:	4259      	negs	r1, r3
10005b7c:	414b      	adcs	r3, r1
10005b7e:	9910      	ldr	r1, [sp, #64]	; 0x40
10005b80:	3a01      	subs	r2, #1
10005b82:	18cb      	adds	r3, r1, r3
10005b84:	9310      	str	r3, [sp, #64]	; 0x40
10005b86:	9b10      	ldr	r3, [sp, #64]	; 0x40
10005b88:	9200      	str	r2, [sp, #0]
10005b8a:	9301      	str	r3, [sp, #4]
10005b8c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
10005b8e:	1c22      	adds	r2, r4, #0
10005b90:	9302      	str	r3, [sp, #8]
10005b92:	ab08      	add	r3, sp, #32
10005b94:	9303      	str	r3, [sp, #12]
10005b96:	ab09      	add	r3, sp, #36	; 0x24
10005b98:	9304      	str	r3, [sp, #16]
10005b9a:	1c2b      	adds	r3, r5, #0
10005b9c:	f000 fe68 	bl	10006870 <_dtoa_r>
10005ba0:	1c07      	adds	r7, r0, #0
10005ba2:	2e47      	cmp	r6, #71	; 0x47
10005ba4:	d102      	bne.n	10005bac <__cvt+0x60>
10005ba6:	9b11      	ldr	r3, [sp, #68]	; 0x44
10005ba8:	07db      	lsls	r3, r3, #31
10005baa:	d52c      	bpl.n	10005c06 <__cvt+0xba>
10005bac:	9b10      	ldr	r3, [sp, #64]	; 0x40
10005bae:	18fb      	adds	r3, r7, r3
10005bb0:	9307      	str	r3, [sp, #28]
10005bb2:	2e46      	cmp	r6, #70	; 0x46
10005bb4:	d114      	bne.n	10005be0 <__cvt+0x94>
10005bb6:	783b      	ldrb	r3, [r7, #0]
10005bb8:	2b30      	cmp	r3, #48	; 0x30
10005bba:	d10c      	bne.n	10005bd6 <__cvt+0x8a>
10005bbc:	1c20      	adds	r0, r4, #0
10005bbe:	1c29      	adds	r1, r5, #0
10005bc0:	2200      	movs	r2, #0
10005bc2:	2300      	movs	r3, #0
10005bc4:	f002 fcea 	bl	1000859c <__aeabi_dcmpeq>
10005bc8:	2800      	cmp	r0, #0
10005bca:	d104      	bne.n	10005bd6 <__cvt+0x8a>
10005bcc:	2301      	movs	r3, #1
10005bce:	9a10      	ldr	r2, [sp, #64]	; 0x40
10005bd0:	1a9b      	subs	r3, r3, r2
10005bd2:	9a13      	ldr	r2, [sp, #76]	; 0x4c
10005bd4:	6013      	str	r3, [r2, #0]
10005bd6:	9b13      	ldr	r3, [sp, #76]	; 0x4c
10005bd8:	9a07      	ldr	r2, [sp, #28]
10005bda:	681b      	ldr	r3, [r3, #0]
10005bdc:	18d3      	adds	r3, r2, r3
10005bde:	9307      	str	r3, [sp, #28]
10005be0:	1c20      	adds	r0, r4, #0
10005be2:	1c29      	adds	r1, r5, #0
10005be4:	2200      	movs	r2, #0
10005be6:	2300      	movs	r3, #0
10005be8:	f002 fcd8 	bl	1000859c <__aeabi_dcmpeq>
10005bec:	2800      	cmp	r0, #0
10005bee:	d001      	beq.n	10005bf4 <__cvt+0xa8>
10005bf0:	9b07      	ldr	r3, [sp, #28]
10005bf2:	9309      	str	r3, [sp, #36]	; 0x24
10005bf4:	9b09      	ldr	r3, [sp, #36]	; 0x24
10005bf6:	9a07      	ldr	r2, [sp, #28]
10005bf8:	4293      	cmp	r3, r2
10005bfa:	d204      	bcs.n	10005c06 <__cvt+0xba>
10005bfc:	1c5a      	adds	r2, r3, #1
10005bfe:	9209      	str	r2, [sp, #36]	; 0x24
10005c00:	2230      	movs	r2, #48	; 0x30
10005c02:	701a      	strb	r2, [r3, #0]
10005c04:	e7f6      	b.n	10005bf4 <__cvt+0xa8>
10005c06:	1c38      	adds	r0, r7, #0
10005c08:	9b09      	ldr	r3, [sp, #36]	; 0x24
10005c0a:	9a15      	ldr	r2, [sp, #84]	; 0x54
10005c0c:	1bdb      	subs	r3, r3, r7
10005c0e:	6013      	str	r3, [r2, #0]
10005c10:	b00b      	add	sp, #44	; 0x2c
10005c12:	bdf0      	pop	{r4, r5, r6, r7, pc}

10005c14 <__exponent>:
10005c14:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
10005c16:	232b      	movs	r3, #43	; 0x2b
10005c18:	1c07      	adds	r7, r0, #0
10005c1a:	1c0c      	adds	r4, r1, #0
10005c1c:	7002      	strb	r2, [r0, #0]
10005c1e:	1c86      	adds	r6, r0, #2
10005c20:	2900      	cmp	r1, #0
10005c22:	da01      	bge.n	10005c28 <__exponent+0x14>
10005c24:	232d      	movs	r3, #45	; 0x2d
10005c26:	424c      	negs	r4, r1
10005c28:	707b      	strb	r3, [r7, #1]
10005c2a:	2c09      	cmp	r4, #9
10005c2c:	dd1c      	ble.n	10005c68 <__exponent+0x54>
10005c2e:	466b      	mov	r3, sp
10005c30:	1ddd      	adds	r5, r3, #7
10005c32:	1c20      	adds	r0, r4, #0
10005c34:	210a      	movs	r1, #10
10005c36:	f7ff fe95 	bl	10005964 <__aeabi_idivmod>
10005c3a:	3d01      	subs	r5, #1
10005c3c:	3130      	adds	r1, #48	; 0x30
10005c3e:	7029      	strb	r1, [r5, #0]
10005c40:	1c20      	adds	r0, r4, #0
10005c42:	210a      	movs	r1, #10
10005c44:	f7ff fda8 	bl	10005798 <__aeabi_idiv>
10005c48:	1e04      	subs	r4, r0, #0
10005c4a:	2c09      	cmp	r4, #9
10005c4c:	dcf1      	bgt.n	10005c32 <__exponent+0x1e>
10005c4e:	3d01      	subs	r5, #1
10005c50:	3430      	adds	r4, #48	; 0x30
10005c52:	702c      	strb	r4, [r5, #0]
10005c54:	466b      	mov	r3, sp
10005c56:	3307      	adds	r3, #7
10005c58:	1c30      	adds	r0, r6, #0
10005c5a:	42ab      	cmp	r3, r5
10005c5c:	d909      	bls.n	10005c72 <__exponent+0x5e>
10005c5e:	782b      	ldrb	r3, [r5, #0]
10005c60:	3501      	adds	r5, #1
10005c62:	7033      	strb	r3, [r6, #0]
10005c64:	3601      	adds	r6, #1
10005c66:	e7f5      	b.n	10005c54 <__exponent+0x40>
10005c68:	2330      	movs	r3, #48	; 0x30
10005c6a:	18e4      	adds	r4, r4, r3
10005c6c:	7033      	strb	r3, [r6, #0]
10005c6e:	1cb0      	adds	r0, r6, #2
10005c70:	7074      	strb	r4, [r6, #1]
10005c72:	1bc0      	subs	r0, r0, r7
10005c74:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	...

10005c78 <_printf_float>:
10005c78:	b5f0      	push	{r4, r5, r6, r7, lr}
10005c7a:	b093      	sub	sp, #76	; 0x4c
10005c7c:	1c0c      	adds	r4, r1, #0
10005c7e:	9208      	str	r2, [sp, #32]
10005c80:	9e18      	ldr	r6, [sp, #96]	; 0x60
10005c82:	9309      	str	r3, [sp, #36]	; 0x24
10005c84:	1c05      	adds	r5, r0, #0
10005c86:	f001 fd7d 	bl	10007784 <_localeconv_r>
10005c8a:	6803      	ldr	r3, [r0, #0]
10005c8c:	1c18      	adds	r0, r3, #0
10005c8e:	930b      	str	r3, [sp, #44]	; 0x2c
10005c90:	f000 fc92 	bl	100065b8 <strlen>
10005c94:	2300      	movs	r3, #0
10005c96:	2207      	movs	r2, #7
10005c98:	9310      	str	r3, [sp, #64]	; 0x40
10005c9a:	6833      	ldr	r3, [r6, #0]
10005c9c:	900c      	str	r0, [sp, #48]	; 0x30
10005c9e:	3307      	adds	r3, #7
10005ca0:	4393      	bics	r3, r2
10005ca2:	1c1a      	adds	r2, r3, #0
10005ca4:	6818      	ldr	r0, [r3, #0]
10005ca6:	6859      	ldr	r1, [r3, #4]
10005ca8:	3208      	adds	r2, #8
10005caa:	7e27      	ldrb	r7, [r4, #24]
10005cac:	6032      	str	r2, [r6, #0]
10005cae:	64a0      	str	r0, [r4, #72]	; 0x48
10005cb0:	64e1      	str	r1, [r4, #76]	; 0x4c
10005cb2:	f000 fc25 	bl	10006500 <__fpclassifyd>
10005cb6:	2801      	cmp	r0, #1
10005cb8:	d118      	bne.n	10005cec <_printf_float+0x74>
10005cba:	6ca0      	ldr	r0, [r4, #72]	; 0x48
10005cbc:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
10005cbe:	2200      	movs	r2, #0
10005cc0:	2300      	movs	r3, #0
10005cc2:	f002 fc71 	bl	100085a8 <__aeabi_dcmplt>
10005cc6:	2800      	cmp	r0, #0
10005cc8:	d003      	beq.n	10005cd2 <_printf_float+0x5a>
10005cca:	1c23      	adds	r3, r4, #0
10005ccc:	222d      	movs	r2, #45	; 0x2d
10005cce:	3343      	adds	r3, #67	; 0x43
10005cd0:	701a      	strb	r2, [r3, #0]
10005cd2:	4bb7      	ldr	r3, [pc, #732]	; (10005fb0 <_printf_float+0x338>)
10005cd4:	930a      	str	r3, [sp, #40]	; 0x28
10005cd6:	2f47      	cmp	r7, #71	; 0x47
10005cd8:	d901      	bls.n	10005cde <_printf_float+0x66>
10005cda:	4bb6      	ldr	r3, [pc, #728]	; (10005fb4 <_printf_float+0x33c>)
10005cdc:	930a      	str	r3, [sp, #40]	; 0x28
10005cde:	2303      	movs	r3, #3
10005ce0:	6822      	ldr	r2, [r4, #0]
10005ce2:	6123      	str	r3, [r4, #16]
10005ce4:	3301      	adds	r3, #1
10005ce6:	439a      	bics	r2, r3
10005ce8:	6022      	str	r2, [r4, #0]
10005cea:	e012      	b.n	10005d12 <_printf_float+0x9a>
10005cec:	6ca0      	ldr	r0, [r4, #72]	; 0x48
10005cee:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
10005cf0:	f000 fc06 	bl	10006500 <__fpclassifyd>
10005cf4:	6826      	ldr	r6, [r4, #0]
10005cf6:	2800      	cmp	r0, #0
10005cf8:	d10d      	bne.n	10005d16 <_printf_float+0x9e>
10005cfa:	4baf      	ldr	r3, [pc, #700]	; (10005fb8 <_printf_float+0x340>)
10005cfc:	930a      	str	r3, [sp, #40]	; 0x28
10005cfe:	2f47      	cmp	r7, #71	; 0x47
10005d00:	d901      	bls.n	10005d06 <_printf_float+0x8e>
10005d02:	4bae      	ldr	r3, [pc, #696]	; (10005fbc <_printf_float+0x344>)
10005d04:	930a      	str	r3, [sp, #40]	; 0x28
10005d06:	2303      	movs	r3, #3
10005d08:	1c31      	adds	r1, r6, #0
10005d0a:	6123      	str	r3, [r4, #16]
10005d0c:	3301      	adds	r3, #1
10005d0e:	4399      	bics	r1, r3
10005d10:	6021      	str	r1, [r4, #0]
10005d12:	2600      	movs	r6, #0
10005d14:	e080      	b.n	10005e18 <_printf_float+0x1a0>
10005d16:	2180      	movs	r1, #128	; 0x80
10005d18:	6860      	ldr	r0, [r4, #4]
10005d1a:	00c9      	lsls	r1, r1, #3
10005d1c:	1c43      	adds	r3, r0, #1
10005d1e:	d101      	bne.n	10005d24 <_printf_float+0xac>
10005d20:	2306      	movs	r3, #6
10005d22:	e009      	b.n	10005d38 <_printf_float+0xc0>
10005d24:	6ca2      	ldr	r2, [r4, #72]	; 0x48
10005d26:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
10005d28:	2f67      	cmp	r7, #103	; 0x67
10005d2a:	d001      	beq.n	10005d30 <_printf_float+0xb8>
10005d2c:	2f47      	cmp	r7, #71	; 0x47
10005d2e:	d104      	bne.n	10005d3a <_printf_float+0xc2>
10005d30:	2800      	cmp	r0, #0
10005d32:	d000      	beq.n	10005d36 <_printf_float+0xbe>
10005d34:	e1c1      	b.n	100060ba <_printf_float+0x442>
10005d36:	2301      	movs	r3, #1
10005d38:	6063      	str	r3, [r4, #4]
10005d3a:	6863      	ldr	r3, [r4, #4]
10005d3c:	4331      	orrs	r1, r6
10005d3e:	9300      	str	r3, [sp, #0]
10005d40:	2323      	movs	r3, #35	; 0x23
10005d42:	6021      	str	r1, [r4, #0]
10005d44:	9101      	str	r1, [sp, #4]
10005d46:	2100      	movs	r1, #0
10005d48:	aa06      	add	r2, sp, #24
10005d4a:	189b      	adds	r3, r3, r2
10005d4c:	9302      	str	r3, [sp, #8]
10005d4e:	ab0f      	add	r3, sp, #60	; 0x3c
10005d50:	9303      	str	r3, [sp, #12]
10005d52:	ab10      	add	r3, sp, #64	; 0x40
10005d54:	9305      	str	r3, [sp, #20]
10005d56:	9704      	str	r7, [sp, #16]
10005d58:	6ca2      	ldr	r2, [r4, #72]	; 0x48
10005d5a:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
10005d5c:	9106      	str	r1, [sp, #24]
10005d5e:	1c28      	adds	r0, r5, #0
10005d60:	f7ff fef4 	bl	10005b4c <__cvt>
10005d64:	2320      	movs	r3, #32
10005d66:	1c3a      	adds	r2, r7, #0
10005d68:	900a      	str	r0, [sp, #40]	; 0x28
10005d6a:	439a      	bics	r2, r3
10005d6c:	2a47      	cmp	r2, #71	; 0x47
10005d6e:	d107      	bne.n	10005d80 <_printf_float+0x108>
10005d70:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
10005d72:	1cda      	adds	r2, r3, #3
10005d74:	db02      	blt.n	10005d7c <_printf_float+0x104>
10005d76:	6862      	ldr	r2, [r4, #4]
10005d78:	4293      	cmp	r3, r2
10005d7a:	dd2d      	ble.n	10005dd8 <_printf_float+0x160>
10005d7c:	3f02      	subs	r7, #2
10005d7e:	b2ff      	uxtb	r7, r7
10005d80:	990f      	ldr	r1, [sp, #60]	; 0x3c
10005d82:	2f65      	cmp	r7, #101	; 0x65
10005d84:	d812      	bhi.n	10005dac <_printf_float+0x134>
10005d86:	1c20      	adds	r0, r4, #0
10005d88:	3901      	subs	r1, #1
10005d8a:	1c3a      	adds	r2, r7, #0
10005d8c:	3050      	adds	r0, #80	; 0x50
10005d8e:	910f      	str	r1, [sp, #60]	; 0x3c
10005d90:	f7ff ff40 	bl	10005c14 <__exponent>
10005d94:	9a10      	ldr	r2, [sp, #64]	; 0x40
10005d96:	1c06      	adds	r6, r0, #0
10005d98:	1883      	adds	r3, r0, r2
10005d9a:	6123      	str	r3, [r4, #16]
10005d9c:	2a01      	cmp	r2, #1
10005d9e:	dc02      	bgt.n	10005da6 <_printf_float+0x12e>
10005da0:	6822      	ldr	r2, [r4, #0]
10005da2:	07d2      	lsls	r2, r2, #31
10005da4:	d52e      	bpl.n	10005e04 <_printf_float+0x18c>
10005da6:	3301      	adds	r3, #1
10005da8:	6123      	str	r3, [r4, #16]
10005daa:	e02b      	b.n	10005e04 <_printf_float+0x18c>
10005dac:	2f66      	cmp	r7, #102	; 0x66
10005dae:	d114      	bne.n	10005dda <_printf_float+0x162>
10005db0:	6863      	ldr	r3, [r4, #4]
10005db2:	2900      	cmp	r1, #0
10005db4:	dd08      	ble.n	10005dc8 <_printf_float+0x150>
10005db6:	6121      	str	r1, [r4, #16]
10005db8:	2b00      	cmp	r3, #0
10005dba:	d102      	bne.n	10005dc2 <_printf_float+0x14a>
10005dbc:	6822      	ldr	r2, [r4, #0]
10005dbe:	07d2      	lsls	r2, r2, #31
10005dc0:	d51d      	bpl.n	10005dfe <_printf_float+0x186>
10005dc2:	3301      	adds	r3, #1
10005dc4:	18cb      	adds	r3, r1, r3
10005dc6:	e011      	b.n	10005dec <_printf_float+0x174>
10005dc8:	2b00      	cmp	r3, #0
10005dca:	d103      	bne.n	10005dd4 <_printf_float+0x15c>
10005dcc:	2201      	movs	r2, #1
10005dce:	6821      	ldr	r1, [r4, #0]
10005dd0:	4211      	tst	r1, r2
10005dd2:	d013      	beq.n	10005dfc <_printf_float+0x184>
10005dd4:	1c9a      	adds	r2, r3, #2
10005dd6:	e011      	b.n	10005dfc <_printf_float+0x184>
10005dd8:	2767      	movs	r7, #103	; 0x67
10005dda:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
10005ddc:	9810      	ldr	r0, [sp, #64]	; 0x40
10005dde:	4283      	cmp	r3, r0
10005de0:	db06      	blt.n	10005df0 <_printf_float+0x178>
10005de2:	6822      	ldr	r2, [r4, #0]
10005de4:	6123      	str	r3, [r4, #16]
10005de6:	07d2      	lsls	r2, r2, #31
10005de8:	d509      	bpl.n	10005dfe <_printf_float+0x186>
10005dea:	3301      	adds	r3, #1
10005dec:	6123      	str	r3, [r4, #16]
10005dee:	e006      	b.n	10005dfe <_printf_float+0x186>
10005df0:	2201      	movs	r2, #1
10005df2:	2b00      	cmp	r3, #0
10005df4:	dc01      	bgt.n	10005dfa <_printf_float+0x182>
10005df6:	2102      	movs	r1, #2
10005df8:	1aca      	subs	r2, r1, r3
10005dfa:	1882      	adds	r2, r0, r2
10005dfc:	6122      	str	r2, [r4, #16]
10005dfe:	2600      	movs	r6, #0
10005e00:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
10005e02:	65a3      	str	r3, [r4, #88]	; 0x58
10005e04:	2323      	movs	r3, #35	; 0x23
10005e06:	aa06      	add	r2, sp, #24
10005e08:	189b      	adds	r3, r3, r2
10005e0a:	781b      	ldrb	r3, [r3, #0]
10005e0c:	2b00      	cmp	r3, #0
10005e0e:	d003      	beq.n	10005e18 <_printf_float+0x1a0>
10005e10:	1c23      	adds	r3, r4, #0
10005e12:	222d      	movs	r2, #45	; 0x2d
10005e14:	3343      	adds	r3, #67	; 0x43
10005e16:	701a      	strb	r2, [r3, #0]
10005e18:	9b09      	ldr	r3, [sp, #36]	; 0x24
10005e1a:	1c28      	adds	r0, r5, #0
10005e1c:	9300      	str	r3, [sp, #0]
10005e1e:	1c21      	adds	r1, r4, #0
10005e20:	9b08      	ldr	r3, [sp, #32]
10005e22:	aa11      	add	r2, sp, #68	; 0x44
10005e24:	f000 f960 	bl	100060e8 <_printf_common>
10005e28:	1c43      	adds	r3, r0, #1
10005e2a:	d102      	bne.n	10005e32 <_printf_float+0x1ba>
10005e2c:	2001      	movs	r0, #1
10005e2e:	4240      	negs	r0, r0
10005e30:	e157      	b.n	100060e2 <_printf_float+0x46a>
10005e32:	6822      	ldr	r2, [r4, #0]
10005e34:	0553      	lsls	r3, r2, #21
10005e36:	d404      	bmi.n	10005e42 <_printf_float+0x1ca>
10005e38:	1c28      	adds	r0, r5, #0
10005e3a:	9908      	ldr	r1, [sp, #32]
10005e3c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
10005e3e:	6923      	ldr	r3, [r4, #16]
10005e40:	e117      	b.n	10006072 <_printf_float+0x3fa>
10005e42:	2f65      	cmp	r7, #101	; 0x65
10005e44:	d800      	bhi.n	10005e48 <_printf_float+0x1d0>
10005e46:	e0d5      	b.n	10005ff4 <_printf_float+0x37c>
10005e48:	6ca0      	ldr	r0, [r4, #72]	; 0x48
10005e4a:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
10005e4c:	2200      	movs	r2, #0
10005e4e:	2300      	movs	r3, #0
10005e50:	f002 fba4 	bl	1000859c <__aeabi_dcmpeq>
10005e54:	2800      	cmp	r0, #0
10005e56:	d02b      	beq.n	10005eb0 <_printf_float+0x238>
10005e58:	2301      	movs	r3, #1
10005e5a:	1c28      	adds	r0, r5, #0
10005e5c:	9908      	ldr	r1, [sp, #32]
10005e5e:	4a58      	ldr	r2, [pc, #352]	; (10005fc0 <_printf_float+0x348>)
10005e60:	9e09      	ldr	r6, [sp, #36]	; 0x24
10005e62:	47b0      	blx	r6
10005e64:	1c43      	adds	r3, r0, #1
10005e66:	d0e1      	beq.n	10005e2c <_printf_float+0x1b4>
10005e68:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
10005e6a:	9a10      	ldr	r2, [sp, #64]	; 0x40
10005e6c:	4293      	cmp	r3, r2
10005e6e:	db07      	blt.n	10005e80 <_printf_float+0x208>
10005e70:	6823      	ldr	r3, [r4, #0]
10005e72:	07db      	lsls	r3, r3, #31
10005e74:	d404      	bmi.n	10005e80 <_printf_float+0x208>
10005e76:	6823      	ldr	r3, [r4, #0]
10005e78:	079b      	lsls	r3, r3, #30
10005e7a:	d500      	bpl.n	10005e7e <_printf_float+0x206>
10005e7c:	e11b      	b.n	100060b6 <_printf_float+0x43e>
10005e7e:	e114      	b.n	100060aa <_printf_float+0x432>
10005e80:	9e09      	ldr	r6, [sp, #36]	; 0x24
10005e82:	1c28      	adds	r0, r5, #0
10005e84:	9908      	ldr	r1, [sp, #32]
10005e86:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
10005e88:	9b0c      	ldr	r3, [sp, #48]	; 0x30
10005e8a:	47b0      	blx	r6
10005e8c:	2600      	movs	r6, #0
10005e8e:	1c43      	adds	r3, r0, #1
10005e90:	d0cc      	beq.n	10005e2c <_printf_float+0x1b4>
10005e92:	9b10      	ldr	r3, [sp, #64]	; 0x40
10005e94:	3b01      	subs	r3, #1
10005e96:	429e      	cmp	r6, r3
10005e98:	daed      	bge.n	10005e76 <_printf_float+0x1fe>
10005e9a:	1c22      	adds	r2, r4, #0
10005e9c:	2301      	movs	r3, #1
10005e9e:	1c28      	adds	r0, r5, #0
10005ea0:	9908      	ldr	r1, [sp, #32]
10005ea2:	321a      	adds	r2, #26
10005ea4:	9f09      	ldr	r7, [sp, #36]	; 0x24
10005ea6:	47b8      	blx	r7
10005ea8:	1c43      	adds	r3, r0, #1
10005eaa:	d0bf      	beq.n	10005e2c <_printf_float+0x1b4>
10005eac:	3601      	adds	r6, #1
10005eae:	e7f0      	b.n	10005e92 <_printf_float+0x21a>
10005eb0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
10005eb2:	2b00      	cmp	r3, #0
10005eb4:	dc2b      	bgt.n	10005f0e <_printf_float+0x296>
10005eb6:	2301      	movs	r3, #1
10005eb8:	1c28      	adds	r0, r5, #0
10005eba:	9908      	ldr	r1, [sp, #32]
10005ebc:	4a40      	ldr	r2, [pc, #256]	; (10005fc0 <_printf_float+0x348>)
10005ebe:	9e09      	ldr	r6, [sp, #36]	; 0x24
10005ec0:	47b0      	blx	r6
10005ec2:	1c43      	adds	r3, r0, #1
10005ec4:	d0b2      	beq.n	10005e2c <_printf_float+0x1b4>
10005ec6:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
10005ec8:	2b00      	cmp	r3, #0
10005eca:	d105      	bne.n	10005ed8 <_printf_float+0x260>
10005ecc:	9b10      	ldr	r3, [sp, #64]	; 0x40
10005ece:	2b00      	cmp	r3, #0
10005ed0:	d102      	bne.n	10005ed8 <_printf_float+0x260>
10005ed2:	6823      	ldr	r3, [r4, #0]
10005ed4:	07db      	lsls	r3, r3, #31
10005ed6:	d5ce      	bpl.n	10005e76 <_printf_float+0x1fe>
10005ed8:	9e09      	ldr	r6, [sp, #36]	; 0x24
10005eda:	1c28      	adds	r0, r5, #0
10005edc:	9908      	ldr	r1, [sp, #32]
10005ede:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
10005ee0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
10005ee2:	47b0      	blx	r6
10005ee4:	2600      	movs	r6, #0
10005ee6:	1c43      	adds	r3, r0, #1
10005ee8:	d0a0      	beq.n	10005e2c <_printf_float+0x1b4>
10005eea:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
10005eec:	1c28      	adds	r0, r5, #0
10005eee:	425b      	negs	r3, r3
10005ef0:	9908      	ldr	r1, [sp, #32]
10005ef2:	429e      	cmp	r6, r3
10005ef4:	da08      	bge.n	10005f08 <_printf_float+0x290>
10005ef6:	1c22      	adds	r2, r4, #0
10005ef8:	2301      	movs	r3, #1
10005efa:	321a      	adds	r2, #26
10005efc:	9f09      	ldr	r7, [sp, #36]	; 0x24
10005efe:	47b8      	blx	r7
10005f00:	1c43      	adds	r3, r0, #1
10005f02:	d093      	beq.n	10005e2c <_printf_float+0x1b4>
10005f04:	3601      	adds	r6, #1
10005f06:	e7f0      	b.n	10005eea <_printf_float+0x272>
10005f08:	9a0a      	ldr	r2, [sp, #40]	; 0x28
10005f0a:	9b10      	ldr	r3, [sp, #64]	; 0x40
10005f0c:	e0b1      	b.n	10006072 <_printf_float+0x3fa>
10005f0e:	9b10      	ldr	r3, [sp, #64]	; 0x40
10005f10:	6da6      	ldr	r6, [r4, #88]	; 0x58
10005f12:	429e      	cmp	r6, r3
10005f14:	dd00      	ble.n	10005f18 <_printf_float+0x2a0>
10005f16:	1c1e      	adds	r6, r3, #0
10005f18:	2e00      	cmp	r6, #0
10005f1a:	dc01      	bgt.n	10005f20 <_printf_float+0x2a8>
10005f1c:	2300      	movs	r3, #0
10005f1e:	e014      	b.n	10005f4a <_printf_float+0x2d2>
10005f20:	1c33      	adds	r3, r6, #0
10005f22:	1c28      	adds	r0, r5, #0
10005f24:	9908      	ldr	r1, [sp, #32]
10005f26:	9a0a      	ldr	r2, [sp, #40]	; 0x28
10005f28:	9f09      	ldr	r7, [sp, #36]	; 0x24
10005f2a:	47b8      	blx	r7
10005f2c:	1c43      	adds	r3, r0, #1
10005f2e:	d1f5      	bne.n	10005f1c <_printf_float+0x2a4>
10005f30:	e77c      	b.n	10005e2c <_printf_float+0x1b4>
10005f32:	1c22      	adds	r2, r4, #0
10005f34:	2301      	movs	r3, #1
10005f36:	1c28      	adds	r0, r5, #0
10005f38:	9908      	ldr	r1, [sp, #32]
10005f3a:	321a      	adds	r2, #26
10005f3c:	9f09      	ldr	r7, [sp, #36]	; 0x24
10005f3e:	47b8      	blx	r7
10005f40:	1c43      	adds	r3, r0, #1
10005f42:	d100      	bne.n	10005f46 <_printf_float+0x2ce>
10005f44:	e772      	b.n	10005e2c <_printf_float+0x1b4>
10005f46:	9b0d      	ldr	r3, [sp, #52]	; 0x34
10005f48:	3301      	adds	r3, #1
10005f4a:	930d      	str	r3, [sp, #52]	; 0x34
10005f4c:	43f3      	mvns	r3, r6
10005f4e:	6da2      	ldr	r2, [r4, #88]	; 0x58
10005f50:	17db      	asrs	r3, r3, #31
10005f52:	990d      	ldr	r1, [sp, #52]	; 0x34
10005f54:	4033      	ands	r3, r6
10005f56:	1ad3      	subs	r3, r2, r3
10005f58:	4299      	cmp	r1, r3
10005f5a:	dbea      	blt.n	10005f32 <_printf_float+0x2ba>
10005f5c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
10005f5e:	189e      	adds	r6, r3, r2
10005f60:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
10005f62:	9a10      	ldr	r2, [sp, #64]	; 0x40
10005f64:	4293      	cmp	r3, r2
10005f66:	db0e      	blt.n	10005f86 <_printf_float+0x30e>
10005f68:	6823      	ldr	r3, [r4, #0]
10005f6a:	07db      	lsls	r3, r3, #31
10005f6c:	d40b      	bmi.n	10005f86 <_printf_float+0x30e>
10005f6e:	9b10      	ldr	r3, [sp, #64]	; 0x40
10005f70:	9a0a      	ldr	r2, [sp, #40]	; 0x28
10005f72:	18d7      	adds	r7, r2, r3
10005f74:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
10005f76:	1bbf      	subs	r7, r7, r6
10005f78:	1a9b      	subs	r3, r3, r2
10005f7a:	429f      	cmp	r7, r3
10005f7c:	dd00      	ble.n	10005f80 <_printf_float+0x308>
10005f7e:	1c1f      	adds	r7, r3, #0
10005f80:	2f00      	cmp	r7, #0
10005f82:	dc09      	bgt.n	10005f98 <_printf_float+0x320>
10005f84:	e011      	b.n	10005faa <_printf_float+0x332>
10005f86:	9b0c      	ldr	r3, [sp, #48]	; 0x30
10005f88:	1c28      	adds	r0, r5, #0
10005f8a:	9908      	ldr	r1, [sp, #32]
10005f8c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
10005f8e:	9f09      	ldr	r7, [sp, #36]	; 0x24
10005f90:	47b8      	blx	r7
10005f92:	1c43      	adds	r3, r0, #1
10005f94:	d1eb      	bne.n	10005f6e <_printf_float+0x2f6>
10005f96:	e749      	b.n	10005e2c <_printf_float+0x1b4>
10005f98:	1c32      	adds	r2, r6, #0
10005f9a:	1c3b      	adds	r3, r7, #0
10005f9c:	1c28      	adds	r0, r5, #0
10005f9e:	9908      	ldr	r1, [sp, #32]
10005fa0:	9e09      	ldr	r6, [sp, #36]	; 0x24
10005fa2:	47b0      	blx	r6
10005fa4:	1c43      	adds	r3, r0, #1
10005fa6:	d100      	bne.n	10005faa <_printf_float+0x332>
10005fa8:	e740      	b.n	10005e2c <_printf_float+0x1b4>
10005faa:	2300      	movs	r3, #0
10005fac:	e016      	b.n	10005fdc <_printf_float+0x364>
10005fae:	46c0      	nop			; (mov r8, r8)
10005fb0:	1000a7b0 	.word	0x1000a7b0
10005fb4:	1000a7b4 	.word	0x1000a7b4
10005fb8:	1000a7b8 	.word	0x1000a7b8
10005fbc:	1000a7bc 	.word	0x1000a7bc
10005fc0:	1000a7c0 	.word	0x1000a7c0
10005fc4:	1c22      	adds	r2, r4, #0
10005fc6:	2301      	movs	r3, #1
10005fc8:	1c28      	adds	r0, r5, #0
10005fca:	9908      	ldr	r1, [sp, #32]
10005fcc:	321a      	adds	r2, #26
10005fce:	9e09      	ldr	r6, [sp, #36]	; 0x24
10005fd0:	47b0      	blx	r6
10005fd2:	1c43      	adds	r3, r0, #1
10005fd4:	d100      	bne.n	10005fd8 <_printf_float+0x360>
10005fd6:	e729      	b.n	10005e2c <_printf_float+0x1b4>
10005fd8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
10005fda:	3301      	adds	r3, #1
10005fdc:	930a      	str	r3, [sp, #40]	; 0x28
10005fde:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
10005fe0:	9b10      	ldr	r3, [sp, #64]	; 0x40
10005fe2:	1a9a      	subs	r2, r3, r2
10005fe4:	43fb      	mvns	r3, r7
10005fe6:	17db      	asrs	r3, r3, #31
10005fe8:	403b      	ands	r3, r7
10005fea:	1ad3      	subs	r3, r2, r3
10005fec:	9a0a      	ldr	r2, [sp, #40]	; 0x28
10005fee:	429a      	cmp	r2, r3
10005ff0:	dbe8      	blt.n	10005fc4 <_printf_float+0x34c>
10005ff2:	e740      	b.n	10005e76 <_printf_float+0x1fe>
10005ff4:	9b10      	ldr	r3, [sp, #64]	; 0x40
10005ff6:	1c28      	adds	r0, r5, #0
10005ff8:	9908      	ldr	r1, [sp, #32]
10005ffa:	2b01      	cmp	r3, #1
10005ffc:	dc02      	bgt.n	10006004 <_printf_float+0x38c>
10005ffe:	2301      	movs	r3, #1
10006000:	421a      	tst	r2, r3
10006002:	d03c      	beq.n	1000607e <_printf_float+0x406>
10006004:	2301      	movs	r3, #1
10006006:	9a0a      	ldr	r2, [sp, #40]	; 0x28
10006008:	9f09      	ldr	r7, [sp, #36]	; 0x24
1000600a:	47b8      	blx	r7
1000600c:	1c43      	adds	r3, r0, #1
1000600e:	d100      	bne.n	10006012 <_printf_float+0x39a>
10006010:	e70c      	b.n	10005e2c <_printf_float+0x1b4>
10006012:	9b0c      	ldr	r3, [sp, #48]	; 0x30
10006014:	1c28      	adds	r0, r5, #0
10006016:	9908      	ldr	r1, [sp, #32]
10006018:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
1000601a:	9f09      	ldr	r7, [sp, #36]	; 0x24
1000601c:	47b8      	blx	r7
1000601e:	1c43      	adds	r3, r0, #1
10006020:	d100      	bne.n	10006024 <_printf_float+0x3ac>
10006022:	e703      	b.n	10005e2c <_printf_float+0x1b4>
10006024:	6ca0      	ldr	r0, [r4, #72]	; 0x48
10006026:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
10006028:	2300      	movs	r3, #0
1000602a:	2200      	movs	r2, #0
1000602c:	f002 fab6 	bl	1000859c <__aeabi_dcmpeq>
10006030:	2300      	movs	r3, #0
10006032:	2800      	cmp	r0, #0
10006034:	d112      	bne.n	1000605c <_printf_float+0x3e4>
10006036:	9a0a      	ldr	r2, [sp, #40]	; 0x28
10006038:	9b10      	ldr	r3, [sp, #64]	; 0x40
1000603a:	3201      	adds	r2, #1
1000603c:	3b01      	subs	r3, #1
1000603e:	1c28      	adds	r0, r5, #0
10006040:	9908      	ldr	r1, [sp, #32]
10006042:	e01d      	b.n	10006080 <_printf_float+0x408>
10006044:	1c22      	adds	r2, r4, #0
10006046:	2301      	movs	r3, #1
10006048:	1c28      	adds	r0, r5, #0
1000604a:	9908      	ldr	r1, [sp, #32]
1000604c:	321a      	adds	r2, #26
1000604e:	9f09      	ldr	r7, [sp, #36]	; 0x24
10006050:	47b8      	blx	r7
10006052:	1c43      	adds	r3, r0, #1
10006054:	d100      	bne.n	10006058 <_printf_float+0x3e0>
10006056:	e6e9      	b.n	10005e2c <_printf_float+0x1b4>
10006058:	9b0a      	ldr	r3, [sp, #40]	; 0x28
1000605a:	3301      	adds	r3, #1
1000605c:	930a      	str	r3, [sp, #40]	; 0x28
1000605e:	9b10      	ldr	r3, [sp, #64]	; 0x40
10006060:	9a0a      	ldr	r2, [sp, #40]	; 0x28
10006062:	3b01      	subs	r3, #1
10006064:	429a      	cmp	r2, r3
10006066:	dbed      	blt.n	10006044 <_printf_float+0x3cc>
10006068:	1c22      	adds	r2, r4, #0
1000606a:	1c28      	adds	r0, r5, #0
1000606c:	1c33      	adds	r3, r6, #0
1000606e:	9908      	ldr	r1, [sp, #32]
10006070:	3250      	adds	r2, #80	; 0x50
10006072:	9e09      	ldr	r6, [sp, #36]	; 0x24
10006074:	47b0      	blx	r6
10006076:	1c43      	adds	r3, r0, #1
10006078:	d000      	beq.n	1000607c <_printf_float+0x404>
1000607a:	e6fc      	b.n	10005e76 <_printf_float+0x1fe>
1000607c:	e6d6      	b.n	10005e2c <_printf_float+0x1b4>
1000607e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
10006080:	9f09      	ldr	r7, [sp, #36]	; 0x24
10006082:	47b8      	blx	r7
10006084:	1c43      	adds	r3, r0, #1
10006086:	d1ef      	bne.n	10006068 <_printf_float+0x3f0>
10006088:	e6d0      	b.n	10005e2c <_printf_float+0x1b4>
1000608a:	1c22      	adds	r2, r4, #0
1000608c:	2301      	movs	r3, #1
1000608e:	1c28      	adds	r0, r5, #0
10006090:	9908      	ldr	r1, [sp, #32]
10006092:	3219      	adds	r2, #25
10006094:	9f09      	ldr	r7, [sp, #36]	; 0x24
10006096:	47b8      	blx	r7
10006098:	1c43      	adds	r3, r0, #1
1000609a:	d100      	bne.n	1000609e <_printf_float+0x426>
1000609c:	e6c6      	b.n	10005e2c <_printf_float+0x1b4>
1000609e:	3601      	adds	r6, #1
100060a0:	68e3      	ldr	r3, [r4, #12]
100060a2:	9a11      	ldr	r2, [sp, #68]	; 0x44
100060a4:	1a9b      	subs	r3, r3, r2
100060a6:	429e      	cmp	r6, r3
100060a8:	dbef      	blt.n	1000608a <_printf_float+0x412>
100060aa:	9b11      	ldr	r3, [sp, #68]	; 0x44
100060ac:	68e0      	ldr	r0, [r4, #12]
100060ae:	4298      	cmp	r0, r3
100060b0:	da17      	bge.n	100060e2 <_printf_float+0x46a>
100060b2:	1c18      	adds	r0, r3, #0
100060b4:	e015      	b.n	100060e2 <_printf_float+0x46a>
100060b6:	2600      	movs	r6, #0
100060b8:	e7f2      	b.n	100060a0 <_printf_float+0x428>
100060ba:	4331      	orrs	r1, r6
100060bc:	6021      	str	r1, [r4, #0]
100060be:	9101      	str	r1, [sp, #4]
100060c0:	2123      	movs	r1, #35	; 0x23
100060c2:	9000      	str	r0, [sp, #0]
100060c4:	a806      	add	r0, sp, #24
100060c6:	1809      	adds	r1, r1, r0
100060c8:	9102      	str	r1, [sp, #8]
100060ca:	a90f      	add	r1, sp, #60	; 0x3c
100060cc:	9103      	str	r1, [sp, #12]
100060ce:	a910      	add	r1, sp, #64	; 0x40
100060d0:	9105      	str	r1, [sp, #20]
100060d2:	2100      	movs	r1, #0
100060d4:	9704      	str	r7, [sp, #16]
100060d6:	9106      	str	r1, [sp, #24]
100060d8:	1c28      	adds	r0, r5, #0
100060da:	f7ff fd37 	bl	10005b4c <__cvt>
100060de:	900a      	str	r0, [sp, #40]	; 0x28
100060e0:	e646      	b.n	10005d70 <_printf_float+0xf8>
100060e2:	b013      	add	sp, #76	; 0x4c
100060e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
100060e6:	46c0      	nop			; (mov r8, r8)

100060e8 <_printf_common>:
100060e8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
100060ea:	1c17      	adds	r7, r2, #0
100060ec:	9301      	str	r3, [sp, #4]
100060ee:	690a      	ldr	r2, [r1, #16]
100060f0:	688b      	ldr	r3, [r1, #8]
100060f2:	9000      	str	r0, [sp, #0]
100060f4:	1c0c      	adds	r4, r1, #0
100060f6:	4293      	cmp	r3, r2
100060f8:	da00      	bge.n	100060fc <_printf_common+0x14>
100060fa:	1c13      	adds	r3, r2, #0
100060fc:	1c22      	adds	r2, r4, #0
100060fe:	603b      	str	r3, [r7, #0]
10006100:	3243      	adds	r2, #67	; 0x43
10006102:	7812      	ldrb	r2, [r2, #0]
10006104:	2a00      	cmp	r2, #0
10006106:	d001      	beq.n	1000610c <_printf_common+0x24>
10006108:	3301      	adds	r3, #1
1000610a:	603b      	str	r3, [r7, #0]
1000610c:	6823      	ldr	r3, [r4, #0]
1000610e:	069b      	lsls	r3, r3, #26
10006110:	d502      	bpl.n	10006118 <_printf_common+0x30>
10006112:	683b      	ldr	r3, [r7, #0]
10006114:	3302      	adds	r3, #2
10006116:	603b      	str	r3, [r7, #0]
10006118:	2506      	movs	r5, #6
1000611a:	6823      	ldr	r3, [r4, #0]
1000611c:	401d      	ands	r5, r3
1000611e:	d01e      	beq.n	1000615e <_printf_common+0x76>
10006120:	1c23      	adds	r3, r4, #0
10006122:	3343      	adds	r3, #67	; 0x43
10006124:	781b      	ldrb	r3, [r3, #0]
10006126:	1e5a      	subs	r2, r3, #1
10006128:	4193      	sbcs	r3, r2
1000612a:	6822      	ldr	r2, [r4, #0]
1000612c:	0692      	lsls	r2, r2, #26
1000612e:	d51c      	bpl.n	1000616a <_printf_common+0x82>
10006130:	2030      	movs	r0, #48	; 0x30
10006132:	18e1      	adds	r1, r4, r3
10006134:	3140      	adds	r1, #64	; 0x40
10006136:	70c8      	strb	r0, [r1, #3]
10006138:	1c21      	adds	r1, r4, #0
1000613a:	1c5a      	adds	r2, r3, #1
1000613c:	3145      	adds	r1, #69	; 0x45
1000613e:	7809      	ldrb	r1, [r1, #0]
10006140:	18a2      	adds	r2, r4, r2
10006142:	3240      	adds	r2, #64	; 0x40
10006144:	3302      	adds	r3, #2
10006146:	70d1      	strb	r1, [r2, #3]
10006148:	e00f      	b.n	1000616a <_printf_common+0x82>
1000614a:	1c22      	adds	r2, r4, #0
1000614c:	2301      	movs	r3, #1
1000614e:	9800      	ldr	r0, [sp, #0]
10006150:	9901      	ldr	r1, [sp, #4]
10006152:	3219      	adds	r2, #25
10006154:	9e08      	ldr	r6, [sp, #32]
10006156:	47b0      	blx	r6
10006158:	1c43      	adds	r3, r0, #1
1000615a:	d00e      	beq.n	1000617a <_printf_common+0x92>
1000615c:	3501      	adds	r5, #1
1000615e:	68e3      	ldr	r3, [r4, #12]
10006160:	683a      	ldr	r2, [r7, #0]
10006162:	1a9b      	subs	r3, r3, r2
10006164:	429d      	cmp	r5, r3
10006166:	dbf0      	blt.n	1000614a <_printf_common+0x62>
10006168:	e7da      	b.n	10006120 <_printf_common+0x38>
1000616a:	1c22      	adds	r2, r4, #0
1000616c:	9800      	ldr	r0, [sp, #0]
1000616e:	9901      	ldr	r1, [sp, #4]
10006170:	3243      	adds	r2, #67	; 0x43
10006172:	9d08      	ldr	r5, [sp, #32]
10006174:	47a8      	blx	r5
10006176:	1c43      	adds	r3, r0, #1
10006178:	d102      	bne.n	10006180 <_printf_common+0x98>
1000617a:	2001      	movs	r0, #1
1000617c:	4240      	negs	r0, r0
1000617e:	e020      	b.n	100061c2 <_printf_common+0xda>
10006180:	2306      	movs	r3, #6
10006182:	6820      	ldr	r0, [r4, #0]
10006184:	68e1      	ldr	r1, [r4, #12]
10006186:	683a      	ldr	r2, [r7, #0]
10006188:	4003      	ands	r3, r0
1000618a:	2500      	movs	r5, #0
1000618c:	2b04      	cmp	r3, #4
1000618e:	d103      	bne.n	10006198 <_printf_common+0xb0>
10006190:	1a8d      	subs	r5, r1, r2
10006192:	43eb      	mvns	r3, r5
10006194:	17db      	asrs	r3, r3, #31
10006196:	401d      	ands	r5, r3
10006198:	68a3      	ldr	r3, [r4, #8]
1000619a:	6922      	ldr	r2, [r4, #16]
1000619c:	4293      	cmp	r3, r2
1000619e:	dd01      	ble.n	100061a4 <_printf_common+0xbc>
100061a0:	1a9b      	subs	r3, r3, r2
100061a2:	18ed      	adds	r5, r5, r3
100061a4:	2700      	movs	r7, #0
100061a6:	42af      	cmp	r7, r5
100061a8:	da0a      	bge.n	100061c0 <_printf_common+0xd8>
100061aa:	1c22      	adds	r2, r4, #0
100061ac:	2301      	movs	r3, #1
100061ae:	9800      	ldr	r0, [sp, #0]
100061b0:	9901      	ldr	r1, [sp, #4]
100061b2:	321a      	adds	r2, #26
100061b4:	9e08      	ldr	r6, [sp, #32]
100061b6:	47b0      	blx	r6
100061b8:	1c43      	adds	r3, r0, #1
100061ba:	d0de      	beq.n	1000617a <_printf_common+0x92>
100061bc:	3701      	adds	r7, #1
100061be:	e7f2      	b.n	100061a6 <_printf_common+0xbe>
100061c0:	2000      	movs	r0, #0
100061c2:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

100061c4 <_printf_i>:
100061c4:	b5f0      	push	{r4, r5, r6, r7, lr}
100061c6:	b08b      	sub	sp, #44	; 0x2c
100061c8:	9206      	str	r2, [sp, #24]
100061ca:	1c0a      	adds	r2, r1, #0
100061cc:	3243      	adds	r2, #67	; 0x43
100061ce:	9307      	str	r3, [sp, #28]
100061d0:	9005      	str	r0, [sp, #20]
100061d2:	9204      	str	r2, [sp, #16]
100061d4:	7e0a      	ldrb	r2, [r1, #24]
100061d6:	1c0c      	adds	r4, r1, #0
100061d8:	9b10      	ldr	r3, [sp, #64]	; 0x40
100061da:	2a6e      	cmp	r2, #110	; 0x6e
100061dc:	d100      	bne.n	100061e0 <_printf_i+0x1c>
100061de:	e0a8      	b.n	10006332 <_printf_i+0x16e>
100061e0:	d811      	bhi.n	10006206 <_printf_i+0x42>
100061e2:	2a63      	cmp	r2, #99	; 0x63
100061e4:	d022      	beq.n	1000622c <_printf_i+0x68>
100061e6:	d809      	bhi.n	100061fc <_printf_i+0x38>
100061e8:	2a00      	cmp	r2, #0
100061ea:	d100      	bne.n	100061ee <_printf_i+0x2a>
100061ec:	e0b2      	b.n	10006354 <_printf_i+0x190>
100061ee:	2a58      	cmp	r2, #88	; 0x58
100061f0:	d000      	beq.n	100061f4 <_printf_i+0x30>
100061f2:	e0c2      	b.n	1000637a <_printf_i+0x1b6>
100061f4:	3145      	adds	r1, #69	; 0x45
100061f6:	700a      	strb	r2, [r1, #0]
100061f8:	4a7c      	ldr	r2, [pc, #496]	; (100063ec <_printf_i+0x228>)
100061fa:	e04f      	b.n	1000629c <_printf_i+0xd8>
100061fc:	2a64      	cmp	r2, #100	; 0x64
100061fe:	d01d      	beq.n	1000623c <_printf_i+0x78>
10006200:	2a69      	cmp	r2, #105	; 0x69
10006202:	d01b      	beq.n	1000623c <_printf_i+0x78>
10006204:	e0b9      	b.n	1000637a <_printf_i+0x1b6>
10006206:	2a73      	cmp	r2, #115	; 0x73
10006208:	d100      	bne.n	1000620c <_printf_i+0x48>
1000620a:	e0a7      	b.n	1000635c <_printf_i+0x198>
1000620c:	d809      	bhi.n	10006222 <_printf_i+0x5e>
1000620e:	2a6f      	cmp	r2, #111	; 0x6f
10006210:	d029      	beq.n	10006266 <_printf_i+0xa2>
10006212:	2a70      	cmp	r2, #112	; 0x70
10006214:	d000      	beq.n	10006218 <_printf_i+0x54>
10006216:	e0b0      	b.n	1000637a <_printf_i+0x1b6>
10006218:	2220      	movs	r2, #32
1000621a:	6809      	ldr	r1, [r1, #0]
1000621c:	430a      	orrs	r2, r1
1000621e:	6022      	str	r2, [r4, #0]
10006220:	e037      	b.n	10006292 <_printf_i+0xce>
10006222:	2a75      	cmp	r2, #117	; 0x75
10006224:	d01f      	beq.n	10006266 <_printf_i+0xa2>
10006226:	2a78      	cmp	r2, #120	; 0x78
10006228:	d033      	beq.n	10006292 <_printf_i+0xce>
1000622a:	e0a6      	b.n	1000637a <_printf_i+0x1b6>
1000622c:	1c0d      	adds	r5, r1, #0
1000622e:	681a      	ldr	r2, [r3, #0]
10006230:	3542      	adds	r5, #66	; 0x42
10006232:	1d11      	adds	r1, r2, #4
10006234:	6019      	str	r1, [r3, #0]
10006236:	6813      	ldr	r3, [r2, #0]
10006238:	702b      	strb	r3, [r5, #0]
1000623a:	e0a1      	b.n	10006380 <_printf_i+0x1bc>
1000623c:	6821      	ldr	r1, [r4, #0]
1000623e:	681a      	ldr	r2, [r3, #0]
10006240:	0608      	lsls	r0, r1, #24
10006242:	d503      	bpl.n	1000624c <_printf_i+0x88>
10006244:	1d11      	adds	r1, r2, #4
10006246:	6019      	str	r1, [r3, #0]
10006248:	6816      	ldr	r6, [r2, #0]
1000624a:	e005      	b.n	10006258 <_printf_i+0x94>
1000624c:	0649      	lsls	r1, r1, #25
1000624e:	d5f9      	bpl.n	10006244 <_printf_i+0x80>
10006250:	1d11      	adds	r1, r2, #4
10006252:	6019      	str	r1, [r3, #0]
10006254:	2300      	movs	r3, #0
10006256:	5ed6      	ldrsh	r6, [r2, r3]
10006258:	2e00      	cmp	r6, #0
1000625a:	da3b      	bge.n	100062d4 <_printf_i+0x110>
1000625c:	232d      	movs	r3, #45	; 0x2d
1000625e:	9a04      	ldr	r2, [sp, #16]
10006260:	4276      	negs	r6, r6
10006262:	7013      	strb	r3, [r2, #0]
10006264:	e036      	b.n	100062d4 <_printf_i+0x110>
10006266:	6821      	ldr	r1, [r4, #0]
10006268:	681a      	ldr	r2, [r3, #0]
1000626a:	0608      	lsls	r0, r1, #24
1000626c:	d503      	bpl.n	10006276 <_printf_i+0xb2>
1000626e:	1d11      	adds	r1, r2, #4
10006270:	6019      	str	r1, [r3, #0]
10006272:	6816      	ldr	r6, [r2, #0]
10006274:	e005      	b.n	10006282 <_printf_i+0xbe>
10006276:	0649      	lsls	r1, r1, #25
10006278:	d5f9      	bpl.n	1000626e <_printf_i+0xaa>
1000627a:	1d11      	adds	r1, r2, #4
1000627c:	6019      	str	r1, [r3, #0]
1000627e:	6816      	ldr	r6, [r2, #0]
10006280:	b2b6      	uxth	r6, r6
10006282:	4b5a      	ldr	r3, [pc, #360]	; (100063ec <_printf_i+0x228>)
10006284:	7e22      	ldrb	r2, [r4, #24]
10006286:	9303      	str	r3, [sp, #12]
10006288:	270a      	movs	r7, #10
1000628a:	2a6f      	cmp	r2, #111	; 0x6f
1000628c:	d11d      	bne.n	100062ca <_printf_i+0x106>
1000628e:	2708      	movs	r7, #8
10006290:	e01b      	b.n	100062ca <_printf_i+0x106>
10006292:	1c22      	adds	r2, r4, #0
10006294:	2178      	movs	r1, #120	; 0x78
10006296:	3245      	adds	r2, #69	; 0x45
10006298:	7011      	strb	r1, [r2, #0]
1000629a:	4a55      	ldr	r2, [pc, #340]	; (100063f0 <_printf_i+0x22c>)
1000629c:	6819      	ldr	r1, [r3, #0]
1000629e:	9203      	str	r2, [sp, #12]
100062a0:	1d08      	adds	r0, r1, #4
100062a2:	6822      	ldr	r2, [r4, #0]
100062a4:	6018      	str	r0, [r3, #0]
100062a6:	680e      	ldr	r6, [r1, #0]
100062a8:	0610      	lsls	r0, r2, #24
100062aa:	d402      	bmi.n	100062b2 <_printf_i+0xee>
100062ac:	0650      	lsls	r0, r2, #25
100062ae:	d500      	bpl.n	100062b2 <_printf_i+0xee>
100062b0:	b2b6      	uxth	r6, r6
100062b2:	07d3      	lsls	r3, r2, #31
100062b4:	d502      	bpl.n	100062bc <_printf_i+0xf8>
100062b6:	2320      	movs	r3, #32
100062b8:	431a      	orrs	r2, r3
100062ba:	6022      	str	r2, [r4, #0]
100062bc:	2710      	movs	r7, #16
100062be:	2e00      	cmp	r6, #0
100062c0:	d103      	bne.n	100062ca <_printf_i+0x106>
100062c2:	2320      	movs	r3, #32
100062c4:	6822      	ldr	r2, [r4, #0]
100062c6:	439a      	bics	r2, r3
100062c8:	6022      	str	r2, [r4, #0]
100062ca:	1c23      	adds	r3, r4, #0
100062cc:	2200      	movs	r2, #0
100062ce:	3343      	adds	r3, #67	; 0x43
100062d0:	701a      	strb	r2, [r3, #0]
100062d2:	e002      	b.n	100062da <_printf_i+0x116>
100062d4:	270a      	movs	r7, #10
100062d6:	4b45      	ldr	r3, [pc, #276]	; (100063ec <_printf_i+0x228>)
100062d8:	9303      	str	r3, [sp, #12]
100062da:	6863      	ldr	r3, [r4, #4]
100062dc:	60a3      	str	r3, [r4, #8]
100062de:	2b00      	cmp	r3, #0
100062e0:	db03      	blt.n	100062ea <_printf_i+0x126>
100062e2:	2204      	movs	r2, #4
100062e4:	6821      	ldr	r1, [r4, #0]
100062e6:	4391      	bics	r1, r2
100062e8:	6021      	str	r1, [r4, #0]
100062ea:	2e00      	cmp	r6, #0
100062ec:	d102      	bne.n	100062f4 <_printf_i+0x130>
100062ee:	9d04      	ldr	r5, [sp, #16]
100062f0:	2b00      	cmp	r3, #0
100062f2:	d00e      	beq.n	10006312 <_printf_i+0x14e>
100062f4:	9d04      	ldr	r5, [sp, #16]
100062f6:	1c30      	adds	r0, r6, #0
100062f8:	1c39      	adds	r1, r7, #0
100062fa:	f7ff fa43 	bl	10005784 <__aeabi_uidivmod>
100062fe:	9b03      	ldr	r3, [sp, #12]
10006300:	3d01      	subs	r5, #1
10006302:	5c5b      	ldrb	r3, [r3, r1]
10006304:	1c30      	adds	r0, r6, #0
10006306:	702b      	strb	r3, [r5, #0]
10006308:	1c39      	adds	r1, r7, #0
1000630a:	f7ff f9b5 	bl	10005678 <__aeabi_uidiv>
1000630e:	1e06      	subs	r6, r0, #0
10006310:	d1f1      	bne.n	100062f6 <_printf_i+0x132>
10006312:	2f08      	cmp	r7, #8
10006314:	d109      	bne.n	1000632a <_printf_i+0x166>
10006316:	6823      	ldr	r3, [r4, #0]
10006318:	07db      	lsls	r3, r3, #31
1000631a:	d506      	bpl.n	1000632a <_printf_i+0x166>
1000631c:	6863      	ldr	r3, [r4, #4]
1000631e:	6922      	ldr	r2, [r4, #16]
10006320:	4293      	cmp	r3, r2
10006322:	dc02      	bgt.n	1000632a <_printf_i+0x166>
10006324:	2330      	movs	r3, #48	; 0x30
10006326:	3d01      	subs	r5, #1
10006328:	702b      	strb	r3, [r5, #0]
1000632a:	9b04      	ldr	r3, [sp, #16]
1000632c:	1b5b      	subs	r3, r3, r5
1000632e:	6123      	str	r3, [r4, #16]
10006330:	e02b      	b.n	1000638a <_printf_i+0x1c6>
10006332:	6809      	ldr	r1, [r1, #0]
10006334:	681a      	ldr	r2, [r3, #0]
10006336:	0608      	lsls	r0, r1, #24
10006338:	d407      	bmi.n	1000634a <_printf_i+0x186>
1000633a:	0649      	lsls	r1, r1, #25
1000633c:	d505      	bpl.n	1000634a <_printf_i+0x186>
1000633e:	1d11      	adds	r1, r2, #4
10006340:	6019      	str	r1, [r3, #0]
10006342:	6813      	ldr	r3, [r2, #0]
10006344:	8aa2      	ldrh	r2, [r4, #20]
10006346:	801a      	strh	r2, [r3, #0]
10006348:	e004      	b.n	10006354 <_printf_i+0x190>
1000634a:	1d11      	adds	r1, r2, #4
1000634c:	6019      	str	r1, [r3, #0]
1000634e:	6813      	ldr	r3, [r2, #0]
10006350:	6962      	ldr	r2, [r4, #20]
10006352:	601a      	str	r2, [r3, #0]
10006354:	2300      	movs	r3, #0
10006356:	9d04      	ldr	r5, [sp, #16]
10006358:	6123      	str	r3, [r4, #16]
1000635a:	e016      	b.n	1000638a <_printf_i+0x1c6>
1000635c:	681a      	ldr	r2, [r3, #0]
1000635e:	1d11      	adds	r1, r2, #4
10006360:	6019      	str	r1, [r3, #0]
10006362:	6815      	ldr	r5, [r2, #0]
10006364:	2100      	movs	r1, #0
10006366:	1c28      	adds	r0, r5, #0
10006368:	6862      	ldr	r2, [r4, #4]
1000636a:	f001 fa67 	bl	1000783c <memchr>
1000636e:	2800      	cmp	r0, #0
10006370:	d001      	beq.n	10006376 <_printf_i+0x1b2>
10006372:	1b40      	subs	r0, r0, r5
10006374:	6060      	str	r0, [r4, #4]
10006376:	6863      	ldr	r3, [r4, #4]
10006378:	e003      	b.n	10006382 <_printf_i+0x1be>
1000637a:	1c25      	adds	r5, r4, #0
1000637c:	3542      	adds	r5, #66	; 0x42
1000637e:	702a      	strb	r2, [r5, #0]
10006380:	2301      	movs	r3, #1
10006382:	6123      	str	r3, [r4, #16]
10006384:	2300      	movs	r3, #0
10006386:	9a04      	ldr	r2, [sp, #16]
10006388:	7013      	strb	r3, [r2, #0]
1000638a:	9b07      	ldr	r3, [sp, #28]
1000638c:	9805      	ldr	r0, [sp, #20]
1000638e:	9300      	str	r3, [sp, #0]
10006390:	1c21      	adds	r1, r4, #0
10006392:	9b06      	ldr	r3, [sp, #24]
10006394:	aa09      	add	r2, sp, #36	; 0x24
10006396:	f7ff fea7 	bl	100060e8 <_printf_common>
1000639a:	1c43      	adds	r3, r0, #1
1000639c:	d102      	bne.n	100063a4 <_printf_i+0x1e0>
1000639e:	2001      	movs	r0, #1
100063a0:	4240      	negs	r0, r0
100063a2:	e021      	b.n	100063e8 <_printf_i+0x224>
100063a4:	1c2a      	adds	r2, r5, #0
100063a6:	6923      	ldr	r3, [r4, #16]
100063a8:	9805      	ldr	r0, [sp, #20]
100063aa:	9906      	ldr	r1, [sp, #24]
100063ac:	9d07      	ldr	r5, [sp, #28]
100063ae:	47a8      	blx	r5
100063b0:	1c43      	adds	r3, r0, #1
100063b2:	d0f4      	beq.n	1000639e <_printf_i+0x1da>
100063b4:	6823      	ldr	r3, [r4, #0]
100063b6:	079b      	lsls	r3, r3, #30
100063b8:	d405      	bmi.n	100063c6 <_printf_i+0x202>
100063ba:	9b09      	ldr	r3, [sp, #36]	; 0x24
100063bc:	68e0      	ldr	r0, [r4, #12]
100063be:	4298      	cmp	r0, r3
100063c0:	da12      	bge.n	100063e8 <_printf_i+0x224>
100063c2:	1c18      	adds	r0, r3, #0
100063c4:	e010      	b.n	100063e8 <_printf_i+0x224>
100063c6:	2500      	movs	r5, #0
100063c8:	68e3      	ldr	r3, [r4, #12]
100063ca:	9a09      	ldr	r2, [sp, #36]	; 0x24
100063cc:	1a9b      	subs	r3, r3, r2
100063ce:	429d      	cmp	r5, r3
100063d0:	daf3      	bge.n	100063ba <_printf_i+0x1f6>
100063d2:	1c22      	adds	r2, r4, #0
100063d4:	2301      	movs	r3, #1
100063d6:	9805      	ldr	r0, [sp, #20]
100063d8:	9906      	ldr	r1, [sp, #24]
100063da:	3219      	adds	r2, #25
100063dc:	9e07      	ldr	r6, [sp, #28]
100063de:	47b0      	blx	r6
100063e0:	1c43      	adds	r3, r0, #1
100063e2:	d0dc      	beq.n	1000639e <_printf_i+0x1da>
100063e4:	3501      	adds	r5, #1
100063e6:	e7ef      	b.n	100063c8 <_printf_i+0x204>
100063e8:	b00b      	add	sp, #44	; 0x2c
100063ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
100063ec:	1000a7c2 	.word	0x1000a7c2
100063f0:	1000a7d3 	.word	0x1000a7d3

100063f4 <iprintf>:
100063f4:	b40f      	push	{r0, r1, r2, r3}
100063f6:	4b0b      	ldr	r3, [pc, #44]	; (10006424 <iprintf+0x30>)
100063f8:	b513      	push	{r0, r1, r4, lr}
100063fa:	681c      	ldr	r4, [r3, #0]
100063fc:	2c00      	cmp	r4, #0
100063fe:	d005      	beq.n	1000640c <iprintf+0x18>
10006400:	69a3      	ldr	r3, [r4, #24]
10006402:	2b00      	cmp	r3, #0
10006404:	d102      	bne.n	1000640c <iprintf+0x18>
10006406:	1c20      	adds	r0, r4, #0
10006408:	f001 f92a 	bl	10007660 <__sinit>
1000640c:	ab05      	add	r3, sp, #20
1000640e:	1c20      	adds	r0, r4, #0
10006410:	68a1      	ldr	r1, [r4, #8]
10006412:	9a04      	ldr	r2, [sp, #16]
10006414:	9301      	str	r3, [sp, #4]
10006416:	f001 fe93 	bl	10008140 <_vfiprintf_r>
1000641a:	bc16      	pop	{r1, r2, r4}
1000641c:	bc08      	pop	{r3}
1000641e:	b004      	add	sp, #16
10006420:	4718      	bx	r3
10006422:	46c0      	nop			; (mov r8, r8)
10006424:	20000664 	.word	0x20000664

10006428 <_puts_r>:
10006428:	b570      	push	{r4, r5, r6, lr}
1000642a:	1c05      	adds	r5, r0, #0
1000642c:	1c0e      	adds	r6, r1, #0
1000642e:	2800      	cmp	r0, #0
10006430:	d004      	beq.n	1000643c <_puts_r+0x14>
10006432:	6983      	ldr	r3, [r0, #24]
10006434:	2b00      	cmp	r3, #0
10006436:	d101      	bne.n	1000643c <_puts_r+0x14>
10006438:	f001 f912 	bl	10007660 <__sinit>
1000643c:	68ac      	ldr	r4, [r5, #8]
1000643e:	89a3      	ldrh	r3, [r4, #12]
10006440:	071b      	lsls	r3, r3, #28
10006442:	d502      	bpl.n	1000644a <_puts_r+0x22>
10006444:	6923      	ldr	r3, [r4, #16]
10006446:	2b00      	cmp	r3, #0
10006448:	d119      	bne.n	1000647e <_puts_r+0x56>
1000644a:	1c28      	adds	r0, r5, #0
1000644c:	1c21      	adds	r1, r4, #0
1000644e:	f000 f913 	bl	10006678 <__swsetup_r>
10006452:	2800      	cmp	r0, #0
10006454:	d013      	beq.n	1000647e <_puts_r+0x56>
10006456:	2001      	movs	r0, #1
10006458:	4240      	negs	r0, r0
1000645a:	e045      	b.n	100064e8 <_puts_r+0xc0>
1000645c:	7831      	ldrb	r1, [r6, #0]
1000645e:	2b00      	cmp	r3, #0
10006460:	da1b      	bge.n	1000649a <_puts_r+0x72>
10006462:	69a2      	ldr	r2, [r4, #24]
10006464:	4293      	cmp	r3, r2
10006466:	da11      	bge.n	1000648c <_puts_r+0x64>
10006468:	1c22      	adds	r2, r4, #0
1000646a:	1c28      	adds	r0, r5, #0
1000646c:	f000 f8ac 	bl	100065c8 <__swbuf_r>
10006470:	3001      	adds	r0, #1
10006472:	4242      	negs	r2, r0
10006474:	4142      	adcs	r2, r0
10006476:	b2d0      	uxtb	r0, r2
10006478:	2800      	cmp	r0, #0
1000647a:	d1ec      	bne.n	10006456 <_puts_r+0x2e>
1000647c:	3601      	adds	r6, #1
1000647e:	68a3      	ldr	r3, [r4, #8]
10006480:	7832      	ldrb	r2, [r6, #0]
10006482:	3b01      	subs	r3, #1
10006484:	60a3      	str	r3, [r4, #8]
10006486:	2a00      	cmp	r2, #0
10006488:	d1e8      	bne.n	1000645c <_puts_r+0x34>
1000648a:	e00c      	b.n	100064a6 <_puts_r+0x7e>
1000648c:	6823      	ldr	r3, [r4, #0]
1000648e:	7019      	strb	r1, [r3, #0]
10006490:	6823      	ldr	r3, [r4, #0]
10006492:	7819      	ldrb	r1, [r3, #0]
10006494:	290a      	cmp	r1, #10
10006496:	d103      	bne.n	100064a0 <_puts_r+0x78>
10006498:	e7e6      	b.n	10006468 <_puts_r+0x40>
1000649a:	6823      	ldr	r3, [r4, #0]
1000649c:	7019      	strb	r1, [r3, #0]
1000649e:	6823      	ldr	r3, [r4, #0]
100064a0:	3301      	adds	r3, #1
100064a2:	6023      	str	r3, [r4, #0]
100064a4:	e7ea      	b.n	1000647c <_puts_r+0x54>
100064a6:	2b00      	cmp	r3, #0
100064a8:	da17      	bge.n	100064da <_puts_r+0xb2>
100064aa:	69a2      	ldr	r2, [r4, #24]
100064ac:	4293      	cmp	r3, r2
100064ae:	db08      	blt.n	100064c2 <_puts_r+0x9a>
100064b0:	230a      	movs	r3, #10
100064b2:	6822      	ldr	r2, [r4, #0]
100064b4:	7013      	strb	r3, [r2, #0]
100064b6:	6823      	ldr	r3, [r4, #0]
100064b8:	7819      	ldrb	r1, [r3, #0]
100064ba:	290a      	cmp	r1, #10
100064bc:	d111      	bne.n	100064e2 <_puts_r+0xba>
100064be:	1c28      	adds	r0, r5, #0
100064c0:	e001      	b.n	100064c6 <_puts_r+0x9e>
100064c2:	1c28      	adds	r0, r5, #0
100064c4:	210a      	movs	r1, #10
100064c6:	1c22      	adds	r2, r4, #0
100064c8:	f000 f87e 	bl	100065c8 <__swbuf_r>
100064cc:	3001      	adds	r0, #1
100064ce:	4242      	negs	r2, r0
100064d0:	4142      	adcs	r2, r0
100064d2:	b2d0      	uxtb	r0, r2
100064d4:	2800      	cmp	r0, #0
100064d6:	d006      	beq.n	100064e6 <_puts_r+0xbe>
100064d8:	e7bd      	b.n	10006456 <_puts_r+0x2e>
100064da:	230a      	movs	r3, #10
100064dc:	6822      	ldr	r2, [r4, #0]
100064de:	7013      	strb	r3, [r2, #0]
100064e0:	6823      	ldr	r3, [r4, #0]
100064e2:	3301      	adds	r3, #1
100064e4:	6023      	str	r3, [r4, #0]
100064e6:	200a      	movs	r0, #10
100064e8:	bd70      	pop	{r4, r5, r6, pc}
	...

100064ec <puts>:
100064ec:	b508      	push	{r3, lr}
100064ee:	4b03      	ldr	r3, [pc, #12]	; (100064fc <puts+0x10>)
100064f0:	1c01      	adds	r1, r0, #0
100064f2:	6818      	ldr	r0, [r3, #0]
100064f4:	f7ff ff98 	bl	10006428 <_puts_r>
100064f8:	bd08      	pop	{r3, pc}
100064fa:	46c0      	nop			; (mov r8, r8)
100064fc:	20000664 	.word	0x20000664

10006500 <__fpclassifyd>:
10006500:	b530      	push	{r4, r5, lr}
10006502:	1c0c      	adds	r4, r1, #0
10006504:	2302      	movs	r3, #2
10006506:	4304      	orrs	r4, r0
10006508:	d017      	beq.n	1000653a <__fpclassifyd+0x3a>
1000650a:	2480      	movs	r4, #128	; 0x80
1000650c:	0624      	lsls	r4, r4, #24
1000650e:	42a1      	cmp	r1, r4
10006510:	d101      	bne.n	10006516 <__fpclassifyd+0x16>
10006512:	2800      	cmp	r0, #0
10006514:	d011      	beq.n	1000653a <__fpclassifyd+0x3a>
10006516:	4b0a      	ldr	r3, [pc, #40]	; (10006540 <__fpclassifyd+0x40>)
10006518:	0049      	lsls	r1, r1, #1
1000651a:	0849      	lsrs	r1, r1, #1
1000651c:	4a09      	ldr	r2, [pc, #36]	; (10006544 <__fpclassifyd+0x44>)
1000651e:	18cc      	adds	r4, r1, r3
10006520:	2304      	movs	r3, #4
10006522:	4294      	cmp	r4, r2
10006524:	d909      	bls.n	1000653a <__fpclassifyd+0x3a>
10006526:	4a08      	ldr	r2, [pc, #32]	; (10006548 <__fpclassifyd+0x48>)
10006528:	3b01      	subs	r3, #1
1000652a:	4291      	cmp	r1, r2
1000652c:	d905      	bls.n	1000653a <__fpclassifyd+0x3a>
1000652e:	4a07      	ldr	r2, [pc, #28]	; (1000654c <__fpclassifyd+0x4c>)
10006530:	2300      	movs	r3, #0
10006532:	4291      	cmp	r1, r2
10006534:	d101      	bne.n	1000653a <__fpclassifyd+0x3a>
10006536:	4243      	negs	r3, r0
10006538:	4143      	adcs	r3, r0
1000653a:	1c18      	adds	r0, r3, #0
1000653c:	bd30      	pop	{r4, r5, pc}
1000653e:	46c0      	nop			; (mov r8, r8)
10006540:	fff00000 	.word	0xfff00000
10006544:	7fdfffff 	.word	0x7fdfffff
10006548:	000fffff 	.word	0x000fffff
1000654c:	7ff00000 	.word	0x7ff00000

10006550 <_sbrk_r>:
10006550:	b538      	push	{r3, r4, r5, lr}
10006552:	2300      	movs	r3, #0
10006554:	4c06      	ldr	r4, [pc, #24]	; (10006570 <_sbrk_r+0x20>)
10006556:	1c05      	adds	r5, r0, #0
10006558:	1c08      	adds	r0, r1, #0
1000655a:	6023      	str	r3, [r4, #0]
1000655c:	f7fb fbaa 	bl	10001cb4 <_sbrk>
10006560:	1c43      	adds	r3, r0, #1
10006562:	d103      	bne.n	1000656c <_sbrk_r+0x1c>
10006564:	6823      	ldr	r3, [r4, #0]
10006566:	2b00      	cmp	r3, #0
10006568:	d000      	beq.n	1000656c <_sbrk_r+0x1c>
1000656a:	602b      	str	r3, [r5, #0]
1000656c:	bd38      	pop	{r3, r4, r5, pc}
1000656e:	46c0      	nop			; (mov r8, r8)
10006570:	20000928 	.word	0x20000928

10006574 <siprintf>:
10006574:	b40e      	push	{r1, r2, r3}
10006576:	b510      	push	{r4, lr}
10006578:	b09d      	sub	sp, #116	; 0x74
1000657a:	a902      	add	r1, sp, #8
1000657c:	9002      	str	r0, [sp, #8]
1000657e:	6108      	str	r0, [r1, #16]
10006580:	480b      	ldr	r0, [pc, #44]	; (100065b0 <siprintf+0x3c>)
10006582:	2482      	movs	r4, #130	; 0x82
10006584:	6088      	str	r0, [r1, #8]
10006586:	6148      	str	r0, [r1, #20]
10006588:	2001      	movs	r0, #1
1000658a:	4240      	negs	r0, r0
1000658c:	ab1f      	add	r3, sp, #124	; 0x7c
1000658e:	81c8      	strh	r0, [r1, #14]
10006590:	4808      	ldr	r0, [pc, #32]	; (100065b4 <siprintf+0x40>)
10006592:	cb04      	ldmia	r3!, {r2}
10006594:	00a4      	lsls	r4, r4, #2
10006596:	6800      	ldr	r0, [r0, #0]
10006598:	9301      	str	r3, [sp, #4]
1000659a:	818c      	strh	r4, [r1, #12]
1000659c:	f001 fcb2 	bl	10007f04 <_svfiprintf_r>
100065a0:	2300      	movs	r3, #0
100065a2:	9a02      	ldr	r2, [sp, #8]
100065a4:	7013      	strb	r3, [r2, #0]
100065a6:	b01d      	add	sp, #116	; 0x74
100065a8:	bc10      	pop	{r4}
100065aa:	bc08      	pop	{r3}
100065ac:	b003      	add	sp, #12
100065ae:	4718      	bx	r3
100065b0:	7fffffff 	.word	0x7fffffff
100065b4:	20000664 	.word	0x20000664

100065b8 <strlen>:
100065b8:	2300      	movs	r3, #0
100065ba:	5cc2      	ldrb	r2, [r0, r3]
100065bc:	3301      	adds	r3, #1
100065be:	2a00      	cmp	r2, #0
100065c0:	d1fb      	bne.n	100065ba <strlen+0x2>
100065c2:	1e58      	subs	r0, r3, #1
100065c4:	4770      	bx	lr
	...

100065c8 <__swbuf_r>:
100065c8:	b570      	push	{r4, r5, r6, lr}
100065ca:	1c05      	adds	r5, r0, #0
100065cc:	1c0e      	adds	r6, r1, #0
100065ce:	1c14      	adds	r4, r2, #0
100065d0:	2800      	cmp	r0, #0
100065d2:	d004      	beq.n	100065de <__swbuf_r+0x16>
100065d4:	6983      	ldr	r3, [r0, #24]
100065d6:	2b00      	cmp	r3, #0
100065d8:	d101      	bne.n	100065de <__swbuf_r+0x16>
100065da:	f001 f841 	bl	10007660 <__sinit>
100065de:	4b23      	ldr	r3, [pc, #140]	; (1000666c <__swbuf_r+0xa4>)
100065e0:	429c      	cmp	r4, r3
100065e2:	d101      	bne.n	100065e8 <__swbuf_r+0x20>
100065e4:	686c      	ldr	r4, [r5, #4]
100065e6:	e008      	b.n	100065fa <__swbuf_r+0x32>
100065e8:	4b21      	ldr	r3, [pc, #132]	; (10006670 <__swbuf_r+0xa8>)
100065ea:	429c      	cmp	r4, r3
100065ec:	d101      	bne.n	100065f2 <__swbuf_r+0x2a>
100065ee:	68ac      	ldr	r4, [r5, #8]
100065f0:	e003      	b.n	100065fa <__swbuf_r+0x32>
100065f2:	4b20      	ldr	r3, [pc, #128]	; (10006674 <__swbuf_r+0xac>)
100065f4:	429c      	cmp	r4, r3
100065f6:	d100      	bne.n	100065fa <__swbuf_r+0x32>
100065f8:	68ec      	ldr	r4, [r5, #12]
100065fa:	69a3      	ldr	r3, [r4, #24]
100065fc:	60a3      	str	r3, [r4, #8]
100065fe:	89a3      	ldrh	r3, [r4, #12]
10006600:	071b      	lsls	r3, r3, #28
10006602:	d50a      	bpl.n	1000661a <__swbuf_r+0x52>
10006604:	6923      	ldr	r3, [r4, #16]
10006606:	2b00      	cmp	r3, #0
10006608:	d007      	beq.n	1000661a <__swbuf_r+0x52>
1000660a:	6823      	ldr	r3, [r4, #0]
1000660c:	6922      	ldr	r2, [r4, #16]
1000660e:	b2f6      	uxtb	r6, r6
10006610:	1a98      	subs	r0, r3, r2
10006612:	6963      	ldr	r3, [r4, #20]
10006614:	4298      	cmp	r0, r3
10006616:	db0f      	blt.n	10006638 <__swbuf_r+0x70>
10006618:	e008      	b.n	1000662c <__swbuf_r+0x64>
1000661a:	1c28      	adds	r0, r5, #0
1000661c:	1c21      	adds	r1, r4, #0
1000661e:	f000 f82b 	bl	10006678 <__swsetup_r>
10006622:	2800      	cmp	r0, #0
10006624:	d0f1      	beq.n	1000660a <__swbuf_r+0x42>
10006626:	2001      	movs	r0, #1
10006628:	4240      	negs	r0, r0
1000662a:	e01d      	b.n	10006668 <__swbuf_r+0xa0>
1000662c:	1c28      	adds	r0, r5, #0
1000662e:	1c21      	adds	r1, r4, #0
10006630:	f000 ffa8 	bl	10007584 <_fflush_r>
10006634:	2800      	cmp	r0, #0
10006636:	d1f6      	bne.n	10006626 <__swbuf_r+0x5e>
10006638:	68a3      	ldr	r3, [r4, #8]
1000663a:	3001      	adds	r0, #1
1000663c:	3b01      	subs	r3, #1
1000663e:	60a3      	str	r3, [r4, #8]
10006640:	6823      	ldr	r3, [r4, #0]
10006642:	1c5a      	adds	r2, r3, #1
10006644:	6022      	str	r2, [r4, #0]
10006646:	701e      	strb	r6, [r3, #0]
10006648:	6963      	ldr	r3, [r4, #20]
1000664a:	4298      	cmp	r0, r3
1000664c:	d005      	beq.n	1000665a <__swbuf_r+0x92>
1000664e:	89a3      	ldrh	r3, [r4, #12]
10006650:	1c30      	adds	r0, r6, #0
10006652:	07db      	lsls	r3, r3, #31
10006654:	d508      	bpl.n	10006668 <__swbuf_r+0xa0>
10006656:	2e0a      	cmp	r6, #10
10006658:	d106      	bne.n	10006668 <__swbuf_r+0xa0>
1000665a:	1c28      	adds	r0, r5, #0
1000665c:	1c21      	adds	r1, r4, #0
1000665e:	f000 ff91 	bl	10007584 <_fflush_r>
10006662:	2800      	cmp	r0, #0
10006664:	d1df      	bne.n	10006626 <__swbuf_r+0x5e>
10006666:	1c30      	adds	r0, r6, #0
10006668:	bd70      	pop	{r4, r5, r6, pc}
1000666a:	46c0      	nop			; (mov r8, r8)
1000666c:	1000a7f4 	.word	0x1000a7f4
10006670:	1000a814 	.word	0x1000a814
10006674:	1000a834 	.word	0x1000a834

10006678 <__swsetup_r>:
10006678:	4b35      	ldr	r3, [pc, #212]	; (10006750 <__swsetup_r+0xd8>)
1000667a:	b570      	push	{r4, r5, r6, lr}
1000667c:	681d      	ldr	r5, [r3, #0]
1000667e:	1c06      	adds	r6, r0, #0
10006680:	1c0c      	adds	r4, r1, #0
10006682:	2d00      	cmp	r5, #0
10006684:	d005      	beq.n	10006692 <__swsetup_r+0x1a>
10006686:	69ab      	ldr	r3, [r5, #24]
10006688:	2b00      	cmp	r3, #0
1000668a:	d102      	bne.n	10006692 <__swsetup_r+0x1a>
1000668c:	1c28      	adds	r0, r5, #0
1000668e:	f000 ffe7 	bl	10007660 <__sinit>
10006692:	4b30      	ldr	r3, [pc, #192]	; (10006754 <__swsetup_r+0xdc>)
10006694:	429c      	cmp	r4, r3
10006696:	d101      	bne.n	1000669c <__swsetup_r+0x24>
10006698:	686c      	ldr	r4, [r5, #4]
1000669a:	e008      	b.n	100066ae <__swsetup_r+0x36>
1000669c:	4b2e      	ldr	r3, [pc, #184]	; (10006758 <__swsetup_r+0xe0>)
1000669e:	429c      	cmp	r4, r3
100066a0:	d101      	bne.n	100066a6 <__swsetup_r+0x2e>
100066a2:	68ac      	ldr	r4, [r5, #8]
100066a4:	e003      	b.n	100066ae <__swsetup_r+0x36>
100066a6:	4b2d      	ldr	r3, [pc, #180]	; (1000675c <__swsetup_r+0xe4>)
100066a8:	429c      	cmp	r4, r3
100066aa:	d100      	bne.n	100066ae <__swsetup_r+0x36>
100066ac:	68ec      	ldr	r4, [r5, #12]
100066ae:	89a3      	ldrh	r3, [r4, #12]
100066b0:	b29a      	uxth	r2, r3
100066b2:	0711      	lsls	r1, r2, #28
100066b4:	d423      	bmi.n	100066fe <__swsetup_r+0x86>
100066b6:	06d1      	lsls	r1, r2, #27
100066b8:	d407      	bmi.n	100066ca <__swsetup_r+0x52>
100066ba:	2209      	movs	r2, #9
100066bc:	2001      	movs	r0, #1
100066be:	6032      	str	r2, [r6, #0]
100066c0:	3237      	adds	r2, #55	; 0x37
100066c2:	4313      	orrs	r3, r2
100066c4:	81a3      	strh	r3, [r4, #12]
100066c6:	4240      	negs	r0, r0
100066c8:	e040      	b.n	1000674c <__swsetup_r+0xd4>
100066ca:	0753      	lsls	r3, r2, #29
100066cc:	d513      	bpl.n	100066f6 <__swsetup_r+0x7e>
100066ce:	6b61      	ldr	r1, [r4, #52]	; 0x34
100066d0:	2900      	cmp	r1, #0
100066d2:	d008      	beq.n	100066e6 <__swsetup_r+0x6e>
100066d4:	1c23      	adds	r3, r4, #0
100066d6:	3344      	adds	r3, #68	; 0x44
100066d8:	4299      	cmp	r1, r3
100066da:	d002      	beq.n	100066e2 <__swsetup_r+0x6a>
100066dc:	1c30      	adds	r0, r6, #0
100066de:	f7ff f997 	bl	10005a10 <_free_r>
100066e2:	2300      	movs	r3, #0
100066e4:	6363      	str	r3, [r4, #52]	; 0x34
100066e6:	2224      	movs	r2, #36	; 0x24
100066e8:	89a3      	ldrh	r3, [r4, #12]
100066ea:	4393      	bics	r3, r2
100066ec:	81a3      	strh	r3, [r4, #12]
100066ee:	2300      	movs	r3, #0
100066f0:	6063      	str	r3, [r4, #4]
100066f2:	6923      	ldr	r3, [r4, #16]
100066f4:	6023      	str	r3, [r4, #0]
100066f6:	2208      	movs	r2, #8
100066f8:	89a3      	ldrh	r3, [r4, #12]
100066fa:	4313      	orrs	r3, r2
100066fc:	81a3      	strh	r3, [r4, #12]
100066fe:	6923      	ldr	r3, [r4, #16]
10006700:	2b00      	cmp	r3, #0
10006702:	d10b      	bne.n	1000671c <__swsetup_r+0xa4>
10006704:	23a0      	movs	r3, #160	; 0xa0
10006706:	89a2      	ldrh	r2, [r4, #12]
10006708:	009b      	lsls	r3, r3, #2
1000670a:	4013      	ands	r3, r2
1000670c:	2280      	movs	r2, #128	; 0x80
1000670e:	0092      	lsls	r2, r2, #2
10006710:	4293      	cmp	r3, r2
10006712:	d003      	beq.n	1000671c <__swsetup_r+0xa4>
10006714:	1c30      	adds	r0, r6, #0
10006716:	1c21      	adds	r1, r4, #0
10006718:	f001 f838 	bl	1000778c <__smakebuf_r>
1000671c:	2301      	movs	r3, #1
1000671e:	89a2      	ldrh	r2, [r4, #12]
10006720:	4013      	ands	r3, r2
10006722:	d005      	beq.n	10006730 <__swsetup_r+0xb8>
10006724:	2300      	movs	r3, #0
10006726:	60a3      	str	r3, [r4, #8]
10006728:	6963      	ldr	r3, [r4, #20]
1000672a:	425b      	negs	r3, r3
1000672c:	61a3      	str	r3, [r4, #24]
1000672e:	e003      	b.n	10006738 <__swsetup_r+0xc0>
10006730:	0791      	lsls	r1, r2, #30
10006732:	d400      	bmi.n	10006736 <__swsetup_r+0xbe>
10006734:	6963      	ldr	r3, [r4, #20]
10006736:	60a3      	str	r3, [r4, #8]
10006738:	2000      	movs	r0, #0
1000673a:	6923      	ldr	r3, [r4, #16]
1000673c:	4283      	cmp	r3, r0
1000673e:	d105      	bne.n	1000674c <__swsetup_r+0xd4>
10006740:	0613      	lsls	r3, r2, #24
10006742:	d503      	bpl.n	1000674c <__swsetup_r+0xd4>
10006744:	2340      	movs	r3, #64	; 0x40
10006746:	431a      	orrs	r2, r3
10006748:	81a2      	strh	r2, [r4, #12]
1000674a:	3801      	subs	r0, #1
1000674c:	bd70      	pop	{r4, r5, r6, pc}
1000674e:	46c0      	nop			; (mov r8, r8)
10006750:	20000664 	.word	0x20000664
10006754:	1000a7f4 	.word	0x1000a7f4
10006758:	1000a814 	.word	0x1000a814
1000675c:	1000a834 	.word	0x1000a834

10006760 <quorem>:
10006760:	b5f0      	push	{r4, r5, r6, r7, lr}
10006762:	6903      	ldr	r3, [r0, #16]
10006764:	690c      	ldr	r4, [r1, #16]
10006766:	b089      	sub	sp, #36	; 0x24
10006768:	2600      	movs	r6, #0
1000676a:	42a3      	cmp	r3, r4
1000676c:	db7c      	blt.n	10006868 <quorem+0x108>
1000676e:	1c0b      	adds	r3, r1, #0
10006770:	3c01      	subs	r4, #1
10006772:	3314      	adds	r3, #20
10006774:	00a5      	lsls	r5, r4, #2
10006776:	9303      	str	r3, [sp, #12]
10006778:	195b      	adds	r3, r3, r5
1000677a:	9304      	str	r3, [sp, #16]
1000677c:	1c03      	adds	r3, r0, #0
1000677e:	3314      	adds	r3, #20
10006780:	9301      	str	r3, [sp, #4]
10006782:	195d      	adds	r5, r3, r5
10006784:	9b04      	ldr	r3, [sp, #16]
10006786:	9107      	str	r1, [sp, #28]
10006788:	681b      	ldr	r3, [r3, #0]
1000678a:	9002      	str	r0, [sp, #8]
1000678c:	1c59      	adds	r1, r3, #1
1000678e:	6828      	ldr	r0, [r5, #0]
10006790:	9305      	str	r3, [sp, #20]
10006792:	f7fe ff71 	bl	10005678 <__aeabi_uidiv>
10006796:	1e07      	subs	r7, r0, #0
10006798:	42b7      	cmp	r7, r6
1000679a:	d035      	beq.n	10006808 <quorem+0xa8>
1000679c:	9b03      	ldr	r3, [sp, #12]
1000679e:	9801      	ldr	r0, [sp, #4]
100067a0:	469c      	mov	ip, r3
100067a2:	9605      	str	r6, [sp, #20]
100067a4:	4663      	mov	r3, ip
100067a6:	cb04      	ldmia	r3!, {r2}
100067a8:	b291      	uxth	r1, r2
100067aa:	4379      	muls	r1, r7
100067ac:	0c12      	lsrs	r2, r2, #16
100067ae:	437a      	muls	r2, r7
100067b0:	1871      	adds	r1, r6, r1
100067b2:	0c0e      	lsrs	r6, r1, #16
100067b4:	469c      	mov	ip, r3
100067b6:	18b3      	adds	r3, r6, r2
100067b8:	9306      	str	r3, [sp, #24]
100067ba:	8802      	ldrh	r2, [r0, #0]
100067bc:	0c1e      	lsrs	r6, r3, #16
100067be:	9b05      	ldr	r3, [sp, #20]
100067c0:	b289      	uxth	r1, r1
100067c2:	18d2      	adds	r2, r2, r3
100067c4:	6803      	ldr	r3, [r0, #0]
100067c6:	1a52      	subs	r2, r2, r1
100067c8:	0c19      	lsrs	r1, r3, #16
100067ca:	466b      	mov	r3, sp
100067cc:	8b1b      	ldrh	r3, [r3, #24]
100067ce:	1acb      	subs	r3, r1, r3
100067d0:	1411      	asrs	r1, r2, #16
100067d2:	185b      	adds	r3, r3, r1
100067d4:	1419      	asrs	r1, r3, #16
100067d6:	b292      	uxth	r2, r2
100067d8:	041b      	lsls	r3, r3, #16
100067da:	431a      	orrs	r2, r3
100067dc:	9b04      	ldr	r3, [sp, #16]
100067de:	9105      	str	r1, [sp, #20]
100067e0:	c004      	stmia	r0!, {r2}
100067e2:	4563      	cmp	r3, ip
100067e4:	d2de      	bcs.n	100067a4 <quorem+0x44>
100067e6:	682b      	ldr	r3, [r5, #0]
100067e8:	2b00      	cmp	r3, #0
100067ea:	d10d      	bne.n	10006808 <quorem+0xa8>
100067ec:	1c23      	adds	r3, r4, #0
100067ee:	9a01      	ldr	r2, [sp, #4]
100067f0:	3d04      	subs	r5, #4
100067f2:	4295      	cmp	r5, r2
100067f4:	d803      	bhi.n	100067fe <quorem+0x9e>
100067f6:	9a02      	ldr	r2, [sp, #8]
100067f8:	1c1c      	adds	r4, r3, #0
100067fa:	6113      	str	r3, [r2, #16]
100067fc:	e004      	b.n	10006808 <quorem+0xa8>
100067fe:	682a      	ldr	r2, [r5, #0]
10006800:	2a00      	cmp	r2, #0
10006802:	d1f8      	bne.n	100067f6 <quorem+0x96>
10006804:	3b01      	subs	r3, #1
10006806:	e7f2      	b.n	100067ee <quorem+0x8e>
10006808:	9802      	ldr	r0, [sp, #8]
1000680a:	9907      	ldr	r1, [sp, #28]
1000680c:	f001 fa32 	bl	10007c74 <__mcmp>
10006810:	2800      	cmp	r0, #0
10006812:	db28      	blt.n	10006866 <quorem+0x106>
10006814:	2000      	movs	r0, #0
10006816:	9901      	ldr	r1, [sp, #4]
10006818:	9a03      	ldr	r2, [sp, #12]
1000681a:	3701      	adds	r7, #1
1000681c:	ca20      	ldmia	r2!, {r5}
1000681e:	880b      	ldrh	r3, [r1, #0]
10006820:	1818      	adds	r0, r3, r0
10006822:	b2ab      	uxth	r3, r5
10006824:	1ac3      	subs	r3, r0, r3
10006826:	6808      	ldr	r0, [r1, #0]
10006828:	0c2d      	lsrs	r5, r5, #16
1000682a:	0c00      	lsrs	r0, r0, #16
1000682c:	1b45      	subs	r5, r0, r5
1000682e:	141e      	asrs	r6, r3, #16
10006830:	19ad      	adds	r5, r5, r6
10006832:	1428      	asrs	r0, r5, #16
10006834:	b29b      	uxth	r3, r3
10006836:	042d      	lsls	r5, r5, #16
10006838:	432b      	orrs	r3, r5
1000683a:	c108      	stmia	r1!, {r3}
1000683c:	9b04      	ldr	r3, [sp, #16]
1000683e:	4293      	cmp	r3, r2
10006840:	d2ec      	bcs.n	1000681c <quorem+0xbc>
10006842:	9a01      	ldr	r2, [sp, #4]
10006844:	00a3      	lsls	r3, r4, #2
10006846:	18d3      	adds	r3, r2, r3
10006848:	681a      	ldr	r2, [r3, #0]
1000684a:	2a00      	cmp	r2, #0
1000684c:	d10b      	bne.n	10006866 <quorem+0x106>
1000684e:	9a01      	ldr	r2, [sp, #4]
10006850:	3b04      	subs	r3, #4
10006852:	4293      	cmp	r3, r2
10006854:	d802      	bhi.n	1000685c <quorem+0xfc>
10006856:	9b02      	ldr	r3, [sp, #8]
10006858:	611c      	str	r4, [r3, #16]
1000685a:	e004      	b.n	10006866 <quorem+0x106>
1000685c:	681a      	ldr	r2, [r3, #0]
1000685e:	2a00      	cmp	r2, #0
10006860:	d1f9      	bne.n	10006856 <quorem+0xf6>
10006862:	3c01      	subs	r4, #1
10006864:	e7f3      	b.n	1000684e <quorem+0xee>
10006866:	1c3e      	adds	r6, r7, #0
10006868:	1c30      	adds	r0, r6, #0
1000686a:	b009      	add	sp, #36	; 0x24
1000686c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

10006870 <_dtoa_r>:
10006870:	b5f0      	push	{r4, r5, r6, r7, lr}
10006872:	1c16      	adds	r6, r2, #0
10006874:	1c1f      	adds	r7, r3, #0
10006876:	6a44      	ldr	r4, [r0, #36]	; 0x24
10006878:	b09b      	sub	sp, #108	; 0x6c
1000687a:	9008      	str	r0, [sp, #32]
1000687c:	9d23      	ldr	r5, [sp, #140]	; 0x8c
1000687e:	9606      	str	r6, [sp, #24]
10006880:	9707      	str	r7, [sp, #28]
10006882:	2c00      	cmp	r4, #0
10006884:	d108      	bne.n	10006898 <_dtoa_r+0x28>
10006886:	2010      	movs	r0, #16
10006888:	f7ff f89c 	bl	100059c4 <malloc>
1000688c:	9b08      	ldr	r3, [sp, #32]
1000688e:	6258      	str	r0, [r3, #36]	; 0x24
10006890:	6044      	str	r4, [r0, #4]
10006892:	6084      	str	r4, [r0, #8]
10006894:	6004      	str	r4, [r0, #0]
10006896:	60c4      	str	r4, [r0, #12]
10006898:	9b08      	ldr	r3, [sp, #32]
1000689a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
1000689c:	6819      	ldr	r1, [r3, #0]
1000689e:	2900      	cmp	r1, #0
100068a0:	d00b      	beq.n	100068ba <_dtoa_r+0x4a>
100068a2:	685a      	ldr	r2, [r3, #4]
100068a4:	2301      	movs	r3, #1
100068a6:	4093      	lsls	r3, r2
100068a8:	604a      	str	r2, [r1, #4]
100068aa:	608b      	str	r3, [r1, #8]
100068ac:	9808      	ldr	r0, [sp, #32]
100068ae:	f001 f808 	bl	100078c2 <_Bfree>
100068b2:	2200      	movs	r2, #0
100068b4:	9b08      	ldr	r3, [sp, #32]
100068b6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
100068b8:	601a      	str	r2, [r3, #0]
100068ba:	9b07      	ldr	r3, [sp, #28]
100068bc:	2b00      	cmp	r3, #0
100068be:	da05      	bge.n	100068cc <_dtoa_r+0x5c>
100068c0:	2301      	movs	r3, #1
100068c2:	602b      	str	r3, [r5, #0]
100068c4:	007b      	lsls	r3, r7, #1
100068c6:	085b      	lsrs	r3, r3, #1
100068c8:	9307      	str	r3, [sp, #28]
100068ca:	e001      	b.n	100068d0 <_dtoa_r+0x60>
100068cc:	2300      	movs	r3, #0
100068ce:	602b      	str	r3, [r5, #0]
100068d0:	9c07      	ldr	r4, [sp, #28]
100068d2:	4bc6      	ldr	r3, [pc, #792]	; (10006bec <_dtoa_r+0x37c>)
100068d4:	1c22      	adds	r2, r4, #0
100068d6:	9317      	str	r3, [sp, #92]	; 0x5c
100068d8:	401a      	ands	r2, r3
100068da:	429a      	cmp	r2, r3
100068dc:	d119      	bne.n	10006912 <_dtoa_r+0xa2>
100068de:	4bc4      	ldr	r3, [pc, #784]	; (10006bf0 <_dtoa_r+0x380>)
100068e0:	9a22      	ldr	r2, [sp, #136]	; 0x88
100068e2:	6013      	str	r3, [r2, #0]
100068e4:	9a06      	ldr	r2, [sp, #24]
100068e6:	4bc3      	ldr	r3, [pc, #780]	; (10006bf4 <_dtoa_r+0x384>)
100068e8:	2a00      	cmp	r2, #0
100068ea:	d102      	bne.n	100068f2 <_dtoa_r+0x82>
100068ec:	0324      	lsls	r4, r4, #12
100068ee:	d100      	bne.n	100068f2 <_dtoa_r+0x82>
100068f0:	4bc1      	ldr	r3, [pc, #772]	; (10006bf8 <_dtoa_r+0x388>)
100068f2:	9a24      	ldr	r2, [sp, #144]	; 0x90
100068f4:	1c18      	adds	r0, r3, #0
100068f6:	2a00      	cmp	r2, #0
100068f8:	d101      	bne.n	100068fe <_dtoa_r+0x8e>
100068fa:	f000 fdb6 	bl	1000746a <_dtoa_r+0xbfa>
100068fe:	78d9      	ldrb	r1, [r3, #3]
10006900:	1cda      	adds	r2, r3, #3
10006902:	2900      	cmp	r1, #0
10006904:	d000      	beq.n	10006908 <_dtoa_r+0x98>
10006906:	3205      	adds	r2, #5
10006908:	9924      	ldr	r1, [sp, #144]	; 0x90
1000690a:	1c18      	adds	r0, r3, #0
1000690c:	600a      	str	r2, [r1, #0]
1000690e:	f000 fdac 	bl	1000746a <_dtoa_r+0xbfa>
10006912:	9e06      	ldr	r6, [sp, #24]
10006914:	9f07      	ldr	r7, [sp, #28]
10006916:	2200      	movs	r2, #0
10006918:	1c30      	adds	r0, r6, #0
1000691a:	1c39      	adds	r1, r7, #0
1000691c:	2300      	movs	r3, #0
1000691e:	f001 fe3d 	bl	1000859c <__aeabi_dcmpeq>
10006922:	1e05      	subs	r5, r0, #0
10006924:	d00e      	beq.n	10006944 <_dtoa_r+0xd4>
10006926:	2301      	movs	r3, #1
10006928:	9a22      	ldr	r2, [sp, #136]	; 0x88
1000692a:	6013      	str	r3, [r2, #0]
1000692c:	4bb3      	ldr	r3, [pc, #716]	; (10006bfc <_dtoa_r+0x38c>)
1000692e:	9a24      	ldr	r2, [sp, #144]	; 0x90
10006930:	1c18      	adds	r0, r3, #0
10006932:	2a00      	cmp	r2, #0
10006934:	d101      	bne.n	1000693a <_dtoa_r+0xca>
10006936:	f000 fd98 	bl	1000746a <_dtoa_r+0xbfa>
1000693a:	4ab1      	ldr	r2, [pc, #708]	; (10006c00 <_dtoa_r+0x390>)
1000693c:	9924      	ldr	r1, [sp, #144]	; 0x90
1000693e:	600a      	str	r2, [r1, #0]
10006940:	f000 fd93 	bl	1000746a <_dtoa_r+0xbfa>
10006944:	ab19      	add	r3, sp, #100	; 0x64
10006946:	9300      	str	r3, [sp, #0]
10006948:	ab18      	add	r3, sp, #96	; 0x60
1000694a:	9301      	str	r3, [sp, #4]
1000694c:	9808      	ldr	r0, [sp, #32]
1000694e:	1c32      	adds	r2, r6, #0
10006950:	1c3b      	adds	r3, r7, #0
10006952:	f001 fa15 	bl	10007d80 <__d2b>
10006956:	0061      	lsls	r1, r4, #1
10006958:	900a      	str	r0, [sp, #40]	; 0x28
1000695a:	0d49      	lsrs	r1, r1, #21
1000695c:	d009      	beq.n	10006972 <_dtoa_r+0x102>
1000695e:	0338      	lsls	r0, r7, #12
10006960:	4ca8      	ldr	r4, [pc, #672]	; (10006c04 <_dtoa_r+0x394>)
10006962:	0b00      	lsrs	r0, r0, #12
10006964:	4304      	orrs	r4, r0
10006966:	48a8      	ldr	r0, [pc, #672]	; (10006c08 <_dtoa_r+0x398>)
10006968:	1c32      	adds	r2, r6, #0
1000696a:	1c23      	adds	r3, r4, #0
1000696c:	180e      	adds	r6, r1, r0
1000696e:	9516      	str	r5, [sp, #88]	; 0x58
10006970:	e01c      	b.n	100069ac <_dtoa_r+0x13c>
10006972:	9b18      	ldr	r3, [sp, #96]	; 0x60
10006974:	9a19      	ldr	r2, [sp, #100]	; 0x64
10006976:	189e      	adds	r6, r3, r2
10006978:	4ba4      	ldr	r3, [pc, #656]	; (10006c0c <_dtoa_r+0x39c>)
1000697a:	429e      	cmp	r6, r3
1000697c:	db09      	blt.n	10006992 <_dtoa_r+0x122>
1000697e:	4ba4      	ldr	r3, [pc, #656]	; (10006c10 <_dtoa_r+0x3a0>)
10006980:	18f0      	adds	r0, r6, r3
10006982:	9b06      	ldr	r3, [sp, #24]
10006984:	40c3      	lsrs	r3, r0
10006986:	1c18      	adds	r0, r3, #0
10006988:	4ba2      	ldr	r3, [pc, #648]	; (10006c14 <_dtoa_r+0x3a4>)
1000698a:	1b9b      	subs	r3, r3, r6
1000698c:	409c      	lsls	r4, r3
1000698e:	4320      	orrs	r0, r4
10006990:	e004      	b.n	1000699c <_dtoa_r+0x12c>
10006992:	48a1      	ldr	r0, [pc, #644]	; (10006c18 <_dtoa_r+0x3a8>)
10006994:	9b06      	ldr	r3, [sp, #24]
10006996:	1b80      	subs	r0, r0, r6
10006998:	4083      	lsls	r3, r0
1000699a:	1c18      	adds	r0, r3, #0
1000699c:	f003 fc18 	bl	1000a1d0 <__aeabi_ui2d>
100069a0:	4c9e      	ldr	r4, [pc, #632]	; (10006c1c <_dtoa_r+0x3ac>)
100069a2:	1c02      	adds	r2, r0, #0
100069a4:	190b      	adds	r3, r1, r4
100069a6:	2101      	movs	r1, #1
100069a8:	3e01      	subs	r6, #1
100069aa:	9116      	str	r1, [sp, #88]	; 0x58
100069ac:	1c10      	adds	r0, r2, #0
100069ae:	1c19      	adds	r1, r3, #0
100069b0:	2200      	movs	r2, #0
100069b2:	4b9b      	ldr	r3, [pc, #620]	; (10006c20 <_dtoa_r+0x3b0>)
100069b4:	f003 f820 	bl	100099f8 <__aeabi_dsub>
100069b8:	4a9a      	ldr	r2, [pc, #616]	; (10006c24 <_dtoa_r+0x3b4>)
100069ba:	4b9b      	ldr	r3, [pc, #620]	; (10006c28 <_dtoa_r+0x3b8>)
100069bc:	f002 fd82 	bl	100094c4 <__aeabi_dmul>
100069c0:	4a9a      	ldr	r2, [pc, #616]	; (10006c2c <_dtoa_r+0x3bc>)
100069c2:	4b9b      	ldr	r3, [pc, #620]	; (10006c30 <_dtoa_r+0x3c0>)
100069c4:	f001 fe18 	bl	100085f8 <__aeabi_dadd>
100069c8:	1c04      	adds	r4, r0, #0
100069ca:	1c30      	adds	r0, r6, #0
100069cc:	1c0d      	adds	r5, r1, #0
100069ce:	f003 fbc3 	bl	1000a158 <__aeabi_i2d>
100069d2:	4a98      	ldr	r2, [pc, #608]	; (10006c34 <_dtoa_r+0x3c4>)
100069d4:	4b98      	ldr	r3, [pc, #608]	; (10006c38 <_dtoa_r+0x3c8>)
100069d6:	f002 fd75 	bl	100094c4 <__aeabi_dmul>
100069da:	1c02      	adds	r2, r0, #0
100069dc:	1c0b      	adds	r3, r1, #0
100069de:	1c20      	adds	r0, r4, #0
100069e0:	1c29      	adds	r1, r5, #0
100069e2:	f001 fe09 	bl	100085f8 <__aeabi_dadd>
100069e6:	1c04      	adds	r4, r0, #0
100069e8:	1c0d      	adds	r5, r1, #0
100069ea:	f003 fb7f 	bl	1000a0ec <__aeabi_d2iz>
100069ee:	1c29      	adds	r1, r5, #0
100069f0:	9003      	str	r0, [sp, #12]
100069f2:	2200      	movs	r2, #0
100069f4:	1c20      	adds	r0, r4, #0
100069f6:	2300      	movs	r3, #0
100069f8:	f001 fdd6 	bl	100085a8 <__aeabi_dcmplt>
100069fc:	2800      	cmp	r0, #0
100069fe:	d00d      	beq.n	10006a1c <_dtoa_r+0x1ac>
10006a00:	9803      	ldr	r0, [sp, #12]
10006a02:	f003 fba9 	bl	1000a158 <__aeabi_i2d>
10006a06:	1c02      	adds	r2, r0, #0
10006a08:	1c0b      	adds	r3, r1, #0
10006a0a:	1c20      	adds	r0, r4, #0
10006a0c:	1c29      	adds	r1, r5, #0
10006a0e:	f001 fdc5 	bl	1000859c <__aeabi_dcmpeq>
10006a12:	4243      	negs	r3, r0
10006a14:	4143      	adcs	r3, r0
10006a16:	9a03      	ldr	r2, [sp, #12]
10006a18:	1ad3      	subs	r3, r2, r3
10006a1a:	9303      	str	r3, [sp, #12]
10006a1c:	2301      	movs	r3, #1
10006a1e:	9313      	str	r3, [sp, #76]	; 0x4c
10006a20:	9b03      	ldr	r3, [sp, #12]
10006a22:	2b16      	cmp	r3, #22
10006a24:	d811      	bhi.n	10006a4a <_dtoa_r+0x1da>
10006a26:	4a85      	ldr	r2, [pc, #532]	; (10006c3c <_dtoa_r+0x3cc>)
10006a28:	00db      	lsls	r3, r3, #3
10006a2a:	18d3      	adds	r3, r2, r3
10006a2c:	6818      	ldr	r0, [r3, #0]
10006a2e:	6859      	ldr	r1, [r3, #4]
10006a30:	9a06      	ldr	r2, [sp, #24]
10006a32:	9b07      	ldr	r3, [sp, #28]
10006a34:	f001 fdcc 	bl	100085d0 <__aeabi_dcmpgt>
10006a38:	2800      	cmp	r0, #0
10006a3a:	d005      	beq.n	10006a48 <_dtoa_r+0x1d8>
10006a3c:	9b03      	ldr	r3, [sp, #12]
10006a3e:	3b01      	subs	r3, #1
10006a40:	9303      	str	r3, [sp, #12]
10006a42:	2300      	movs	r3, #0
10006a44:	9313      	str	r3, [sp, #76]	; 0x4c
10006a46:	e000      	b.n	10006a4a <_dtoa_r+0x1da>
10006a48:	9013      	str	r0, [sp, #76]	; 0x4c
10006a4a:	9b18      	ldr	r3, [sp, #96]	; 0x60
10006a4c:	1b9e      	subs	r6, r3, r6
10006a4e:	2300      	movs	r3, #0
10006a50:	930d      	str	r3, [sp, #52]	; 0x34
10006a52:	3e01      	subs	r6, #1
10006a54:	960e      	str	r6, [sp, #56]	; 0x38
10006a56:	d504      	bpl.n	10006a62 <_dtoa_r+0x1f2>
10006a58:	9b0e      	ldr	r3, [sp, #56]	; 0x38
10006a5a:	425b      	negs	r3, r3
10006a5c:	930d      	str	r3, [sp, #52]	; 0x34
10006a5e:	2300      	movs	r3, #0
10006a60:	930e      	str	r3, [sp, #56]	; 0x38
10006a62:	9b03      	ldr	r3, [sp, #12]
10006a64:	2b00      	cmp	r3, #0
10006a66:	db08      	blt.n	10006a7a <_dtoa_r+0x20a>
10006a68:	9a03      	ldr	r2, [sp, #12]
10006a6a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
10006a6c:	4694      	mov	ip, r2
10006a6e:	4463      	add	r3, ip
10006a70:	930e      	str	r3, [sp, #56]	; 0x38
10006a72:	2300      	movs	r3, #0
10006a74:	9212      	str	r2, [sp, #72]	; 0x48
10006a76:	930f      	str	r3, [sp, #60]	; 0x3c
10006a78:	e007      	b.n	10006a8a <_dtoa_r+0x21a>
10006a7a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
10006a7c:	9a03      	ldr	r2, [sp, #12]
10006a7e:	1a9b      	subs	r3, r3, r2
10006a80:	930d      	str	r3, [sp, #52]	; 0x34
10006a82:	4253      	negs	r3, r2
10006a84:	930f      	str	r3, [sp, #60]	; 0x3c
10006a86:	2300      	movs	r3, #0
10006a88:	9312      	str	r3, [sp, #72]	; 0x48
10006a8a:	9b20      	ldr	r3, [sp, #128]	; 0x80
10006a8c:	2501      	movs	r5, #1
10006a8e:	2b09      	cmp	r3, #9
10006a90:	d827      	bhi.n	10006ae2 <_dtoa_r+0x272>
10006a92:	2b05      	cmp	r3, #5
10006a94:	dd02      	ble.n	10006a9c <_dtoa_r+0x22c>
10006a96:	2500      	movs	r5, #0
10006a98:	3b04      	subs	r3, #4
10006a9a:	9320      	str	r3, [sp, #128]	; 0x80
10006a9c:	9b20      	ldr	r3, [sp, #128]	; 0x80
10006a9e:	1e98      	subs	r0, r3, #2
10006aa0:	2803      	cmp	r0, #3
10006aa2:	d823      	bhi.n	10006aec <_dtoa_r+0x27c>
10006aa4:	f001 fd60 	bl	10008568 <__gnu_thumb1_case_uqi>
10006aa8:	10040e02 	.word	0x10040e02
10006aac:	2300      	movs	r3, #0
10006aae:	e000      	b.n	10006ab2 <_dtoa_r+0x242>
10006ab0:	2301      	movs	r3, #1
10006ab2:	9310      	str	r3, [sp, #64]	; 0x40
10006ab4:	9b21      	ldr	r3, [sp, #132]	; 0x84
10006ab6:	2b00      	cmp	r3, #0
10006ab8:	dc21      	bgt.n	10006afe <_dtoa_r+0x28e>
10006aba:	2301      	movs	r3, #1
10006abc:	930b      	str	r3, [sp, #44]	; 0x2c
10006abe:	9309      	str	r3, [sp, #36]	; 0x24
10006ac0:	1c1a      	adds	r2, r3, #0
10006ac2:	e01a      	b.n	10006afa <_dtoa_r+0x28a>
10006ac4:	2300      	movs	r3, #0
10006ac6:	e000      	b.n	10006aca <_dtoa_r+0x25a>
10006ac8:	2301      	movs	r3, #1
10006aca:	9a03      	ldr	r2, [sp, #12]
10006acc:	9310      	str	r3, [sp, #64]	; 0x40
10006ace:	4694      	mov	ip, r2
10006ad0:	9b21      	ldr	r3, [sp, #132]	; 0x84
10006ad2:	4463      	add	r3, ip
10006ad4:	930b      	str	r3, [sp, #44]	; 0x2c
10006ad6:	3301      	adds	r3, #1
10006ad8:	9309      	str	r3, [sp, #36]	; 0x24
10006ada:	2b00      	cmp	r3, #0
10006adc:	dc12      	bgt.n	10006b04 <_dtoa_r+0x294>
10006ade:	2301      	movs	r3, #1
10006ae0:	e010      	b.n	10006b04 <_dtoa_r+0x294>
10006ae2:	2300      	movs	r3, #0
10006ae4:	9510      	str	r5, [sp, #64]	; 0x40
10006ae6:	9320      	str	r3, [sp, #128]	; 0x80
10006ae8:	3b01      	subs	r3, #1
10006aea:	e002      	b.n	10006af2 <_dtoa_r+0x282>
10006aec:	2301      	movs	r3, #1
10006aee:	9310      	str	r3, [sp, #64]	; 0x40
10006af0:	3b02      	subs	r3, #2
10006af2:	2200      	movs	r2, #0
10006af4:	930b      	str	r3, [sp, #44]	; 0x2c
10006af6:	9309      	str	r3, [sp, #36]	; 0x24
10006af8:	3313      	adds	r3, #19
10006afa:	9221      	str	r2, [sp, #132]	; 0x84
10006afc:	e002      	b.n	10006b04 <_dtoa_r+0x294>
10006afe:	9b21      	ldr	r3, [sp, #132]	; 0x84
10006b00:	930b      	str	r3, [sp, #44]	; 0x2c
10006b02:	9309      	str	r3, [sp, #36]	; 0x24
10006b04:	9a08      	ldr	r2, [sp, #32]
10006b06:	6a54      	ldr	r4, [r2, #36]	; 0x24
10006b08:	2200      	movs	r2, #0
10006b0a:	6062      	str	r2, [r4, #4]
10006b0c:	3204      	adds	r2, #4
10006b0e:	1c11      	adds	r1, r2, #0
10006b10:	3114      	adds	r1, #20
10006b12:	4299      	cmp	r1, r3
10006b14:	d804      	bhi.n	10006b20 <_dtoa_r+0x2b0>
10006b16:	6861      	ldr	r1, [r4, #4]
10006b18:	0052      	lsls	r2, r2, #1
10006b1a:	3101      	adds	r1, #1
10006b1c:	6061      	str	r1, [r4, #4]
10006b1e:	e7f6      	b.n	10006b0e <_dtoa_r+0x29e>
10006b20:	9808      	ldr	r0, [sp, #32]
10006b22:	6861      	ldr	r1, [r4, #4]
10006b24:	f000 fe95 	bl	10007852 <_Balloc>
10006b28:	9b08      	ldr	r3, [sp, #32]
10006b2a:	6020      	str	r0, [r4, #0]
10006b2c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
10006b2e:	681b      	ldr	r3, [r3, #0]
10006b30:	930c      	str	r3, [sp, #48]	; 0x30
10006b32:	9b09      	ldr	r3, [sp, #36]	; 0x24
10006b34:	2b0e      	cmp	r3, #14
10006b36:	d900      	bls.n	10006b3a <_dtoa_r+0x2ca>
10006b38:	e188      	b.n	10006e4c <_dtoa_r+0x5dc>
10006b3a:	2d00      	cmp	r5, #0
10006b3c:	d100      	bne.n	10006b40 <_dtoa_r+0x2d0>
10006b3e:	e185      	b.n	10006e4c <_dtoa_r+0x5dc>
10006b40:	9b06      	ldr	r3, [sp, #24]
10006b42:	9c07      	ldr	r4, [sp, #28]
10006b44:	9314      	str	r3, [sp, #80]	; 0x50
10006b46:	9415      	str	r4, [sp, #84]	; 0x54
10006b48:	9b03      	ldr	r3, [sp, #12]
10006b4a:	2b00      	cmp	r3, #0
10006b4c:	dd30      	ble.n	10006bb0 <_dtoa_r+0x340>
10006b4e:	220f      	movs	r2, #15
10006b50:	493a      	ldr	r1, [pc, #232]	; (10006c3c <_dtoa_r+0x3cc>)
10006b52:	4013      	ands	r3, r2
10006b54:	00db      	lsls	r3, r3, #3
10006b56:	18cb      	adds	r3, r1, r3
10006b58:	685c      	ldr	r4, [r3, #4]
10006b5a:	681b      	ldr	r3, [r3, #0]
10006b5c:	9304      	str	r3, [sp, #16]
10006b5e:	9405      	str	r4, [sp, #20]
10006b60:	9b03      	ldr	r3, [sp, #12]
10006b62:	2702      	movs	r7, #2
10006b64:	111d      	asrs	r5, r3, #4
10006b66:	06eb      	lsls	r3, r5, #27
10006b68:	d50a      	bpl.n	10006b80 <_dtoa_r+0x310>
10006b6a:	9814      	ldr	r0, [sp, #80]	; 0x50
10006b6c:	9915      	ldr	r1, [sp, #84]	; 0x54
10006b6e:	4b34      	ldr	r3, [pc, #208]	; (10006c40 <_dtoa_r+0x3d0>)
10006b70:	4015      	ands	r5, r2
10006b72:	6a1a      	ldr	r2, [r3, #32]
10006b74:	6a5b      	ldr	r3, [r3, #36]	; 0x24
10006b76:	f002 f867 	bl	10008c48 <__aeabi_ddiv>
10006b7a:	9006      	str	r0, [sp, #24]
10006b7c:	9107      	str	r1, [sp, #28]
10006b7e:	3701      	adds	r7, #1
10006b80:	4c2f      	ldr	r4, [pc, #188]	; (10006c40 <_dtoa_r+0x3d0>)
10006b82:	2d00      	cmp	r5, #0
10006b84:	d00d      	beq.n	10006ba2 <_dtoa_r+0x332>
10006b86:	07eb      	lsls	r3, r5, #31
10006b88:	d508      	bpl.n	10006b9c <_dtoa_r+0x32c>
10006b8a:	9804      	ldr	r0, [sp, #16]
10006b8c:	9905      	ldr	r1, [sp, #20]
10006b8e:	6822      	ldr	r2, [r4, #0]
10006b90:	6863      	ldr	r3, [r4, #4]
10006b92:	f002 fc97 	bl	100094c4 <__aeabi_dmul>
10006b96:	9004      	str	r0, [sp, #16]
10006b98:	9105      	str	r1, [sp, #20]
10006b9a:	3701      	adds	r7, #1
10006b9c:	106d      	asrs	r5, r5, #1
10006b9e:	3408      	adds	r4, #8
10006ba0:	e7ef      	b.n	10006b82 <_dtoa_r+0x312>
10006ba2:	9806      	ldr	r0, [sp, #24]
10006ba4:	9907      	ldr	r1, [sp, #28]
10006ba6:	9a04      	ldr	r2, [sp, #16]
10006ba8:	9b05      	ldr	r3, [sp, #20]
10006baa:	f002 f84d 	bl	10008c48 <__aeabi_ddiv>
10006bae:	e049      	b.n	10006c44 <_dtoa_r+0x3d4>
10006bb0:	9b03      	ldr	r3, [sp, #12]
10006bb2:	2702      	movs	r7, #2
10006bb4:	425d      	negs	r5, r3
10006bb6:	2d00      	cmp	r5, #0
10006bb8:	d046      	beq.n	10006c48 <_dtoa_r+0x3d8>
10006bba:	9814      	ldr	r0, [sp, #80]	; 0x50
10006bbc:	9915      	ldr	r1, [sp, #84]	; 0x54
10006bbe:	230f      	movs	r3, #15
10006bc0:	4a1e      	ldr	r2, [pc, #120]	; (10006c3c <_dtoa_r+0x3cc>)
10006bc2:	402b      	ands	r3, r5
10006bc4:	00db      	lsls	r3, r3, #3
10006bc6:	18d3      	adds	r3, r2, r3
10006bc8:	681a      	ldr	r2, [r3, #0]
10006bca:	685b      	ldr	r3, [r3, #4]
10006bcc:	f002 fc7a 	bl	100094c4 <__aeabi_dmul>
10006bd0:	4c1b      	ldr	r4, [pc, #108]	; (10006c40 <_dtoa_r+0x3d0>)
10006bd2:	112d      	asrs	r5, r5, #4
10006bd4:	2d00      	cmp	r5, #0
10006bd6:	d035      	beq.n	10006c44 <_dtoa_r+0x3d4>
10006bd8:	07eb      	lsls	r3, r5, #31
10006bda:	d504      	bpl.n	10006be6 <_dtoa_r+0x376>
10006bdc:	6822      	ldr	r2, [r4, #0]
10006bde:	6863      	ldr	r3, [r4, #4]
10006be0:	3701      	adds	r7, #1
10006be2:	f002 fc6f 	bl	100094c4 <__aeabi_dmul>
10006be6:	106d      	asrs	r5, r5, #1
10006be8:	3408      	adds	r4, #8
10006bea:	e7f3      	b.n	10006bd4 <_dtoa_r+0x364>
10006bec:	7ff00000 	.word	0x7ff00000
10006bf0:	0000270f 	.word	0x0000270f
10006bf4:	1000a7ed 	.word	0x1000a7ed
10006bf8:	1000a7e4 	.word	0x1000a7e4
10006bfc:	1000a7c0 	.word	0x1000a7c0
10006c00:	1000a7c1 	.word	0x1000a7c1
10006c04:	3ff00000 	.word	0x3ff00000
10006c08:	fffffc01 	.word	0xfffffc01
10006c0c:	fffffbef 	.word	0xfffffbef
10006c10:	00000412 	.word	0x00000412
10006c14:	fffffc0e 	.word	0xfffffc0e
10006c18:	fffffbee 	.word	0xfffffbee
10006c1c:	fe100000 	.word	0xfe100000
10006c20:	3ff80000 	.word	0x3ff80000
10006c24:	636f4361 	.word	0x636f4361
10006c28:	3fd287a7 	.word	0x3fd287a7
10006c2c:	8b60c8b3 	.word	0x8b60c8b3
10006c30:	3fc68a28 	.word	0x3fc68a28
10006c34:	509f79fb 	.word	0x509f79fb
10006c38:	3fd34413 	.word	0x3fd34413
10006c3c:	1000a860 	.word	0x1000a860
10006c40:	1000a928 	.word	0x1000a928
10006c44:	9006      	str	r0, [sp, #24]
10006c46:	9107      	str	r1, [sp, #28]
10006c48:	9b13      	ldr	r3, [sp, #76]	; 0x4c
10006c4a:	2b00      	cmp	r3, #0
10006c4c:	d01e      	beq.n	10006c8c <_dtoa_r+0x41c>
10006c4e:	9c06      	ldr	r4, [sp, #24]
10006c50:	9d07      	ldr	r5, [sp, #28]
10006c52:	2200      	movs	r2, #0
10006c54:	1c20      	adds	r0, r4, #0
10006c56:	1c29      	adds	r1, r5, #0
10006c58:	4bce      	ldr	r3, [pc, #824]	; (10006f94 <_dtoa_r+0x724>)
10006c5a:	f001 fca5 	bl	100085a8 <__aeabi_dcmplt>
10006c5e:	2800      	cmp	r0, #0
10006c60:	d014      	beq.n	10006c8c <_dtoa_r+0x41c>
10006c62:	9b09      	ldr	r3, [sp, #36]	; 0x24
10006c64:	2b00      	cmp	r3, #0
10006c66:	d011      	beq.n	10006c8c <_dtoa_r+0x41c>
10006c68:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
10006c6a:	2b00      	cmp	r3, #0
10006c6c:	dc00      	bgt.n	10006c70 <_dtoa_r+0x400>
10006c6e:	e0e9      	b.n	10006e44 <_dtoa_r+0x5d4>
10006c70:	9b03      	ldr	r3, [sp, #12]
10006c72:	1c29      	adds	r1, r5, #0
10006c74:	3b01      	subs	r3, #1
10006c76:	9311      	str	r3, [sp, #68]	; 0x44
10006c78:	1c20      	adds	r0, r4, #0
10006c7a:	2200      	movs	r2, #0
10006c7c:	4bc6      	ldr	r3, [pc, #792]	; (10006f98 <_dtoa_r+0x728>)
10006c7e:	f002 fc21 	bl	100094c4 <__aeabi_dmul>
10006c82:	3701      	adds	r7, #1
10006c84:	9006      	str	r0, [sp, #24]
10006c86:	9107      	str	r1, [sp, #28]
10006c88:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
10006c8a:	e002      	b.n	10006c92 <_dtoa_r+0x422>
10006c8c:	9b03      	ldr	r3, [sp, #12]
10006c8e:	9d09      	ldr	r5, [sp, #36]	; 0x24
10006c90:	9311      	str	r3, [sp, #68]	; 0x44
10006c92:	1c38      	adds	r0, r7, #0
10006c94:	9b06      	ldr	r3, [sp, #24]
10006c96:	9c07      	ldr	r4, [sp, #28]
10006c98:	9304      	str	r3, [sp, #16]
10006c9a:	9405      	str	r4, [sp, #20]
10006c9c:	f003 fa5c 	bl	1000a158 <__aeabi_i2d>
10006ca0:	9a04      	ldr	r2, [sp, #16]
10006ca2:	9b05      	ldr	r3, [sp, #20]
10006ca4:	f002 fc0e 	bl	100094c4 <__aeabi_dmul>
10006ca8:	2200      	movs	r2, #0
10006caa:	4bbc      	ldr	r3, [pc, #752]	; (10006f9c <_dtoa_r+0x72c>)
10006cac:	f001 fca4 	bl	100085f8 <__aeabi_dadd>
10006cb0:	9006      	str	r0, [sp, #24]
10006cb2:	9107      	str	r1, [sp, #28]
10006cb4:	9e06      	ldr	r6, [sp, #24]
10006cb6:	9f07      	ldr	r7, [sp, #28]
10006cb8:	9b07      	ldr	r3, [sp, #28]
10006cba:	4ab9      	ldr	r2, [pc, #740]	; (10006fa0 <_dtoa_r+0x730>)
10006cbc:	189c      	adds	r4, r3, r2
10006cbe:	2d00      	cmp	r5, #0
10006cc0:	d11c      	bne.n	10006cfc <_dtoa_r+0x48c>
10006cc2:	9804      	ldr	r0, [sp, #16]
10006cc4:	9905      	ldr	r1, [sp, #20]
10006cc6:	2200      	movs	r2, #0
10006cc8:	4bb6      	ldr	r3, [pc, #728]	; (10006fa4 <_dtoa_r+0x734>)
10006cca:	f002 fe95 	bl	100099f8 <__aeabi_dsub>
10006cce:	1c32      	adds	r2, r6, #0
10006cd0:	1c23      	adds	r3, r4, #0
10006cd2:	9004      	str	r0, [sp, #16]
10006cd4:	9105      	str	r1, [sp, #20]
10006cd6:	f001 fc7b 	bl	100085d0 <__aeabi_dcmpgt>
10006cda:	2800      	cmp	r0, #0
10006cdc:	d000      	beq.n	10006ce0 <_dtoa_r+0x470>
10006cde:	e263      	b.n	100071a8 <_dtoa_r+0x938>
10006ce0:	9804      	ldr	r0, [sp, #16]
10006ce2:	9905      	ldr	r1, [sp, #20]
10006ce4:	1c32      	adds	r2, r6, #0
10006ce6:	4eb0      	ldr	r6, [pc, #704]	; (10006fa8 <_dtoa_r+0x738>)
10006ce8:	9c07      	ldr	r4, [sp, #28]
10006cea:	46b4      	mov	ip, r6
10006cec:	4464      	add	r4, ip
10006cee:	1c23      	adds	r3, r4, #0
10006cf0:	f001 fc5a 	bl	100085a8 <__aeabi_dcmplt>
10006cf4:	2800      	cmp	r0, #0
10006cf6:	d000      	beq.n	10006cfa <_dtoa_r+0x48a>
10006cf8:	e24c      	b.n	10007194 <_dtoa_r+0x924>
10006cfa:	e0a3      	b.n	10006e44 <_dtoa_r+0x5d4>
10006cfc:	4aab      	ldr	r2, [pc, #684]	; (10006fac <_dtoa_r+0x73c>)
10006cfe:	1e6b      	subs	r3, r5, #1
10006d00:	9910      	ldr	r1, [sp, #64]	; 0x40
10006d02:	00db      	lsls	r3, r3, #3
10006d04:	18d3      	adds	r3, r2, r3
10006d06:	2900      	cmp	r1, #0
10006d08:	d04e      	beq.n	10006da8 <_dtoa_r+0x538>
10006d0a:	681a      	ldr	r2, [r3, #0]
10006d0c:	685b      	ldr	r3, [r3, #4]
10006d0e:	2000      	movs	r0, #0
10006d10:	49a7      	ldr	r1, [pc, #668]	; (10006fb0 <_dtoa_r+0x740>)
10006d12:	f001 ff99 	bl	10008c48 <__aeabi_ddiv>
10006d16:	1c32      	adds	r2, r6, #0
10006d18:	1c23      	adds	r3, r4, #0
10006d1a:	f002 fe6d 	bl	100099f8 <__aeabi_dsub>
10006d1e:	9e04      	ldr	r6, [sp, #16]
10006d20:	9f05      	ldr	r7, [sp, #20]
10006d22:	9b0c      	ldr	r3, [sp, #48]	; 0x30
10006d24:	9006      	str	r0, [sp, #24]
10006d26:	9107      	str	r1, [sp, #28]
10006d28:	9304      	str	r3, [sp, #16]
10006d2a:	1c39      	adds	r1, r7, #0
10006d2c:	1c30      	adds	r0, r6, #0
10006d2e:	f003 f9dd 	bl	1000a0ec <__aeabi_d2iz>
10006d32:	1c04      	adds	r4, r0, #0
10006d34:	f003 fa10 	bl	1000a158 <__aeabi_i2d>
10006d38:	1c02      	adds	r2, r0, #0
10006d3a:	1c0b      	adds	r3, r1, #0
10006d3c:	1c30      	adds	r0, r6, #0
10006d3e:	1c39      	adds	r1, r7, #0
10006d40:	f002 fe5a 	bl	100099f8 <__aeabi_dsub>
10006d44:	9b04      	ldr	r3, [sp, #16]
10006d46:	3430      	adds	r4, #48	; 0x30
10006d48:	3301      	adds	r3, #1
10006d4a:	9304      	str	r3, [sp, #16]
10006d4c:	3b01      	subs	r3, #1
10006d4e:	701c      	strb	r4, [r3, #0]
10006d50:	9a06      	ldr	r2, [sp, #24]
10006d52:	9b07      	ldr	r3, [sp, #28]
10006d54:	1c06      	adds	r6, r0, #0
10006d56:	1c0f      	adds	r7, r1, #0
10006d58:	f001 fc26 	bl	100085a8 <__aeabi_dcmplt>
10006d5c:	2800      	cmp	r0, #0
10006d5e:	d000      	beq.n	10006d62 <_dtoa_r+0x4f2>
10006d60:	e361      	b.n	10007426 <_dtoa_r+0xbb6>
10006d62:	1c32      	adds	r2, r6, #0
10006d64:	1c3b      	adds	r3, r7, #0
10006d66:	2000      	movs	r0, #0
10006d68:	498a      	ldr	r1, [pc, #552]	; (10006f94 <_dtoa_r+0x724>)
10006d6a:	f002 fe45 	bl	100099f8 <__aeabi_dsub>
10006d6e:	9a06      	ldr	r2, [sp, #24]
10006d70:	9b07      	ldr	r3, [sp, #28]
10006d72:	f001 fc19 	bl	100085a8 <__aeabi_dcmplt>
10006d76:	2800      	cmp	r0, #0
10006d78:	d000      	beq.n	10006d7c <_dtoa_r+0x50c>
10006d7a:	e0cd      	b.n	10006f18 <_dtoa_r+0x6a8>
10006d7c:	9b04      	ldr	r3, [sp, #16]
10006d7e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
10006d80:	1a9b      	subs	r3, r3, r2
10006d82:	42ab      	cmp	r3, r5
10006d84:	da5e      	bge.n	10006e44 <_dtoa_r+0x5d4>
10006d86:	9806      	ldr	r0, [sp, #24]
10006d88:	9907      	ldr	r1, [sp, #28]
10006d8a:	2200      	movs	r2, #0
10006d8c:	4b82      	ldr	r3, [pc, #520]	; (10006f98 <_dtoa_r+0x728>)
10006d8e:	f002 fb99 	bl	100094c4 <__aeabi_dmul>
10006d92:	2200      	movs	r2, #0
10006d94:	9006      	str	r0, [sp, #24]
10006d96:	9107      	str	r1, [sp, #28]
10006d98:	4b7f      	ldr	r3, [pc, #508]	; (10006f98 <_dtoa_r+0x728>)
10006d9a:	1c30      	adds	r0, r6, #0
10006d9c:	1c39      	adds	r1, r7, #0
10006d9e:	f002 fb91 	bl	100094c4 <__aeabi_dmul>
10006da2:	1c06      	adds	r6, r0, #0
10006da4:	1c0f      	adds	r7, r1, #0
10006da6:	e7c0      	b.n	10006d2a <_dtoa_r+0x4ba>
10006da8:	6818      	ldr	r0, [r3, #0]
10006daa:	6859      	ldr	r1, [r3, #4]
10006dac:	1c32      	adds	r2, r6, #0
10006dae:	1c23      	adds	r3, r4, #0
10006db0:	f002 fb88 	bl	100094c4 <__aeabi_dmul>
10006db4:	9e04      	ldr	r6, [sp, #16]
10006db6:	9f05      	ldr	r7, [sp, #20]
10006db8:	9c0c      	ldr	r4, [sp, #48]	; 0x30
10006dba:	9006      	str	r0, [sp, #24]
10006dbc:	9107      	str	r1, [sp, #28]
10006dbe:	1963      	adds	r3, r4, r5
10006dc0:	9304      	str	r3, [sp, #16]
10006dc2:	1c39      	adds	r1, r7, #0
10006dc4:	1c30      	adds	r0, r6, #0
10006dc6:	f003 f991 	bl	1000a0ec <__aeabi_d2iz>
10006dca:	1c05      	adds	r5, r0, #0
10006dcc:	f003 f9c4 	bl	1000a158 <__aeabi_i2d>
10006dd0:	1c0b      	adds	r3, r1, #0
10006dd2:	1c02      	adds	r2, r0, #0
10006dd4:	1c39      	adds	r1, r7, #0
10006dd6:	1c30      	adds	r0, r6, #0
10006dd8:	f002 fe0e 	bl	100099f8 <__aeabi_dsub>
10006ddc:	3530      	adds	r5, #48	; 0x30
10006dde:	9b04      	ldr	r3, [sp, #16]
10006de0:	7025      	strb	r5, [r4, #0]
10006de2:	3401      	adds	r4, #1
10006de4:	1c06      	adds	r6, r0, #0
10006de6:	1c0f      	adds	r7, r1, #0
10006de8:	42a3      	cmp	r3, r4
10006dea:	d124      	bne.n	10006e36 <_dtoa_r+0x5c6>
10006dec:	2200      	movs	r2, #0
10006dee:	9806      	ldr	r0, [sp, #24]
10006df0:	9907      	ldr	r1, [sp, #28]
10006df2:	4b6f      	ldr	r3, [pc, #444]	; (10006fb0 <_dtoa_r+0x740>)
10006df4:	f001 fc00 	bl	100085f8 <__aeabi_dadd>
10006df8:	1c02      	adds	r2, r0, #0
10006dfa:	1c0b      	adds	r3, r1, #0
10006dfc:	1c30      	adds	r0, r6, #0
10006dfe:	1c39      	adds	r1, r7, #0
10006e00:	f001 fbe6 	bl	100085d0 <__aeabi_dcmpgt>
10006e04:	2800      	cmp	r0, #0
10006e06:	d000      	beq.n	10006e0a <_dtoa_r+0x59a>
10006e08:	e086      	b.n	10006f18 <_dtoa_r+0x6a8>
10006e0a:	9a06      	ldr	r2, [sp, #24]
10006e0c:	9b07      	ldr	r3, [sp, #28]
10006e0e:	2000      	movs	r0, #0
10006e10:	4967      	ldr	r1, [pc, #412]	; (10006fb0 <_dtoa_r+0x740>)
10006e12:	f002 fdf1 	bl	100099f8 <__aeabi_dsub>
10006e16:	1c02      	adds	r2, r0, #0
10006e18:	1c0b      	adds	r3, r1, #0
10006e1a:	1c30      	adds	r0, r6, #0
10006e1c:	1c39      	adds	r1, r7, #0
10006e1e:	f001 fbc3 	bl	100085a8 <__aeabi_dcmplt>
10006e22:	2800      	cmp	r0, #0
10006e24:	d00e      	beq.n	10006e44 <_dtoa_r+0x5d4>
10006e26:	9b04      	ldr	r3, [sp, #16]
10006e28:	3b01      	subs	r3, #1
10006e2a:	781a      	ldrb	r2, [r3, #0]
10006e2c:	2a30      	cmp	r2, #48	; 0x30
10006e2e:	d000      	beq.n	10006e32 <_dtoa_r+0x5c2>
10006e30:	e2f9      	b.n	10007426 <_dtoa_r+0xbb6>
10006e32:	9304      	str	r3, [sp, #16]
10006e34:	e7f7      	b.n	10006e26 <_dtoa_r+0x5b6>
10006e36:	2200      	movs	r2, #0
10006e38:	4b57      	ldr	r3, [pc, #348]	; (10006f98 <_dtoa_r+0x728>)
10006e3a:	f002 fb43 	bl	100094c4 <__aeabi_dmul>
10006e3e:	1c06      	adds	r6, r0, #0
10006e40:	1c0f      	adds	r7, r1, #0
10006e42:	e7be      	b.n	10006dc2 <_dtoa_r+0x552>
10006e44:	9b14      	ldr	r3, [sp, #80]	; 0x50
10006e46:	9c15      	ldr	r4, [sp, #84]	; 0x54
10006e48:	9306      	str	r3, [sp, #24]
10006e4a:	9407      	str	r4, [sp, #28]
10006e4c:	9b19      	ldr	r3, [sp, #100]	; 0x64
10006e4e:	2b00      	cmp	r3, #0
10006e50:	da00      	bge.n	10006e54 <_dtoa_r+0x5e4>
10006e52:	e086      	b.n	10006f62 <_dtoa_r+0x6f2>
10006e54:	9a03      	ldr	r2, [sp, #12]
10006e56:	2a0e      	cmp	r2, #14
10006e58:	dd00      	ble.n	10006e5c <_dtoa_r+0x5ec>
10006e5a:	e082      	b.n	10006f62 <_dtoa_r+0x6f2>
10006e5c:	00d3      	lsls	r3, r2, #3
10006e5e:	4a53      	ldr	r2, [pc, #332]	; (10006fac <_dtoa_r+0x73c>)
10006e60:	18d3      	adds	r3, r2, r3
10006e62:	681e      	ldr	r6, [r3, #0]
10006e64:	685f      	ldr	r7, [r3, #4]
10006e66:	9b21      	ldr	r3, [sp, #132]	; 0x84
10006e68:	2b00      	cmp	r3, #0
10006e6a:	da14      	bge.n	10006e96 <_dtoa_r+0x626>
10006e6c:	9b09      	ldr	r3, [sp, #36]	; 0x24
10006e6e:	2b00      	cmp	r3, #0
10006e70:	dc11      	bgt.n	10006e96 <_dtoa_r+0x626>
10006e72:	d000      	beq.n	10006e76 <_dtoa_r+0x606>
10006e74:	e190      	b.n	10007198 <_dtoa_r+0x928>
10006e76:	1c30      	adds	r0, r6, #0
10006e78:	1c39      	adds	r1, r7, #0
10006e7a:	2200      	movs	r2, #0
10006e7c:	4b49      	ldr	r3, [pc, #292]	; (10006fa4 <_dtoa_r+0x734>)
10006e7e:	f002 fb21 	bl	100094c4 <__aeabi_dmul>
10006e82:	9a06      	ldr	r2, [sp, #24]
10006e84:	9b07      	ldr	r3, [sp, #28]
10006e86:	f001 fbad 	bl	100085e4 <__aeabi_dcmpge>
10006e8a:	9f09      	ldr	r7, [sp, #36]	; 0x24
10006e8c:	1c3e      	adds	r6, r7, #0
10006e8e:	2800      	cmp	r0, #0
10006e90:	d000      	beq.n	10006e94 <_dtoa_r+0x624>
10006e92:	e183      	b.n	1000719c <_dtoa_r+0x92c>
10006e94:	e18c      	b.n	100071b0 <_dtoa_r+0x940>
10006e96:	9b0c      	ldr	r3, [sp, #48]	; 0x30
10006e98:	9c06      	ldr	r4, [sp, #24]
10006e9a:	9d07      	ldr	r5, [sp, #28]
10006e9c:	9304      	str	r3, [sp, #16]
10006e9e:	1c32      	adds	r2, r6, #0
10006ea0:	1c3b      	adds	r3, r7, #0
10006ea2:	1c20      	adds	r0, r4, #0
10006ea4:	1c29      	adds	r1, r5, #0
10006ea6:	f001 fecf 	bl	10008c48 <__aeabi_ddiv>
10006eaa:	f003 f91f 	bl	1000a0ec <__aeabi_d2iz>
10006eae:	9006      	str	r0, [sp, #24]
10006eb0:	f003 f952 	bl	1000a158 <__aeabi_i2d>
10006eb4:	1c32      	adds	r2, r6, #0
10006eb6:	1c3b      	adds	r3, r7, #0
10006eb8:	f002 fb04 	bl	100094c4 <__aeabi_dmul>
10006ebc:	1c02      	adds	r2, r0, #0
10006ebe:	1c0b      	adds	r3, r1, #0
10006ec0:	1c20      	adds	r0, r4, #0
10006ec2:	1c29      	adds	r1, r5, #0
10006ec4:	f002 fd98 	bl	100099f8 <__aeabi_dsub>
10006ec8:	1c0b      	adds	r3, r1, #0
10006eca:	9904      	ldr	r1, [sp, #16]
10006ecc:	1c02      	adds	r2, r0, #0
10006ece:	9806      	ldr	r0, [sp, #24]
10006ed0:	3101      	adds	r1, #1
10006ed2:	9104      	str	r1, [sp, #16]
10006ed4:	3030      	adds	r0, #48	; 0x30
10006ed6:	3901      	subs	r1, #1
10006ed8:	7008      	strb	r0, [r1, #0]
10006eda:	980c      	ldr	r0, [sp, #48]	; 0x30
10006edc:	9904      	ldr	r1, [sp, #16]
10006ede:	1a09      	subs	r1, r1, r0
10006ee0:	9809      	ldr	r0, [sp, #36]	; 0x24
10006ee2:	4281      	cmp	r1, r0
10006ee4:	d12e      	bne.n	10006f44 <_dtoa_r+0x6d4>
10006ee6:	1c10      	adds	r0, r2, #0
10006ee8:	1c19      	adds	r1, r3, #0
10006eea:	f001 fb85 	bl	100085f8 <__aeabi_dadd>
10006eee:	1c32      	adds	r2, r6, #0
10006ef0:	1c3b      	adds	r3, r7, #0
10006ef2:	1c04      	adds	r4, r0, #0
10006ef4:	1c0d      	adds	r5, r1, #0
10006ef6:	f001 fb6b 	bl	100085d0 <__aeabi_dcmpgt>
10006efa:	2800      	cmp	r0, #0
10006efc:	d110      	bne.n	10006f20 <_dtoa_r+0x6b0>
10006efe:	1c20      	adds	r0, r4, #0
10006f00:	1c29      	adds	r1, r5, #0
10006f02:	1c32      	adds	r2, r6, #0
10006f04:	1c3b      	adds	r3, r7, #0
10006f06:	f001 fb49 	bl	1000859c <__aeabi_dcmpeq>
10006f0a:	2800      	cmp	r0, #0
10006f0c:	d100      	bne.n	10006f10 <_dtoa_r+0x6a0>
10006f0e:	e28c      	b.n	1000742a <_dtoa_r+0xbba>
10006f10:	9b06      	ldr	r3, [sp, #24]
10006f12:	07db      	lsls	r3, r3, #31
10006f14:	d404      	bmi.n	10006f20 <_dtoa_r+0x6b0>
10006f16:	e288      	b.n	1000742a <_dtoa_r+0xbba>
10006f18:	9b11      	ldr	r3, [sp, #68]	; 0x44
10006f1a:	9303      	str	r3, [sp, #12]
10006f1c:	e000      	b.n	10006f20 <_dtoa_r+0x6b0>
10006f1e:	9304      	str	r3, [sp, #16]
10006f20:	9b04      	ldr	r3, [sp, #16]
10006f22:	3b01      	subs	r3, #1
10006f24:	781a      	ldrb	r2, [r3, #0]
10006f26:	2a39      	cmp	r2, #57	; 0x39
10006f28:	d108      	bne.n	10006f3c <_dtoa_r+0x6cc>
10006f2a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
10006f2c:	4293      	cmp	r3, r2
10006f2e:	d1f6      	bne.n	10006f1e <_dtoa_r+0x6ae>
10006f30:	9b03      	ldr	r3, [sp, #12]
10006f32:	3301      	adds	r3, #1
10006f34:	9303      	str	r3, [sp, #12]
10006f36:	2330      	movs	r3, #48	; 0x30
10006f38:	7013      	strb	r3, [r2, #0]
10006f3a:	1c13      	adds	r3, r2, #0
10006f3c:	781a      	ldrb	r2, [r3, #0]
10006f3e:	3201      	adds	r2, #1
10006f40:	701a      	strb	r2, [r3, #0]
10006f42:	e272      	b.n	1000742a <_dtoa_r+0xbba>
10006f44:	1c10      	adds	r0, r2, #0
10006f46:	1c19      	adds	r1, r3, #0
10006f48:	2200      	movs	r2, #0
10006f4a:	4b13      	ldr	r3, [pc, #76]	; (10006f98 <_dtoa_r+0x728>)
10006f4c:	f002 faba 	bl	100094c4 <__aeabi_dmul>
10006f50:	2200      	movs	r2, #0
10006f52:	2300      	movs	r3, #0
10006f54:	1c04      	adds	r4, r0, #0
10006f56:	1c0d      	adds	r5, r1, #0
10006f58:	f001 fb20 	bl	1000859c <__aeabi_dcmpeq>
10006f5c:	2800      	cmp	r0, #0
10006f5e:	d09e      	beq.n	10006e9e <_dtoa_r+0x62e>
10006f60:	e263      	b.n	1000742a <_dtoa_r+0xbba>
10006f62:	9a10      	ldr	r2, [sp, #64]	; 0x40
10006f64:	2a00      	cmp	r2, #0
10006f66:	d044      	beq.n	10006ff2 <_dtoa_r+0x782>
10006f68:	9a20      	ldr	r2, [sp, #128]	; 0x80
10006f6a:	2a01      	cmp	r2, #1
10006f6c:	dc0b      	bgt.n	10006f86 <_dtoa_r+0x716>
10006f6e:	9a16      	ldr	r2, [sp, #88]	; 0x58
10006f70:	2a00      	cmp	r2, #0
10006f72:	d002      	beq.n	10006f7a <_dtoa_r+0x70a>
10006f74:	4a0f      	ldr	r2, [pc, #60]	; (10006fb4 <_dtoa_r+0x744>)
10006f76:	189b      	adds	r3, r3, r2
10006f78:	e002      	b.n	10006f80 <_dtoa_r+0x710>
10006f7a:	2336      	movs	r3, #54	; 0x36
10006f7c:	9a18      	ldr	r2, [sp, #96]	; 0x60
10006f7e:	1a9b      	subs	r3, r3, r2
10006f80:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
10006f82:	9c0d      	ldr	r4, [sp, #52]	; 0x34
10006f84:	e029      	b.n	10006fda <_dtoa_r+0x76a>
10006f86:	9b09      	ldr	r3, [sp, #36]	; 0x24
10006f88:	1e5d      	subs	r5, r3, #1
10006f8a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
10006f8c:	42ab      	cmp	r3, r5
10006f8e:	db13      	blt.n	10006fb8 <_dtoa_r+0x748>
10006f90:	1b5d      	subs	r5, r3, r5
10006f92:	e018      	b.n	10006fc6 <_dtoa_r+0x756>
10006f94:	3ff00000 	.word	0x3ff00000
10006f98:	40240000 	.word	0x40240000
10006f9c:	401c0000 	.word	0x401c0000
10006fa0:	fcc00000 	.word	0xfcc00000
10006fa4:	40140000 	.word	0x40140000
10006fa8:	7cc00000 	.word	0x7cc00000
10006fac:	1000a860 	.word	0x1000a860
10006fb0:	3fe00000 	.word	0x3fe00000
10006fb4:	00000433 	.word	0x00000433
10006fb8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
10006fba:	950f      	str	r5, [sp, #60]	; 0x3c
10006fbc:	1aea      	subs	r2, r5, r3
10006fbe:	2500      	movs	r5, #0
10006fc0:	9b12      	ldr	r3, [sp, #72]	; 0x48
10006fc2:	189b      	adds	r3, r3, r2
10006fc4:	9312      	str	r3, [sp, #72]	; 0x48
10006fc6:	9b09      	ldr	r3, [sp, #36]	; 0x24
10006fc8:	2b00      	cmp	r3, #0
10006fca:	da04      	bge.n	10006fd6 <_dtoa_r+0x766>
10006fcc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
10006fce:	9a09      	ldr	r2, [sp, #36]	; 0x24
10006fd0:	1a9c      	subs	r4, r3, r2
10006fd2:	2300      	movs	r3, #0
10006fd4:	e001      	b.n	10006fda <_dtoa_r+0x76a>
10006fd6:	9c0d      	ldr	r4, [sp, #52]	; 0x34
10006fd8:	9b09      	ldr	r3, [sp, #36]	; 0x24
10006fda:	9a0d      	ldr	r2, [sp, #52]	; 0x34
10006fdc:	9808      	ldr	r0, [sp, #32]
10006fde:	18d2      	adds	r2, r2, r3
10006fe0:	920d      	str	r2, [sp, #52]	; 0x34
10006fe2:	9a0e      	ldr	r2, [sp, #56]	; 0x38
10006fe4:	2101      	movs	r1, #1
10006fe6:	18d3      	adds	r3, r2, r3
10006fe8:	930e      	str	r3, [sp, #56]	; 0x38
10006fea:	f000 fd09 	bl	10007a00 <__i2b>
10006fee:	1c06      	adds	r6, r0, #0
10006ff0:	e002      	b.n	10006ff8 <_dtoa_r+0x788>
10006ff2:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
10006ff4:	9c0d      	ldr	r4, [sp, #52]	; 0x34
10006ff6:	9e10      	ldr	r6, [sp, #64]	; 0x40
10006ff8:	2c00      	cmp	r4, #0
10006ffa:	d00c      	beq.n	10007016 <_dtoa_r+0x7a6>
10006ffc:	9b0e      	ldr	r3, [sp, #56]	; 0x38
10006ffe:	2b00      	cmp	r3, #0
10007000:	dd09      	ble.n	10007016 <_dtoa_r+0x7a6>
10007002:	42a3      	cmp	r3, r4
10007004:	dd00      	ble.n	10007008 <_dtoa_r+0x798>
10007006:	1c23      	adds	r3, r4, #0
10007008:	9a0d      	ldr	r2, [sp, #52]	; 0x34
1000700a:	1ae4      	subs	r4, r4, r3
1000700c:	1ad2      	subs	r2, r2, r3
1000700e:	920d      	str	r2, [sp, #52]	; 0x34
10007010:	9a0e      	ldr	r2, [sp, #56]	; 0x38
10007012:	1ad3      	subs	r3, r2, r3
10007014:	930e      	str	r3, [sp, #56]	; 0x38
10007016:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
10007018:	2b00      	cmp	r3, #0
1000701a:	dd21      	ble.n	10007060 <_dtoa_r+0x7f0>
1000701c:	9b10      	ldr	r3, [sp, #64]	; 0x40
1000701e:	2b00      	cmp	r3, #0
10007020:	d018      	beq.n	10007054 <_dtoa_r+0x7e4>
10007022:	2d00      	cmp	r5, #0
10007024:	dd10      	ble.n	10007048 <_dtoa_r+0x7d8>
10007026:	1c31      	adds	r1, r6, #0
10007028:	1c2a      	adds	r2, r5, #0
1000702a:	9808      	ldr	r0, [sp, #32]
1000702c:	f000 fd7e 	bl	10007b2c <__pow5mult>
10007030:	1c06      	adds	r6, r0, #0
10007032:	9a0a      	ldr	r2, [sp, #40]	; 0x28
10007034:	1c31      	adds	r1, r6, #0
10007036:	9808      	ldr	r0, [sp, #32]
10007038:	f000 fceb 	bl	10007a12 <__multiply>
1000703c:	1c07      	adds	r7, r0, #0
1000703e:	990a      	ldr	r1, [sp, #40]	; 0x28
10007040:	9808      	ldr	r0, [sp, #32]
10007042:	f000 fc3e 	bl	100078c2 <_Bfree>
10007046:	970a      	str	r7, [sp, #40]	; 0x28
10007048:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
1000704a:	1b5a      	subs	r2, r3, r5
1000704c:	d008      	beq.n	10007060 <_dtoa_r+0x7f0>
1000704e:	9808      	ldr	r0, [sp, #32]
10007050:	990a      	ldr	r1, [sp, #40]	; 0x28
10007052:	e002      	b.n	1000705a <_dtoa_r+0x7ea>
10007054:	9808      	ldr	r0, [sp, #32]
10007056:	990a      	ldr	r1, [sp, #40]	; 0x28
10007058:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
1000705a:	f000 fd67 	bl	10007b2c <__pow5mult>
1000705e:	900a      	str	r0, [sp, #40]	; 0x28
10007060:	9808      	ldr	r0, [sp, #32]
10007062:	2101      	movs	r1, #1
10007064:	f000 fccc 	bl	10007a00 <__i2b>
10007068:	9b12      	ldr	r3, [sp, #72]	; 0x48
1000706a:	1c07      	adds	r7, r0, #0
1000706c:	2b00      	cmp	r3, #0
1000706e:	dd0a      	ble.n	10007086 <_dtoa_r+0x816>
10007070:	1c39      	adds	r1, r7, #0
10007072:	1c1a      	adds	r2, r3, #0
10007074:	9808      	ldr	r0, [sp, #32]
10007076:	f000 fd59 	bl	10007b2c <__pow5mult>
1000707a:	9b20      	ldr	r3, [sp, #128]	; 0x80
1000707c:	1c07      	adds	r7, r0, #0
1000707e:	2500      	movs	r5, #0
10007080:	2b01      	cmp	r3, #1
10007082:	dc1b      	bgt.n	100070bc <_dtoa_r+0x84c>
10007084:	e003      	b.n	1000708e <_dtoa_r+0x81e>
10007086:	9b20      	ldr	r3, [sp, #128]	; 0x80
10007088:	2500      	movs	r5, #0
1000708a:	2b01      	cmp	r3, #1
1000708c:	dc12      	bgt.n	100070b4 <_dtoa_r+0x844>
1000708e:	2500      	movs	r5, #0
10007090:	9b06      	ldr	r3, [sp, #24]
10007092:	42ab      	cmp	r3, r5
10007094:	d10e      	bne.n	100070b4 <_dtoa_r+0x844>
10007096:	9b07      	ldr	r3, [sp, #28]
10007098:	031b      	lsls	r3, r3, #12
1000709a:	42ab      	cmp	r3, r5
1000709c:	d10a      	bne.n	100070b4 <_dtoa_r+0x844>
1000709e:	9b17      	ldr	r3, [sp, #92]	; 0x5c
100070a0:	9a07      	ldr	r2, [sp, #28]
100070a2:	4213      	tst	r3, r2
100070a4:	d006      	beq.n	100070b4 <_dtoa_r+0x844>
100070a6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
100070a8:	3501      	adds	r5, #1
100070aa:	3301      	adds	r3, #1
100070ac:	930d      	str	r3, [sp, #52]	; 0x34
100070ae:	9b0e      	ldr	r3, [sp, #56]	; 0x38
100070b0:	3301      	adds	r3, #1
100070b2:	930e      	str	r3, [sp, #56]	; 0x38
100070b4:	9b12      	ldr	r3, [sp, #72]	; 0x48
100070b6:	2001      	movs	r0, #1
100070b8:	2b00      	cmp	r3, #0
100070ba:	d008      	beq.n	100070ce <_dtoa_r+0x85e>
100070bc:	693b      	ldr	r3, [r7, #16]
100070be:	3303      	adds	r3, #3
100070c0:	009b      	lsls	r3, r3, #2
100070c2:	18fb      	adds	r3, r7, r3
100070c4:	6858      	ldr	r0, [r3, #4]
100070c6:	f000 fc51 	bl	1000796c <__hi0bits>
100070ca:	2320      	movs	r3, #32
100070cc:	1a18      	subs	r0, r3, r0
100070ce:	9b0e      	ldr	r3, [sp, #56]	; 0x38
100070d0:	18c0      	adds	r0, r0, r3
100070d2:	231f      	movs	r3, #31
100070d4:	4018      	ands	r0, r3
100070d6:	d009      	beq.n	100070ec <_dtoa_r+0x87c>
100070d8:	3301      	adds	r3, #1
100070da:	1a1b      	subs	r3, r3, r0
100070dc:	2b04      	cmp	r3, #4
100070de:	dd02      	ble.n	100070e6 <_dtoa_r+0x876>
100070e0:	231c      	movs	r3, #28
100070e2:	1a18      	subs	r0, r3, r0
100070e4:	e003      	b.n	100070ee <_dtoa_r+0x87e>
100070e6:	2b04      	cmp	r3, #4
100070e8:	d008      	beq.n	100070fc <_dtoa_r+0x88c>
100070ea:	1c18      	adds	r0, r3, #0
100070ec:	301c      	adds	r0, #28
100070ee:	9b0d      	ldr	r3, [sp, #52]	; 0x34
100070f0:	1824      	adds	r4, r4, r0
100070f2:	181b      	adds	r3, r3, r0
100070f4:	930d      	str	r3, [sp, #52]	; 0x34
100070f6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
100070f8:	181b      	adds	r3, r3, r0
100070fa:	930e      	str	r3, [sp, #56]	; 0x38
100070fc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
100070fe:	2b00      	cmp	r3, #0
10007100:	dd05      	ble.n	1000710e <_dtoa_r+0x89e>
10007102:	9808      	ldr	r0, [sp, #32]
10007104:	990a      	ldr	r1, [sp, #40]	; 0x28
10007106:	1c1a      	adds	r2, r3, #0
10007108:	f000 fd62 	bl	10007bd0 <__lshift>
1000710c:	900a      	str	r0, [sp, #40]	; 0x28
1000710e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
10007110:	2b00      	cmp	r3, #0
10007112:	dd05      	ble.n	10007120 <_dtoa_r+0x8b0>
10007114:	1c39      	adds	r1, r7, #0
10007116:	9808      	ldr	r0, [sp, #32]
10007118:	1c1a      	adds	r2, r3, #0
1000711a:	f000 fd59 	bl	10007bd0 <__lshift>
1000711e:	1c07      	adds	r7, r0, #0
10007120:	9b13      	ldr	r3, [sp, #76]	; 0x4c
10007122:	2b00      	cmp	r3, #0
10007124:	d01e      	beq.n	10007164 <_dtoa_r+0x8f4>
10007126:	980a      	ldr	r0, [sp, #40]	; 0x28
10007128:	1c39      	adds	r1, r7, #0
1000712a:	f000 fda3 	bl	10007c74 <__mcmp>
1000712e:	2800      	cmp	r0, #0
10007130:	da18      	bge.n	10007164 <_dtoa_r+0x8f4>
10007132:	9b03      	ldr	r3, [sp, #12]
10007134:	9808      	ldr	r0, [sp, #32]
10007136:	3b01      	subs	r3, #1
10007138:	9303      	str	r3, [sp, #12]
1000713a:	990a      	ldr	r1, [sp, #40]	; 0x28
1000713c:	2300      	movs	r3, #0
1000713e:	220a      	movs	r2, #10
10007140:	f000 fbd8 	bl	100078f4 <__multadd>
10007144:	9b10      	ldr	r3, [sp, #64]	; 0x40
10007146:	900a      	str	r0, [sp, #40]	; 0x28
10007148:	2b00      	cmp	r3, #0
1000714a:	d100      	bne.n	1000714e <_dtoa_r+0x8de>
1000714c:	e17f      	b.n	1000744e <_dtoa_r+0xbde>
1000714e:	1c31      	adds	r1, r6, #0
10007150:	2300      	movs	r3, #0
10007152:	9808      	ldr	r0, [sp, #32]
10007154:	220a      	movs	r2, #10
10007156:	f000 fbcd 	bl	100078f4 <__multadd>
1000715a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
1000715c:	1c06      	adds	r6, r0, #0
1000715e:	2b00      	cmp	r3, #0
10007160:	dc3c      	bgt.n	100071dc <_dtoa_r+0x96c>
10007162:	e17d      	b.n	10007460 <_dtoa_r+0xbf0>
10007164:	9b09      	ldr	r3, [sp, #36]	; 0x24
10007166:	2b00      	cmp	r3, #0
10007168:	dc2e      	bgt.n	100071c8 <_dtoa_r+0x958>
1000716a:	9b20      	ldr	r3, [sp, #128]	; 0x80
1000716c:	2b02      	cmp	r3, #2
1000716e:	dd2b      	ble.n	100071c8 <_dtoa_r+0x958>
10007170:	9b09      	ldr	r3, [sp, #36]	; 0x24
10007172:	930b      	str	r3, [sp, #44]	; 0x2c
10007174:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
10007176:	2b00      	cmp	r3, #0
10007178:	d110      	bne.n	1000719c <_dtoa_r+0x92c>
1000717a:	1c39      	adds	r1, r7, #0
1000717c:	9808      	ldr	r0, [sp, #32]
1000717e:	2205      	movs	r2, #5
10007180:	f000 fbb8 	bl	100078f4 <__multadd>
10007184:	1c07      	adds	r7, r0, #0
10007186:	980a      	ldr	r0, [sp, #40]	; 0x28
10007188:	1c39      	adds	r1, r7, #0
1000718a:	f000 fd73 	bl	10007c74 <__mcmp>
1000718e:	2800      	cmp	r0, #0
10007190:	dc0e      	bgt.n	100071b0 <_dtoa_r+0x940>
10007192:	e003      	b.n	1000719c <_dtoa_r+0x92c>
10007194:	1c2f      	adds	r7, r5, #0
10007196:	e000      	b.n	1000719a <_dtoa_r+0x92a>
10007198:	2700      	movs	r7, #0
1000719a:	1c3e      	adds	r6, r7, #0
1000719c:	9b21      	ldr	r3, [sp, #132]	; 0x84
1000719e:	43db      	mvns	r3, r3
100071a0:	9303      	str	r3, [sp, #12]
100071a2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
100071a4:	9304      	str	r3, [sp, #16]
100071a6:	e00c      	b.n	100071c2 <_dtoa_r+0x952>
100071a8:	1c2f      	adds	r7, r5, #0
100071aa:	1c2e      	adds	r6, r5, #0
100071ac:	9b11      	ldr	r3, [sp, #68]	; 0x44
100071ae:	9303      	str	r3, [sp, #12]
100071b0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
100071b2:	9a0c      	ldr	r2, [sp, #48]	; 0x30
100071b4:	3301      	adds	r3, #1
100071b6:	9304      	str	r3, [sp, #16]
100071b8:	2331      	movs	r3, #49	; 0x31
100071ba:	7013      	strb	r3, [r2, #0]
100071bc:	9b03      	ldr	r3, [sp, #12]
100071be:	3301      	adds	r3, #1
100071c0:	9303      	str	r3, [sp, #12]
100071c2:	9609      	str	r6, [sp, #36]	; 0x24
100071c4:	2600      	movs	r6, #0
100071c6:	e11a      	b.n	100073fe <_dtoa_r+0xb8e>
100071c8:	9b10      	ldr	r3, [sp, #64]	; 0x40
100071ca:	2b00      	cmp	r3, #0
100071cc:	d104      	bne.n	100071d8 <_dtoa_r+0x968>
100071ce:	9b09      	ldr	r3, [sp, #36]	; 0x24
100071d0:	930b      	str	r3, [sp, #44]	; 0x2c
100071d2:	9d0c      	ldr	r5, [sp, #48]	; 0x30
100071d4:	9c0a      	ldr	r4, [sp, #40]	; 0x28
100071d6:	e0d0      	b.n	1000737a <_dtoa_r+0xb0a>
100071d8:	9b09      	ldr	r3, [sp, #36]	; 0x24
100071da:	930b      	str	r3, [sp, #44]	; 0x2c
100071dc:	2c00      	cmp	r4, #0
100071de:	dd05      	ble.n	100071ec <_dtoa_r+0x97c>
100071e0:	1c31      	adds	r1, r6, #0
100071e2:	9808      	ldr	r0, [sp, #32]
100071e4:	1c22      	adds	r2, r4, #0
100071e6:	f000 fcf3 	bl	10007bd0 <__lshift>
100071ea:	1c06      	adds	r6, r0, #0
100071ec:	9609      	str	r6, [sp, #36]	; 0x24
100071ee:	2d00      	cmp	r5, #0
100071f0:	d012      	beq.n	10007218 <_dtoa_r+0x9a8>
100071f2:	6871      	ldr	r1, [r6, #4]
100071f4:	9808      	ldr	r0, [sp, #32]
100071f6:	f000 fb2c 	bl	10007852 <_Balloc>
100071fa:	1c31      	adds	r1, r6, #0
100071fc:	1c04      	adds	r4, r0, #0
100071fe:	6933      	ldr	r3, [r6, #16]
10007200:	310c      	adds	r1, #12
10007202:	1c9a      	adds	r2, r3, #2
10007204:	0092      	lsls	r2, r2, #2
10007206:	300c      	adds	r0, #12
10007208:	f7fe fbf0 	bl	100059ec <memcpy>
1000720c:	9808      	ldr	r0, [sp, #32]
1000720e:	1c21      	adds	r1, r4, #0
10007210:	2201      	movs	r2, #1
10007212:	f000 fcdd 	bl	10007bd0 <__lshift>
10007216:	9009      	str	r0, [sp, #36]	; 0x24
10007218:	9b0c      	ldr	r3, [sp, #48]	; 0x30
1000721a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
1000721c:	930e      	str	r3, [sp, #56]	; 0x38
1000721e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
10007220:	9c0a      	ldr	r4, [sp, #40]	; 0x28
10007222:	3b01      	subs	r3, #1
10007224:	18d3      	adds	r3, r2, r3
10007226:	9310      	str	r3, [sp, #64]	; 0x40
10007228:	1c39      	adds	r1, r7, #0
1000722a:	1c20      	adds	r0, r4, #0
1000722c:	f7ff fa98 	bl	10006760 <quorem>
10007230:	1c03      	adds	r3, r0, #0
10007232:	900f      	str	r0, [sp, #60]	; 0x3c
10007234:	3330      	adds	r3, #48	; 0x30
10007236:	1c31      	adds	r1, r6, #0
10007238:	1c20      	adds	r0, r4, #0
1000723a:	930d      	str	r3, [sp, #52]	; 0x34
1000723c:	f000 fd1a 	bl	10007c74 <__mcmp>
10007240:	1c39      	adds	r1, r7, #0
10007242:	900b      	str	r0, [sp, #44]	; 0x2c
10007244:	9a09      	ldr	r2, [sp, #36]	; 0x24
10007246:	9808      	ldr	r0, [sp, #32]
10007248:	f000 fd2f 	bl	10007caa <__mdiff>
1000724c:	2301      	movs	r3, #1
1000724e:	9304      	str	r3, [sp, #16]
10007250:	68c3      	ldr	r3, [r0, #12]
10007252:	1c05      	adds	r5, r0, #0
10007254:	2b00      	cmp	r3, #0
10007256:	d104      	bne.n	10007262 <_dtoa_r+0x9f2>
10007258:	1c20      	adds	r0, r4, #0
1000725a:	1c29      	adds	r1, r5, #0
1000725c:	f000 fd0a 	bl	10007c74 <__mcmp>
10007260:	9004      	str	r0, [sp, #16]
10007262:	9808      	ldr	r0, [sp, #32]
10007264:	1c29      	adds	r1, r5, #0
10007266:	f000 fb2c 	bl	100078c2 <_Bfree>
1000726a:	9b04      	ldr	r3, [sp, #16]
1000726c:	9a20      	ldr	r2, [sp, #128]	; 0x80
1000726e:	4313      	orrs	r3, r2
10007270:	d110      	bne.n	10007294 <_dtoa_r+0xa24>
10007272:	9a06      	ldr	r2, [sp, #24]
10007274:	3301      	adds	r3, #1
10007276:	4213      	tst	r3, r2
10007278:	d10c      	bne.n	10007294 <_dtoa_r+0xa24>
1000727a:	980d      	ldr	r0, [sp, #52]	; 0x34
1000727c:	940a      	str	r4, [sp, #40]	; 0x28
1000727e:	2839      	cmp	r0, #57	; 0x39
10007280:	d03d      	beq.n	100072fe <_dtoa_r+0xa8e>
10007282:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
10007284:	2b00      	cmp	r3, #0
10007286:	dd01      	ble.n	1000728c <_dtoa_r+0xa1c>
10007288:	980f      	ldr	r0, [sp, #60]	; 0x3c
1000728a:	3031      	adds	r0, #49	; 0x31
1000728c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
1000728e:	3301      	adds	r3, #1
10007290:	9304      	str	r3, [sp, #16]
10007292:	e03e      	b.n	10007312 <_dtoa_r+0xaa2>
10007294:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
10007296:	2b00      	cmp	r3, #0
10007298:	da05      	bge.n	100072a6 <_dtoa_r+0xa36>
1000729a:	9b04      	ldr	r3, [sp, #16]
1000729c:	9d0d      	ldr	r5, [sp, #52]	; 0x34
1000729e:	940a      	str	r4, [sp, #40]	; 0x28
100072a0:	2b00      	cmp	r3, #0
100072a2:	dc09      	bgt.n	100072b8 <_dtoa_r+0xa48>
100072a4:	e01c      	b.n	100072e0 <_dtoa_r+0xa70>
100072a6:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
100072a8:	9b20      	ldr	r3, [sp, #128]	; 0x80
100072aa:	431d      	orrs	r5, r3
100072ac:	d11e      	bne.n	100072ec <_dtoa_r+0xa7c>
100072ae:	2301      	movs	r3, #1
100072b0:	9a06      	ldr	r2, [sp, #24]
100072b2:	4213      	tst	r3, r2
100072b4:	d11a      	bne.n	100072ec <_dtoa_r+0xa7c>
100072b6:	e7f0      	b.n	1000729a <_dtoa_r+0xa2a>
100072b8:	1c21      	adds	r1, r4, #0
100072ba:	9808      	ldr	r0, [sp, #32]
100072bc:	2201      	movs	r2, #1
100072be:	f000 fc87 	bl	10007bd0 <__lshift>
100072c2:	1c39      	adds	r1, r7, #0
100072c4:	900a      	str	r0, [sp, #40]	; 0x28
100072c6:	f000 fcd5 	bl	10007c74 <__mcmp>
100072ca:	2800      	cmp	r0, #0
100072cc:	dc03      	bgt.n	100072d6 <_dtoa_r+0xa66>
100072ce:	d107      	bne.n	100072e0 <_dtoa_r+0xa70>
100072d0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
100072d2:	07db      	lsls	r3, r3, #31
100072d4:	d504      	bpl.n	100072e0 <_dtoa_r+0xa70>
100072d6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
100072d8:	2b39      	cmp	r3, #57	; 0x39
100072da:	d010      	beq.n	100072fe <_dtoa_r+0xa8e>
100072dc:	1c1d      	adds	r5, r3, #0
100072de:	3501      	adds	r5, #1
100072e0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
100072e2:	3301      	adds	r3, #1
100072e4:	9304      	str	r3, [sp, #16]
100072e6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
100072e8:	701d      	strb	r5, [r3, #0]
100072ea:	e088      	b.n	100073fe <_dtoa_r+0xb8e>
100072ec:	9b0e      	ldr	r3, [sp, #56]	; 0x38
100072ee:	1c5d      	adds	r5, r3, #1
100072f0:	9b04      	ldr	r3, [sp, #16]
100072f2:	2b00      	cmp	r3, #0
100072f4:	dd10      	ble.n	10007318 <_dtoa_r+0xaa8>
100072f6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
100072f8:	940a      	str	r4, [sp, #40]	; 0x28
100072fa:	2b39      	cmp	r3, #57	; 0x39
100072fc:	d106      	bne.n	1000730c <_dtoa_r+0xa9c>
100072fe:	9b0e      	ldr	r3, [sp, #56]	; 0x38
10007300:	9a0e      	ldr	r2, [sp, #56]	; 0x38
10007302:	3301      	adds	r3, #1
10007304:	9304      	str	r3, [sp, #16]
10007306:	2339      	movs	r3, #57	; 0x39
10007308:	7013      	strb	r3, [r2, #0]
1000730a:	e060      	b.n	100073ce <_dtoa_r+0xb5e>
1000730c:	980d      	ldr	r0, [sp, #52]	; 0x34
1000730e:	9504      	str	r5, [sp, #16]
10007310:	3001      	adds	r0, #1
10007312:	9b0e      	ldr	r3, [sp, #56]	; 0x38
10007314:	7018      	strb	r0, [r3, #0]
10007316:	e072      	b.n	100073fe <_dtoa_r+0xb8e>
10007318:	466a      	mov	r2, sp
1000731a:	2134      	movs	r1, #52	; 0x34
1000731c:	1852      	adds	r2, r2, r1
1000731e:	7812      	ldrb	r2, [r2, #0]
10007320:	9b0e      	ldr	r3, [sp, #56]	; 0x38
10007322:	9504      	str	r5, [sp, #16]
10007324:	701a      	strb	r2, [r3, #0]
10007326:	9a10      	ldr	r2, [sp, #64]	; 0x40
10007328:	4293      	cmp	r3, r2
1000732a:	d03f      	beq.n	100073ac <_dtoa_r+0xb3c>
1000732c:	1c21      	adds	r1, r4, #0
1000732e:	220a      	movs	r2, #10
10007330:	2300      	movs	r3, #0
10007332:	9808      	ldr	r0, [sp, #32]
10007334:	f000 fade 	bl	100078f4 <__multadd>
10007338:	9b09      	ldr	r3, [sp, #36]	; 0x24
1000733a:	1c04      	adds	r4, r0, #0
1000733c:	1c31      	adds	r1, r6, #0
1000733e:	9808      	ldr	r0, [sp, #32]
10007340:	220a      	movs	r2, #10
10007342:	429e      	cmp	r6, r3
10007344:	d105      	bne.n	10007352 <_dtoa_r+0xae2>
10007346:	2300      	movs	r3, #0
10007348:	f000 fad4 	bl	100078f4 <__multadd>
1000734c:	1c06      	adds	r6, r0, #0
1000734e:	9009      	str	r0, [sp, #36]	; 0x24
10007350:	e00a      	b.n	10007368 <_dtoa_r+0xaf8>
10007352:	2300      	movs	r3, #0
10007354:	f000 face 	bl	100078f4 <__multadd>
10007358:	9909      	ldr	r1, [sp, #36]	; 0x24
1000735a:	1c06      	adds	r6, r0, #0
1000735c:	220a      	movs	r2, #10
1000735e:	9808      	ldr	r0, [sp, #32]
10007360:	2300      	movs	r3, #0
10007362:	f000 fac7 	bl	100078f4 <__multadd>
10007366:	9009      	str	r0, [sp, #36]	; 0x24
10007368:	950e      	str	r5, [sp, #56]	; 0x38
1000736a:	e75d      	b.n	10007228 <_dtoa_r+0x9b8>
1000736c:	1c21      	adds	r1, r4, #0
1000736e:	9808      	ldr	r0, [sp, #32]
10007370:	220a      	movs	r2, #10
10007372:	2300      	movs	r3, #0
10007374:	f000 fabe 	bl	100078f4 <__multadd>
10007378:	1c04      	adds	r4, r0, #0
1000737a:	1c20      	adds	r0, r4, #0
1000737c:	1c39      	adds	r1, r7, #0
1000737e:	f7ff f9ef 	bl	10006760 <quorem>
10007382:	2234      	movs	r2, #52	; 0x34
10007384:	466b      	mov	r3, sp
10007386:	3030      	adds	r0, #48	; 0x30
10007388:	189b      	adds	r3, r3, r2
1000738a:	900d      	str	r0, [sp, #52]	; 0x34
1000738c:	781b      	ldrb	r3, [r3, #0]
1000738e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
10007390:	702b      	strb	r3, [r5, #0]
10007392:	9b0c      	ldr	r3, [sp, #48]	; 0x30
10007394:	3501      	adds	r5, #1
10007396:	1aeb      	subs	r3, r5, r3
10007398:	4293      	cmp	r3, r2
1000739a:	dbe7      	blt.n	1000736c <_dtoa_r+0xafc>
1000739c:	1e13      	subs	r3, r2, #0
1000739e:	dc00      	bgt.n	100073a2 <_dtoa_r+0xb32>
100073a0:	2301      	movs	r3, #1
100073a2:	9609      	str	r6, [sp, #36]	; 0x24
100073a4:	2600      	movs	r6, #0
100073a6:	9a0c      	ldr	r2, [sp, #48]	; 0x30
100073a8:	18d3      	adds	r3, r2, r3
100073aa:	9304      	str	r3, [sp, #16]
100073ac:	1c21      	adds	r1, r4, #0
100073ae:	9808      	ldr	r0, [sp, #32]
100073b0:	2201      	movs	r2, #1
100073b2:	f000 fc0d 	bl	10007bd0 <__lshift>
100073b6:	1c39      	adds	r1, r7, #0
100073b8:	900a      	str	r0, [sp, #40]	; 0x28
100073ba:	f000 fc5b 	bl	10007c74 <__mcmp>
100073be:	2800      	cmp	r0, #0
100073c0:	dc05      	bgt.n	100073ce <_dtoa_r+0xb5e>
100073c2:	d115      	bne.n	100073f0 <_dtoa_r+0xb80>
100073c4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
100073c6:	07db      	lsls	r3, r3, #31
100073c8:	d401      	bmi.n	100073ce <_dtoa_r+0xb5e>
100073ca:	e011      	b.n	100073f0 <_dtoa_r+0xb80>
100073cc:	9304      	str	r3, [sp, #16]
100073ce:	9b04      	ldr	r3, [sp, #16]
100073d0:	3b01      	subs	r3, #1
100073d2:	781a      	ldrb	r2, [r3, #0]
100073d4:	2a39      	cmp	r2, #57	; 0x39
100073d6:	d108      	bne.n	100073ea <_dtoa_r+0xb7a>
100073d8:	9a0c      	ldr	r2, [sp, #48]	; 0x30
100073da:	4293      	cmp	r3, r2
100073dc:	d1f6      	bne.n	100073cc <_dtoa_r+0xb5c>
100073de:	9b03      	ldr	r3, [sp, #12]
100073e0:	3301      	adds	r3, #1
100073e2:	9303      	str	r3, [sp, #12]
100073e4:	2331      	movs	r3, #49	; 0x31
100073e6:	7013      	strb	r3, [r2, #0]
100073e8:	e009      	b.n	100073fe <_dtoa_r+0xb8e>
100073ea:	3201      	adds	r2, #1
100073ec:	701a      	strb	r2, [r3, #0]
100073ee:	e006      	b.n	100073fe <_dtoa_r+0xb8e>
100073f0:	9b04      	ldr	r3, [sp, #16]
100073f2:	3b01      	subs	r3, #1
100073f4:	781a      	ldrb	r2, [r3, #0]
100073f6:	2a30      	cmp	r2, #48	; 0x30
100073f8:	d101      	bne.n	100073fe <_dtoa_r+0xb8e>
100073fa:	9304      	str	r3, [sp, #16]
100073fc:	e7f8      	b.n	100073f0 <_dtoa_r+0xb80>
100073fe:	9808      	ldr	r0, [sp, #32]
10007400:	1c39      	adds	r1, r7, #0
10007402:	f000 fa5e 	bl	100078c2 <_Bfree>
10007406:	9b09      	ldr	r3, [sp, #36]	; 0x24
10007408:	2b00      	cmp	r3, #0
1000740a:	d00e      	beq.n	1000742a <_dtoa_r+0xbba>
1000740c:	2e00      	cmp	r6, #0
1000740e:	d005      	beq.n	1000741c <_dtoa_r+0xbac>
10007410:	429e      	cmp	r6, r3
10007412:	d003      	beq.n	1000741c <_dtoa_r+0xbac>
10007414:	9808      	ldr	r0, [sp, #32]
10007416:	1c31      	adds	r1, r6, #0
10007418:	f000 fa53 	bl	100078c2 <_Bfree>
1000741c:	9808      	ldr	r0, [sp, #32]
1000741e:	9909      	ldr	r1, [sp, #36]	; 0x24
10007420:	f000 fa4f 	bl	100078c2 <_Bfree>
10007424:	e001      	b.n	1000742a <_dtoa_r+0xbba>
10007426:	9b11      	ldr	r3, [sp, #68]	; 0x44
10007428:	9303      	str	r3, [sp, #12]
1000742a:	9808      	ldr	r0, [sp, #32]
1000742c:	990a      	ldr	r1, [sp, #40]	; 0x28
1000742e:	f000 fa48 	bl	100078c2 <_Bfree>
10007432:	2300      	movs	r3, #0
10007434:	9a04      	ldr	r2, [sp, #16]
10007436:	980c      	ldr	r0, [sp, #48]	; 0x30
10007438:	7013      	strb	r3, [r2, #0]
1000743a:	9b03      	ldr	r3, [sp, #12]
1000743c:	9a22      	ldr	r2, [sp, #136]	; 0x88
1000743e:	3301      	adds	r3, #1
10007440:	6013      	str	r3, [r2, #0]
10007442:	9b24      	ldr	r3, [sp, #144]	; 0x90
10007444:	2b00      	cmp	r3, #0
10007446:	d010      	beq.n	1000746a <_dtoa_r+0xbfa>
10007448:	9a04      	ldr	r2, [sp, #16]
1000744a:	601a      	str	r2, [r3, #0]
1000744c:	e00d      	b.n	1000746a <_dtoa_r+0xbfa>
1000744e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
10007450:	2b00      	cmp	r3, #0
10007452:	dd00      	ble.n	10007456 <_dtoa_r+0xbe6>
10007454:	e6bd      	b.n	100071d2 <_dtoa_r+0x962>
10007456:	9b20      	ldr	r3, [sp, #128]	; 0x80
10007458:	2b02      	cmp	r3, #2
1000745a:	dd00      	ble.n	1000745e <_dtoa_r+0xbee>
1000745c:	e68a      	b.n	10007174 <_dtoa_r+0x904>
1000745e:	e6b8      	b.n	100071d2 <_dtoa_r+0x962>
10007460:	9b20      	ldr	r3, [sp, #128]	; 0x80
10007462:	2b02      	cmp	r3, #2
10007464:	dd00      	ble.n	10007468 <_dtoa_r+0xbf8>
10007466:	e685      	b.n	10007174 <_dtoa_r+0x904>
10007468:	e6b8      	b.n	100071dc <_dtoa_r+0x96c>
1000746a:	b01b      	add	sp, #108	; 0x6c
1000746c:	bdf0      	pop	{r4, r5, r6, r7, pc}
1000746e:	46c0      	nop			; (mov r8, r8)

10007470 <__sflush_r>:
10007470:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
10007472:	898a      	ldrh	r2, [r1, #12]
10007474:	1c05      	adds	r5, r0, #0
10007476:	1c0c      	adds	r4, r1, #0
10007478:	0713      	lsls	r3, r2, #28
1000747a:	d45e      	bmi.n	1000753a <__sflush_r+0xca>
1000747c:	684b      	ldr	r3, [r1, #4]
1000747e:	2b00      	cmp	r3, #0
10007480:	dc02      	bgt.n	10007488 <__sflush_r+0x18>
10007482:	6c0b      	ldr	r3, [r1, #64]	; 0x40
10007484:	2b00      	cmp	r3, #0
10007486:	dd1a      	ble.n	100074be <__sflush_r+0x4e>
10007488:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
1000748a:	2f00      	cmp	r7, #0
1000748c:	d017      	beq.n	100074be <__sflush_r+0x4e>
1000748e:	2300      	movs	r3, #0
10007490:	682e      	ldr	r6, [r5, #0]
10007492:	602b      	str	r3, [r5, #0]
10007494:	2380      	movs	r3, #128	; 0x80
10007496:	015b      	lsls	r3, r3, #5
10007498:	401a      	ands	r2, r3
1000749a:	d001      	beq.n	100074a0 <__sflush_r+0x30>
1000749c:	6d62      	ldr	r2, [r4, #84]	; 0x54
1000749e:	e015      	b.n	100074cc <__sflush_r+0x5c>
100074a0:	1c28      	adds	r0, r5, #0
100074a2:	6a21      	ldr	r1, [r4, #32]
100074a4:	2301      	movs	r3, #1
100074a6:	47b8      	blx	r7
100074a8:	1c02      	adds	r2, r0, #0
100074aa:	1c43      	adds	r3, r0, #1
100074ac:	d10e      	bne.n	100074cc <__sflush_r+0x5c>
100074ae:	682b      	ldr	r3, [r5, #0]
100074b0:	2b00      	cmp	r3, #0
100074b2:	d00b      	beq.n	100074cc <__sflush_r+0x5c>
100074b4:	2b1d      	cmp	r3, #29
100074b6:	d001      	beq.n	100074bc <__sflush_r+0x4c>
100074b8:	2b16      	cmp	r3, #22
100074ba:	d102      	bne.n	100074c2 <__sflush_r+0x52>
100074bc:	602e      	str	r6, [r5, #0]
100074be:	2000      	movs	r0, #0
100074c0:	e05e      	b.n	10007580 <__sflush_r+0x110>
100074c2:	2140      	movs	r1, #64	; 0x40
100074c4:	89a3      	ldrh	r3, [r4, #12]
100074c6:	430b      	orrs	r3, r1
100074c8:	81a3      	strh	r3, [r4, #12]
100074ca:	e059      	b.n	10007580 <__sflush_r+0x110>
100074cc:	89a3      	ldrh	r3, [r4, #12]
100074ce:	075b      	lsls	r3, r3, #29
100074d0:	d506      	bpl.n	100074e0 <__sflush_r+0x70>
100074d2:	6863      	ldr	r3, [r4, #4]
100074d4:	1ad2      	subs	r2, r2, r3
100074d6:	6b63      	ldr	r3, [r4, #52]	; 0x34
100074d8:	2b00      	cmp	r3, #0
100074da:	d001      	beq.n	100074e0 <__sflush_r+0x70>
100074dc:	6c23      	ldr	r3, [r4, #64]	; 0x40
100074de:	1ad2      	subs	r2, r2, r3
100074e0:	2300      	movs	r3, #0
100074e2:	1c28      	adds	r0, r5, #0
100074e4:	6a21      	ldr	r1, [r4, #32]
100074e6:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
100074e8:	47b8      	blx	r7
100074ea:	89a3      	ldrh	r3, [r4, #12]
100074ec:	1c42      	adds	r2, r0, #1
100074ee:	d106      	bne.n	100074fe <__sflush_r+0x8e>
100074f0:	682a      	ldr	r2, [r5, #0]
100074f2:	2a00      	cmp	r2, #0
100074f4:	d003      	beq.n	100074fe <__sflush_r+0x8e>
100074f6:	2a1d      	cmp	r2, #29
100074f8:	d001      	beq.n	100074fe <__sflush_r+0x8e>
100074fa:	2a16      	cmp	r2, #22
100074fc:	d119      	bne.n	10007532 <__sflush_r+0xc2>
100074fe:	2200      	movs	r2, #0
10007500:	6062      	str	r2, [r4, #4]
10007502:	6922      	ldr	r2, [r4, #16]
10007504:	6022      	str	r2, [r4, #0]
10007506:	04db      	lsls	r3, r3, #19
10007508:	d505      	bpl.n	10007516 <__sflush_r+0xa6>
1000750a:	1c43      	adds	r3, r0, #1
1000750c:	d102      	bne.n	10007514 <__sflush_r+0xa4>
1000750e:	682b      	ldr	r3, [r5, #0]
10007510:	2b00      	cmp	r3, #0
10007512:	d100      	bne.n	10007516 <__sflush_r+0xa6>
10007514:	6560      	str	r0, [r4, #84]	; 0x54
10007516:	6b61      	ldr	r1, [r4, #52]	; 0x34
10007518:	602e      	str	r6, [r5, #0]
1000751a:	2900      	cmp	r1, #0
1000751c:	d0cf      	beq.n	100074be <__sflush_r+0x4e>
1000751e:	1c23      	adds	r3, r4, #0
10007520:	3344      	adds	r3, #68	; 0x44
10007522:	4299      	cmp	r1, r3
10007524:	d002      	beq.n	1000752c <__sflush_r+0xbc>
10007526:	1c28      	adds	r0, r5, #0
10007528:	f7fe fa72 	bl	10005a10 <_free_r>
1000752c:	2000      	movs	r0, #0
1000752e:	6360      	str	r0, [r4, #52]	; 0x34
10007530:	e026      	b.n	10007580 <__sflush_r+0x110>
10007532:	2240      	movs	r2, #64	; 0x40
10007534:	4313      	orrs	r3, r2
10007536:	81a3      	strh	r3, [r4, #12]
10007538:	e022      	b.n	10007580 <__sflush_r+0x110>
1000753a:	690f      	ldr	r7, [r1, #16]
1000753c:	2f00      	cmp	r7, #0
1000753e:	d0be      	beq.n	100074be <__sflush_r+0x4e>
10007540:	680b      	ldr	r3, [r1, #0]
10007542:	600f      	str	r7, [r1, #0]
10007544:	1bdb      	subs	r3, r3, r7
10007546:	9301      	str	r3, [sp, #4]
10007548:	2300      	movs	r3, #0
1000754a:	0792      	lsls	r2, r2, #30
1000754c:	d100      	bne.n	10007550 <__sflush_r+0xe0>
1000754e:	694b      	ldr	r3, [r1, #20]
10007550:	60a3      	str	r3, [r4, #8]
10007552:	9b01      	ldr	r3, [sp, #4]
10007554:	2b00      	cmp	r3, #0
10007556:	ddb2      	ble.n	100074be <__sflush_r+0x4e>
10007558:	1c28      	adds	r0, r5, #0
1000755a:	6a21      	ldr	r1, [r4, #32]
1000755c:	1c3a      	adds	r2, r7, #0
1000755e:	9b01      	ldr	r3, [sp, #4]
10007560:	6aa6      	ldr	r6, [r4, #40]	; 0x28
10007562:	47b0      	blx	r6
10007564:	2800      	cmp	r0, #0
10007566:	dc06      	bgt.n	10007576 <__sflush_r+0x106>
10007568:	2240      	movs	r2, #64	; 0x40
1000756a:	2001      	movs	r0, #1
1000756c:	89a3      	ldrh	r3, [r4, #12]
1000756e:	4240      	negs	r0, r0
10007570:	4313      	orrs	r3, r2
10007572:	81a3      	strh	r3, [r4, #12]
10007574:	e004      	b.n	10007580 <__sflush_r+0x110>
10007576:	9b01      	ldr	r3, [sp, #4]
10007578:	183f      	adds	r7, r7, r0
1000757a:	1a1b      	subs	r3, r3, r0
1000757c:	9301      	str	r3, [sp, #4]
1000757e:	e7e8      	b.n	10007552 <__sflush_r+0xe2>
10007580:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	...

10007584 <_fflush_r>:
10007584:	b538      	push	{r3, r4, r5, lr}
10007586:	690b      	ldr	r3, [r1, #16]
10007588:	1c05      	adds	r5, r0, #0
1000758a:	1c0c      	adds	r4, r1, #0
1000758c:	2b00      	cmp	r3, #0
1000758e:	d101      	bne.n	10007594 <_fflush_r+0x10>
10007590:	2000      	movs	r0, #0
10007592:	e01c      	b.n	100075ce <_fflush_r+0x4a>
10007594:	2800      	cmp	r0, #0
10007596:	d004      	beq.n	100075a2 <_fflush_r+0x1e>
10007598:	6983      	ldr	r3, [r0, #24]
1000759a:	2b00      	cmp	r3, #0
1000759c:	d101      	bne.n	100075a2 <_fflush_r+0x1e>
1000759e:	f000 f85f 	bl	10007660 <__sinit>
100075a2:	4b0b      	ldr	r3, [pc, #44]	; (100075d0 <_fflush_r+0x4c>)
100075a4:	429c      	cmp	r4, r3
100075a6:	d101      	bne.n	100075ac <_fflush_r+0x28>
100075a8:	686c      	ldr	r4, [r5, #4]
100075aa:	e008      	b.n	100075be <_fflush_r+0x3a>
100075ac:	4b09      	ldr	r3, [pc, #36]	; (100075d4 <_fflush_r+0x50>)
100075ae:	429c      	cmp	r4, r3
100075b0:	d101      	bne.n	100075b6 <_fflush_r+0x32>
100075b2:	68ac      	ldr	r4, [r5, #8]
100075b4:	e003      	b.n	100075be <_fflush_r+0x3a>
100075b6:	4b08      	ldr	r3, [pc, #32]	; (100075d8 <_fflush_r+0x54>)
100075b8:	429c      	cmp	r4, r3
100075ba:	d100      	bne.n	100075be <_fflush_r+0x3a>
100075bc:	68ec      	ldr	r4, [r5, #12]
100075be:	220c      	movs	r2, #12
100075c0:	5ea3      	ldrsh	r3, [r4, r2]
100075c2:	2b00      	cmp	r3, #0
100075c4:	d0e4      	beq.n	10007590 <_fflush_r+0xc>
100075c6:	1c28      	adds	r0, r5, #0
100075c8:	1c21      	adds	r1, r4, #0
100075ca:	f7ff ff51 	bl	10007470 <__sflush_r>
100075ce:	bd38      	pop	{r3, r4, r5, pc}
100075d0:	1000a7f4 	.word	0x1000a7f4
100075d4:	1000a814 	.word	0x1000a814
100075d8:	1000a834 	.word	0x1000a834

100075dc <_cleanup_r>:
100075dc:	b508      	push	{r3, lr}
100075de:	4902      	ldr	r1, [pc, #8]	; (100075e8 <_cleanup_r+0xc>)
100075e0:	f000 f8ae 	bl	10007740 <_fwalk_reent>
100075e4:	bd08      	pop	{r3, pc}
100075e6:	46c0      	nop			; (mov r8, r8)
100075e8:	10007585 	.word	0x10007585

100075ec <std.isra.0>:
100075ec:	2300      	movs	r3, #0
100075ee:	b510      	push	{r4, lr}
100075f0:	1c04      	adds	r4, r0, #0
100075f2:	6003      	str	r3, [r0, #0]
100075f4:	6043      	str	r3, [r0, #4]
100075f6:	6083      	str	r3, [r0, #8]
100075f8:	8181      	strh	r1, [r0, #12]
100075fa:	6643      	str	r3, [r0, #100]	; 0x64
100075fc:	81c2      	strh	r2, [r0, #14]
100075fe:	6103      	str	r3, [r0, #16]
10007600:	6143      	str	r3, [r0, #20]
10007602:	6183      	str	r3, [r0, #24]
10007604:	1c19      	adds	r1, r3, #0
10007606:	2208      	movs	r2, #8
10007608:	305c      	adds	r0, #92	; 0x5c
1000760a:	f7fe f9f8 	bl	100059fe <memset>
1000760e:	4b05      	ldr	r3, [pc, #20]	; (10007624 <std.isra.0+0x38>)
10007610:	6224      	str	r4, [r4, #32]
10007612:	6263      	str	r3, [r4, #36]	; 0x24
10007614:	4b04      	ldr	r3, [pc, #16]	; (10007628 <std.isra.0+0x3c>)
10007616:	62a3      	str	r3, [r4, #40]	; 0x28
10007618:	4b04      	ldr	r3, [pc, #16]	; (1000762c <std.isra.0+0x40>)
1000761a:	62e3      	str	r3, [r4, #44]	; 0x2c
1000761c:	4b04      	ldr	r3, [pc, #16]	; (10007630 <std.isra.0+0x44>)
1000761e:	6323      	str	r3, [r4, #48]	; 0x30
10007620:	bd10      	pop	{r4, pc}
10007622:	46c0      	nop			; (mov r8, r8)
10007624:	10008361 	.word	0x10008361
10007628:	10008389 	.word	0x10008389
1000762c:	100083c1 	.word	0x100083c1
10007630:	100083ed 	.word	0x100083ed

10007634 <__sfmoreglue>:
10007634:	b570      	push	{r4, r5, r6, lr}
10007636:	2568      	movs	r5, #104	; 0x68
10007638:	1e4b      	subs	r3, r1, #1
1000763a:	435d      	muls	r5, r3
1000763c:	1c0e      	adds	r6, r1, #0
1000763e:	1c29      	adds	r1, r5, #0
10007640:	3174      	adds	r1, #116	; 0x74
10007642:	f7fe fa2b 	bl	10005a9c <_malloc_r>
10007646:	1e04      	subs	r4, r0, #0
10007648:	d008      	beq.n	1000765c <__sfmoreglue+0x28>
1000764a:	2100      	movs	r1, #0
1000764c:	1c2a      	adds	r2, r5, #0
1000764e:	6001      	str	r1, [r0, #0]
10007650:	6046      	str	r6, [r0, #4]
10007652:	300c      	adds	r0, #12
10007654:	60a0      	str	r0, [r4, #8]
10007656:	3268      	adds	r2, #104	; 0x68
10007658:	f7fe f9d1 	bl	100059fe <memset>
1000765c:	1c20      	adds	r0, r4, #0
1000765e:	bd70      	pop	{r4, r5, r6, pc}

10007660 <__sinit>:
10007660:	6983      	ldr	r3, [r0, #24]
10007662:	b513      	push	{r0, r1, r4, lr}
10007664:	2b00      	cmp	r3, #0
10007666:	d128      	bne.n	100076ba <__sinit+0x5a>
10007668:	6483      	str	r3, [r0, #72]	; 0x48
1000766a:	64c3      	str	r3, [r0, #76]	; 0x4c
1000766c:	6503      	str	r3, [r0, #80]	; 0x50
1000766e:	4b13      	ldr	r3, [pc, #76]	; (100076bc <__sinit+0x5c>)
10007670:	4a13      	ldr	r2, [pc, #76]	; (100076c0 <__sinit+0x60>)
10007672:	681b      	ldr	r3, [r3, #0]
10007674:	6282      	str	r2, [r0, #40]	; 0x28
10007676:	9301      	str	r3, [sp, #4]
10007678:	4298      	cmp	r0, r3
1000767a:	d101      	bne.n	10007680 <__sinit+0x20>
1000767c:	2301      	movs	r3, #1
1000767e:	6183      	str	r3, [r0, #24]
10007680:	1c04      	adds	r4, r0, #0
10007682:	f000 f81f 	bl	100076c4 <__sfp>
10007686:	6060      	str	r0, [r4, #4]
10007688:	1c20      	adds	r0, r4, #0
1000768a:	f000 f81b 	bl	100076c4 <__sfp>
1000768e:	60a0      	str	r0, [r4, #8]
10007690:	1c20      	adds	r0, r4, #0
10007692:	f000 f817 	bl	100076c4 <__sfp>
10007696:	2104      	movs	r1, #4
10007698:	60e0      	str	r0, [r4, #12]
1000769a:	2200      	movs	r2, #0
1000769c:	6860      	ldr	r0, [r4, #4]
1000769e:	f7ff ffa5 	bl	100075ec <std.isra.0>
100076a2:	68a0      	ldr	r0, [r4, #8]
100076a4:	2109      	movs	r1, #9
100076a6:	2201      	movs	r2, #1
100076a8:	f7ff ffa0 	bl	100075ec <std.isra.0>
100076ac:	68e0      	ldr	r0, [r4, #12]
100076ae:	2112      	movs	r1, #18
100076b0:	2202      	movs	r2, #2
100076b2:	f7ff ff9b 	bl	100075ec <std.isra.0>
100076b6:	2301      	movs	r3, #1
100076b8:	61a3      	str	r3, [r4, #24]
100076ba:	bd13      	pop	{r0, r1, r4, pc}
100076bc:	1000a7ac 	.word	0x1000a7ac
100076c0:	100075dd 	.word	0x100075dd

100076c4 <__sfp>:
100076c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
100076c6:	4b1d      	ldr	r3, [pc, #116]	; (1000773c <__sfp+0x78>)
100076c8:	1c06      	adds	r6, r0, #0
100076ca:	681d      	ldr	r5, [r3, #0]
100076cc:	69ab      	ldr	r3, [r5, #24]
100076ce:	2b00      	cmp	r3, #0
100076d0:	d102      	bne.n	100076d8 <__sfp+0x14>
100076d2:	1c28      	adds	r0, r5, #0
100076d4:	f7ff ffc4 	bl	10007660 <__sinit>
100076d8:	3548      	adds	r5, #72	; 0x48
100076da:	68ac      	ldr	r4, [r5, #8]
100076dc:	686b      	ldr	r3, [r5, #4]
100076de:	3b01      	subs	r3, #1
100076e0:	d405      	bmi.n	100076ee <__sfp+0x2a>
100076e2:	220c      	movs	r2, #12
100076e4:	5ea7      	ldrsh	r7, [r4, r2]
100076e6:	2f00      	cmp	r7, #0
100076e8:	d010      	beq.n	1000770c <__sfp+0x48>
100076ea:	3468      	adds	r4, #104	; 0x68
100076ec:	e7f7      	b.n	100076de <__sfp+0x1a>
100076ee:	682b      	ldr	r3, [r5, #0]
100076f0:	2b00      	cmp	r3, #0
100076f2:	d106      	bne.n	10007702 <__sfp+0x3e>
100076f4:	1c30      	adds	r0, r6, #0
100076f6:	2104      	movs	r1, #4
100076f8:	f7ff ff9c 	bl	10007634 <__sfmoreglue>
100076fc:	6028      	str	r0, [r5, #0]
100076fe:	2800      	cmp	r0, #0
10007700:	d001      	beq.n	10007706 <__sfp+0x42>
10007702:	682d      	ldr	r5, [r5, #0]
10007704:	e7e9      	b.n	100076da <__sfp+0x16>
10007706:	230c      	movs	r3, #12
10007708:	6033      	str	r3, [r6, #0]
1000770a:	e016      	b.n	1000773a <__sfp+0x76>
1000770c:	2301      	movs	r3, #1
1000770e:	1c20      	adds	r0, r4, #0
10007710:	425b      	negs	r3, r3
10007712:	81e3      	strh	r3, [r4, #14]
10007714:	3302      	adds	r3, #2
10007716:	81a3      	strh	r3, [r4, #12]
10007718:	6667      	str	r7, [r4, #100]	; 0x64
1000771a:	6027      	str	r7, [r4, #0]
1000771c:	60a7      	str	r7, [r4, #8]
1000771e:	6067      	str	r7, [r4, #4]
10007720:	6127      	str	r7, [r4, #16]
10007722:	6167      	str	r7, [r4, #20]
10007724:	61a7      	str	r7, [r4, #24]
10007726:	305c      	adds	r0, #92	; 0x5c
10007728:	1c39      	adds	r1, r7, #0
1000772a:	2208      	movs	r2, #8
1000772c:	f7fe f967 	bl	100059fe <memset>
10007730:	1c20      	adds	r0, r4, #0
10007732:	6367      	str	r7, [r4, #52]	; 0x34
10007734:	63a7      	str	r7, [r4, #56]	; 0x38
10007736:	64a7      	str	r7, [r4, #72]	; 0x48
10007738:	64e7      	str	r7, [r4, #76]	; 0x4c
1000773a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
1000773c:	1000a7ac 	.word	0x1000a7ac

10007740 <_fwalk_reent>:
10007740:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
10007742:	1c04      	adds	r4, r0, #0
10007744:	1c07      	adds	r7, r0, #0
10007746:	2600      	movs	r6, #0
10007748:	9101      	str	r1, [sp, #4]
1000774a:	3448      	adds	r4, #72	; 0x48
1000774c:	2c00      	cmp	r4, #0
1000774e:	d016      	beq.n	1000777e <_fwalk_reent+0x3e>
10007750:	6863      	ldr	r3, [r4, #4]
10007752:	68a5      	ldr	r5, [r4, #8]
10007754:	9300      	str	r3, [sp, #0]
10007756:	9b00      	ldr	r3, [sp, #0]
10007758:	3b01      	subs	r3, #1
1000775a:	9300      	str	r3, [sp, #0]
1000775c:	d40d      	bmi.n	1000777a <_fwalk_reent+0x3a>
1000775e:	89ab      	ldrh	r3, [r5, #12]
10007760:	2b01      	cmp	r3, #1
10007762:	d908      	bls.n	10007776 <_fwalk_reent+0x36>
10007764:	220e      	movs	r2, #14
10007766:	5eab      	ldrsh	r3, [r5, r2]
10007768:	3301      	adds	r3, #1
1000776a:	d004      	beq.n	10007776 <_fwalk_reent+0x36>
1000776c:	1c38      	adds	r0, r7, #0
1000776e:	1c29      	adds	r1, r5, #0
10007770:	9b01      	ldr	r3, [sp, #4]
10007772:	4798      	blx	r3
10007774:	4306      	orrs	r6, r0
10007776:	3568      	adds	r5, #104	; 0x68
10007778:	e7ed      	b.n	10007756 <_fwalk_reent+0x16>
1000777a:	6824      	ldr	r4, [r4, #0]
1000777c:	e7e6      	b.n	1000774c <_fwalk_reent+0xc>
1000777e:	1c30      	adds	r0, r6, #0
10007780:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	...

10007784 <_localeconv_r>:
10007784:	4800      	ldr	r0, [pc, #0]	; (10007788 <_localeconv_r+0x4>)
10007786:	4770      	bx	lr
10007788:	20000668 	.word	0x20000668

1000778c <__smakebuf_r>:
1000778c:	b5f0      	push	{r4, r5, r6, r7, lr}
1000778e:	898b      	ldrh	r3, [r1, #12]
10007790:	b091      	sub	sp, #68	; 0x44
10007792:	079b      	lsls	r3, r3, #30
10007794:	d506      	bpl.n	100077a4 <__smakebuf_r+0x18>
10007796:	1c0b      	adds	r3, r1, #0
10007798:	3347      	adds	r3, #71	; 0x47
1000779a:	600b      	str	r3, [r1, #0]
1000779c:	610b      	str	r3, [r1, #16]
1000779e:	2301      	movs	r3, #1
100077a0:	614b      	str	r3, [r1, #20]
100077a2:	e045      	b.n	10007830 <__smakebuf_r+0xa4>
100077a4:	1c0c      	adds	r4, r1, #0
100077a6:	230e      	movs	r3, #14
100077a8:	5ec9      	ldrsh	r1, [r1, r3]
100077aa:	1c06      	adds	r6, r0, #0
100077ac:	2900      	cmp	r1, #0
100077ae:	da04      	bge.n	100077ba <__smakebuf_r+0x2e>
100077b0:	2380      	movs	r3, #128	; 0x80
100077b2:	89a5      	ldrh	r5, [r4, #12]
100077b4:	401d      	ands	r5, r3
100077b6:	d110      	bne.n	100077da <__smakebuf_r+0x4e>
100077b8:	e00c      	b.n	100077d4 <__smakebuf_r+0x48>
100077ba:	aa01      	add	r2, sp, #4
100077bc:	f000 fe42 	bl	10008444 <_fstat_r>
100077c0:	2800      	cmp	r0, #0
100077c2:	dbf5      	blt.n	100077b0 <__smakebuf_r+0x24>
100077c4:	23f0      	movs	r3, #240	; 0xf0
100077c6:	9d02      	ldr	r5, [sp, #8]
100077c8:	021b      	lsls	r3, r3, #8
100077ca:	401d      	ands	r5, r3
100077cc:	4b19      	ldr	r3, [pc, #100]	; (10007834 <__smakebuf_r+0xa8>)
100077ce:	18ed      	adds	r5, r5, r3
100077d0:	426b      	negs	r3, r5
100077d2:	415d      	adcs	r5, r3
100077d4:	2780      	movs	r7, #128	; 0x80
100077d6:	00ff      	lsls	r7, r7, #3
100077d8:	e001      	b.n	100077de <__smakebuf_r+0x52>
100077da:	2500      	movs	r5, #0
100077dc:	2740      	movs	r7, #64	; 0x40
100077de:	1c30      	adds	r0, r6, #0
100077e0:	1c39      	adds	r1, r7, #0
100077e2:	f7fe f95b 	bl	10005a9c <_malloc_r>
100077e6:	2800      	cmp	r0, #0
100077e8:	d10c      	bne.n	10007804 <__smakebuf_r+0x78>
100077ea:	89a3      	ldrh	r3, [r4, #12]
100077ec:	059a      	lsls	r2, r3, #22
100077ee:	d41f      	bmi.n	10007830 <__smakebuf_r+0xa4>
100077f0:	2202      	movs	r2, #2
100077f2:	4313      	orrs	r3, r2
100077f4:	81a3      	strh	r3, [r4, #12]
100077f6:	1c23      	adds	r3, r4, #0
100077f8:	3347      	adds	r3, #71	; 0x47
100077fa:	6023      	str	r3, [r4, #0]
100077fc:	6123      	str	r3, [r4, #16]
100077fe:	2301      	movs	r3, #1
10007800:	6163      	str	r3, [r4, #20]
10007802:	e015      	b.n	10007830 <__smakebuf_r+0xa4>
10007804:	2280      	movs	r2, #128	; 0x80
10007806:	4b0c      	ldr	r3, [pc, #48]	; (10007838 <__smakebuf_r+0xac>)
10007808:	62b3      	str	r3, [r6, #40]	; 0x28
1000780a:	89a3      	ldrh	r3, [r4, #12]
1000780c:	6020      	str	r0, [r4, #0]
1000780e:	4313      	orrs	r3, r2
10007810:	81a3      	strh	r3, [r4, #12]
10007812:	6120      	str	r0, [r4, #16]
10007814:	6167      	str	r7, [r4, #20]
10007816:	2d00      	cmp	r5, #0
10007818:	d00a      	beq.n	10007830 <__smakebuf_r+0xa4>
1000781a:	230e      	movs	r3, #14
1000781c:	5ee1      	ldrsh	r1, [r4, r3]
1000781e:	1c30      	adds	r0, r6, #0
10007820:	f000 fe22 	bl	10008468 <_isatty_r>
10007824:	2800      	cmp	r0, #0
10007826:	d003      	beq.n	10007830 <__smakebuf_r+0xa4>
10007828:	2201      	movs	r2, #1
1000782a:	89a3      	ldrh	r3, [r4, #12]
1000782c:	4313      	orrs	r3, r2
1000782e:	81a3      	strh	r3, [r4, #12]
10007830:	b011      	add	sp, #68	; 0x44
10007832:	bdf0      	pop	{r4, r5, r6, r7, pc}
10007834:	ffffe000 	.word	0xffffe000
10007838:	100075dd 	.word	0x100075dd

1000783c <memchr>:
1000783c:	b2c9      	uxtb	r1, r1
1000783e:	1882      	adds	r2, r0, r2
10007840:	4290      	cmp	r0, r2
10007842:	d004      	beq.n	1000784e <memchr+0x12>
10007844:	7803      	ldrb	r3, [r0, #0]
10007846:	428b      	cmp	r3, r1
10007848:	d002      	beq.n	10007850 <memchr+0x14>
1000784a:	3001      	adds	r0, #1
1000784c:	e7f8      	b.n	10007840 <memchr+0x4>
1000784e:	2000      	movs	r0, #0
10007850:	4770      	bx	lr

10007852 <_Balloc>:
10007852:	b570      	push	{r4, r5, r6, lr}
10007854:	6a46      	ldr	r6, [r0, #36]	; 0x24
10007856:	1c04      	adds	r4, r0, #0
10007858:	1c0d      	adds	r5, r1, #0
1000785a:	2e00      	cmp	r6, #0
1000785c:	d107      	bne.n	1000786e <_Balloc+0x1c>
1000785e:	2010      	movs	r0, #16
10007860:	f7fe f8b0 	bl	100059c4 <malloc>
10007864:	6260      	str	r0, [r4, #36]	; 0x24
10007866:	6046      	str	r6, [r0, #4]
10007868:	6086      	str	r6, [r0, #8]
1000786a:	6006      	str	r6, [r0, #0]
1000786c:	60c6      	str	r6, [r0, #12]
1000786e:	6a66      	ldr	r6, [r4, #36]	; 0x24
10007870:	68f3      	ldr	r3, [r6, #12]
10007872:	2b00      	cmp	r3, #0
10007874:	d009      	beq.n	1000788a <_Balloc+0x38>
10007876:	6a62      	ldr	r2, [r4, #36]	; 0x24
10007878:	00ab      	lsls	r3, r5, #2
1000787a:	68d2      	ldr	r2, [r2, #12]
1000787c:	18d3      	adds	r3, r2, r3
1000787e:	6818      	ldr	r0, [r3, #0]
10007880:	2800      	cmp	r0, #0
10007882:	d00e      	beq.n	100078a2 <_Balloc+0x50>
10007884:	6802      	ldr	r2, [r0, #0]
10007886:	601a      	str	r2, [r3, #0]
10007888:	e017      	b.n	100078ba <_Balloc+0x68>
1000788a:	1c20      	adds	r0, r4, #0
1000788c:	2104      	movs	r1, #4
1000788e:	2221      	movs	r2, #33	; 0x21
10007890:	f000 faca 	bl	10007e28 <_calloc_r>
10007894:	6a63      	ldr	r3, [r4, #36]	; 0x24
10007896:	60f0      	str	r0, [r6, #12]
10007898:	68db      	ldr	r3, [r3, #12]
1000789a:	2b00      	cmp	r3, #0
1000789c:	d1eb      	bne.n	10007876 <_Balloc+0x24>
1000789e:	2000      	movs	r0, #0
100078a0:	e00e      	b.n	100078c0 <_Balloc+0x6e>
100078a2:	2101      	movs	r1, #1
100078a4:	1c0e      	adds	r6, r1, #0
100078a6:	40ae      	lsls	r6, r5
100078a8:	1d72      	adds	r2, r6, #5
100078aa:	0092      	lsls	r2, r2, #2
100078ac:	1c20      	adds	r0, r4, #0
100078ae:	f000 fabb 	bl	10007e28 <_calloc_r>
100078b2:	2800      	cmp	r0, #0
100078b4:	d0f3      	beq.n	1000789e <_Balloc+0x4c>
100078b6:	6045      	str	r5, [r0, #4]
100078b8:	6086      	str	r6, [r0, #8]
100078ba:	2300      	movs	r3, #0
100078bc:	6103      	str	r3, [r0, #16]
100078be:	60c3      	str	r3, [r0, #12]
100078c0:	bd70      	pop	{r4, r5, r6, pc}

100078c2 <_Bfree>:
100078c2:	b570      	push	{r4, r5, r6, lr}
100078c4:	6a45      	ldr	r5, [r0, #36]	; 0x24
100078c6:	1c06      	adds	r6, r0, #0
100078c8:	1c0c      	adds	r4, r1, #0
100078ca:	2d00      	cmp	r5, #0
100078cc:	d107      	bne.n	100078de <_Bfree+0x1c>
100078ce:	2010      	movs	r0, #16
100078d0:	f7fe f878 	bl	100059c4 <malloc>
100078d4:	6270      	str	r0, [r6, #36]	; 0x24
100078d6:	6045      	str	r5, [r0, #4]
100078d8:	6085      	str	r5, [r0, #8]
100078da:	6005      	str	r5, [r0, #0]
100078dc:	60c5      	str	r5, [r0, #12]
100078de:	2c00      	cmp	r4, #0
100078e0:	d007      	beq.n	100078f2 <_Bfree+0x30>
100078e2:	6a72      	ldr	r2, [r6, #36]	; 0x24
100078e4:	6863      	ldr	r3, [r4, #4]
100078e6:	68d2      	ldr	r2, [r2, #12]
100078e8:	009b      	lsls	r3, r3, #2
100078ea:	18d3      	adds	r3, r2, r3
100078ec:	681a      	ldr	r2, [r3, #0]
100078ee:	6022      	str	r2, [r4, #0]
100078f0:	601c      	str	r4, [r3, #0]
100078f2:	bd70      	pop	{r4, r5, r6, pc}

100078f4 <__multadd>:
100078f4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
100078f6:	1c1e      	adds	r6, r3, #0
100078f8:	2314      	movs	r3, #20
100078fa:	469c      	mov	ip, r3
100078fc:	1c07      	adds	r7, r0, #0
100078fe:	1c0c      	adds	r4, r1, #0
10007900:	2000      	movs	r0, #0
10007902:	690d      	ldr	r5, [r1, #16]
10007904:	448c      	add	ip, r1
10007906:	4663      	mov	r3, ip
10007908:	8819      	ldrh	r1, [r3, #0]
1000790a:	681b      	ldr	r3, [r3, #0]
1000790c:	4351      	muls	r1, r2
1000790e:	0c1b      	lsrs	r3, r3, #16
10007910:	4353      	muls	r3, r2
10007912:	1989      	adds	r1, r1, r6
10007914:	0c0e      	lsrs	r6, r1, #16
10007916:	18f3      	adds	r3, r6, r3
10007918:	b289      	uxth	r1, r1
1000791a:	0c1e      	lsrs	r6, r3, #16
1000791c:	041b      	lsls	r3, r3, #16
1000791e:	185b      	adds	r3, r3, r1
10007920:	4661      	mov	r1, ip
10007922:	3001      	adds	r0, #1
10007924:	c108      	stmia	r1!, {r3}
10007926:	468c      	mov	ip, r1
10007928:	42a8      	cmp	r0, r5
1000792a:	dbec      	blt.n	10007906 <__multadd+0x12>
1000792c:	2e00      	cmp	r6, #0
1000792e:	d01b      	beq.n	10007968 <__multadd+0x74>
10007930:	68a3      	ldr	r3, [r4, #8]
10007932:	429d      	cmp	r5, r3
10007934:	db12      	blt.n	1000795c <__multadd+0x68>
10007936:	6863      	ldr	r3, [r4, #4]
10007938:	1c38      	adds	r0, r7, #0
1000793a:	1c59      	adds	r1, r3, #1
1000793c:	f7ff ff89 	bl	10007852 <_Balloc>
10007940:	1c21      	adds	r1, r4, #0
10007942:	6923      	ldr	r3, [r4, #16]
10007944:	9001      	str	r0, [sp, #4]
10007946:	1c9a      	adds	r2, r3, #2
10007948:	310c      	adds	r1, #12
1000794a:	0092      	lsls	r2, r2, #2
1000794c:	300c      	adds	r0, #12
1000794e:	f7fe f84d 	bl	100059ec <memcpy>
10007952:	1c21      	adds	r1, r4, #0
10007954:	1c38      	adds	r0, r7, #0
10007956:	f7ff ffb4 	bl	100078c2 <_Bfree>
1000795a:	9c01      	ldr	r4, [sp, #4]
1000795c:	1d2b      	adds	r3, r5, #4
1000795e:	009b      	lsls	r3, r3, #2
10007960:	18e3      	adds	r3, r4, r3
10007962:	3501      	adds	r5, #1
10007964:	605e      	str	r6, [r3, #4]
10007966:	6125      	str	r5, [r4, #16]
10007968:	1c20      	adds	r0, r4, #0
1000796a:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

1000796c <__hi0bits>:
1000796c:	2200      	movs	r2, #0
1000796e:	1c03      	adds	r3, r0, #0
10007970:	0c01      	lsrs	r1, r0, #16
10007972:	4291      	cmp	r1, r2
10007974:	d101      	bne.n	1000797a <__hi0bits+0xe>
10007976:	0403      	lsls	r3, r0, #16
10007978:	3210      	adds	r2, #16
1000797a:	0e19      	lsrs	r1, r3, #24
1000797c:	d101      	bne.n	10007982 <__hi0bits+0x16>
1000797e:	3208      	adds	r2, #8
10007980:	021b      	lsls	r3, r3, #8
10007982:	0f19      	lsrs	r1, r3, #28
10007984:	d101      	bne.n	1000798a <__hi0bits+0x1e>
10007986:	3204      	adds	r2, #4
10007988:	011b      	lsls	r3, r3, #4
1000798a:	0f99      	lsrs	r1, r3, #30
1000798c:	d101      	bne.n	10007992 <__hi0bits+0x26>
1000798e:	3202      	adds	r2, #2
10007990:	009b      	lsls	r3, r3, #2
10007992:	1c10      	adds	r0, r2, #0
10007994:	2b00      	cmp	r3, #0
10007996:	db03      	blt.n	100079a0 <__hi0bits+0x34>
10007998:	2020      	movs	r0, #32
1000799a:	005b      	lsls	r3, r3, #1
1000799c:	d500      	bpl.n	100079a0 <__hi0bits+0x34>
1000799e:	1c50      	adds	r0, r2, #1
100079a0:	4770      	bx	lr

100079a2 <__lo0bits>:
100079a2:	2207      	movs	r2, #7
100079a4:	6803      	ldr	r3, [r0, #0]
100079a6:	b510      	push	{r4, lr}
100079a8:	1c01      	adds	r1, r0, #0
100079aa:	401a      	ands	r2, r3
100079ac:	d00c      	beq.n	100079c8 <__lo0bits+0x26>
100079ae:	2401      	movs	r4, #1
100079b0:	2000      	movs	r0, #0
100079b2:	4223      	tst	r3, r4
100079b4:	d123      	bne.n	100079fe <__lo0bits+0x5c>
100079b6:	2202      	movs	r2, #2
100079b8:	4213      	tst	r3, r2
100079ba:	d003      	beq.n	100079c4 <__lo0bits+0x22>
100079bc:	40e3      	lsrs	r3, r4
100079be:	1c20      	adds	r0, r4, #0
100079c0:	600b      	str	r3, [r1, #0]
100079c2:	e01c      	b.n	100079fe <__lo0bits+0x5c>
100079c4:	089b      	lsrs	r3, r3, #2
100079c6:	e018      	b.n	100079fa <__lo0bits+0x58>
100079c8:	b298      	uxth	r0, r3
100079ca:	2800      	cmp	r0, #0
100079cc:	d101      	bne.n	100079d2 <__lo0bits+0x30>
100079ce:	2210      	movs	r2, #16
100079d0:	0c1b      	lsrs	r3, r3, #16
100079d2:	b2d8      	uxtb	r0, r3
100079d4:	2800      	cmp	r0, #0
100079d6:	d101      	bne.n	100079dc <__lo0bits+0x3a>
100079d8:	3208      	adds	r2, #8
100079da:	0a1b      	lsrs	r3, r3, #8
100079dc:	0718      	lsls	r0, r3, #28
100079de:	d101      	bne.n	100079e4 <__lo0bits+0x42>
100079e0:	3204      	adds	r2, #4
100079e2:	091b      	lsrs	r3, r3, #4
100079e4:	0798      	lsls	r0, r3, #30
100079e6:	d101      	bne.n	100079ec <__lo0bits+0x4a>
100079e8:	3202      	adds	r2, #2
100079ea:	089b      	lsrs	r3, r3, #2
100079ec:	07d8      	lsls	r0, r3, #31
100079ee:	d404      	bmi.n	100079fa <__lo0bits+0x58>
100079f0:	085b      	lsrs	r3, r3, #1
100079f2:	2020      	movs	r0, #32
100079f4:	2b00      	cmp	r3, #0
100079f6:	d002      	beq.n	100079fe <__lo0bits+0x5c>
100079f8:	3201      	adds	r2, #1
100079fa:	1c10      	adds	r0, r2, #0
100079fc:	600b      	str	r3, [r1, #0]
100079fe:	bd10      	pop	{r4, pc}

10007a00 <__i2b>:
10007a00:	b510      	push	{r4, lr}
10007a02:	1c0c      	adds	r4, r1, #0
10007a04:	2101      	movs	r1, #1
10007a06:	f7ff ff24 	bl	10007852 <_Balloc>
10007a0a:	2301      	movs	r3, #1
10007a0c:	6144      	str	r4, [r0, #20]
10007a0e:	6103      	str	r3, [r0, #16]
10007a10:	bd10      	pop	{r4, pc}

10007a12 <__multiply>:
10007a12:	b5f0      	push	{r4, r5, r6, r7, lr}
10007a14:	690b      	ldr	r3, [r1, #16]
10007a16:	1c14      	adds	r4, r2, #0
10007a18:	6912      	ldr	r2, [r2, #16]
10007a1a:	b089      	sub	sp, #36	; 0x24
10007a1c:	1c0d      	adds	r5, r1, #0
10007a1e:	4293      	cmp	r3, r2
10007a20:	da01      	bge.n	10007a26 <__multiply+0x14>
10007a22:	1c25      	adds	r5, r4, #0
10007a24:	1c0c      	adds	r4, r1, #0
10007a26:	692f      	ldr	r7, [r5, #16]
10007a28:	6926      	ldr	r6, [r4, #16]
10007a2a:	68aa      	ldr	r2, [r5, #8]
10007a2c:	19bb      	adds	r3, r7, r6
10007a2e:	6869      	ldr	r1, [r5, #4]
10007a30:	9300      	str	r3, [sp, #0]
10007a32:	4293      	cmp	r3, r2
10007a34:	dd00      	ble.n	10007a38 <__multiply+0x26>
10007a36:	3101      	adds	r1, #1
10007a38:	f7ff ff0b 	bl	10007852 <_Balloc>
10007a3c:	1c01      	adds	r1, r0, #0
10007a3e:	9b00      	ldr	r3, [sp, #0]
10007a40:	3114      	adds	r1, #20
10007a42:	4684      	mov	ip, r0
10007a44:	0098      	lsls	r0, r3, #2
10007a46:	1c0b      	adds	r3, r1, #0
10007a48:	1808      	adds	r0, r1, r0
10007a4a:	4283      	cmp	r3, r0
10007a4c:	d202      	bcs.n	10007a54 <__multiply+0x42>
10007a4e:	2200      	movs	r2, #0
10007a50:	c304      	stmia	r3!, {r2}
10007a52:	e7fa      	b.n	10007a4a <__multiply+0x38>
10007a54:	3514      	adds	r5, #20
10007a56:	00bf      	lsls	r7, r7, #2
10007a58:	19eb      	adds	r3, r5, r7
10007a5a:	3414      	adds	r4, #20
10007a5c:	00b6      	lsls	r6, r6, #2
10007a5e:	9304      	str	r3, [sp, #16]
10007a60:	19a3      	adds	r3, r4, r6
10007a62:	9502      	str	r5, [sp, #8]
10007a64:	9306      	str	r3, [sp, #24]
10007a66:	9b06      	ldr	r3, [sp, #24]
10007a68:	429c      	cmp	r4, r3
10007a6a:	d256      	bcs.n	10007b1a <__multiply+0x108>
10007a6c:	8823      	ldrh	r3, [r4, #0]
10007a6e:	9303      	str	r3, [sp, #12]
10007a70:	2b00      	cmp	r3, #0
10007a72:	d022      	beq.n	10007aba <__multiply+0xa8>
10007a74:	1c0e      	adds	r6, r1, #0
10007a76:	2700      	movs	r7, #0
10007a78:	9b02      	ldr	r3, [sp, #8]
10007a7a:	9301      	str	r3, [sp, #4]
10007a7c:	9b01      	ldr	r3, [sp, #4]
10007a7e:	9d03      	ldr	r5, [sp, #12]
10007a80:	cb04      	ldmia	r3!, {r2}
10007a82:	9605      	str	r6, [sp, #20]
10007a84:	9301      	str	r3, [sp, #4]
10007a86:	8833      	ldrh	r3, [r6, #0]
10007a88:	9307      	str	r3, [sp, #28]
10007a8a:	b293      	uxth	r3, r2
10007a8c:	436b      	muls	r3, r5
10007a8e:	9d07      	ldr	r5, [sp, #28]
10007a90:	0c12      	lsrs	r2, r2, #16
10007a92:	18eb      	adds	r3, r5, r3
10007a94:	6835      	ldr	r5, [r6, #0]
10007a96:	19db      	adds	r3, r3, r7
10007a98:	0c2f      	lsrs	r7, r5, #16
10007a9a:	9d03      	ldr	r5, [sp, #12]
10007a9c:	436a      	muls	r2, r5
10007a9e:	18ba      	adds	r2, r7, r2
10007aa0:	0c1f      	lsrs	r7, r3, #16
10007aa2:	19d2      	adds	r2, r2, r7
10007aa4:	0c17      	lsrs	r7, r2, #16
10007aa6:	b29b      	uxth	r3, r3
10007aa8:	0412      	lsls	r2, r2, #16
10007aaa:	4313      	orrs	r3, r2
10007aac:	c608      	stmia	r6!, {r3}
10007aae:	9a01      	ldr	r2, [sp, #4]
10007ab0:	9b04      	ldr	r3, [sp, #16]
10007ab2:	429a      	cmp	r2, r3
10007ab4:	d3e2      	bcc.n	10007a7c <__multiply+0x6a>
10007ab6:	9b05      	ldr	r3, [sp, #20]
10007ab8:	605f      	str	r7, [r3, #4]
10007aba:	6823      	ldr	r3, [r4, #0]
10007abc:	0c1b      	lsrs	r3, r3, #16
10007abe:	9301      	str	r3, [sp, #4]
10007ac0:	d021      	beq.n	10007b06 <__multiply+0xf4>
10007ac2:	2200      	movs	r2, #0
10007ac4:	1c0d      	adds	r5, r1, #0
10007ac6:	680b      	ldr	r3, [r1, #0]
10007ac8:	9f02      	ldr	r7, [sp, #8]
10007aca:	9203      	str	r2, [sp, #12]
10007acc:	883e      	ldrh	r6, [r7, #0]
10007ace:	9a01      	ldr	r2, [sp, #4]
10007ad0:	b29b      	uxth	r3, r3
10007ad2:	4356      	muls	r6, r2
10007ad4:	682a      	ldr	r2, [r5, #0]
10007ad6:	9505      	str	r5, [sp, #20]
10007ad8:	0c12      	lsrs	r2, r2, #16
10007ada:	18b2      	adds	r2, r6, r2
10007adc:	9e03      	ldr	r6, [sp, #12]
10007ade:	1992      	adds	r2, r2, r6
10007ae0:	0416      	lsls	r6, r2, #16
10007ae2:	4333      	orrs	r3, r6
10007ae4:	602b      	str	r3, [r5, #0]
10007ae6:	cf08      	ldmia	r7!, {r3}
10007ae8:	9e01      	ldr	r6, [sp, #4]
10007aea:	0c1b      	lsrs	r3, r3, #16
10007aec:	4373      	muls	r3, r6
10007aee:	88ae      	ldrh	r6, [r5, #4]
10007af0:	0c12      	lsrs	r2, r2, #16
10007af2:	199b      	adds	r3, r3, r6
10007af4:	189b      	adds	r3, r3, r2
10007af6:	0c1a      	lsrs	r2, r3, #16
10007af8:	9203      	str	r2, [sp, #12]
10007afa:	9a04      	ldr	r2, [sp, #16]
10007afc:	3504      	adds	r5, #4
10007afe:	42ba      	cmp	r2, r7
10007b00:	d8e4      	bhi.n	10007acc <__multiply+0xba>
10007b02:	9a05      	ldr	r2, [sp, #20]
10007b04:	6053      	str	r3, [r2, #4]
10007b06:	3404      	adds	r4, #4
10007b08:	3104      	adds	r1, #4
10007b0a:	e7ac      	b.n	10007a66 <__multiply+0x54>
10007b0c:	3804      	subs	r0, #4
10007b0e:	6803      	ldr	r3, [r0, #0]
10007b10:	2b00      	cmp	r3, #0
10007b12:	d105      	bne.n	10007b20 <__multiply+0x10e>
10007b14:	9b00      	ldr	r3, [sp, #0]
10007b16:	3b01      	subs	r3, #1
10007b18:	9300      	str	r3, [sp, #0]
10007b1a:	9b00      	ldr	r3, [sp, #0]
10007b1c:	2b00      	cmp	r3, #0
10007b1e:	dcf5      	bgt.n	10007b0c <__multiply+0xfa>
10007b20:	4663      	mov	r3, ip
10007b22:	4660      	mov	r0, ip
10007b24:	9a00      	ldr	r2, [sp, #0]
10007b26:	611a      	str	r2, [r3, #16]
10007b28:	b009      	add	sp, #36	; 0x24
10007b2a:	bdf0      	pop	{r4, r5, r6, r7, pc}

10007b2c <__pow5mult>:
10007b2c:	2303      	movs	r3, #3
10007b2e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
10007b30:	4013      	ands	r3, r2
10007b32:	1c05      	adds	r5, r0, #0
10007b34:	1c0e      	adds	r6, r1, #0
10007b36:	1c14      	adds	r4, r2, #0
10007b38:	2b00      	cmp	r3, #0
10007b3a:	d007      	beq.n	10007b4c <__pow5mult+0x20>
10007b3c:	4a22      	ldr	r2, [pc, #136]	; (10007bc8 <__pow5mult+0x9c>)
10007b3e:	3b01      	subs	r3, #1
10007b40:	009b      	lsls	r3, r3, #2
10007b42:	589a      	ldr	r2, [r3, r2]
10007b44:	2300      	movs	r3, #0
10007b46:	f7ff fed5 	bl	100078f4 <__multadd>
10007b4a:	1c06      	adds	r6, r0, #0
10007b4c:	10a3      	asrs	r3, r4, #2
10007b4e:	9301      	str	r3, [sp, #4]
10007b50:	d037      	beq.n	10007bc2 <__pow5mult+0x96>
10007b52:	6a6c      	ldr	r4, [r5, #36]	; 0x24
10007b54:	2c00      	cmp	r4, #0
10007b56:	d107      	bne.n	10007b68 <__pow5mult+0x3c>
10007b58:	2010      	movs	r0, #16
10007b5a:	f7fd ff33 	bl	100059c4 <malloc>
10007b5e:	6268      	str	r0, [r5, #36]	; 0x24
10007b60:	6044      	str	r4, [r0, #4]
10007b62:	6084      	str	r4, [r0, #8]
10007b64:	6004      	str	r4, [r0, #0]
10007b66:	60c4      	str	r4, [r0, #12]
10007b68:	6a6f      	ldr	r7, [r5, #36]	; 0x24
10007b6a:	68bc      	ldr	r4, [r7, #8]
10007b6c:	2c00      	cmp	r4, #0
10007b6e:	d110      	bne.n	10007b92 <__pow5mult+0x66>
10007b70:	1c28      	adds	r0, r5, #0
10007b72:	4916      	ldr	r1, [pc, #88]	; (10007bcc <__pow5mult+0xa0>)
10007b74:	f7ff ff44 	bl	10007a00 <__i2b>
10007b78:	2300      	movs	r3, #0
10007b7a:	60b8      	str	r0, [r7, #8]
10007b7c:	1c04      	adds	r4, r0, #0
10007b7e:	6003      	str	r3, [r0, #0]
10007b80:	e007      	b.n	10007b92 <__pow5mult+0x66>
10007b82:	9b01      	ldr	r3, [sp, #4]
10007b84:	105b      	asrs	r3, r3, #1
10007b86:	9301      	str	r3, [sp, #4]
10007b88:	d01b      	beq.n	10007bc2 <__pow5mult+0x96>
10007b8a:	6820      	ldr	r0, [r4, #0]
10007b8c:	2800      	cmp	r0, #0
10007b8e:	d00f      	beq.n	10007bb0 <__pow5mult+0x84>
10007b90:	1c04      	adds	r4, r0, #0
10007b92:	9b01      	ldr	r3, [sp, #4]
10007b94:	07db      	lsls	r3, r3, #31
10007b96:	d5f4      	bpl.n	10007b82 <__pow5mult+0x56>
10007b98:	1c31      	adds	r1, r6, #0
10007b9a:	1c22      	adds	r2, r4, #0
10007b9c:	1c28      	adds	r0, r5, #0
10007b9e:	f7ff ff38 	bl	10007a12 <__multiply>
10007ba2:	1c07      	adds	r7, r0, #0
10007ba4:	1c31      	adds	r1, r6, #0
10007ba6:	1c28      	adds	r0, r5, #0
10007ba8:	f7ff fe8b 	bl	100078c2 <_Bfree>
10007bac:	1c3e      	adds	r6, r7, #0
10007bae:	e7e8      	b.n	10007b82 <__pow5mult+0x56>
10007bb0:	1c28      	adds	r0, r5, #0
10007bb2:	1c21      	adds	r1, r4, #0
10007bb4:	1c22      	adds	r2, r4, #0
10007bb6:	f7ff ff2c 	bl	10007a12 <__multiply>
10007bba:	2300      	movs	r3, #0
10007bbc:	6020      	str	r0, [r4, #0]
10007bbe:	6003      	str	r3, [r0, #0]
10007bc0:	e7e6      	b.n	10007b90 <__pow5mult+0x64>
10007bc2:	1c30      	adds	r0, r6, #0
10007bc4:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
10007bc6:	46c0      	nop			; (mov r8, r8)
10007bc8:	1000a950 	.word	0x1000a950
10007bcc:	00000271 	.word	0x00000271

10007bd0 <__lshift>:
10007bd0:	b5f0      	push	{r4, r5, r6, r7, lr}
10007bd2:	1c0c      	adds	r4, r1, #0
10007bd4:	1c17      	adds	r7, r2, #0
10007bd6:	6923      	ldr	r3, [r4, #16]
10007bd8:	1155      	asrs	r5, r2, #5
10007bda:	b085      	sub	sp, #20
10007bdc:	18eb      	adds	r3, r5, r3
10007bde:	9301      	str	r3, [sp, #4]
10007be0:	3301      	adds	r3, #1
10007be2:	9300      	str	r3, [sp, #0]
10007be4:	6849      	ldr	r1, [r1, #4]
10007be6:	68a3      	ldr	r3, [r4, #8]
10007be8:	9002      	str	r0, [sp, #8]
10007bea:	9a00      	ldr	r2, [sp, #0]
10007bec:	429a      	cmp	r2, r3
10007bee:	dd02      	ble.n	10007bf6 <__lshift+0x26>
10007bf0:	3101      	adds	r1, #1
10007bf2:	005b      	lsls	r3, r3, #1
10007bf4:	e7f9      	b.n	10007bea <__lshift+0x1a>
10007bf6:	9802      	ldr	r0, [sp, #8]
10007bf8:	f7ff fe2b 	bl	10007852 <_Balloc>
10007bfc:	1c02      	adds	r2, r0, #0
10007bfe:	1c06      	adds	r6, r0, #0
10007c00:	2300      	movs	r3, #0
10007c02:	3214      	adds	r2, #20
10007c04:	42ab      	cmp	r3, r5
10007c06:	da04      	bge.n	10007c12 <__lshift+0x42>
10007c08:	2000      	movs	r0, #0
10007c0a:	0099      	lsls	r1, r3, #2
10007c0c:	5050      	str	r0, [r2, r1]
10007c0e:	3301      	adds	r3, #1
10007c10:	e7f8      	b.n	10007c04 <__lshift+0x34>
10007c12:	43eb      	mvns	r3, r5
10007c14:	17db      	asrs	r3, r3, #31
10007c16:	401d      	ands	r5, r3
10007c18:	1c23      	adds	r3, r4, #0
10007c1a:	00ad      	lsls	r5, r5, #2
10007c1c:	1955      	adds	r5, r2, r5
10007c1e:	6922      	ldr	r2, [r4, #16]
10007c20:	3314      	adds	r3, #20
10007c22:	0092      	lsls	r2, r2, #2
10007c24:	189a      	adds	r2, r3, r2
10007c26:	4694      	mov	ip, r2
10007c28:	221f      	movs	r2, #31
10007c2a:	4017      	ands	r7, r2
10007c2c:	d014      	beq.n	10007c58 <__lshift+0x88>
10007c2e:	3201      	adds	r2, #1
10007c30:	1bd2      	subs	r2, r2, r7
10007c32:	9203      	str	r2, [sp, #12]
10007c34:	2200      	movs	r2, #0
10007c36:	6819      	ldr	r1, [r3, #0]
10007c38:	1c28      	adds	r0, r5, #0
10007c3a:	40b9      	lsls	r1, r7
10007c3c:	430a      	orrs	r2, r1
10007c3e:	c504      	stmia	r5!, {r2}
10007c40:	cb04      	ldmia	r3!, {r2}
10007c42:	9903      	ldr	r1, [sp, #12]
10007c44:	40ca      	lsrs	r2, r1
10007c46:	459c      	cmp	ip, r3
10007c48:	d8f5      	bhi.n	10007c36 <__lshift+0x66>
10007c4a:	6042      	str	r2, [r0, #4]
10007c4c:	2a00      	cmp	r2, #0
10007c4e:	d007      	beq.n	10007c60 <__lshift+0x90>
10007c50:	9b01      	ldr	r3, [sp, #4]
10007c52:	3302      	adds	r3, #2
10007c54:	9300      	str	r3, [sp, #0]
10007c56:	e003      	b.n	10007c60 <__lshift+0x90>
10007c58:	cb04      	ldmia	r3!, {r2}
10007c5a:	c504      	stmia	r5!, {r2}
10007c5c:	459c      	cmp	ip, r3
10007c5e:	d8fb      	bhi.n	10007c58 <__lshift+0x88>
10007c60:	9b00      	ldr	r3, [sp, #0]
10007c62:	9802      	ldr	r0, [sp, #8]
10007c64:	3b01      	subs	r3, #1
10007c66:	6133      	str	r3, [r6, #16]
10007c68:	1c21      	adds	r1, r4, #0
10007c6a:	f7ff fe2a 	bl	100078c2 <_Bfree>
10007c6e:	1c30      	adds	r0, r6, #0
10007c70:	b005      	add	sp, #20
10007c72:	bdf0      	pop	{r4, r5, r6, r7, pc}

10007c74 <__mcmp>:
10007c74:	6903      	ldr	r3, [r0, #16]
10007c76:	690a      	ldr	r2, [r1, #16]
10007c78:	b510      	push	{r4, lr}
10007c7a:	1a9b      	subs	r3, r3, r2
10007c7c:	1c04      	adds	r4, r0, #0
10007c7e:	1e18      	subs	r0, r3, #0
10007c80:	d112      	bne.n	10007ca8 <__mcmp+0x34>
10007c82:	0093      	lsls	r3, r2, #2
10007c84:	3414      	adds	r4, #20
10007c86:	3114      	adds	r1, #20
10007c88:	18e2      	adds	r2, r4, r3
10007c8a:	18c9      	adds	r1, r1, r3
10007c8c:	3a04      	subs	r2, #4
10007c8e:	3904      	subs	r1, #4
10007c90:	6813      	ldr	r3, [r2, #0]
10007c92:	6808      	ldr	r0, [r1, #0]
10007c94:	4283      	cmp	r3, r0
10007c96:	d004      	beq.n	10007ca2 <__mcmp+0x2e>
10007c98:	4283      	cmp	r3, r0
10007c9a:	419b      	sbcs	r3, r3
10007c9c:	2001      	movs	r0, #1
10007c9e:	4318      	orrs	r0, r3
10007ca0:	e002      	b.n	10007ca8 <__mcmp+0x34>
10007ca2:	42a2      	cmp	r2, r4
10007ca4:	d8f2      	bhi.n	10007c8c <__mcmp+0x18>
10007ca6:	2000      	movs	r0, #0
10007ca8:	bd10      	pop	{r4, pc}

10007caa <__mdiff>:
10007caa:	b5f0      	push	{r4, r5, r6, r7, lr}
10007cac:	1c07      	adds	r7, r0, #0
10007cae:	b085      	sub	sp, #20
10007cb0:	1c08      	adds	r0, r1, #0
10007cb2:	1c0c      	adds	r4, r1, #0
10007cb4:	1c11      	adds	r1, r2, #0
10007cb6:	1c15      	adds	r5, r2, #0
10007cb8:	f7ff ffdc 	bl	10007c74 <__mcmp>
10007cbc:	1e06      	subs	r6, r0, #0
10007cbe:	d107      	bne.n	10007cd0 <__mdiff+0x26>
10007cc0:	1c38      	adds	r0, r7, #0
10007cc2:	1c31      	adds	r1, r6, #0
10007cc4:	f7ff fdc5 	bl	10007852 <_Balloc>
10007cc8:	2301      	movs	r3, #1
10007cca:	6146      	str	r6, [r0, #20]
10007ccc:	6103      	str	r3, [r0, #16]
10007cce:	e055      	b.n	10007d7c <__mdiff+0xd2>
10007cd0:	2300      	movs	r3, #0
10007cd2:	9301      	str	r3, [sp, #4]
10007cd4:	4298      	cmp	r0, r3
10007cd6:	da04      	bge.n	10007ce2 <__mdiff+0x38>
10007cd8:	1c23      	adds	r3, r4, #0
10007cda:	1c2c      	adds	r4, r5, #0
10007cdc:	1c1d      	adds	r5, r3, #0
10007cde:	2301      	movs	r3, #1
10007ce0:	9301      	str	r3, [sp, #4]
10007ce2:	1c38      	adds	r0, r7, #0
10007ce4:	6861      	ldr	r1, [r4, #4]
10007ce6:	f7ff fdb4 	bl	10007852 <_Balloc>
10007cea:	9b01      	ldr	r3, [sp, #4]
10007cec:	6926      	ldr	r6, [r4, #16]
10007cee:	1c2f      	adds	r7, r5, #0
10007cf0:	60c3      	str	r3, [r0, #12]
10007cf2:	3414      	adds	r4, #20
10007cf4:	00b3      	lsls	r3, r6, #2
10007cf6:	18e3      	adds	r3, r4, r3
10007cf8:	1c02      	adds	r2, r0, #0
10007cfa:	9302      	str	r3, [sp, #8]
10007cfc:	692b      	ldr	r3, [r5, #16]
10007cfe:	2500      	movs	r5, #0
10007d00:	3714      	adds	r7, #20
10007d02:	009b      	lsls	r3, r3, #2
10007d04:	18fb      	adds	r3, r7, r3
10007d06:	9303      	str	r3, [sp, #12]
10007d08:	3214      	adds	r2, #20
10007d0a:	cc08      	ldmia	r4!, {r3}
10007d0c:	4669      	mov	r1, sp
10007d0e:	469c      	mov	ip, r3
10007d10:	cf08      	ldmia	r7!, {r3}
10007d12:	3204      	adds	r2, #4
10007d14:	9300      	str	r3, [sp, #0]
10007d16:	4663      	mov	r3, ip
10007d18:	808b      	strh	r3, [r1, #4]
10007d1a:	888b      	ldrh	r3, [r1, #4]
10007d1c:	195d      	adds	r5, r3, r5
10007d1e:	9b00      	ldr	r3, [sp, #0]
10007d20:	b29b      	uxth	r3, r3
10007d22:	1aeb      	subs	r3, r5, r3
10007d24:	4665      	mov	r5, ip
10007d26:	9301      	str	r3, [sp, #4]
10007d28:	9b00      	ldr	r3, [sp, #0]
10007d2a:	0c2d      	lsrs	r5, r5, #16
10007d2c:	0c19      	lsrs	r1, r3, #16
10007d2e:	9b01      	ldr	r3, [sp, #4]
10007d30:	1a69      	subs	r1, r5, r1
10007d32:	141d      	asrs	r5, r3, #16
10007d34:	1f13      	subs	r3, r2, #4
10007d36:	469c      	mov	ip, r3
10007d38:	466b      	mov	r3, sp
10007d3a:	1949      	adds	r1, r1, r5
10007d3c:	889b      	ldrh	r3, [r3, #4]
10007d3e:	140d      	asrs	r5, r1, #16
10007d40:	0409      	lsls	r1, r1, #16
10007d42:	430b      	orrs	r3, r1
10007d44:	4661      	mov	r1, ip
10007d46:	600b      	str	r3, [r1, #0]
10007d48:	9b03      	ldr	r3, [sp, #12]
10007d4a:	429f      	cmp	r7, r3
10007d4c:	d3dd      	bcc.n	10007d0a <__mdiff+0x60>
10007d4e:	9902      	ldr	r1, [sp, #8]
10007d50:	1c13      	adds	r3, r2, #0
10007d52:	428c      	cmp	r4, r1
10007d54:	d20b      	bcs.n	10007d6e <__mdiff+0xc4>
10007d56:	cc08      	ldmia	r4!, {r3}
10007d58:	b299      	uxth	r1, r3
10007d5a:	1949      	adds	r1, r1, r5
10007d5c:	140d      	asrs	r5, r1, #16
10007d5e:	0c1b      	lsrs	r3, r3, #16
10007d60:	18eb      	adds	r3, r5, r3
10007d62:	141d      	asrs	r5, r3, #16
10007d64:	b289      	uxth	r1, r1
10007d66:	041b      	lsls	r3, r3, #16
10007d68:	430b      	orrs	r3, r1
10007d6a:	c208      	stmia	r2!, {r3}
10007d6c:	e7ef      	b.n	10007d4e <__mdiff+0xa4>
10007d6e:	3b04      	subs	r3, #4
10007d70:	681a      	ldr	r2, [r3, #0]
10007d72:	2a00      	cmp	r2, #0
10007d74:	d101      	bne.n	10007d7a <__mdiff+0xd0>
10007d76:	3e01      	subs	r6, #1
10007d78:	e7f9      	b.n	10007d6e <__mdiff+0xc4>
10007d7a:	6106      	str	r6, [r0, #16]
10007d7c:	b005      	add	sp, #20
10007d7e:	bdf0      	pop	{r4, r5, r6, r7, pc}

10007d80 <__d2b>:
10007d80:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
10007d82:	1c1d      	adds	r5, r3, #0
10007d84:	2101      	movs	r1, #1
10007d86:	9f08      	ldr	r7, [sp, #32]
10007d88:	1c14      	adds	r4, r2, #0
10007d8a:	f7ff fd62 	bl	10007852 <_Balloc>
10007d8e:	032b      	lsls	r3, r5, #12
10007d90:	006d      	lsls	r5, r5, #1
10007d92:	1c06      	adds	r6, r0, #0
10007d94:	0b1b      	lsrs	r3, r3, #12
10007d96:	0d6d      	lsrs	r5, r5, #21
10007d98:	d002      	beq.n	10007da0 <__d2b+0x20>
10007d9a:	2280      	movs	r2, #128	; 0x80
10007d9c:	0352      	lsls	r2, r2, #13
10007d9e:	4313      	orrs	r3, r2
10007da0:	9301      	str	r3, [sp, #4]
10007da2:	2c00      	cmp	r4, #0
10007da4:	d018      	beq.n	10007dd8 <__d2b+0x58>
10007da6:	4668      	mov	r0, sp
10007da8:	9400      	str	r4, [sp, #0]
10007daa:	f7ff fdfa 	bl	100079a2 <__lo0bits>
10007dae:	9c00      	ldr	r4, [sp, #0]
10007db0:	2800      	cmp	r0, #0
10007db2:	d009      	beq.n	10007dc8 <__d2b+0x48>
10007db4:	2320      	movs	r3, #32
10007db6:	9a01      	ldr	r2, [sp, #4]
10007db8:	1a19      	subs	r1, r3, r0
10007dba:	1c13      	adds	r3, r2, #0
10007dbc:	408b      	lsls	r3, r1
10007dbe:	40c2      	lsrs	r2, r0
10007dc0:	4323      	orrs	r3, r4
10007dc2:	6173      	str	r3, [r6, #20]
10007dc4:	9201      	str	r2, [sp, #4]
10007dc6:	e000      	b.n	10007dca <__d2b+0x4a>
10007dc8:	6174      	str	r4, [r6, #20]
10007dca:	9c01      	ldr	r4, [sp, #4]
10007dcc:	61b4      	str	r4, [r6, #24]
10007dce:	1e63      	subs	r3, r4, #1
10007dd0:	419c      	sbcs	r4, r3
10007dd2:	3401      	adds	r4, #1
10007dd4:	6134      	str	r4, [r6, #16]
10007dd6:	e007      	b.n	10007de8 <__d2b+0x68>
10007dd8:	a801      	add	r0, sp, #4
10007dda:	f7ff fde2 	bl	100079a2 <__lo0bits>
10007dde:	2401      	movs	r4, #1
10007de0:	9b01      	ldr	r3, [sp, #4]
10007de2:	6134      	str	r4, [r6, #16]
10007de4:	6173      	str	r3, [r6, #20]
10007de6:	3020      	adds	r0, #32
10007de8:	2d00      	cmp	r5, #0
10007dea:	d006      	beq.n	10007dfa <__d2b+0x7a>
10007dec:	4b0b      	ldr	r3, [pc, #44]	; (10007e1c <__d2b+0x9c>)
10007dee:	18ed      	adds	r5, r5, r3
10007df0:	2335      	movs	r3, #53	; 0x35
10007df2:	182d      	adds	r5, r5, r0
10007df4:	603d      	str	r5, [r7, #0]
10007df6:	1a18      	subs	r0, r3, r0
10007df8:	e00b      	b.n	10007e12 <__d2b+0x92>
10007dfa:	4b09      	ldr	r3, [pc, #36]	; (10007e20 <__d2b+0xa0>)
10007dfc:	18c0      	adds	r0, r0, r3
10007dfe:	4b09      	ldr	r3, [pc, #36]	; (10007e24 <__d2b+0xa4>)
10007e00:	6038      	str	r0, [r7, #0]
10007e02:	18e3      	adds	r3, r4, r3
10007e04:	009b      	lsls	r3, r3, #2
10007e06:	18f3      	adds	r3, r6, r3
10007e08:	6958      	ldr	r0, [r3, #20]
10007e0a:	f7ff fdaf 	bl	1000796c <__hi0bits>
10007e0e:	0164      	lsls	r4, r4, #5
10007e10:	1a20      	subs	r0, r4, r0
10007e12:	9b09      	ldr	r3, [sp, #36]	; 0x24
10007e14:	6018      	str	r0, [r3, #0]
10007e16:	1c30      	adds	r0, r6, #0
10007e18:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
10007e1a:	46c0      	nop			; (mov r8, r8)
10007e1c:	fffffbcd 	.word	0xfffffbcd
10007e20:	fffffbce 	.word	0xfffffbce
10007e24:	3fffffff 	.word	0x3fffffff

10007e28 <_calloc_r>:
10007e28:	434a      	muls	r2, r1
10007e2a:	b538      	push	{r3, r4, r5, lr}
10007e2c:	1c11      	adds	r1, r2, #0
10007e2e:	1c14      	adds	r4, r2, #0
10007e30:	f7fd fe34 	bl	10005a9c <_malloc_r>
10007e34:	1e05      	subs	r5, r0, #0
10007e36:	d003      	beq.n	10007e40 <_calloc_r+0x18>
10007e38:	2100      	movs	r1, #0
10007e3a:	1c22      	adds	r2, r4, #0
10007e3c:	f7fd fddf 	bl	100059fe <memset>
10007e40:	1c28      	adds	r0, r5, #0
10007e42:	bd38      	pop	{r3, r4, r5, pc}

10007e44 <__ssputs_r>:
10007e44:	b5f0      	push	{r4, r5, r6, r7, lr}
10007e46:	688e      	ldr	r6, [r1, #8]
10007e48:	b085      	sub	sp, #20
10007e4a:	1c07      	adds	r7, r0, #0
10007e4c:	1c0c      	adds	r4, r1, #0
10007e4e:	9203      	str	r2, [sp, #12]
10007e50:	9301      	str	r3, [sp, #4]
10007e52:	42b3      	cmp	r3, r6
10007e54:	d345      	bcc.n	10007ee2 <__ssputs_r+0x9e>
10007e56:	2390      	movs	r3, #144	; 0x90
10007e58:	898a      	ldrh	r2, [r1, #12]
10007e5a:	00db      	lsls	r3, r3, #3
10007e5c:	421a      	tst	r2, r3
10007e5e:	d03d      	beq.n	10007edc <__ssputs_r+0x98>
10007e60:	2503      	movs	r5, #3
10007e62:	6909      	ldr	r1, [r1, #16]
10007e64:	6823      	ldr	r3, [r4, #0]
10007e66:	9801      	ldr	r0, [sp, #4]
10007e68:	1a5b      	subs	r3, r3, r1
10007e6a:	9302      	str	r3, [sp, #8]
10007e6c:	6963      	ldr	r3, [r4, #20]
10007e6e:	435d      	muls	r5, r3
10007e70:	0feb      	lsrs	r3, r5, #31
10007e72:	195d      	adds	r5, r3, r5
10007e74:	9b02      	ldr	r3, [sp, #8]
10007e76:	106d      	asrs	r5, r5, #1
10007e78:	3301      	adds	r3, #1
10007e7a:	181b      	adds	r3, r3, r0
10007e7c:	429d      	cmp	r5, r3
10007e7e:	d200      	bcs.n	10007e82 <__ssputs_r+0x3e>
10007e80:	1c1d      	adds	r5, r3, #0
10007e82:	1c38      	adds	r0, r7, #0
10007e84:	0553      	lsls	r3, r2, #21
10007e86:	d50f      	bpl.n	10007ea8 <__ssputs_r+0x64>
10007e88:	1c29      	adds	r1, r5, #0
10007e8a:	f7fd fe07 	bl	10005a9c <_malloc_r>
10007e8e:	1e06      	subs	r6, r0, #0
10007e90:	d013      	beq.n	10007eba <__ssputs_r+0x76>
10007e92:	9a02      	ldr	r2, [sp, #8]
10007e94:	6921      	ldr	r1, [r4, #16]
10007e96:	f7fd fda9 	bl	100059ec <memcpy>
10007e9a:	89a2      	ldrh	r2, [r4, #12]
10007e9c:	4b18      	ldr	r3, [pc, #96]	; (10007f00 <__ssputs_r+0xbc>)
10007e9e:	4013      	ands	r3, r2
10007ea0:	2280      	movs	r2, #128	; 0x80
10007ea2:	4313      	orrs	r3, r2
10007ea4:	81a3      	strh	r3, [r4, #12]
10007ea6:	e011      	b.n	10007ecc <__ssputs_r+0x88>
10007ea8:	1c2a      	adds	r2, r5, #0
10007eaa:	f000 fb17 	bl	100084dc <_realloc_r>
10007eae:	1e06      	subs	r6, r0, #0
10007eb0:	d10c      	bne.n	10007ecc <__ssputs_r+0x88>
10007eb2:	1c38      	adds	r0, r7, #0
10007eb4:	6921      	ldr	r1, [r4, #16]
10007eb6:	f7fd fdab 	bl	10005a10 <_free_r>
10007eba:	230c      	movs	r3, #12
10007ebc:	2240      	movs	r2, #64	; 0x40
10007ebe:	2001      	movs	r0, #1
10007ec0:	603b      	str	r3, [r7, #0]
10007ec2:	89a3      	ldrh	r3, [r4, #12]
10007ec4:	4240      	negs	r0, r0
10007ec6:	4313      	orrs	r3, r2
10007ec8:	81a3      	strh	r3, [r4, #12]
10007eca:	e017      	b.n	10007efc <__ssputs_r+0xb8>
10007ecc:	9b02      	ldr	r3, [sp, #8]
10007ece:	6126      	str	r6, [r4, #16]
10007ed0:	18f6      	adds	r6, r6, r3
10007ed2:	6026      	str	r6, [r4, #0]
10007ed4:	6165      	str	r5, [r4, #20]
10007ed6:	9e01      	ldr	r6, [sp, #4]
10007ed8:	1aed      	subs	r5, r5, r3
10007eda:	60a5      	str	r5, [r4, #8]
10007edc:	9b01      	ldr	r3, [sp, #4]
10007ede:	42b3      	cmp	r3, r6
10007ee0:	d200      	bcs.n	10007ee4 <__ssputs_r+0xa0>
10007ee2:	9e01      	ldr	r6, [sp, #4]
10007ee4:	1c32      	adds	r2, r6, #0
10007ee6:	6820      	ldr	r0, [r4, #0]
10007ee8:	9903      	ldr	r1, [sp, #12]
10007eea:	f000 fae3 	bl	100084b4 <memmove>
10007eee:	2000      	movs	r0, #0
10007ef0:	68a3      	ldr	r3, [r4, #8]
10007ef2:	1b9b      	subs	r3, r3, r6
10007ef4:	60a3      	str	r3, [r4, #8]
10007ef6:	6823      	ldr	r3, [r4, #0]
10007ef8:	199e      	adds	r6, r3, r6
10007efa:	6026      	str	r6, [r4, #0]
10007efc:	b005      	add	sp, #20
10007efe:	bdf0      	pop	{r4, r5, r6, r7, pc}
10007f00:	fffffb7f 	.word	0xfffffb7f

10007f04 <_svfiprintf_r>:
10007f04:	b5f0      	push	{r4, r5, r6, r7, lr}
10007f06:	b09f      	sub	sp, #124	; 0x7c
10007f08:	9002      	str	r0, [sp, #8]
10007f0a:	9305      	str	r3, [sp, #20]
10007f0c:	898b      	ldrh	r3, [r1, #12]
10007f0e:	1c0e      	adds	r6, r1, #0
10007f10:	1c17      	adds	r7, r2, #0
10007f12:	061b      	lsls	r3, r3, #24
10007f14:	d510      	bpl.n	10007f38 <_svfiprintf_r+0x34>
10007f16:	690b      	ldr	r3, [r1, #16]
10007f18:	2b00      	cmp	r3, #0
10007f1a:	d10d      	bne.n	10007f38 <_svfiprintf_r+0x34>
10007f1c:	2140      	movs	r1, #64	; 0x40
10007f1e:	f7fd fdbd 	bl	10005a9c <_malloc_r>
10007f22:	6030      	str	r0, [r6, #0]
10007f24:	6130      	str	r0, [r6, #16]
10007f26:	2800      	cmp	r0, #0
10007f28:	d104      	bne.n	10007f34 <_svfiprintf_r+0x30>
10007f2a:	230c      	movs	r3, #12
10007f2c:	9a02      	ldr	r2, [sp, #8]
10007f2e:	3801      	subs	r0, #1
10007f30:	6013      	str	r3, [r2, #0]
10007f32:	e0d0      	b.n	100080d6 <_svfiprintf_r+0x1d2>
10007f34:	2340      	movs	r3, #64	; 0x40
10007f36:	6173      	str	r3, [r6, #20]
10007f38:	2300      	movs	r3, #0
10007f3a:	ad06      	add	r5, sp, #24
10007f3c:	616b      	str	r3, [r5, #20]
10007f3e:	3320      	adds	r3, #32
10007f40:	766b      	strb	r3, [r5, #25]
10007f42:	3310      	adds	r3, #16
10007f44:	76ab      	strb	r3, [r5, #26]
10007f46:	1c3c      	adds	r4, r7, #0
10007f48:	7823      	ldrb	r3, [r4, #0]
10007f4a:	2b00      	cmp	r3, #0
10007f4c:	d103      	bne.n	10007f56 <_svfiprintf_r+0x52>
10007f4e:	1be3      	subs	r3, r4, r7
10007f50:	9304      	str	r3, [sp, #16]
10007f52:	d012      	beq.n	10007f7a <_svfiprintf_r+0x76>
10007f54:	e003      	b.n	10007f5e <_svfiprintf_r+0x5a>
10007f56:	2b25      	cmp	r3, #37	; 0x25
10007f58:	d0f9      	beq.n	10007f4e <_svfiprintf_r+0x4a>
10007f5a:	3401      	adds	r4, #1
10007f5c:	e7f4      	b.n	10007f48 <_svfiprintf_r+0x44>
10007f5e:	9b04      	ldr	r3, [sp, #16]
10007f60:	9802      	ldr	r0, [sp, #8]
10007f62:	1c31      	adds	r1, r6, #0
10007f64:	1c3a      	adds	r2, r7, #0
10007f66:	f7ff ff6d 	bl	10007e44 <__ssputs_r>
10007f6a:	1c43      	adds	r3, r0, #1
10007f6c:	d100      	bne.n	10007f70 <_svfiprintf_r+0x6c>
10007f6e:	e0ac      	b.n	100080ca <_svfiprintf_r+0x1c6>
10007f70:	696a      	ldr	r2, [r5, #20]
10007f72:	9b04      	ldr	r3, [sp, #16]
10007f74:	4694      	mov	ip, r2
10007f76:	4463      	add	r3, ip
10007f78:	616b      	str	r3, [r5, #20]
10007f7a:	7823      	ldrb	r3, [r4, #0]
10007f7c:	2b00      	cmp	r3, #0
10007f7e:	d100      	bne.n	10007f82 <_svfiprintf_r+0x7e>
10007f80:	e0a3      	b.n	100080ca <_svfiprintf_r+0x1c6>
10007f82:	2201      	movs	r2, #1
10007f84:	2300      	movs	r3, #0
10007f86:	4252      	negs	r2, r2
10007f88:	606a      	str	r2, [r5, #4]
10007f8a:	a902      	add	r1, sp, #8
10007f8c:	3254      	adds	r2, #84	; 0x54
10007f8e:	1852      	adds	r2, r2, r1
10007f90:	3401      	adds	r4, #1
10007f92:	602b      	str	r3, [r5, #0]
10007f94:	60eb      	str	r3, [r5, #12]
10007f96:	60ab      	str	r3, [r5, #8]
10007f98:	7013      	strb	r3, [r2, #0]
10007f9a:	65ab      	str	r3, [r5, #88]	; 0x58
10007f9c:	4f4f      	ldr	r7, [pc, #316]	; (100080dc <_svfiprintf_r+0x1d8>)
10007f9e:	7821      	ldrb	r1, [r4, #0]
10007fa0:	1c38      	adds	r0, r7, #0
10007fa2:	2205      	movs	r2, #5
10007fa4:	f7ff fc4a 	bl	1000783c <memchr>
10007fa8:	2800      	cmp	r0, #0
10007faa:	d008      	beq.n	10007fbe <_svfiprintf_r+0xba>
10007fac:	1bc0      	subs	r0, r0, r7
10007fae:	2701      	movs	r7, #1
10007fb0:	4087      	lsls	r7, r0
10007fb2:	1c38      	adds	r0, r7, #0
10007fb4:	682b      	ldr	r3, [r5, #0]
10007fb6:	3401      	adds	r4, #1
10007fb8:	4318      	orrs	r0, r3
10007fba:	6028      	str	r0, [r5, #0]
10007fbc:	e7ee      	b.n	10007f9c <_svfiprintf_r+0x98>
10007fbe:	682b      	ldr	r3, [r5, #0]
10007fc0:	06da      	lsls	r2, r3, #27
10007fc2:	d504      	bpl.n	10007fce <_svfiprintf_r+0xca>
10007fc4:	2253      	movs	r2, #83	; 0x53
10007fc6:	2120      	movs	r1, #32
10007fc8:	a802      	add	r0, sp, #8
10007fca:	1812      	adds	r2, r2, r0
10007fcc:	7011      	strb	r1, [r2, #0]
10007fce:	071a      	lsls	r2, r3, #28
10007fd0:	d504      	bpl.n	10007fdc <_svfiprintf_r+0xd8>
10007fd2:	2253      	movs	r2, #83	; 0x53
10007fd4:	212b      	movs	r1, #43	; 0x2b
10007fd6:	a802      	add	r0, sp, #8
10007fd8:	1812      	adds	r2, r2, r0
10007fda:	7011      	strb	r1, [r2, #0]
10007fdc:	7822      	ldrb	r2, [r4, #0]
10007fde:	2a2a      	cmp	r2, #42	; 0x2a
10007fe0:	d001      	beq.n	10007fe6 <_svfiprintf_r+0xe2>
10007fe2:	9b09      	ldr	r3, [sp, #36]	; 0x24
10007fe4:	e00e      	b.n	10008004 <_svfiprintf_r+0x100>
10007fe6:	9a05      	ldr	r2, [sp, #20]
10007fe8:	1d11      	adds	r1, r2, #4
10007fea:	6812      	ldr	r2, [r2, #0]
10007fec:	9105      	str	r1, [sp, #20]
10007fee:	2a00      	cmp	r2, #0
10007ff0:	db01      	blt.n	10007ff6 <_svfiprintf_r+0xf2>
10007ff2:	9209      	str	r2, [sp, #36]	; 0x24
10007ff4:	e004      	b.n	10008000 <_svfiprintf_r+0xfc>
10007ff6:	4252      	negs	r2, r2
10007ff8:	60ea      	str	r2, [r5, #12]
10007ffa:	2202      	movs	r2, #2
10007ffc:	4313      	orrs	r3, r2
10007ffe:	602b      	str	r3, [r5, #0]
10008000:	3401      	adds	r4, #1
10008002:	e009      	b.n	10008018 <_svfiprintf_r+0x114>
10008004:	7822      	ldrb	r2, [r4, #0]
10008006:	3a30      	subs	r2, #48	; 0x30
10008008:	2a09      	cmp	r2, #9
1000800a:	d804      	bhi.n	10008016 <_svfiprintf_r+0x112>
1000800c:	210a      	movs	r1, #10
1000800e:	434b      	muls	r3, r1
10008010:	3401      	adds	r4, #1
10008012:	189b      	adds	r3, r3, r2
10008014:	e7f6      	b.n	10008004 <_svfiprintf_r+0x100>
10008016:	9309      	str	r3, [sp, #36]	; 0x24
10008018:	7823      	ldrb	r3, [r4, #0]
1000801a:	2b2e      	cmp	r3, #46	; 0x2e
1000801c:	d118      	bne.n	10008050 <_svfiprintf_r+0x14c>
1000801e:	7863      	ldrb	r3, [r4, #1]
10008020:	2b2a      	cmp	r3, #42	; 0x2a
10008022:	d109      	bne.n	10008038 <_svfiprintf_r+0x134>
10008024:	9b05      	ldr	r3, [sp, #20]
10008026:	3402      	adds	r4, #2
10008028:	1d1a      	adds	r2, r3, #4
1000802a:	681b      	ldr	r3, [r3, #0]
1000802c:	9205      	str	r2, [sp, #20]
1000802e:	2b00      	cmp	r3, #0
10008030:	da0d      	bge.n	1000804e <_svfiprintf_r+0x14a>
10008032:	2301      	movs	r3, #1
10008034:	425b      	negs	r3, r3
10008036:	e00a      	b.n	1000804e <_svfiprintf_r+0x14a>
10008038:	2300      	movs	r3, #0
1000803a:	3401      	adds	r4, #1
1000803c:	7822      	ldrb	r2, [r4, #0]
1000803e:	3a30      	subs	r2, #48	; 0x30
10008040:	2a09      	cmp	r2, #9
10008042:	d804      	bhi.n	1000804e <_svfiprintf_r+0x14a>
10008044:	210a      	movs	r1, #10
10008046:	434b      	muls	r3, r1
10008048:	3401      	adds	r4, #1
1000804a:	189b      	adds	r3, r3, r2
1000804c:	e7f6      	b.n	1000803c <_svfiprintf_r+0x138>
1000804e:	9307      	str	r3, [sp, #28]
10008050:	4f23      	ldr	r7, [pc, #140]	; (100080e0 <_svfiprintf_r+0x1dc>)
10008052:	7821      	ldrb	r1, [r4, #0]
10008054:	1c38      	adds	r0, r7, #0
10008056:	2203      	movs	r2, #3
10008058:	f7ff fbf0 	bl	1000783c <memchr>
1000805c:	2800      	cmp	r0, #0
1000805e:	d007      	beq.n	10008070 <_svfiprintf_r+0x16c>
10008060:	1bc0      	subs	r0, r0, r7
10008062:	2740      	movs	r7, #64	; 0x40
10008064:	4087      	lsls	r7, r0
10008066:	1c38      	adds	r0, r7, #0
10008068:	682b      	ldr	r3, [r5, #0]
1000806a:	3401      	adds	r4, #1
1000806c:	4318      	orrs	r0, r3
1000806e:	6028      	str	r0, [r5, #0]
10008070:	7821      	ldrb	r1, [r4, #0]
10008072:	481c      	ldr	r0, [pc, #112]	; (100080e4 <_svfiprintf_r+0x1e0>)
10008074:	2206      	movs	r2, #6
10008076:	1c67      	adds	r7, r4, #1
10008078:	7629      	strb	r1, [r5, #24]
1000807a:	f7ff fbdf 	bl	1000783c <memchr>
1000807e:	2800      	cmp	r0, #0
10008080:	d012      	beq.n	100080a8 <_svfiprintf_r+0x1a4>
10008082:	4b19      	ldr	r3, [pc, #100]	; (100080e8 <_svfiprintf_r+0x1e4>)
10008084:	2b00      	cmp	r3, #0
10008086:	d106      	bne.n	10008096 <_svfiprintf_r+0x192>
10008088:	2207      	movs	r2, #7
1000808a:	9b05      	ldr	r3, [sp, #20]
1000808c:	3307      	adds	r3, #7
1000808e:	4393      	bics	r3, r2
10008090:	3308      	adds	r3, #8
10008092:	9305      	str	r3, [sp, #20]
10008094:	e014      	b.n	100080c0 <_svfiprintf_r+0x1bc>
10008096:	ab05      	add	r3, sp, #20
10008098:	9300      	str	r3, [sp, #0]
1000809a:	9802      	ldr	r0, [sp, #8]
1000809c:	1c29      	adds	r1, r5, #0
1000809e:	1c32      	adds	r2, r6, #0
100080a0:	4b12      	ldr	r3, [pc, #72]	; (100080ec <_svfiprintf_r+0x1e8>)
100080a2:	f7fd fde9 	bl	10005c78 <_printf_float>
100080a6:	e007      	b.n	100080b8 <_svfiprintf_r+0x1b4>
100080a8:	ab05      	add	r3, sp, #20
100080aa:	9300      	str	r3, [sp, #0]
100080ac:	9802      	ldr	r0, [sp, #8]
100080ae:	1c29      	adds	r1, r5, #0
100080b0:	1c32      	adds	r2, r6, #0
100080b2:	4b0e      	ldr	r3, [pc, #56]	; (100080ec <_svfiprintf_r+0x1e8>)
100080b4:	f7fe f886 	bl	100061c4 <_printf_i>
100080b8:	9003      	str	r0, [sp, #12]
100080ba:	9b03      	ldr	r3, [sp, #12]
100080bc:	3301      	adds	r3, #1
100080be:	d004      	beq.n	100080ca <_svfiprintf_r+0x1c6>
100080c0:	696b      	ldr	r3, [r5, #20]
100080c2:	9a03      	ldr	r2, [sp, #12]
100080c4:	189b      	adds	r3, r3, r2
100080c6:	616b      	str	r3, [r5, #20]
100080c8:	e73d      	b.n	10007f46 <_svfiprintf_r+0x42>
100080ca:	89b3      	ldrh	r3, [r6, #12]
100080cc:	980b      	ldr	r0, [sp, #44]	; 0x2c
100080ce:	065b      	lsls	r3, r3, #25
100080d0:	d501      	bpl.n	100080d6 <_svfiprintf_r+0x1d2>
100080d2:	2001      	movs	r0, #1
100080d4:	4240      	negs	r0, r0
100080d6:	b01f      	add	sp, #124	; 0x7c
100080d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
100080da:	46c0      	nop			; (mov r8, r8)
100080dc:	1000a95c 	.word	0x1000a95c
100080e0:	1000a962 	.word	0x1000a962
100080e4:	1000a966 	.word	0x1000a966
100080e8:	10005c79 	.word	0x10005c79
100080ec:	10007e45 	.word	0x10007e45

100080f0 <__sfputc_r>:
100080f0:	6893      	ldr	r3, [r2, #8]
100080f2:	b510      	push	{r4, lr}
100080f4:	3b01      	subs	r3, #1
100080f6:	6093      	str	r3, [r2, #8]
100080f8:	2b00      	cmp	r3, #0
100080fa:	da05      	bge.n	10008108 <__sfputc_r+0x18>
100080fc:	6994      	ldr	r4, [r2, #24]
100080fe:	42a3      	cmp	r3, r4
10008100:	db08      	blt.n	10008114 <__sfputc_r+0x24>
10008102:	b2cb      	uxtb	r3, r1
10008104:	2b0a      	cmp	r3, #10
10008106:	d005      	beq.n	10008114 <__sfputc_r+0x24>
10008108:	6813      	ldr	r3, [r2, #0]
1000810a:	1c58      	adds	r0, r3, #1
1000810c:	6010      	str	r0, [r2, #0]
1000810e:	7019      	strb	r1, [r3, #0]
10008110:	b2c8      	uxtb	r0, r1
10008112:	e001      	b.n	10008118 <__sfputc_r+0x28>
10008114:	f7fe fa58 	bl	100065c8 <__swbuf_r>
10008118:	bd10      	pop	{r4, pc}

1000811a <__sfputs_r>:
1000811a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
1000811c:	1c06      	adds	r6, r0, #0
1000811e:	1c0f      	adds	r7, r1, #0
10008120:	1c14      	adds	r4, r2, #0
10008122:	18d5      	adds	r5, r2, r3
10008124:	42ac      	cmp	r4, r5
10008126:	d008      	beq.n	1000813a <__sfputs_r+0x20>
10008128:	7821      	ldrb	r1, [r4, #0]
1000812a:	1c30      	adds	r0, r6, #0
1000812c:	1c3a      	adds	r2, r7, #0
1000812e:	f7ff ffdf 	bl	100080f0 <__sfputc_r>
10008132:	3401      	adds	r4, #1
10008134:	1c43      	adds	r3, r0, #1
10008136:	d1f5      	bne.n	10008124 <__sfputs_r+0xa>
10008138:	e000      	b.n	1000813c <__sfputs_r+0x22>
1000813a:	2000      	movs	r0, #0
1000813c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

10008140 <_vfiprintf_r>:
10008140:	b5f0      	push	{r4, r5, r6, r7, lr}
10008142:	b09f      	sub	sp, #124	; 0x7c
10008144:	1c06      	adds	r6, r0, #0
10008146:	1c0f      	adds	r7, r1, #0
10008148:	9202      	str	r2, [sp, #8]
1000814a:	9305      	str	r3, [sp, #20]
1000814c:	2800      	cmp	r0, #0
1000814e:	d004      	beq.n	1000815a <_vfiprintf_r+0x1a>
10008150:	6983      	ldr	r3, [r0, #24]
10008152:	2b00      	cmp	r3, #0
10008154:	d101      	bne.n	1000815a <_vfiprintf_r+0x1a>
10008156:	f7ff fa83 	bl	10007660 <__sinit>
1000815a:	4b79      	ldr	r3, [pc, #484]	; (10008340 <_vfiprintf_r+0x200>)
1000815c:	429f      	cmp	r7, r3
1000815e:	d101      	bne.n	10008164 <_vfiprintf_r+0x24>
10008160:	6877      	ldr	r7, [r6, #4]
10008162:	e008      	b.n	10008176 <_vfiprintf_r+0x36>
10008164:	4b77      	ldr	r3, [pc, #476]	; (10008344 <_vfiprintf_r+0x204>)
10008166:	429f      	cmp	r7, r3
10008168:	d101      	bne.n	1000816e <_vfiprintf_r+0x2e>
1000816a:	68b7      	ldr	r7, [r6, #8]
1000816c:	e003      	b.n	10008176 <_vfiprintf_r+0x36>
1000816e:	4b76      	ldr	r3, [pc, #472]	; (10008348 <_vfiprintf_r+0x208>)
10008170:	429f      	cmp	r7, r3
10008172:	d100      	bne.n	10008176 <_vfiprintf_r+0x36>
10008174:	68f7      	ldr	r7, [r6, #12]
10008176:	89bb      	ldrh	r3, [r7, #12]
10008178:	071b      	lsls	r3, r3, #28
1000817a:	d50a      	bpl.n	10008192 <_vfiprintf_r+0x52>
1000817c:	693b      	ldr	r3, [r7, #16]
1000817e:	2b00      	cmp	r3, #0
10008180:	d007      	beq.n	10008192 <_vfiprintf_r+0x52>
10008182:	2300      	movs	r3, #0
10008184:	ad06      	add	r5, sp, #24
10008186:	616b      	str	r3, [r5, #20]
10008188:	3320      	adds	r3, #32
1000818a:	766b      	strb	r3, [r5, #25]
1000818c:	3310      	adds	r3, #16
1000818e:	76ab      	strb	r3, [r5, #26]
10008190:	e03d      	b.n	1000820e <_vfiprintf_r+0xce>
10008192:	1c30      	adds	r0, r6, #0
10008194:	1c39      	adds	r1, r7, #0
10008196:	f7fe fa6f 	bl	10006678 <__swsetup_r>
1000819a:	2800      	cmp	r0, #0
1000819c:	d0f1      	beq.n	10008182 <_vfiprintf_r+0x42>
1000819e:	2001      	movs	r0, #1
100081a0:	4240      	negs	r0, r0
100081a2:	e0ca      	b.n	1000833a <_vfiprintf_r+0x1fa>
100081a4:	9a05      	ldr	r2, [sp, #20]
100081a6:	1d11      	adds	r1, r2, #4
100081a8:	6812      	ldr	r2, [r2, #0]
100081aa:	9105      	str	r1, [sp, #20]
100081ac:	2a00      	cmp	r2, #0
100081ae:	db7e      	blt.n	100082ae <_vfiprintf_r+0x16e>
100081b0:	9209      	str	r2, [sp, #36]	; 0x24
100081b2:	3401      	adds	r4, #1
100081b4:	7823      	ldrb	r3, [r4, #0]
100081b6:	2b2e      	cmp	r3, #46	; 0x2e
100081b8:	d100      	bne.n	100081bc <_vfiprintf_r+0x7c>
100081ba:	e089      	b.n	100082d0 <_vfiprintf_r+0x190>
100081bc:	7821      	ldrb	r1, [r4, #0]
100081be:	4863      	ldr	r0, [pc, #396]	; (1000834c <_vfiprintf_r+0x20c>)
100081c0:	2203      	movs	r2, #3
100081c2:	f7ff fb3b 	bl	1000783c <memchr>
100081c6:	2800      	cmp	r0, #0
100081c8:	d008      	beq.n	100081dc <_vfiprintf_r+0x9c>
100081ca:	4b60      	ldr	r3, [pc, #384]	; (1000834c <_vfiprintf_r+0x20c>)
100081cc:	3401      	adds	r4, #1
100081ce:	1ac0      	subs	r0, r0, r3
100081d0:	2340      	movs	r3, #64	; 0x40
100081d2:	4083      	lsls	r3, r0
100081d4:	1c18      	adds	r0, r3, #0
100081d6:	682b      	ldr	r3, [r5, #0]
100081d8:	4318      	orrs	r0, r3
100081da:	6028      	str	r0, [r5, #0]
100081dc:	7821      	ldrb	r1, [r4, #0]
100081de:	1c63      	adds	r3, r4, #1
100081e0:	485b      	ldr	r0, [pc, #364]	; (10008350 <_vfiprintf_r+0x210>)
100081e2:	2206      	movs	r2, #6
100081e4:	9302      	str	r3, [sp, #8]
100081e6:	7629      	strb	r1, [r5, #24]
100081e8:	f7ff fb28 	bl	1000783c <memchr>
100081ec:	2800      	cmp	r0, #0
100081ee:	d100      	bne.n	100081f2 <_vfiprintf_r+0xb2>
100081f0:	e091      	b.n	10008316 <_vfiprintf_r+0x1d6>
100081f2:	4b58      	ldr	r3, [pc, #352]	; (10008354 <_vfiprintf_r+0x214>)
100081f4:	2b00      	cmp	r3, #0
100081f6:	d000      	beq.n	100081fa <_vfiprintf_r+0xba>
100081f8:	e084      	b.n	10008304 <_vfiprintf_r+0x1c4>
100081fa:	2207      	movs	r2, #7
100081fc:	9b05      	ldr	r3, [sp, #20]
100081fe:	3307      	adds	r3, #7
10008200:	4393      	bics	r3, r2
10008202:	3308      	adds	r3, #8
10008204:	9305      	str	r3, [sp, #20]
10008206:	696b      	ldr	r3, [r5, #20]
10008208:	9a03      	ldr	r2, [sp, #12]
1000820a:	189b      	adds	r3, r3, r2
1000820c:	616b      	str	r3, [r5, #20]
1000820e:	9c02      	ldr	r4, [sp, #8]
10008210:	7823      	ldrb	r3, [r4, #0]
10008212:	2b00      	cmp	r3, #0
10008214:	d104      	bne.n	10008220 <_vfiprintf_r+0xe0>
10008216:	9b02      	ldr	r3, [sp, #8]
10008218:	1ae3      	subs	r3, r4, r3
1000821a:	9304      	str	r3, [sp, #16]
1000821c:	d011      	beq.n	10008242 <_vfiprintf_r+0x102>
1000821e:	e003      	b.n	10008228 <_vfiprintf_r+0xe8>
10008220:	2b25      	cmp	r3, #37	; 0x25
10008222:	d0f8      	beq.n	10008216 <_vfiprintf_r+0xd6>
10008224:	3401      	adds	r4, #1
10008226:	e7f3      	b.n	10008210 <_vfiprintf_r+0xd0>
10008228:	9b04      	ldr	r3, [sp, #16]
1000822a:	1c30      	adds	r0, r6, #0
1000822c:	1c39      	adds	r1, r7, #0
1000822e:	9a02      	ldr	r2, [sp, #8]
10008230:	f7ff ff73 	bl	1000811a <__sfputs_r>
10008234:	1c43      	adds	r3, r0, #1
10008236:	d07b      	beq.n	10008330 <_vfiprintf_r+0x1f0>
10008238:	696a      	ldr	r2, [r5, #20]
1000823a:	9b04      	ldr	r3, [sp, #16]
1000823c:	4694      	mov	ip, r2
1000823e:	4463      	add	r3, ip
10008240:	616b      	str	r3, [r5, #20]
10008242:	7823      	ldrb	r3, [r4, #0]
10008244:	2b00      	cmp	r3, #0
10008246:	d073      	beq.n	10008330 <_vfiprintf_r+0x1f0>
10008248:	2201      	movs	r2, #1
1000824a:	2300      	movs	r3, #0
1000824c:	4252      	negs	r2, r2
1000824e:	606a      	str	r2, [r5, #4]
10008250:	a902      	add	r1, sp, #8
10008252:	3254      	adds	r2, #84	; 0x54
10008254:	1852      	adds	r2, r2, r1
10008256:	3401      	adds	r4, #1
10008258:	602b      	str	r3, [r5, #0]
1000825a:	60eb      	str	r3, [r5, #12]
1000825c:	60ab      	str	r3, [r5, #8]
1000825e:	7013      	strb	r3, [r2, #0]
10008260:	65ab      	str	r3, [r5, #88]	; 0x58
10008262:	7821      	ldrb	r1, [r4, #0]
10008264:	483c      	ldr	r0, [pc, #240]	; (10008358 <_vfiprintf_r+0x218>)
10008266:	2205      	movs	r2, #5
10008268:	f7ff fae8 	bl	1000783c <memchr>
1000826c:	2800      	cmp	r0, #0
1000826e:	d009      	beq.n	10008284 <_vfiprintf_r+0x144>
10008270:	4b39      	ldr	r3, [pc, #228]	; (10008358 <_vfiprintf_r+0x218>)
10008272:	3401      	adds	r4, #1
10008274:	1ac0      	subs	r0, r0, r3
10008276:	2301      	movs	r3, #1
10008278:	4083      	lsls	r3, r0
1000827a:	1c18      	adds	r0, r3, #0
1000827c:	682b      	ldr	r3, [r5, #0]
1000827e:	4318      	orrs	r0, r3
10008280:	6028      	str	r0, [r5, #0]
10008282:	e7ee      	b.n	10008262 <_vfiprintf_r+0x122>
10008284:	682b      	ldr	r3, [r5, #0]
10008286:	06da      	lsls	r2, r3, #27
10008288:	d504      	bpl.n	10008294 <_vfiprintf_r+0x154>
1000828a:	2253      	movs	r2, #83	; 0x53
1000828c:	2120      	movs	r1, #32
1000828e:	a802      	add	r0, sp, #8
10008290:	1812      	adds	r2, r2, r0
10008292:	7011      	strb	r1, [r2, #0]
10008294:	071a      	lsls	r2, r3, #28
10008296:	d504      	bpl.n	100082a2 <_vfiprintf_r+0x162>
10008298:	2253      	movs	r2, #83	; 0x53
1000829a:	212b      	movs	r1, #43	; 0x2b
1000829c:	a802      	add	r0, sp, #8
1000829e:	1812      	adds	r2, r2, r0
100082a0:	7011      	strb	r1, [r2, #0]
100082a2:	7822      	ldrb	r2, [r4, #0]
100082a4:	2a2a      	cmp	r2, #42	; 0x2a
100082a6:	d100      	bne.n	100082aa <_vfiprintf_r+0x16a>
100082a8:	e77c      	b.n	100081a4 <_vfiprintf_r+0x64>
100082aa:	9b09      	ldr	r3, [sp, #36]	; 0x24
100082ac:	e005      	b.n	100082ba <_vfiprintf_r+0x17a>
100082ae:	4252      	negs	r2, r2
100082b0:	60ea      	str	r2, [r5, #12]
100082b2:	2202      	movs	r2, #2
100082b4:	4313      	orrs	r3, r2
100082b6:	602b      	str	r3, [r5, #0]
100082b8:	e77b      	b.n	100081b2 <_vfiprintf_r+0x72>
100082ba:	7822      	ldrb	r2, [r4, #0]
100082bc:	3a30      	subs	r2, #48	; 0x30
100082be:	2a09      	cmp	r2, #9
100082c0:	d804      	bhi.n	100082cc <_vfiprintf_r+0x18c>
100082c2:	210a      	movs	r1, #10
100082c4:	434b      	muls	r3, r1
100082c6:	3401      	adds	r4, #1
100082c8:	189b      	adds	r3, r3, r2
100082ca:	e7f6      	b.n	100082ba <_vfiprintf_r+0x17a>
100082cc:	9309      	str	r3, [sp, #36]	; 0x24
100082ce:	e771      	b.n	100081b4 <_vfiprintf_r+0x74>
100082d0:	7863      	ldrb	r3, [r4, #1]
100082d2:	2b2a      	cmp	r3, #42	; 0x2a
100082d4:	d109      	bne.n	100082ea <_vfiprintf_r+0x1aa>
100082d6:	9b05      	ldr	r3, [sp, #20]
100082d8:	3402      	adds	r4, #2
100082da:	1d1a      	adds	r2, r3, #4
100082dc:	681b      	ldr	r3, [r3, #0]
100082de:	9205      	str	r2, [sp, #20]
100082e0:	2b00      	cmp	r3, #0
100082e2:	da0d      	bge.n	10008300 <_vfiprintf_r+0x1c0>
100082e4:	2301      	movs	r3, #1
100082e6:	425b      	negs	r3, r3
100082e8:	e00a      	b.n	10008300 <_vfiprintf_r+0x1c0>
100082ea:	2300      	movs	r3, #0
100082ec:	3401      	adds	r4, #1
100082ee:	7822      	ldrb	r2, [r4, #0]
100082f0:	3a30      	subs	r2, #48	; 0x30
100082f2:	2a09      	cmp	r2, #9
100082f4:	d804      	bhi.n	10008300 <_vfiprintf_r+0x1c0>
100082f6:	210a      	movs	r1, #10
100082f8:	434b      	muls	r3, r1
100082fa:	3401      	adds	r4, #1
100082fc:	189b      	adds	r3, r3, r2
100082fe:	e7f6      	b.n	100082ee <_vfiprintf_r+0x1ae>
10008300:	9307      	str	r3, [sp, #28]
10008302:	e75b      	b.n	100081bc <_vfiprintf_r+0x7c>
10008304:	ab05      	add	r3, sp, #20
10008306:	9300      	str	r3, [sp, #0]
10008308:	1c30      	adds	r0, r6, #0
1000830a:	1c29      	adds	r1, r5, #0
1000830c:	1c3a      	adds	r2, r7, #0
1000830e:	4b13      	ldr	r3, [pc, #76]	; (1000835c <_vfiprintf_r+0x21c>)
10008310:	f7fd fcb2 	bl	10005c78 <_printf_float>
10008314:	e007      	b.n	10008326 <_vfiprintf_r+0x1e6>
10008316:	ab05      	add	r3, sp, #20
10008318:	9300      	str	r3, [sp, #0]
1000831a:	1c30      	adds	r0, r6, #0
1000831c:	1c29      	adds	r1, r5, #0
1000831e:	1c3a      	adds	r2, r7, #0
10008320:	4b0e      	ldr	r3, [pc, #56]	; (1000835c <_vfiprintf_r+0x21c>)
10008322:	f7fd ff4f 	bl	100061c4 <_printf_i>
10008326:	9003      	str	r0, [sp, #12]
10008328:	9b03      	ldr	r3, [sp, #12]
1000832a:	3301      	adds	r3, #1
1000832c:	d000      	beq.n	10008330 <_vfiprintf_r+0x1f0>
1000832e:	e76a      	b.n	10008206 <_vfiprintf_r+0xc6>
10008330:	89bb      	ldrh	r3, [r7, #12]
10008332:	065b      	lsls	r3, r3, #25
10008334:	d500      	bpl.n	10008338 <_vfiprintf_r+0x1f8>
10008336:	e732      	b.n	1000819e <_vfiprintf_r+0x5e>
10008338:	980b      	ldr	r0, [sp, #44]	; 0x2c
1000833a:	b01f      	add	sp, #124	; 0x7c
1000833c:	bdf0      	pop	{r4, r5, r6, r7, pc}
1000833e:	46c0      	nop			; (mov r8, r8)
10008340:	1000a7f4 	.word	0x1000a7f4
10008344:	1000a814 	.word	0x1000a814
10008348:	1000a834 	.word	0x1000a834
1000834c:	1000a962 	.word	0x1000a962
10008350:	1000a966 	.word	0x1000a966
10008354:	10005c79 	.word	0x10005c79
10008358:	1000a95c 	.word	0x1000a95c
1000835c:	1000811b 	.word	0x1000811b

10008360 <__sread>:
10008360:	b538      	push	{r3, r4, r5, lr}
10008362:	1c0c      	adds	r4, r1, #0
10008364:	250e      	movs	r5, #14
10008366:	5f49      	ldrsh	r1, [r1, r5]
10008368:	f000 f8de 	bl	10008528 <_read_r>
1000836c:	2800      	cmp	r0, #0
1000836e:	db03      	blt.n	10008378 <__sread+0x18>
10008370:	6d63      	ldr	r3, [r4, #84]	; 0x54
10008372:	181b      	adds	r3, r3, r0
10008374:	6563      	str	r3, [r4, #84]	; 0x54
10008376:	e003      	b.n	10008380 <__sread+0x20>
10008378:	89a2      	ldrh	r2, [r4, #12]
1000837a:	4b02      	ldr	r3, [pc, #8]	; (10008384 <__sread+0x24>)
1000837c:	4013      	ands	r3, r2
1000837e:	81a3      	strh	r3, [r4, #12]
10008380:	bd38      	pop	{r3, r4, r5, pc}
10008382:	46c0      	nop			; (mov r8, r8)
10008384:	ffffefff 	.word	0xffffefff

10008388 <__swrite>:
10008388:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
1000838a:	1c1e      	adds	r6, r3, #0
1000838c:	898b      	ldrh	r3, [r1, #12]
1000838e:	1c05      	adds	r5, r0, #0
10008390:	1c0c      	adds	r4, r1, #0
10008392:	1c17      	adds	r7, r2, #0
10008394:	05db      	lsls	r3, r3, #23
10008396:	d505      	bpl.n	100083a4 <__swrite+0x1c>
10008398:	230e      	movs	r3, #14
1000839a:	5ec9      	ldrsh	r1, [r1, r3]
1000839c:	2200      	movs	r2, #0
1000839e:	2302      	movs	r3, #2
100083a0:	f000 f874 	bl	1000848c <_lseek_r>
100083a4:	89a2      	ldrh	r2, [r4, #12]
100083a6:	4b05      	ldr	r3, [pc, #20]	; (100083bc <__swrite+0x34>)
100083a8:	1c28      	adds	r0, r5, #0
100083aa:	4013      	ands	r3, r2
100083ac:	81a3      	strh	r3, [r4, #12]
100083ae:	1c3a      	adds	r2, r7, #0
100083b0:	230e      	movs	r3, #14
100083b2:	5ee1      	ldrsh	r1, [r4, r3]
100083b4:	1c33      	adds	r3, r6, #0
100083b6:	f000 f81f 	bl	100083f8 <_write_r>
100083ba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
100083bc:	ffffefff 	.word	0xffffefff

100083c0 <__sseek>:
100083c0:	b538      	push	{r3, r4, r5, lr}
100083c2:	1c0c      	adds	r4, r1, #0
100083c4:	250e      	movs	r5, #14
100083c6:	5f49      	ldrsh	r1, [r1, r5]
100083c8:	f000 f860 	bl	1000848c <_lseek_r>
100083cc:	89a3      	ldrh	r3, [r4, #12]
100083ce:	1c42      	adds	r2, r0, #1
100083d0:	d103      	bne.n	100083da <__sseek+0x1a>
100083d2:	4a05      	ldr	r2, [pc, #20]	; (100083e8 <__sseek+0x28>)
100083d4:	4013      	ands	r3, r2
100083d6:	81a3      	strh	r3, [r4, #12]
100083d8:	e004      	b.n	100083e4 <__sseek+0x24>
100083da:	2280      	movs	r2, #128	; 0x80
100083dc:	0152      	lsls	r2, r2, #5
100083de:	4313      	orrs	r3, r2
100083e0:	81a3      	strh	r3, [r4, #12]
100083e2:	6560      	str	r0, [r4, #84]	; 0x54
100083e4:	bd38      	pop	{r3, r4, r5, pc}
100083e6:	46c0      	nop			; (mov r8, r8)
100083e8:	ffffefff 	.word	0xffffefff

100083ec <__sclose>:
100083ec:	b508      	push	{r3, lr}
100083ee:	230e      	movs	r3, #14
100083f0:	5ec9      	ldrsh	r1, [r1, r3]
100083f2:	f000 f815 	bl	10008420 <_close_r>
100083f6:	bd08      	pop	{r3, pc}

100083f8 <_write_r>:
100083f8:	b538      	push	{r3, r4, r5, lr}
100083fa:	1c05      	adds	r5, r0, #0
100083fc:	2000      	movs	r0, #0
100083fe:	4c07      	ldr	r4, [pc, #28]	; (1000841c <_write_r+0x24>)
10008400:	6020      	str	r0, [r4, #0]
10008402:	1c08      	adds	r0, r1, #0
10008404:	1c11      	adds	r1, r2, #0
10008406:	1c1a      	adds	r2, r3, #0
10008408:	f002 f808 	bl	1000a41c <_write>
1000840c:	1c43      	adds	r3, r0, #1
1000840e:	d103      	bne.n	10008418 <_write_r+0x20>
10008410:	6823      	ldr	r3, [r4, #0]
10008412:	2b00      	cmp	r3, #0
10008414:	d000      	beq.n	10008418 <_write_r+0x20>
10008416:	602b      	str	r3, [r5, #0]
10008418:	bd38      	pop	{r3, r4, r5, pc}
1000841a:	46c0      	nop			; (mov r8, r8)
1000841c:	20000928 	.word	0x20000928

10008420 <_close_r>:
10008420:	b538      	push	{r3, r4, r5, lr}
10008422:	2300      	movs	r3, #0
10008424:	4c06      	ldr	r4, [pc, #24]	; (10008440 <_close_r+0x20>)
10008426:	1c05      	adds	r5, r0, #0
10008428:	1c08      	adds	r0, r1, #0
1000842a:	6023      	str	r3, [r4, #0]
1000842c:	f002 f822 	bl	1000a474 <_close>
10008430:	1c43      	adds	r3, r0, #1
10008432:	d103      	bne.n	1000843c <_close_r+0x1c>
10008434:	6823      	ldr	r3, [r4, #0]
10008436:	2b00      	cmp	r3, #0
10008438:	d000      	beq.n	1000843c <_close_r+0x1c>
1000843a:	602b      	str	r3, [r5, #0]
1000843c:	bd38      	pop	{r3, r4, r5, pc}
1000843e:	46c0      	nop			; (mov r8, r8)
10008440:	20000928 	.word	0x20000928

10008444 <_fstat_r>:
10008444:	b538      	push	{r3, r4, r5, lr}
10008446:	2300      	movs	r3, #0
10008448:	4c06      	ldr	r4, [pc, #24]	; (10008464 <_fstat_r+0x20>)
1000844a:	1c05      	adds	r5, r0, #0
1000844c:	1c08      	adds	r0, r1, #0
1000844e:	1c11      	adds	r1, r2, #0
10008450:	6023      	str	r3, [r4, #0]
10008452:	f002 f858 	bl	1000a506 <_fstat>
10008456:	1c43      	adds	r3, r0, #1
10008458:	d103      	bne.n	10008462 <_fstat_r+0x1e>
1000845a:	6823      	ldr	r3, [r4, #0]
1000845c:	2b00      	cmp	r3, #0
1000845e:	d000      	beq.n	10008462 <_fstat_r+0x1e>
10008460:	602b      	str	r3, [r5, #0]
10008462:	bd38      	pop	{r3, r4, r5, pc}
10008464:	20000928 	.word	0x20000928

10008468 <_isatty_r>:
10008468:	b538      	push	{r3, r4, r5, lr}
1000846a:	2300      	movs	r3, #0
1000846c:	4c06      	ldr	r4, [pc, #24]	; (10008488 <_isatty_r+0x20>)
1000846e:	1c05      	adds	r5, r0, #0
10008470:	1c08      	adds	r0, r1, #0
10008472:	6023      	str	r3, [r4, #0]
10008474:	f002 f854 	bl	1000a520 <_isatty>
10008478:	1c43      	adds	r3, r0, #1
1000847a:	d103      	bne.n	10008484 <_isatty_r+0x1c>
1000847c:	6823      	ldr	r3, [r4, #0]
1000847e:	2b00      	cmp	r3, #0
10008480:	d000      	beq.n	10008484 <_isatty_r+0x1c>
10008482:	602b      	str	r3, [r5, #0]
10008484:	bd38      	pop	{r3, r4, r5, pc}
10008486:	46c0      	nop			; (mov r8, r8)
10008488:	20000928 	.word	0x20000928

1000848c <_lseek_r>:
1000848c:	b538      	push	{r3, r4, r5, lr}
1000848e:	1c05      	adds	r5, r0, #0
10008490:	2000      	movs	r0, #0
10008492:	4c07      	ldr	r4, [pc, #28]	; (100084b0 <_lseek_r+0x24>)
10008494:	6020      	str	r0, [r4, #0]
10008496:	1c08      	adds	r0, r1, #0
10008498:	1c11      	adds	r1, r2, #0
1000849a:	1c1a      	adds	r2, r3, #0
1000849c:	f001 ffaa 	bl	1000a3f4 <_lseek>
100084a0:	1c43      	adds	r3, r0, #1
100084a2:	d103      	bne.n	100084ac <_lseek_r+0x20>
100084a4:	6823      	ldr	r3, [r4, #0]
100084a6:	2b00      	cmp	r3, #0
100084a8:	d000      	beq.n	100084ac <_lseek_r+0x20>
100084aa:	602b      	str	r3, [r5, #0]
100084ac:	bd38      	pop	{r3, r4, r5, pc}
100084ae:	46c0      	nop			; (mov r8, r8)
100084b0:	20000928 	.word	0x20000928

100084b4 <memmove>:
100084b4:	b510      	push	{r4, lr}
100084b6:	4281      	cmp	r1, r0
100084b8:	d208      	bcs.n	100084cc <memmove+0x18>
100084ba:	188b      	adds	r3, r1, r2
100084bc:	4298      	cmp	r0, r3
100084be:	d205      	bcs.n	100084cc <memmove+0x18>
100084c0:	1a9b      	subs	r3, r3, r2
100084c2:	3a01      	subs	r2, #1
100084c4:	d309      	bcc.n	100084da <memmove+0x26>
100084c6:	5c99      	ldrb	r1, [r3, r2]
100084c8:	5481      	strb	r1, [r0, r2]
100084ca:	e7fa      	b.n	100084c2 <memmove+0xe>
100084cc:	2300      	movs	r3, #0
100084ce:	4293      	cmp	r3, r2
100084d0:	d003      	beq.n	100084da <memmove+0x26>
100084d2:	5ccc      	ldrb	r4, [r1, r3]
100084d4:	54c4      	strb	r4, [r0, r3]
100084d6:	3301      	adds	r3, #1
100084d8:	e7f9      	b.n	100084ce <memmove+0x1a>
100084da:	bd10      	pop	{r4, pc}

100084dc <_realloc_r>:
100084dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
100084de:	1c06      	adds	r6, r0, #0
100084e0:	1c0c      	adds	r4, r1, #0
100084e2:	1c15      	adds	r5, r2, #0
100084e4:	2900      	cmp	r1, #0
100084e6:	d104      	bne.n	100084f2 <_realloc_r+0x16>
100084e8:	1c11      	adds	r1, r2, #0
100084ea:	f7fd fad7 	bl	10005a9c <_malloc_r>
100084ee:	1c04      	adds	r4, r0, #0
100084f0:	e018      	b.n	10008524 <_realloc_r+0x48>
100084f2:	2a00      	cmp	r2, #0
100084f4:	d103      	bne.n	100084fe <_realloc_r+0x22>
100084f6:	f7fd fa8b 	bl	10005a10 <_free_r>
100084fa:	1c2c      	adds	r4, r5, #0
100084fc:	e012      	b.n	10008524 <_realloc_r+0x48>
100084fe:	f000 f827 	bl	10008550 <_malloc_usable_size_r>
10008502:	42a8      	cmp	r0, r5
10008504:	d20e      	bcs.n	10008524 <_realloc_r+0x48>
10008506:	1c30      	adds	r0, r6, #0
10008508:	1c29      	adds	r1, r5, #0
1000850a:	f7fd fac7 	bl	10005a9c <_malloc_r>
1000850e:	1e07      	subs	r7, r0, #0
10008510:	d007      	beq.n	10008522 <_realloc_r+0x46>
10008512:	1c21      	adds	r1, r4, #0
10008514:	1c2a      	adds	r2, r5, #0
10008516:	f7fd fa69 	bl	100059ec <memcpy>
1000851a:	1c30      	adds	r0, r6, #0
1000851c:	1c21      	adds	r1, r4, #0
1000851e:	f7fd fa77 	bl	10005a10 <_free_r>
10008522:	1c3c      	adds	r4, r7, #0
10008524:	1c20      	adds	r0, r4, #0
10008526:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

10008528 <_read_r>:
10008528:	b538      	push	{r3, r4, r5, lr}
1000852a:	1c05      	adds	r5, r0, #0
1000852c:	2000      	movs	r0, #0
1000852e:	4c07      	ldr	r4, [pc, #28]	; (1000854c <_read_r+0x24>)
10008530:	6020      	str	r0, [r4, #0]
10008532:	1c08      	adds	r0, r1, #0
10008534:	1c11      	adds	r1, r2, #0
10008536:	1c1a      	adds	r2, r3, #0
10008538:	f001 ff06 	bl	1000a348 <_read>
1000853c:	1c43      	adds	r3, r0, #1
1000853e:	d103      	bne.n	10008548 <_read_r+0x20>
10008540:	6823      	ldr	r3, [r4, #0]
10008542:	2b00      	cmp	r3, #0
10008544:	d000      	beq.n	10008548 <_read_r+0x20>
10008546:	602b      	str	r3, [r5, #0]
10008548:	bd38      	pop	{r3, r4, r5, pc}
1000854a:	46c0      	nop			; (mov r8, r8)
1000854c:	20000928 	.word	0x20000928

10008550 <_malloc_usable_size_r>:
10008550:	1f0b      	subs	r3, r1, #4
10008552:	681a      	ldr	r2, [r3, #0]
10008554:	1f10      	subs	r0, r2, #4
10008556:	2a00      	cmp	r2, #0
10008558:	da04      	bge.n	10008564 <_malloc_usable_size_r+0x14>
1000855a:	1889      	adds	r1, r1, r2
1000855c:	3904      	subs	r1, #4
1000855e:	680b      	ldr	r3, [r1, #0]
10008560:	18d0      	adds	r0, r2, r3
10008562:	3804      	subs	r0, #4
10008564:	4770      	bx	lr
	...

10008568 <__gnu_thumb1_case_uqi>:
10008568:	b402      	push	{r1}
1000856a:	4671      	mov	r1, lr
1000856c:	0849      	lsrs	r1, r1, #1
1000856e:	0049      	lsls	r1, r1, #1
10008570:	5c09      	ldrb	r1, [r1, r0]
10008572:	0049      	lsls	r1, r1, #1
10008574:	448e      	add	lr, r1
10008576:	bc02      	pop	{r1}
10008578:	4770      	bx	lr
1000857a:	46c0      	nop			; (mov r8, r8)

1000857c <__aeabi_cdrcmple>:
1000857c:	4684      	mov	ip, r0
1000857e:	1c10      	adds	r0, r2, #0
10008580:	4662      	mov	r2, ip
10008582:	468c      	mov	ip, r1
10008584:	1c19      	adds	r1, r3, #0
10008586:	4663      	mov	r3, ip
10008588:	e000      	b.n	1000858c <__aeabi_cdcmpeq>
1000858a:	46c0      	nop			; (mov r8, r8)

1000858c <__aeabi_cdcmpeq>:
1000858c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
1000858e:	f000 ff33 	bl	100093f8 <__ledf2>
10008592:	2800      	cmp	r0, #0
10008594:	d401      	bmi.n	1000859a <__aeabi_cdcmpeq+0xe>
10008596:	2100      	movs	r1, #0
10008598:	42c8      	cmn	r0, r1
1000859a:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}

1000859c <__aeabi_dcmpeq>:
1000859c:	b510      	push	{r4, lr}
1000859e:	f000 fe77 	bl	10009290 <__eqdf2>
100085a2:	4240      	negs	r0, r0
100085a4:	3001      	adds	r0, #1
100085a6:	bd10      	pop	{r4, pc}

100085a8 <__aeabi_dcmplt>:
100085a8:	b510      	push	{r4, lr}
100085aa:	f000 ff25 	bl	100093f8 <__ledf2>
100085ae:	2800      	cmp	r0, #0
100085b0:	db01      	blt.n	100085b6 <__aeabi_dcmplt+0xe>
100085b2:	2000      	movs	r0, #0
100085b4:	bd10      	pop	{r4, pc}
100085b6:	2001      	movs	r0, #1
100085b8:	bd10      	pop	{r4, pc}
100085ba:	46c0      	nop			; (mov r8, r8)

100085bc <__aeabi_dcmple>:
100085bc:	b510      	push	{r4, lr}
100085be:	f000 ff1b 	bl	100093f8 <__ledf2>
100085c2:	2800      	cmp	r0, #0
100085c4:	dd01      	ble.n	100085ca <__aeabi_dcmple+0xe>
100085c6:	2000      	movs	r0, #0
100085c8:	bd10      	pop	{r4, pc}
100085ca:	2001      	movs	r0, #1
100085cc:	bd10      	pop	{r4, pc}
100085ce:	46c0      	nop			; (mov r8, r8)

100085d0 <__aeabi_dcmpgt>:
100085d0:	b510      	push	{r4, lr}
100085d2:	f000 fea1 	bl	10009318 <__gedf2>
100085d6:	2800      	cmp	r0, #0
100085d8:	dc01      	bgt.n	100085de <__aeabi_dcmpgt+0xe>
100085da:	2000      	movs	r0, #0
100085dc:	bd10      	pop	{r4, pc}
100085de:	2001      	movs	r0, #1
100085e0:	bd10      	pop	{r4, pc}
100085e2:	46c0      	nop			; (mov r8, r8)

100085e4 <__aeabi_dcmpge>:
100085e4:	b510      	push	{r4, lr}
100085e6:	f000 fe97 	bl	10009318 <__gedf2>
100085ea:	2800      	cmp	r0, #0
100085ec:	da01      	bge.n	100085f2 <__aeabi_dcmpge+0xe>
100085ee:	2000      	movs	r0, #0
100085f0:	bd10      	pop	{r4, pc}
100085f2:	2001      	movs	r0, #1
100085f4:	bd10      	pop	{r4, pc}
100085f6:	46c0      	nop			; (mov r8, r8)

100085f8 <__aeabi_dadd>:
100085f8:	b5f0      	push	{r4, r5, r6, r7, lr}
100085fa:	4645      	mov	r5, r8
100085fc:	4657      	mov	r7, sl
100085fe:	464e      	mov	r6, r9
10008600:	4694      	mov	ip, r2
10008602:	004c      	lsls	r4, r1, #1
10008604:	030a      	lsls	r2, r1, #12
10008606:	0fc9      	lsrs	r1, r1, #31
10008608:	b4e0      	push	{r5, r6, r7}
1000860a:	4688      	mov	r8, r1
1000860c:	1c0e      	adds	r6, r1, #0
1000860e:	0319      	lsls	r1, r3, #12
10008610:	0f47      	lsrs	r7, r0, #29
10008612:	00c5      	lsls	r5, r0, #3
10008614:	0a48      	lsrs	r0, r1, #9
10008616:	4661      	mov	r1, ip
10008618:	0f49      	lsrs	r1, r1, #29
1000861a:	4301      	orrs	r1, r0
1000861c:	4660      	mov	r0, ip
1000861e:	0a52      	lsrs	r2, r2, #9
10008620:	4317      	orrs	r7, r2
10008622:	00c0      	lsls	r0, r0, #3
10008624:	005a      	lsls	r2, r3, #1
10008626:	0d64      	lsrs	r4, r4, #21
10008628:	0d52      	lsrs	r2, r2, #21
1000862a:	0fdb      	lsrs	r3, r3, #31
1000862c:	4684      	mov	ip, r0
1000862e:	4598      	cmp	r8, r3
10008630:	d100      	bne.n	10008634 <__aeabi_dadd+0x3c>
10008632:	e0a7      	b.n	10008784 <__aeabi_dadd+0x18c>
10008634:	1aa0      	subs	r0, r4, r2
10008636:	2800      	cmp	r0, #0
10008638:	dc00      	bgt.n	1000863c <__aeabi_dadd+0x44>
1000863a:	e101      	b.n	10008840 <__aeabi_dadd+0x248>
1000863c:	2a00      	cmp	r2, #0
1000863e:	d13d      	bne.n	100086bc <__aeabi_dadd+0xc4>
10008640:	4663      	mov	r3, ip
10008642:	430b      	orrs	r3, r1
10008644:	d000      	beq.n	10008648 <__aeabi_dadd+0x50>
10008646:	e0d4      	b.n	100087f2 <__aeabi_dadd+0x1fa>
10008648:	076b      	lsls	r3, r5, #29
1000864a:	d100      	bne.n	1000864e <__aeabi_dadd+0x56>
1000864c:	e088      	b.n	10008760 <__aeabi_dadd+0x168>
1000864e:	230f      	movs	r3, #15
10008650:	402b      	ands	r3, r5
10008652:	2b04      	cmp	r3, #4
10008654:	d100      	bne.n	10008658 <__aeabi_dadd+0x60>
10008656:	e083      	b.n	10008760 <__aeabi_dadd+0x168>
10008658:	1d2a      	adds	r2, r5, #4
1000865a:	42aa      	cmp	r2, r5
1000865c:	41ad      	sbcs	r5, r5
1000865e:	2380      	movs	r3, #128	; 0x80
10008660:	426d      	negs	r5, r5
10008662:	197f      	adds	r7, r7, r5
10008664:	041b      	lsls	r3, r3, #16
10008666:	403b      	ands	r3, r7
10008668:	4646      	mov	r6, r8
1000866a:	1c15      	adds	r5, r2, #0
1000866c:	2b00      	cmp	r3, #0
1000866e:	d100      	bne.n	10008672 <__aeabi_dadd+0x7a>
10008670:	e07c      	b.n	1000876c <__aeabi_dadd+0x174>
10008672:	4bcc      	ldr	r3, [pc, #816]	; (100089a4 <__aeabi_dadd+0x3ac>)
10008674:	3401      	adds	r4, #1
10008676:	429c      	cmp	r4, r3
10008678:	d100      	bne.n	1000867c <__aeabi_dadd+0x84>
1000867a:	e0fd      	b.n	10008878 <__aeabi_dadd+0x280>
1000867c:	1c3a      	adds	r2, r7, #0
1000867e:	4bca      	ldr	r3, [pc, #808]	; (100089a8 <__aeabi_dadd+0x3b0>)
10008680:	08ed      	lsrs	r5, r5, #3
10008682:	401a      	ands	r2, r3
10008684:	0750      	lsls	r0, r2, #29
10008686:	0564      	lsls	r4, r4, #21
10008688:	0252      	lsls	r2, r2, #9
1000868a:	4305      	orrs	r5, r0
1000868c:	0b12      	lsrs	r2, r2, #12
1000868e:	0d64      	lsrs	r4, r4, #21
10008690:	2100      	movs	r1, #0
10008692:	0312      	lsls	r2, r2, #12
10008694:	0d0b      	lsrs	r3, r1, #20
10008696:	051b      	lsls	r3, r3, #20
10008698:	0564      	lsls	r4, r4, #21
1000869a:	0b12      	lsrs	r2, r2, #12
1000869c:	431a      	orrs	r2, r3
1000869e:	0863      	lsrs	r3, r4, #1
100086a0:	4cc2      	ldr	r4, [pc, #776]	; (100089ac <__aeabi_dadd+0x3b4>)
100086a2:	07f6      	lsls	r6, r6, #31
100086a4:	4014      	ands	r4, r2
100086a6:	431c      	orrs	r4, r3
100086a8:	0064      	lsls	r4, r4, #1
100086aa:	0864      	lsrs	r4, r4, #1
100086ac:	4334      	orrs	r4, r6
100086ae:	1c28      	adds	r0, r5, #0
100086b0:	1c21      	adds	r1, r4, #0
100086b2:	bc1c      	pop	{r2, r3, r4}
100086b4:	4690      	mov	r8, r2
100086b6:	4699      	mov	r9, r3
100086b8:	46a2      	mov	sl, r4
100086ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
100086bc:	4bb9      	ldr	r3, [pc, #740]	; (100089a4 <__aeabi_dadd+0x3ac>)
100086be:	429c      	cmp	r4, r3
100086c0:	d0c2      	beq.n	10008648 <__aeabi_dadd+0x50>
100086c2:	2380      	movs	r3, #128	; 0x80
100086c4:	041b      	lsls	r3, r3, #16
100086c6:	4319      	orrs	r1, r3
100086c8:	2838      	cmp	r0, #56	; 0x38
100086ca:	dd00      	ble.n	100086ce <__aeabi_dadd+0xd6>
100086cc:	e0ec      	b.n	100088a8 <__aeabi_dadd+0x2b0>
100086ce:	281f      	cmp	r0, #31
100086d0:	dd00      	ble.n	100086d4 <__aeabi_dadd+0xdc>
100086d2:	e121      	b.n	10008918 <__aeabi_dadd+0x320>
100086d4:	2220      	movs	r2, #32
100086d6:	1c0e      	adds	r6, r1, #0
100086d8:	4663      	mov	r3, ip
100086da:	1a12      	subs	r2, r2, r0
100086dc:	4096      	lsls	r6, r2
100086de:	40c3      	lsrs	r3, r0
100086e0:	4333      	orrs	r3, r6
100086e2:	4666      	mov	r6, ip
100086e4:	4096      	lsls	r6, r2
100086e6:	1c32      	adds	r2, r6, #0
100086e8:	1e56      	subs	r6, r2, #1
100086ea:	41b2      	sbcs	r2, r6
100086ec:	4313      	orrs	r3, r2
100086ee:	1c0a      	adds	r2, r1, #0
100086f0:	40c2      	lsrs	r2, r0
100086f2:	1aeb      	subs	r3, r5, r3
100086f4:	429d      	cmp	r5, r3
100086f6:	41b6      	sbcs	r6, r6
100086f8:	1c1d      	adds	r5, r3, #0
100086fa:	1aba      	subs	r2, r7, r2
100086fc:	4276      	negs	r6, r6
100086fe:	1b97      	subs	r7, r2, r6
10008700:	023b      	lsls	r3, r7, #8
10008702:	d400      	bmi.n	10008706 <__aeabi_dadd+0x10e>
10008704:	e097      	b.n	10008836 <__aeabi_dadd+0x23e>
10008706:	027a      	lsls	r2, r7, #9
10008708:	0a56      	lsrs	r6, r2, #9
1000870a:	2e00      	cmp	r6, #0
1000870c:	d100      	bne.n	10008710 <__aeabi_dadd+0x118>
1000870e:	e0b6      	b.n	1000887e <__aeabi_dadd+0x286>
10008710:	1c30      	adds	r0, r6, #0
10008712:	f7fd f933 	bl	1000597c <__clzsi2>
10008716:	1c03      	adds	r3, r0, #0
10008718:	3b08      	subs	r3, #8
1000871a:	2b1f      	cmp	r3, #31
1000871c:	dd00      	ble.n	10008720 <__aeabi_dadd+0x128>
1000871e:	e0b7      	b.n	10008890 <__aeabi_dadd+0x298>
10008720:	409e      	lsls	r6, r3
10008722:	1c37      	adds	r7, r6, #0
10008724:	2628      	movs	r6, #40	; 0x28
10008726:	1c2a      	adds	r2, r5, #0
10008728:	1a36      	subs	r6, r6, r0
1000872a:	40f2      	lsrs	r2, r6
1000872c:	1c16      	adds	r6, r2, #0
1000872e:	409d      	lsls	r5, r3
10008730:	433e      	orrs	r6, r7
10008732:	429c      	cmp	r4, r3
10008734:	dd00      	ble.n	10008738 <__aeabi_dadd+0x140>
10008736:	e0b2      	b.n	1000889e <__aeabi_dadd+0x2a6>
10008738:	1b1c      	subs	r4, r3, r4
1000873a:	1c62      	adds	r2, r4, #1
1000873c:	2a1f      	cmp	r2, #31
1000873e:	dd00      	ble.n	10008742 <__aeabi_dadd+0x14a>
10008740:	e0d8      	b.n	100088f4 <__aeabi_dadd+0x2fc>
10008742:	231f      	movs	r3, #31
10008744:	1c29      	adds	r1, r5, #0
10008746:	1b1c      	subs	r4, r3, r4
10008748:	1c33      	adds	r3, r6, #0
1000874a:	40a5      	lsls	r5, r4
1000874c:	40a3      	lsls	r3, r4
1000874e:	40d1      	lsrs	r1, r2
10008750:	1e6c      	subs	r4, r5, #1
10008752:	41a5      	sbcs	r5, r4
10008754:	40d6      	lsrs	r6, r2
10008756:	4319      	orrs	r1, r3
10008758:	430d      	orrs	r5, r1
1000875a:	1c37      	adds	r7, r6, #0
1000875c:	2400      	movs	r4, #0
1000875e:	e773      	b.n	10008648 <__aeabi_dadd+0x50>
10008760:	2380      	movs	r3, #128	; 0x80
10008762:	041b      	lsls	r3, r3, #16
10008764:	403b      	ands	r3, r7
10008766:	4646      	mov	r6, r8
10008768:	d000      	beq.n	1000876c <__aeabi_dadd+0x174>
1000876a:	e782      	b.n	10008672 <__aeabi_dadd+0x7a>
1000876c:	4b8d      	ldr	r3, [pc, #564]	; (100089a4 <__aeabi_dadd+0x3ac>)
1000876e:	08ed      	lsrs	r5, r5, #3
10008770:	0778      	lsls	r0, r7, #29
10008772:	4305      	orrs	r5, r0
10008774:	08fa      	lsrs	r2, r7, #3
10008776:	429c      	cmp	r4, r3
10008778:	d032      	beq.n	100087e0 <__aeabi_dadd+0x1e8>
1000877a:	0312      	lsls	r2, r2, #12
1000877c:	0564      	lsls	r4, r4, #21
1000877e:	0b12      	lsrs	r2, r2, #12
10008780:	0d64      	lsrs	r4, r4, #21
10008782:	e785      	b.n	10008690 <__aeabi_dadd+0x98>
10008784:	1aa3      	subs	r3, r4, r2
10008786:	2b00      	cmp	r3, #0
10008788:	dc00      	bgt.n	1000878c <__aeabi_dadd+0x194>
1000878a:	e094      	b.n	100088b6 <__aeabi_dadd+0x2be>
1000878c:	2a00      	cmp	r2, #0
1000878e:	d03c      	beq.n	1000880a <__aeabi_dadd+0x212>
10008790:	4a84      	ldr	r2, [pc, #528]	; (100089a4 <__aeabi_dadd+0x3ac>)
10008792:	4294      	cmp	r4, r2
10008794:	d100      	bne.n	10008798 <__aeabi_dadd+0x1a0>
10008796:	e757      	b.n	10008648 <__aeabi_dadd+0x50>
10008798:	2280      	movs	r2, #128	; 0x80
1000879a:	0412      	lsls	r2, r2, #16
1000879c:	4311      	orrs	r1, r2
1000879e:	2b38      	cmp	r3, #56	; 0x38
100087a0:	dc00      	bgt.n	100087a4 <__aeabi_dadd+0x1ac>
100087a2:	e105      	b.n	100089b0 <__aeabi_dadd+0x3b8>
100087a4:	4663      	mov	r3, ip
100087a6:	4319      	orrs	r1, r3
100087a8:	1e48      	subs	r0, r1, #1
100087aa:	4181      	sbcs	r1, r0
100087ac:	2200      	movs	r2, #0
100087ae:	b2c8      	uxtb	r0, r1
100087b0:	1940      	adds	r0, r0, r5
100087b2:	42a8      	cmp	r0, r5
100087b4:	419b      	sbcs	r3, r3
100087b6:	1c05      	adds	r5, r0, #0
100087b8:	19d2      	adds	r2, r2, r7
100087ba:	425b      	negs	r3, r3
100087bc:	18d7      	adds	r7, r2, r3
100087be:	023b      	lsls	r3, r7, #8
100087c0:	d539      	bpl.n	10008836 <__aeabi_dadd+0x23e>
100087c2:	4b78      	ldr	r3, [pc, #480]	; (100089a4 <__aeabi_dadd+0x3ac>)
100087c4:	3401      	adds	r4, #1
100087c6:	429c      	cmp	r4, r3
100087c8:	d100      	bne.n	100087cc <__aeabi_dadd+0x1d4>
100087ca:	e14c      	b.n	10008a66 <__aeabi_dadd+0x46e>
100087cc:	2001      	movs	r0, #1
100087ce:	4a76      	ldr	r2, [pc, #472]	; (100089a8 <__aeabi_dadd+0x3b0>)
100087d0:	086b      	lsrs	r3, r5, #1
100087d2:	403a      	ands	r2, r7
100087d4:	4028      	ands	r0, r5
100087d6:	4318      	orrs	r0, r3
100087d8:	07d5      	lsls	r5, r2, #31
100087da:	4305      	orrs	r5, r0
100087dc:	0857      	lsrs	r7, r2, #1
100087de:	e733      	b.n	10008648 <__aeabi_dadd+0x50>
100087e0:	1c2b      	adds	r3, r5, #0
100087e2:	4313      	orrs	r3, r2
100087e4:	d048      	beq.n	10008878 <__aeabi_dadd+0x280>
100087e6:	2380      	movs	r3, #128	; 0x80
100087e8:	031b      	lsls	r3, r3, #12
100087ea:	431a      	orrs	r2, r3
100087ec:	0312      	lsls	r2, r2, #12
100087ee:	0b12      	lsrs	r2, r2, #12
100087f0:	e74e      	b.n	10008690 <__aeabi_dadd+0x98>
100087f2:	3801      	subs	r0, #1
100087f4:	2800      	cmp	r0, #0
100087f6:	d178      	bne.n	100088ea <__aeabi_dadd+0x2f2>
100087f8:	4663      	mov	r3, ip
100087fa:	1aee      	subs	r6, r5, r3
100087fc:	42b5      	cmp	r5, r6
100087fe:	419b      	sbcs	r3, r3
10008800:	1a7a      	subs	r2, r7, r1
10008802:	425b      	negs	r3, r3
10008804:	1ad7      	subs	r7, r2, r3
10008806:	1c35      	adds	r5, r6, #0
10008808:	e77a      	b.n	10008700 <__aeabi_dadd+0x108>
1000880a:	1c02      	adds	r2, r0, #0
1000880c:	430a      	orrs	r2, r1
1000880e:	d100      	bne.n	10008812 <__aeabi_dadd+0x21a>
10008810:	e71a      	b.n	10008648 <__aeabi_dadd+0x50>
10008812:	3b01      	subs	r3, #1
10008814:	2b00      	cmp	r3, #0
10008816:	d000      	beq.n	1000881a <__aeabi_dadd+0x222>
10008818:	e0f2      	b.n	10008a00 <__aeabi_dadd+0x408>
1000881a:	1940      	adds	r0, r0, r5
1000881c:	42a8      	cmp	r0, r5
1000881e:	419b      	sbcs	r3, r3
10008820:	19ca      	adds	r2, r1, r7
10008822:	425b      	negs	r3, r3
10008824:	18d7      	adds	r7, r2, r3
10008826:	1c05      	adds	r5, r0, #0
10008828:	e7c9      	b.n	100087be <__aeabi_dadd+0x1c6>
1000882a:	1c13      	adds	r3, r2, #0
1000882c:	4333      	orrs	r3, r6
1000882e:	d100      	bne.n	10008832 <__aeabi_dadd+0x23a>
10008830:	e118      	b.n	10008a64 <__aeabi_dadd+0x46c>
10008832:	1c17      	adds	r7, r2, #0
10008834:	1c35      	adds	r5, r6, #0
10008836:	4646      	mov	r6, r8
10008838:	076b      	lsls	r3, r5, #29
1000883a:	d000      	beq.n	1000883e <__aeabi_dadd+0x246>
1000883c:	e707      	b.n	1000864e <__aeabi_dadd+0x56>
1000883e:	e795      	b.n	1000876c <__aeabi_dadd+0x174>
10008840:	2800      	cmp	r0, #0
10008842:	d17a      	bne.n	1000893a <__aeabi_dadd+0x342>
10008844:	1c62      	adds	r2, r4, #1
10008846:	0552      	lsls	r2, r2, #21
10008848:	0d52      	lsrs	r2, r2, #21
1000884a:	2a01      	cmp	r2, #1
1000884c:	dc00      	bgt.n	10008850 <__aeabi_dadd+0x258>
1000884e:	e0fb      	b.n	10008a48 <__aeabi_dadd+0x450>
10008850:	4662      	mov	r2, ip
10008852:	1aaa      	subs	r2, r5, r2
10008854:	4295      	cmp	r5, r2
10008856:	41b6      	sbcs	r6, r6
10008858:	4691      	mov	r9, r2
1000885a:	1a78      	subs	r0, r7, r1
1000885c:	4272      	negs	r2, r6
1000885e:	1a86      	subs	r6, r0, r2
10008860:	0232      	lsls	r2, r6, #8
10008862:	d400      	bmi.n	10008866 <__aeabi_dadd+0x26e>
10008864:	e093      	b.n	1000898e <__aeabi_dadd+0x396>
10008866:	4662      	mov	r2, ip
10008868:	1b55      	subs	r5, r2, r5
1000886a:	45ac      	cmp	ip, r5
1000886c:	4180      	sbcs	r0, r0
1000886e:	1bcf      	subs	r7, r1, r7
10008870:	4240      	negs	r0, r0
10008872:	1a3e      	subs	r6, r7, r0
10008874:	4698      	mov	r8, r3
10008876:	e748      	b.n	1000870a <__aeabi_dadd+0x112>
10008878:	2200      	movs	r2, #0
1000887a:	2500      	movs	r5, #0
1000887c:	e708      	b.n	10008690 <__aeabi_dadd+0x98>
1000887e:	1c28      	adds	r0, r5, #0
10008880:	f7fd f87c 	bl	1000597c <__clzsi2>
10008884:	3020      	adds	r0, #32
10008886:	1c03      	adds	r3, r0, #0
10008888:	3b08      	subs	r3, #8
1000888a:	2b1f      	cmp	r3, #31
1000888c:	dc00      	bgt.n	10008890 <__aeabi_dadd+0x298>
1000888e:	e747      	b.n	10008720 <__aeabi_dadd+0x128>
10008890:	3828      	subs	r0, #40	; 0x28
10008892:	4085      	lsls	r5, r0
10008894:	1c2e      	adds	r6, r5, #0
10008896:	2500      	movs	r5, #0
10008898:	429c      	cmp	r4, r3
1000889a:	dc00      	bgt.n	1000889e <__aeabi_dadd+0x2a6>
1000889c:	e74c      	b.n	10008738 <__aeabi_dadd+0x140>
1000889e:	4a42      	ldr	r2, [pc, #264]	; (100089a8 <__aeabi_dadd+0x3b0>)
100088a0:	1ae4      	subs	r4, r4, r3
100088a2:	4016      	ands	r6, r2
100088a4:	1c37      	adds	r7, r6, #0
100088a6:	e6cf      	b.n	10008648 <__aeabi_dadd+0x50>
100088a8:	4663      	mov	r3, ip
100088aa:	4319      	orrs	r1, r3
100088ac:	1e4b      	subs	r3, r1, #1
100088ae:	4199      	sbcs	r1, r3
100088b0:	2200      	movs	r2, #0
100088b2:	b2cb      	uxtb	r3, r1
100088b4:	e71d      	b.n	100086f2 <__aeabi_dadd+0xfa>
100088b6:	2b00      	cmp	r3, #0
100088b8:	d000      	beq.n	100088bc <__aeabi_dadd+0x2c4>
100088ba:	e0f2      	b.n	10008aa2 <__aeabi_dadd+0x4aa>
100088bc:	1c60      	adds	r0, r4, #1
100088be:	0543      	lsls	r3, r0, #21
100088c0:	0d5b      	lsrs	r3, r3, #21
100088c2:	2b01      	cmp	r3, #1
100088c4:	dc00      	bgt.n	100088c8 <__aeabi_dadd+0x2d0>
100088c6:	e0a4      	b.n	10008a12 <__aeabi_dadd+0x41a>
100088c8:	4b36      	ldr	r3, [pc, #216]	; (100089a4 <__aeabi_dadd+0x3ac>)
100088ca:	4298      	cmp	r0, r3
100088cc:	d100      	bne.n	100088d0 <__aeabi_dadd+0x2d8>
100088ce:	e121      	b.n	10008b14 <__aeabi_dadd+0x51c>
100088d0:	4663      	mov	r3, ip
100088d2:	195c      	adds	r4, r3, r5
100088d4:	42ac      	cmp	r4, r5
100088d6:	419b      	sbcs	r3, r3
100088d8:	19cf      	adds	r7, r1, r7
100088da:	425b      	negs	r3, r3
100088dc:	18fa      	adds	r2, r7, r3
100088de:	0864      	lsrs	r4, r4, #1
100088e0:	07d5      	lsls	r5, r2, #31
100088e2:	4325      	orrs	r5, r4
100088e4:	0857      	lsrs	r7, r2, #1
100088e6:	1c04      	adds	r4, r0, #0
100088e8:	e6ae      	b.n	10008648 <__aeabi_dadd+0x50>
100088ea:	4b2e      	ldr	r3, [pc, #184]	; (100089a4 <__aeabi_dadd+0x3ac>)
100088ec:	429c      	cmp	r4, r3
100088ee:	d000      	beq.n	100088f2 <__aeabi_dadd+0x2fa>
100088f0:	e6ea      	b.n	100086c8 <__aeabi_dadd+0xd0>
100088f2:	e6a9      	b.n	10008648 <__aeabi_dadd+0x50>
100088f4:	1c21      	adds	r1, r4, #0
100088f6:	1c33      	adds	r3, r6, #0
100088f8:	391f      	subs	r1, #31
100088fa:	40cb      	lsrs	r3, r1
100088fc:	1c19      	adds	r1, r3, #0
100088fe:	2a20      	cmp	r2, #32
10008900:	d100      	bne.n	10008904 <__aeabi_dadd+0x30c>
10008902:	e082      	b.n	10008a0a <__aeabi_dadd+0x412>
10008904:	233f      	movs	r3, #63	; 0x3f
10008906:	1b1c      	subs	r4, r3, r4
10008908:	40a6      	lsls	r6, r4
1000890a:	4335      	orrs	r5, r6
1000890c:	1e6e      	subs	r6, r5, #1
1000890e:	41b5      	sbcs	r5, r6
10008910:	2700      	movs	r7, #0
10008912:	430d      	orrs	r5, r1
10008914:	2400      	movs	r4, #0
10008916:	e78e      	b.n	10008836 <__aeabi_dadd+0x23e>
10008918:	1c03      	adds	r3, r0, #0
1000891a:	1c0e      	adds	r6, r1, #0
1000891c:	3b20      	subs	r3, #32
1000891e:	40de      	lsrs	r6, r3
10008920:	2820      	cmp	r0, #32
10008922:	d074      	beq.n	10008a0e <__aeabi_dadd+0x416>
10008924:	2340      	movs	r3, #64	; 0x40
10008926:	1a1b      	subs	r3, r3, r0
10008928:	4099      	lsls	r1, r3
1000892a:	1c0b      	adds	r3, r1, #0
1000892c:	4662      	mov	r2, ip
1000892e:	4313      	orrs	r3, r2
10008930:	1e59      	subs	r1, r3, #1
10008932:	418b      	sbcs	r3, r1
10008934:	2200      	movs	r2, #0
10008936:	4333      	orrs	r3, r6
10008938:	e6db      	b.n	100086f2 <__aeabi_dadd+0xfa>
1000893a:	2c00      	cmp	r4, #0
1000893c:	d050      	beq.n	100089e0 <__aeabi_dadd+0x3e8>
1000893e:	4c19      	ldr	r4, [pc, #100]	; (100089a4 <__aeabi_dadd+0x3ac>)
10008940:	42a2      	cmp	r2, r4
10008942:	d100      	bne.n	10008946 <__aeabi_dadd+0x34e>
10008944:	e0a8      	b.n	10008a98 <__aeabi_dadd+0x4a0>
10008946:	2480      	movs	r4, #128	; 0x80
10008948:	0424      	lsls	r4, r4, #16
1000894a:	4240      	negs	r0, r0
1000894c:	4327      	orrs	r7, r4
1000894e:	2838      	cmp	r0, #56	; 0x38
10008950:	dd00      	ble.n	10008954 <__aeabi_dadd+0x35c>
10008952:	e0d9      	b.n	10008b08 <__aeabi_dadd+0x510>
10008954:	281f      	cmp	r0, #31
10008956:	dd00      	ble.n	1000895a <__aeabi_dadd+0x362>
10008958:	e139      	b.n	10008bce <__aeabi_dadd+0x5d6>
1000895a:	2420      	movs	r4, #32
1000895c:	1c3e      	adds	r6, r7, #0
1000895e:	1a24      	subs	r4, r4, r0
10008960:	40a6      	lsls	r6, r4
10008962:	46b0      	mov	r8, r6
10008964:	1c2e      	adds	r6, r5, #0
10008966:	46a1      	mov	r9, r4
10008968:	40c6      	lsrs	r6, r0
1000896a:	4644      	mov	r4, r8
1000896c:	4326      	orrs	r6, r4
1000896e:	464c      	mov	r4, r9
10008970:	40a5      	lsls	r5, r4
10008972:	1e6c      	subs	r4, r5, #1
10008974:	41a5      	sbcs	r5, r4
10008976:	40c7      	lsrs	r7, r0
10008978:	4335      	orrs	r5, r6
1000897a:	4660      	mov	r0, ip
1000897c:	1b45      	subs	r5, r0, r5
1000897e:	1bcf      	subs	r7, r1, r7
10008980:	45ac      	cmp	ip, r5
10008982:	4189      	sbcs	r1, r1
10008984:	4249      	negs	r1, r1
10008986:	1a7f      	subs	r7, r7, r1
10008988:	1c14      	adds	r4, r2, #0
1000898a:	4698      	mov	r8, r3
1000898c:	e6b8      	b.n	10008700 <__aeabi_dadd+0x108>
1000898e:	464b      	mov	r3, r9
10008990:	464d      	mov	r5, r9
10008992:	4333      	orrs	r3, r6
10008994:	d000      	beq.n	10008998 <__aeabi_dadd+0x3a0>
10008996:	e6b8      	b.n	1000870a <__aeabi_dadd+0x112>
10008998:	2600      	movs	r6, #0
1000899a:	2700      	movs	r7, #0
1000899c:	2400      	movs	r4, #0
1000899e:	2500      	movs	r5, #0
100089a0:	e6e4      	b.n	1000876c <__aeabi_dadd+0x174>
100089a2:	46c0      	nop			; (mov r8, r8)
100089a4:	000007ff 	.word	0x000007ff
100089a8:	ff7fffff 	.word	0xff7fffff
100089ac:	800fffff 	.word	0x800fffff
100089b0:	2b1f      	cmp	r3, #31
100089b2:	dc5b      	bgt.n	10008a6c <__aeabi_dadd+0x474>
100089b4:	2220      	movs	r2, #32
100089b6:	1c08      	adds	r0, r1, #0
100089b8:	1ad2      	subs	r2, r2, r3
100089ba:	4090      	lsls	r0, r2
100089bc:	4681      	mov	r9, r0
100089be:	4660      	mov	r0, ip
100089c0:	4692      	mov	sl, r2
100089c2:	40d8      	lsrs	r0, r3
100089c4:	464a      	mov	r2, r9
100089c6:	4310      	orrs	r0, r2
100089c8:	4681      	mov	r9, r0
100089ca:	4652      	mov	r2, sl
100089cc:	4660      	mov	r0, ip
100089ce:	4090      	lsls	r0, r2
100089d0:	1c02      	adds	r2, r0, #0
100089d2:	1e50      	subs	r0, r2, #1
100089d4:	4182      	sbcs	r2, r0
100089d6:	4648      	mov	r0, r9
100089d8:	4310      	orrs	r0, r2
100089da:	1c0a      	adds	r2, r1, #0
100089dc:	40da      	lsrs	r2, r3
100089de:	e6e7      	b.n	100087b0 <__aeabi_dadd+0x1b8>
100089e0:	1c3c      	adds	r4, r7, #0
100089e2:	432c      	orrs	r4, r5
100089e4:	d058      	beq.n	10008a98 <__aeabi_dadd+0x4a0>
100089e6:	43c0      	mvns	r0, r0
100089e8:	2800      	cmp	r0, #0
100089ea:	d151      	bne.n	10008a90 <__aeabi_dadd+0x498>
100089ec:	4660      	mov	r0, ip
100089ee:	1b45      	subs	r5, r0, r5
100089f0:	45ac      	cmp	ip, r5
100089f2:	4180      	sbcs	r0, r0
100089f4:	1bcf      	subs	r7, r1, r7
100089f6:	4240      	negs	r0, r0
100089f8:	1a3f      	subs	r7, r7, r0
100089fa:	1c14      	adds	r4, r2, #0
100089fc:	4698      	mov	r8, r3
100089fe:	e67f      	b.n	10008700 <__aeabi_dadd+0x108>
10008a00:	4a8f      	ldr	r2, [pc, #572]	; (10008c40 <__aeabi_dadd+0x648>)
10008a02:	4294      	cmp	r4, r2
10008a04:	d000      	beq.n	10008a08 <__aeabi_dadd+0x410>
10008a06:	e6ca      	b.n	1000879e <__aeabi_dadd+0x1a6>
10008a08:	e61e      	b.n	10008648 <__aeabi_dadd+0x50>
10008a0a:	2600      	movs	r6, #0
10008a0c:	e77d      	b.n	1000890a <__aeabi_dadd+0x312>
10008a0e:	2300      	movs	r3, #0
10008a10:	e78c      	b.n	1000892c <__aeabi_dadd+0x334>
10008a12:	1c3b      	adds	r3, r7, #0
10008a14:	432b      	orrs	r3, r5
10008a16:	2c00      	cmp	r4, #0
10008a18:	d000      	beq.n	10008a1c <__aeabi_dadd+0x424>
10008a1a:	e0bd      	b.n	10008b98 <__aeabi_dadd+0x5a0>
10008a1c:	2b00      	cmp	r3, #0
10008a1e:	d100      	bne.n	10008a22 <__aeabi_dadd+0x42a>
10008a20:	e0f5      	b.n	10008c0e <__aeabi_dadd+0x616>
10008a22:	4663      	mov	r3, ip
10008a24:	430b      	orrs	r3, r1
10008a26:	d100      	bne.n	10008a2a <__aeabi_dadd+0x432>
10008a28:	e60e      	b.n	10008648 <__aeabi_dadd+0x50>
10008a2a:	4663      	mov	r3, ip
10008a2c:	195b      	adds	r3, r3, r5
10008a2e:	42ab      	cmp	r3, r5
10008a30:	4180      	sbcs	r0, r0
10008a32:	19ca      	adds	r2, r1, r7
10008a34:	4240      	negs	r0, r0
10008a36:	1817      	adds	r7, r2, r0
10008a38:	023a      	lsls	r2, r7, #8
10008a3a:	d400      	bmi.n	10008a3e <__aeabi_dadd+0x446>
10008a3c:	e0fc      	b.n	10008c38 <__aeabi_dadd+0x640>
10008a3e:	4a81      	ldr	r2, [pc, #516]	; (10008c44 <__aeabi_dadd+0x64c>)
10008a40:	1c1d      	adds	r5, r3, #0
10008a42:	4017      	ands	r7, r2
10008a44:	3401      	adds	r4, #1
10008a46:	e5ff      	b.n	10008648 <__aeabi_dadd+0x50>
10008a48:	1c3a      	adds	r2, r7, #0
10008a4a:	432a      	orrs	r2, r5
10008a4c:	2c00      	cmp	r4, #0
10008a4e:	d151      	bne.n	10008af4 <__aeabi_dadd+0x4fc>
10008a50:	2a00      	cmp	r2, #0
10008a52:	d000      	beq.n	10008a56 <__aeabi_dadd+0x45e>
10008a54:	e085      	b.n	10008b62 <__aeabi_dadd+0x56a>
10008a56:	4662      	mov	r2, ip
10008a58:	430a      	orrs	r2, r1
10008a5a:	d003      	beq.n	10008a64 <__aeabi_dadd+0x46c>
10008a5c:	1c0f      	adds	r7, r1, #0
10008a5e:	4665      	mov	r5, ip
10008a60:	4698      	mov	r8, r3
10008a62:	e5f1      	b.n	10008648 <__aeabi_dadd+0x50>
10008a64:	2600      	movs	r6, #0
10008a66:	2700      	movs	r7, #0
10008a68:	2500      	movs	r5, #0
10008a6a:	e67f      	b.n	1000876c <__aeabi_dadd+0x174>
10008a6c:	1c18      	adds	r0, r3, #0
10008a6e:	1c0a      	adds	r2, r1, #0
10008a70:	3820      	subs	r0, #32
10008a72:	40c2      	lsrs	r2, r0
10008a74:	2b20      	cmp	r3, #32
10008a76:	d100      	bne.n	10008a7a <__aeabi_dadd+0x482>
10008a78:	e0a7      	b.n	10008bca <__aeabi_dadd+0x5d2>
10008a7a:	2040      	movs	r0, #64	; 0x40
10008a7c:	1ac0      	subs	r0, r0, r3
10008a7e:	4081      	lsls	r1, r0
10008a80:	1c08      	adds	r0, r1, #0
10008a82:	4663      	mov	r3, ip
10008a84:	4318      	orrs	r0, r3
10008a86:	1e41      	subs	r1, r0, #1
10008a88:	4188      	sbcs	r0, r1
10008a8a:	4310      	orrs	r0, r2
10008a8c:	2200      	movs	r2, #0
10008a8e:	e68f      	b.n	100087b0 <__aeabi_dadd+0x1b8>
10008a90:	4c6b      	ldr	r4, [pc, #428]	; (10008c40 <__aeabi_dadd+0x648>)
10008a92:	42a2      	cmp	r2, r4
10008a94:	d000      	beq.n	10008a98 <__aeabi_dadd+0x4a0>
10008a96:	e75a      	b.n	1000894e <__aeabi_dadd+0x356>
10008a98:	1c0f      	adds	r7, r1, #0
10008a9a:	4665      	mov	r5, ip
10008a9c:	1c14      	adds	r4, r2, #0
10008a9e:	4698      	mov	r8, r3
10008aa0:	e5d2      	b.n	10008648 <__aeabi_dadd+0x50>
10008aa2:	2c00      	cmp	r4, #0
10008aa4:	d13a      	bne.n	10008b1c <__aeabi_dadd+0x524>
10008aa6:	1c38      	adds	r0, r7, #0
10008aa8:	4328      	orrs	r0, r5
10008aaa:	d071      	beq.n	10008b90 <__aeabi_dadd+0x598>
10008aac:	43db      	mvns	r3, r3
10008aae:	2b00      	cmp	r3, #0
10008ab0:	d018      	beq.n	10008ae4 <__aeabi_dadd+0x4ec>
10008ab2:	4863      	ldr	r0, [pc, #396]	; (10008c40 <__aeabi_dadd+0x648>)
10008ab4:	4282      	cmp	r2, r0
10008ab6:	d06b      	beq.n	10008b90 <__aeabi_dadd+0x598>
10008ab8:	2b38      	cmp	r3, #56	; 0x38
10008aba:	dd00      	ble.n	10008abe <__aeabi_dadd+0x4c6>
10008abc:	e09d      	b.n	10008bfa <__aeabi_dadd+0x602>
10008abe:	2b1f      	cmp	r3, #31
10008ac0:	dd00      	ble.n	10008ac4 <__aeabi_dadd+0x4cc>
10008ac2:	e0a7      	b.n	10008c14 <__aeabi_dadd+0x61c>
10008ac4:	2020      	movs	r0, #32
10008ac6:	1c3c      	adds	r4, r7, #0
10008ac8:	1ac0      	subs	r0, r0, r3
10008aca:	4084      	lsls	r4, r0
10008acc:	46a1      	mov	r9, r4
10008ace:	1c2c      	adds	r4, r5, #0
10008ad0:	4682      	mov	sl, r0
10008ad2:	40dc      	lsrs	r4, r3
10008ad4:	4648      	mov	r0, r9
10008ad6:	4304      	orrs	r4, r0
10008ad8:	4650      	mov	r0, sl
10008ada:	4085      	lsls	r5, r0
10008adc:	1e68      	subs	r0, r5, #1
10008ade:	4185      	sbcs	r5, r0
10008ae0:	40df      	lsrs	r7, r3
10008ae2:	4325      	orrs	r5, r4
10008ae4:	4465      	add	r5, ip
10008ae6:	4565      	cmp	r5, ip
10008ae8:	419b      	sbcs	r3, r3
10008aea:	187f      	adds	r7, r7, r1
10008aec:	425b      	negs	r3, r3
10008aee:	18ff      	adds	r7, r7, r3
10008af0:	1c14      	adds	r4, r2, #0
10008af2:	e664      	b.n	100087be <__aeabi_dadd+0x1c6>
10008af4:	2a00      	cmp	r2, #0
10008af6:	d119      	bne.n	10008b2c <__aeabi_dadd+0x534>
10008af8:	4662      	mov	r2, ip
10008afa:	430a      	orrs	r2, r1
10008afc:	d077      	beq.n	10008bee <__aeabi_dadd+0x5f6>
10008afe:	1c0f      	adds	r7, r1, #0
10008b00:	4665      	mov	r5, ip
10008b02:	4698      	mov	r8, r3
10008b04:	4c4e      	ldr	r4, [pc, #312]	; (10008c40 <__aeabi_dadd+0x648>)
10008b06:	e59f      	b.n	10008648 <__aeabi_dadd+0x50>
10008b08:	433d      	orrs	r5, r7
10008b0a:	1e6f      	subs	r7, r5, #1
10008b0c:	41bd      	sbcs	r5, r7
10008b0e:	2700      	movs	r7, #0
10008b10:	b2ed      	uxtb	r5, r5
10008b12:	e732      	b.n	1000897a <__aeabi_dadd+0x382>
10008b14:	1c04      	adds	r4, r0, #0
10008b16:	2700      	movs	r7, #0
10008b18:	2500      	movs	r5, #0
10008b1a:	e627      	b.n	1000876c <__aeabi_dadd+0x174>
10008b1c:	4848      	ldr	r0, [pc, #288]	; (10008c40 <__aeabi_dadd+0x648>)
10008b1e:	4282      	cmp	r2, r0
10008b20:	d036      	beq.n	10008b90 <__aeabi_dadd+0x598>
10008b22:	2080      	movs	r0, #128	; 0x80
10008b24:	0400      	lsls	r0, r0, #16
10008b26:	425b      	negs	r3, r3
10008b28:	4307      	orrs	r7, r0
10008b2a:	e7c5      	b.n	10008ab8 <__aeabi_dadd+0x4c0>
10008b2c:	4662      	mov	r2, ip
10008b2e:	430a      	orrs	r2, r1
10008b30:	d049      	beq.n	10008bc6 <__aeabi_dadd+0x5ce>
10008b32:	2480      	movs	r4, #128	; 0x80
10008b34:	08ed      	lsrs	r5, r5, #3
10008b36:	0778      	lsls	r0, r7, #29
10008b38:	08fa      	lsrs	r2, r7, #3
10008b3a:	0324      	lsls	r4, r4, #12
10008b3c:	4328      	orrs	r0, r5
10008b3e:	4222      	tst	r2, r4
10008b40:	d009      	beq.n	10008b56 <__aeabi_dadd+0x55e>
10008b42:	08ce      	lsrs	r6, r1, #3
10008b44:	4226      	tst	r6, r4
10008b46:	d106      	bne.n	10008b56 <__aeabi_dadd+0x55e>
10008b48:	4662      	mov	r2, ip
10008b4a:	074f      	lsls	r7, r1, #29
10008b4c:	1c38      	adds	r0, r7, #0
10008b4e:	08d2      	lsrs	r2, r2, #3
10008b50:	4310      	orrs	r0, r2
10008b52:	4698      	mov	r8, r3
10008b54:	1c32      	adds	r2, r6, #0
10008b56:	00d2      	lsls	r2, r2, #3
10008b58:	0f47      	lsrs	r7, r0, #29
10008b5a:	4317      	orrs	r7, r2
10008b5c:	00c5      	lsls	r5, r0, #3
10008b5e:	4c38      	ldr	r4, [pc, #224]	; (10008c40 <__aeabi_dadd+0x648>)
10008b60:	e572      	b.n	10008648 <__aeabi_dadd+0x50>
10008b62:	4662      	mov	r2, ip
10008b64:	430a      	orrs	r2, r1
10008b66:	d100      	bne.n	10008b6a <__aeabi_dadd+0x572>
10008b68:	e56e      	b.n	10008648 <__aeabi_dadd+0x50>
10008b6a:	4662      	mov	r2, ip
10008b6c:	1aae      	subs	r6, r5, r2
10008b6e:	42b5      	cmp	r5, r6
10008b70:	4192      	sbcs	r2, r2
10008b72:	1a78      	subs	r0, r7, r1
10008b74:	4252      	negs	r2, r2
10008b76:	1a82      	subs	r2, r0, r2
10008b78:	0210      	lsls	r0, r2, #8
10008b7a:	d400      	bmi.n	10008b7e <__aeabi_dadd+0x586>
10008b7c:	e655      	b.n	1000882a <__aeabi_dadd+0x232>
10008b7e:	4662      	mov	r2, ip
10008b80:	1b55      	subs	r5, r2, r5
10008b82:	45ac      	cmp	ip, r5
10008b84:	4180      	sbcs	r0, r0
10008b86:	1bca      	subs	r2, r1, r7
10008b88:	4240      	negs	r0, r0
10008b8a:	1a17      	subs	r7, r2, r0
10008b8c:	4698      	mov	r8, r3
10008b8e:	e55b      	b.n	10008648 <__aeabi_dadd+0x50>
10008b90:	1c0f      	adds	r7, r1, #0
10008b92:	4665      	mov	r5, ip
10008b94:	1c14      	adds	r4, r2, #0
10008b96:	e557      	b.n	10008648 <__aeabi_dadd+0x50>
10008b98:	2b00      	cmp	r3, #0
10008b9a:	d034      	beq.n	10008c06 <__aeabi_dadd+0x60e>
10008b9c:	4663      	mov	r3, ip
10008b9e:	430b      	orrs	r3, r1
10008ba0:	d011      	beq.n	10008bc6 <__aeabi_dadd+0x5ce>
10008ba2:	2480      	movs	r4, #128	; 0x80
10008ba4:	08ed      	lsrs	r5, r5, #3
10008ba6:	0778      	lsls	r0, r7, #29
10008ba8:	08fa      	lsrs	r2, r7, #3
10008baa:	0324      	lsls	r4, r4, #12
10008bac:	4328      	orrs	r0, r5
10008bae:	4222      	tst	r2, r4
10008bb0:	d0d1      	beq.n	10008b56 <__aeabi_dadd+0x55e>
10008bb2:	08cb      	lsrs	r3, r1, #3
10008bb4:	4223      	tst	r3, r4
10008bb6:	d1ce      	bne.n	10008b56 <__aeabi_dadd+0x55e>
10008bb8:	4662      	mov	r2, ip
10008bba:	074f      	lsls	r7, r1, #29
10008bbc:	1c38      	adds	r0, r7, #0
10008bbe:	08d2      	lsrs	r2, r2, #3
10008bc0:	4310      	orrs	r0, r2
10008bc2:	1c1a      	adds	r2, r3, #0
10008bc4:	e7c7      	b.n	10008b56 <__aeabi_dadd+0x55e>
10008bc6:	4c1e      	ldr	r4, [pc, #120]	; (10008c40 <__aeabi_dadd+0x648>)
10008bc8:	e53e      	b.n	10008648 <__aeabi_dadd+0x50>
10008bca:	2000      	movs	r0, #0
10008bcc:	e759      	b.n	10008a82 <__aeabi_dadd+0x48a>
10008bce:	1c04      	adds	r4, r0, #0
10008bd0:	1c3e      	adds	r6, r7, #0
10008bd2:	3c20      	subs	r4, #32
10008bd4:	40e6      	lsrs	r6, r4
10008bd6:	1c34      	adds	r4, r6, #0
10008bd8:	2820      	cmp	r0, #32
10008bda:	d02b      	beq.n	10008c34 <__aeabi_dadd+0x63c>
10008bdc:	2640      	movs	r6, #64	; 0x40
10008bde:	1a30      	subs	r0, r6, r0
10008be0:	4087      	lsls	r7, r0
10008be2:	433d      	orrs	r5, r7
10008be4:	1e6f      	subs	r7, r5, #1
10008be6:	41bd      	sbcs	r5, r7
10008be8:	2700      	movs	r7, #0
10008bea:	4325      	orrs	r5, r4
10008bec:	e6c5      	b.n	1000897a <__aeabi_dadd+0x382>
10008bee:	2780      	movs	r7, #128	; 0x80
10008bf0:	2600      	movs	r6, #0
10008bf2:	03ff      	lsls	r7, r7, #15
10008bf4:	4c12      	ldr	r4, [pc, #72]	; (10008c40 <__aeabi_dadd+0x648>)
10008bf6:	2500      	movs	r5, #0
10008bf8:	e5b8      	b.n	1000876c <__aeabi_dadd+0x174>
10008bfa:	433d      	orrs	r5, r7
10008bfc:	1e6f      	subs	r7, r5, #1
10008bfe:	41bd      	sbcs	r5, r7
10008c00:	2700      	movs	r7, #0
10008c02:	b2ed      	uxtb	r5, r5
10008c04:	e76e      	b.n	10008ae4 <__aeabi_dadd+0x4ec>
10008c06:	1c0f      	adds	r7, r1, #0
10008c08:	4665      	mov	r5, ip
10008c0a:	4c0d      	ldr	r4, [pc, #52]	; (10008c40 <__aeabi_dadd+0x648>)
10008c0c:	e51c      	b.n	10008648 <__aeabi_dadd+0x50>
10008c0e:	1c0f      	adds	r7, r1, #0
10008c10:	4665      	mov	r5, ip
10008c12:	e519      	b.n	10008648 <__aeabi_dadd+0x50>
10008c14:	1c1c      	adds	r4, r3, #0
10008c16:	1c38      	adds	r0, r7, #0
10008c18:	3c20      	subs	r4, #32
10008c1a:	40e0      	lsrs	r0, r4
10008c1c:	1c04      	adds	r4, r0, #0
10008c1e:	2b20      	cmp	r3, #32
10008c20:	d00c      	beq.n	10008c3c <__aeabi_dadd+0x644>
10008c22:	2040      	movs	r0, #64	; 0x40
10008c24:	1ac3      	subs	r3, r0, r3
10008c26:	409f      	lsls	r7, r3
10008c28:	433d      	orrs	r5, r7
10008c2a:	1e6f      	subs	r7, r5, #1
10008c2c:	41bd      	sbcs	r5, r7
10008c2e:	2700      	movs	r7, #0
10008c30:	4325      	orrs	r5, r4
10008c32:	e757      	b.n	10008ae4 <__aeabi_dadd+0x4ec>
10008c34:	2700      	movs	r7, #0
10008c36:	e7d4      	b.n	10008be2 <__aeabi_dadd+0x5ea>
10008c38:	1c1d      	adds	r5, r3, #0
10008c3a:	e5fc      	b.n	10008836 <__aeabi_dadd+0x23e>
10008c3c:	2700      	movs	r7, #0
10008c3e:	e7f3      	b.n	10008c28 <__aeabi_dadd+0x630>
10008c40:	000007ff 	.word	0x000007ff
10008c44:	ff7fffff 	.word	0xff7fffff

10008c48 <__aeabi_ddiv>:
10008c48:	b5f0      	push	{r4, r5, r6, r7, lr}
10008c4a:	465f      	mov	r7, fp
10008c4c:	4656      	mov	r6, sl
10008c4e:	464d      	mov	r5, r9
10008c50:	4644      	mov	r4, r8
10008c52:	b4f0      	push	{r4, r5, r6, r7}
10008c54:	030f      	lsls	r7, r1, #12
10008c56:	b087      	sub	sp, #28
10008c58:	4698      	mov	r8, r3
10008c5a:	004d      	lsls	r5, r1, #1
10008c5c:	0b3b      	lsrs	r3, r7, #12
10008c5e:	0fcc      	lsrs	r4, r1, #31
10008c60:	1c06      	adds	r6, r0, #0
10008c62:	4692      	mov	sl, r2
10008c64:	4681      	mov	r9, r0
10008c66:	469b      	mov	fp, r3
10008c68:	0d6d      	lsrs	r5, r5, #21
10008c6a:	9401      	str	r4, [sp, #4]
10008c6c:	d06b      	beq.n	10008d46 <__aeabi_ddiv+0xfe>
10008c6e:	4b66      	ldr	r3, [pc, #408]	; (10008e08 <__aeabi_ddiv+0x1c0>)
10008c70:	429d      	cmp	r5, r3
10008c72:	d035      	beq.n	10008ce0 <__aeabi_ddiv+0x98>
10008c74:	2780      	movs	r7, #128	; 0x80
10008c76:	465b      	mov	r3, fp
10008c78:	037f      	lsls	r7, r7, #13
10008c7a:	431f      	orrs	r7, r3
10008c7c:	00f3      	lsls	r3, r6, #3
10008c7e:	4699      	mov	r9, r3
10008c80:	4b62      	ldr	r3, [pc, #392]	; (10008e0c <__aeabi_ddiv+0x1c4>)
10008c82:	00ff      	lsls	r7, r7, #3
10008c84:	0f40      	lsrs	r0, r0, #29
10008c86:	469c      	mov	ip, r3
10008c88:	4307      	orrs	r7, r0
10008c8a:	2300      	movs	r3, #0
10008c8c:	46bb      	mov	fp, r7
10008c8e:	2600      	movs	r6, #0
10008c90:	4465      	add	r5, ip
10008c92:	9300      	str	r3, [sp, #0]
10008c94:	4642      	mov	r2, r8
10008c96:	0317      	lsls	r7, r2, #12
10008c98:	0050      	lsls	r0, r2, #1
10008c9a:	0fd2      	lsrs	r2, r2, #31
10008c9c:	4653      	mov	r3, sl
10008c9e:	0b3f      	lsrs	r7, r7, #12
10008ca0:	0d40      	lsrs	r0, r0, #21
10008ca2:	4690      	mov	r8, r2
10008ca4:	d100      	bne.n	10008ca8 <__aeabi_ddiv+0x60>
10008ca6:	e072      	b.n	10008d8e <__aeabi_ddiv+0x146>
10008ca8:	4a57      	ldr	r2, [pc, #348]	; (10008e08 <__aeabi_ddiv+0x1c0>)
10008caa:	4290      	cmp	r0, r2
10008cac:	d067      	beq.n	10008d7e <__aeabi_ddiv+0x136>
10008cae:	2380      	movs	r3, #128	; 0x80
10008cb0:	035b      	lsls	r3, r3, #13
10008cb2:	431f      	orrs	r7, r3
10008cb4:	4653      	mov	r3, sl
10008cb6:	4a55      	ldr	r2, [pc, #340]	; (10008e0c <__aeabi_ddiv+0x1c4>)
10008cb8:	0f5b      	lsrs	r3, r3, #29
10008cba:	00ff      	lsls	r7, r7, #3
10008cbc:	431f      	orrs	r7, r3
10008cbe:	4694      	mov	ip, r2
10008cc0:	4653      	mov	r3, sl
10008cc2:	2100      	movs	r1, #0
10008cc4:	00db      	lsls	r3, r3, #3
10008cc6:	4460      	add	r0, ip
10008cc8:	4642      	mov	r2, r8
10008cca:	4062      	eors	r2, r4
10008ccc:	4692      	mov	sl, r2
10008cce:	1a2d      	subs	r5, r5, r0
10008cd0:	430e      	orrs	r6, r1
10008cd2:	2e0f      	cmp	r6, #15
10008cd4:	d900      	bls.n	10008cd8 <__aeabi_ddiv+0x90>
10008cd6:	e0a1      	b.n	10008e1c <__aeabi_ddiv+0x1d4>
10008cd8:	484d      	ldr	r0, [pc, #308]	; (10008e10 <__aeabi_ddiv+0x1c8>)
10008cda:	00b6      	lsls	r6, r6, #2
10008cdc:	5980      	ldr	r0, [r0, r6]
10008cde:	4687      	mov	pc, r0
10008ce0:	465b      	mov	r3, fp
10008ce2:	431e      	orrs	r6, r3
10008ce4:	d000      	beq.n	10008ce8 <__aeabi_ddiv+0xa0>
10008ce6:	e076      	b.n	10008dd6 <__aeabi_ddiv+0x18e>
10008ce8:	2300      	movs	r3, #0
10008cea:	469b      	mov	fp, r3
10008cec:	4699      	mov	r9, r3
10008cee:	3302      	adds	r3, #2
10008cf0:	2608      	movs	r6, #8
10008cf2:	9300      	str	r3, [sp, #0]
10008cf4:	e7ce      	b.n	10008c94 <__aeabi_ddiv+0x4c>
10008cf6:	4699      	mov	r9, r3
10008cf8:	4643      	mov	r3, r8
10008cfa:	46bb      	mov	fp, r7
10008cfc:	9301      	str	r3, [sp, #4]
10008cfe:	9100      	str	r1, [sp, #0]
10008d00:	9b00      	ldr	r3, [sp, #0]
10008d02:	2b02      	cmp	r3, #2
10008d04:	d16b      	bne.n	10008dde <__aeabi_ddiv+0x196>
10008d06:	9b01      	ldr	r3, [sp, #4]
10008d08:	469a      	mov	sl, r3
10008d0a:	2100      	movs	r1, #0
10008d0c:	4653      	mov	r3, sl
10008d0e:	2201      	movs	r2, #1
10008d10:	2700      	movs	r7, #0
10008d12:	4689      	mov	r9, r1
10008d14:	401a      	ands	r2, r3
10008d16:	4b3c      	ldr	r3, [pc, #240]	; (10008e08 <__aeabi_ddiv+0x1c0>)
10008d18:	2100      	movs	r1, #0
10008d1a:	033f      	lsls	r7, r7, #12
10008d1c:	0d0c      	lsrs	r4, r1, #20
10008d1e:	0524      	lsls	r4, r4, #20
10008d20:	0b3f      	lsrs	r7, r7, #12
10008d22:	4327      	orrs	r7, r4
10008d24:	4c3b      	ldr	r4, [pc, #236]	; (10008e14 <__aeabi_ddiv+0x1cc>)
10008d26:	051b      	lsls	r3, r3, #20
10008d28:	4027      	ands	r7, r4
10008d2a:	431f      	orrs	r7, r3
10008d2c:	007f      	lsls	r7, r7, #1
10008d2e:	07d2      	lsls	r2, r2, #31
10008d30:	087f      	lsrs	r7, r7, #1
10008d32:	4317      	orrs	r7, r2
10008d34:	4648      	mov	r0, r9
10008d36:	1c39      	adds	r1, r7, #0
10008d38:	b007      	add	sp, #28
10008d3a:	bc3c      	pop	{r2, r3, r4, r5}
10008d3c:	4690      	mov	r8, r2
10008d3e:	4699      	mov	r9, r3
10008d40:	46a2      	mov	sl, r4
10008d42:	46ab      	mov	fp, r5
10008d44:	bdf0      	pop	{r4, r5, r6, r7, pc}
10008d46:	4303      	orrs	r3, r0
10008d48:	d03e      	beq.n	10008dc8 <__aeabi_ddiv+0x180>
10008d4a:	465b      	mov	r3, fp
10008d4c:	2b00      	cmp	r3, #0
10008d4e:	d100      	bne.n	10008d52 <__aeabi_ddiv+0x10a>
10008d50:	e19c      	b.n	1000908c <__aeabi_ddiv+0x444>
10008d52:	4658      	mov	r0, fp
10008d54:	f7fc fe12 	bl	1000597c <__clzsi2>
10008d58:	2328      	movs	r3, #40	; 0x28
10008d5a:	1c31      	adds	r1, r6, #0
10008d5c:	1a1b      	subs	r3, r3, r0
10008d5e:	1c02      	adds	r2, r0, #0
10008d60:	465f      	mov	r7, fp
10008d62:	40d9      	lsrs	r1, r3
10008d64:	3a08      	subs	r2, #8
10008d66:	4097      	lsls	r7, r2
10008d68:	1c0b      	adds	r3, r1, #0
10008d6a:	4096      	lsls	r6, r2
10008d6c:	433b      	orrs	r3, r7
10008d6e:	469b      	mov	fp, r3
10008d70:	46b1      	mov	r9, r6
10008d72:	2300      	movs	r3, #0
10008d74:	4d28      	ldr	r5, [pc, #160]	; (10008e18 <__aeabi_ddiv+0x1d0>)
10008d76:	2600      	movs	r6, #0
10008d78:	1a2d      	subs	r5, r5, r0
10008d7a:	9300      	str	r3, [sp, #0]
10008d7c:	e78a      	b.n	10008c94 <__aeabi_ddiv+0x4c>
10008d7e:	4652      	mov	r2, sl
10008d80:	2103      	movs	r1, #3
10008d82:	433a      	orrs	r2, r7
10008d84:	d1a0      	bne.n	10008cc8 <__aeabi_ddiv+0x80>
10008d86:	2700      	movs	r7, #0
10008d88:	2300      	movs	r3, #0
10008d8a:	2102      	movs	r1, #2
10008d8c:	e79c      	b.n	10008cc8 <__aeabi_ddiv+0x80>
10008d8e:	4652      	mov	r2, sl
10008d90:	433a      	orrs	r2, r7
10008d92:	d015      	beq.n	10008dc0 <__aeabi_ddiv+0x178>
10008d94:	2f00      	cmp	r7, #0
10008d96:	d100      	bne.n	10008d9a <__aeabi_ddiv+0x152>
10008d98:	e185      	b.n	100090a6 <__aeabi_ddiv+0x45e>
10008d9a:	1c38      	adds	r0, r7, #0
10008d9c:	f7fc fdee 	bl	1000597c <__clzsi2>
10008da0:	1c02      	adds	r2, r0, #0
10008da2:	2128      	movs	r1, #40	; 0x28
10008da4:	4650      	mov	r0, sl
10008da6:	1a89      	subs	r1, r1, r2
10008da8:	1c13      	adds	r3, r2, #0
10008daa:	40c8      	lsrs	r0, r1
10008dac:	4651      	mov	r1, sl
10008dae:	3b08      	subs	r3, #8
10008db0:	4099      	lsls	r1, r3
10008db2:	409f      	lsls	r7, r3
10008db4:	1c0b      	adds	r3, r1, #0
10008db6:	4307      	orrs	r7, r0
10008db8:	4817      	ldr	r0, [pc, #92]	; (10008e18 <__aeabi_ddiv+0x1d0>)
10008dba:	2100      	movs	r1, #0
10008dbc:	1a80      	subs	r0, r0, r2
10008dbe:	e783      	b.n	10008cc8 <__aeabi_ddiv+0x80>
10008dc0:	2700      	movs	r7, #0
10008dc2:	2300      	movs	r3, #0
10008dc4:	2101      	movs	r1, #1
10008dc6:	e77f      	b.n	10008cc8 <__aeabi_ddiv+0x80>
10008dc8:	2300      	movs	r3, #0
10008dca:	469b      	mov	fp, r3
10008dcc:	4699      	mov	r9, r3
10008dce:	3301      	adds	r3, #1
10008dd0:	2604      	movs	r6, #4
10008dd2:	9300      	str	r3, [sp, #0]
10008dd4:	e75e      	b.n	10008c94 <__aeabi_ddiv+0x4c>
10008dd6:	2303      	movs	r3, #3
10008dd8:	260c      	movs	r6, #12
10008dda:	9300      	str	r3, [sp, #0]
10008ddc:	e75a      	b.n	10008c94 <__aeabi_ddiv+0x4c>
10008dde:	2b03      	cmp	r3, #3
10008de0:	d100      	bne.n	10008de4 <__aeabi_ddiv+0x19c>
10008de2:	e23c      	b.n	1000925e <__aeabi_ddiv+0x616>
10008de4:	2b01      	cmp	r3, #1
10008de6:	d000      	beq.n	10008dea <__aeabi_ddiv+0x1a2>
10008de8:	e1bf      	b.n	1000916a <__aeabi_ddiv+0x522>
10008dea:	1c1a      	adds	r2, r3, #0
10008dec:	9b01      	ldr	r3, [sp, #4]
10008dee:	401a      	ands	r2, r3
10008df0:	2100      	movs	r1, #0
10008df2:	2300      	movs	r3, #0
10008df4:	2700      	movs	r7, #0
10008df6:	4689      	mov	r9, r1
10008df8:	e78e      	b.n	10008d18 <__aeabi_ddiv+0xd0>
10008dfa:	2300      	movs	r3, #0
10008dfc:	2780      	movs	r7, #128	; 0x80
10008dfe:	4699      	mov	r9, r3
10008e00:	2200      	movs	r2, #0
10008e02:	033f      	lsls	r7, r7, #12
10008e04:	4b00      	ldr	r3, [pc, #0]	; (10008e08 <__aeabi_ddiv+0x1c0>)
10008e06:	e787      	b.n	10008d18 <__aeabi_ddiv+0xd0>
10008e08:	000007ff 	.word	0x000007ff
10008e0c:	fffffc01 	.word	0xfffffc01
10008e10:	1000a970 	.word	0x1000a970
10008e14:	800fffff 	.word	0x800fffff
10008e18:	fffffc0d 	.word	0xfffffc0d
10008e1c:	45bb      	cmp	fp, r7
10008e1e:	d900      	bls.n	10008e22 <__aeabi_ddiv+0x1da>
10008e20:	e151      	b.n	100090c6 <__aeabi_ddiv+0x47e>
10008e22:	d100      	bne.n	10008e26 <__aeabi_ddiv+0x1de>
10008e24:	e14c      	b.n	100090c0 <__aeabi_ddiv+0x478>
10008e26:	464a      	mov	r2, r9
10008e28:	9203      	str	r2, [sp, #12]
10008e2a:	2200      	movs	r2, #0
10008e2c:	465c      	mov	r4, fp
10008e2e:	4690      	mov	r8, r2
10008e30:	3d01      	subs	r5, #1
10008e32:	0e18      	lsrs	r0, r3, #24
10008e34:	023f      	lsls	r7, r7, #8
10008e36:	4338      	orrs	r0, r7
10008e38:	021b      	lsls	r3, r3, #8
10008e3a:	9301      	str	r3, [sp, #4]
10008e3c:	0c03      	lsrs	r3, r0, #16
10008e3e:	4699      	mov	r9, r3
10008e40:	0403      	lsls	r3, r0, #16
10008e42:	0c1b      	lsrs	r3, r3, #16
10008e44:	4649      	mov	r1, r9
10008e46:	1c06      	adds	r6, r0, #0
10008e48:	1c20      	adds	r0, r4, #0
10008e4a:	1c1f      	adds	r7, r3, #0
10008e4c:	9300      	str	r3, [sp, #0]
10008e4e:	f7fc fc13 	bl	10005678 <__aeabi_uidiv>
10008e52:	1c02      	adds	r2, r0, #0
10008e54:	437a      	muls	r2, r7
10008e56:	9002      	str	r0, [sp, #8]
10008e58:	4649      	mov	r1, r9
10008e5a:	1c20      	adds	r0, r4, #0
10008e5c:	1c17      	adds	r7, r2, #0
10008e5e:	f7fc fc91 	bl	10005784 <__aeabi_uidivmod>
10008e62:	9b03      	ldr	r3, [sp, #12]
10008e64:	0409      	lsls	r1, r1, #16
10008e66:	0c1b      	lsrs	r3, r3, #16
10008e68:	4319      	orrs	r1, r3
10008e6a:	428f      	cmp	r7, r1
10008e6c:	d90c      	bls.n	10008e88 <__aeabi_ddiv+0x240>
10008e6e:	9b02      	ldr	r3, [sp, #8]
10008e70:	1989      	adds	r1, r1, r6
10008e72:	3b01      	subs	r3, #1
10008e74:	428e      	cmp	r6, r1
10008e76:	d900      	bls.n	10008e7a <__aeabi_ddiv+0x232>
10008e78:	e152      	b.n	10009120 <__aeabi_ddiv+0x4d8>
10008e7a:	428f      	cmp	r7, r1
10008e7c:	d800      	bhi.n	10008e80 <__aeabi_ddiv+0x238>
10008e7e:	e14f      	b.n	10009120 <__aeabi_ddiv+0x4d8>
10008e80:	9b02      	ldr	r3, [sp, #8]
10008e82:	1989      	adds	r1, r1, r6
10008e84:	3b02      	subs	r3, #2
10008e86:	9302      	str	r3, [sp, #8]
10008e88:	1bcc      	subs	r4, r1, r7
10008e8a:	1c20      	adds	r0, r4, #0
10008e8c:	4649      	mov	r1, r9
10008e8e:	f7fc fbf3 	bl	10005678 <__aeabi_uidiv>
10008e92:	9f00      	ldr	r7, [sp, #0]
10008e94:	4683      	mov	fp, r0
10008e96:	4347      	muls	r7, r0
10008e98:	4649      	mov	r1, r9
10008e9a:	1c20      	adds	r0, r4, #0
10008e9c:	f7fc fc72 	bl	10005784 <__aeabi_uidivmod>
10008ea0:	9a03      	ldr	r2, [sp, #12]
10008ea2:	040b      	lsls	r3, r1, #16
10008ea4:	0414      	lsls	r4, r2, #16
10008ea6:	0c24      	lsrs	r4, r4, #16
10008ea8:	4323      	orrs	r3, r4
10008eaa:	429f      	cmp	r7, r3
10008eac:	d90d      	bls.n	10008eca <__aeabi_ddiv+0x282>
10008eae:	465a      	mov	r2, fp
10008eb0:	199b      	adds	r3, r3, r6
10008eb2:	3a01      	subs	r2, #1
10008eb4:	429e      	cmp	r6, r3
10008eb6:	d900      	bls.n	10008eba <__aeabi_ddiv+0x272>
10008eb8:	e130      	b.n	1000911c <__aeabi_ddiv+0x4d4>
10008eba:	429f      	cmp	r7, r3
10008ebc:	d800      	bhi.n	10008ec0 <__aeabi_ddiv+0x278>
10008ebe:	e12d      	b.n	1000911c <__aeabi_ddiv+0x4d4>
10008ec0:	2202      	movs	r2, #2
10008ec2:	4252      	negs	r2, r2
10008ec4:	4694      	mov	ip, r2
10008ec6:	199b      	adds	r3, r3, r6
10008ec8:	44e3      	add	fp, ip
10008eca:	9a02      	ldr	r2, [sp, #8]
10008ecc:	1bdb      	subs	r3, r3, r7
10008ece:	0417      	lsls	r7, r2, #16
10008ed0:	465a      	mov	r2, fp
10008ed2:	433a      	orrs	r2, r7
10008ed4:	4693      	mov	fp, r2
10008ed6:	9c01      	ldr	r4, [sp, #4]
10008ed8:	0c17      	lsrs	r7, r2, #16
10008eda:	0c22      	lsrs	r2, r4, #16
10008edc:	1c10      	adds	r0, r2, #0
10008ede:	9204      	str	r2, [sp, #16]
10008ee0:	465a      	mov	r2, fp
10008ee2:	0411      	lsls	r1, r2, #16
10008ee4:	0422      	lsls	r2, r4, #16
10008ee6:	0c12      	lsrs	r2, r2, #16
10008ee8:	1c14      	adds	r4, r2, #0
10008eea:	0c09      	lsrs	r1, r1, #16
10008eec:	437c      	muls	r4, r7
10008eee:	9205      	str	r2, [sp, #20]
10008ef0:	434a      	muls	r2, r1
10008ef2:	4341      	muls	r1, r0
10008ef4:	4347      	muls	r7, r0
10008ef6:	1861      	adds	r1, r4, r1
10008ef8:	0c10      	lsrs	r0, r2, #16
10008efa:	1809      	adds	r1, r1, r0
10008efc:	428c      	cmp	r4, r1
10008efe:	d903      	bls.n	10008f08 <__aeabi_ddiv+0x2c0>
10008f00:	2080      	movs	r0, #128	; 0x80
10008f02:	0240      	lsls	r0, r0, #9
10008f04:	4684      	mov	ip, r0
10008f06:	4467      	add	r7, ip
10008f08:	0c0c      	lsrs	r4, r1, #16
10008f0a:	0412      	lsls	r2, r2, #16
10008f0c:	0408      	lsls	r0, r1, #16
10008f0e:	0c12      	lsrs	r2, r2, #16
10008f10:	193c      	adds	r4, r7, r4
10008f12:	1881      	adds	r1, r0, r2
10008f14:	42a3      	cmp	r3, r4
10008f16:	d200      	bcs.n	10008f1a <__aeabi_ddiv+0x2d2>
10008f18:	e0e5      	b.n	100090e6 <__aeabi_ddiv+0x49e>
10008f1a:	d100      	bne.n	10008f1e <__aeabi_ddiv+0x2d6>
10008f1c:	e0df      	b.n	100090de <__aeabi_ddiv+0x496>
10008f1e:	1b1f      	subs	r7, r3, r4
10008f20:	4643      	mov	r3, r8
10008f22:	1a5c      	subs	r4, r3, r1
10008f24:	45a0      	cmp	r8, r4
10008f26:	4192      	sbcs	r2, r2
10008f28:	4252      	negs	r2, r2
10008f2a:	1abf      	subs	r7, r7, r2
10008f2c:	42b7      	cmp	r7, r6
10008f2e:	d100      	bne.n	10008f32 <__aeabi_ddiv+0x2ea>
10008f30:	e10e      	b.n	10009150 <__aeabi_ddiv+0x508>
10008f32:	1c38      	adds	r0, r7, #0
10008f34:	4649      	mov	r1, r9
10008f36:	f7fc fb9f 	bl	10005678 <__aeabi_uidiv>
10008f3a:	9b00      	ldr	r3, [sp, #0]
10008f3c:	9002      	str	r0, [sp, #8]
10008f3e:	4343      	muls	r3, r0
10008f40:	4649      	mov	r1, r9
10008f42:	1c38      	adds	r0, r7, #0
10008f44:	4698      	mov	r8, r3
10008f46:	f7fc fc1d 	bl	10005784 <__aeabi_uidivmod>
10008f4a:	0c23      	lsrs	r3, r4, #16
10008f4c:	040f      	lsls	r7, r1, #16
10008f4e:	431f      	orrs	r7, r3
10008f50:	45b8      	cmp	r8, r7
10008f52:	d90c      	bls.n	10008f6e <__aeabi_ddiv+0x326>
10008f54:	9b02      	ldr	r3, [sp, #8]
10008f56:	19bf      	adds	r7, r7, r6
10008f58:	3b01      	subs	r3, #1
10008f5a:	42be      	cmp	r6, r7
10008f5c:	d900      	bls.n	10008f60 <__aeabi_ddiv+0x318>
10008f5e:	e0fb      	b.n	10009158 <__aeabi_ddiv+0x510>
10008f60:	45b8      	cmp	r8, r7
10008f62:	d800      	bhi.n	10008f66 <__aeabi_ddiv+0x31e>
10008f64:	e0f8      	b.n	10009158 <__aeabi_ddiv+0x510>
10008f66:	9b02      	ldr	r3, [sp, #8]
10008f68:	19bf      	adds	r7, r7, r6
10008f6a:	3b02      	subs	r3, #2
10008f6c:	9302      	str	r3, [sp, #8]
10008f6e:	4643      	mov	r3, r8
10008f70:	1aff      	subs	r7, r7, r3
10008f72:	4649      	mov	r1, r9
10008f74:	1c38      	adds	r0, r7, #0
10008f76:	f7fc fb7f 	bl	10005678 <__aeabi_uidiv>
10008f7a:	9b00      	ldr	r3, [sp, #0]
10008f7c:	9003      	str	r0, [sp, #12]
10008f7e:	4343      	muls	r3, r0
10008f80:	4649      	mov	r1, r9
10008f82:	1c38      	adds	r0, r7, #0
10008f84:	4698      	mov	r8, r3
10008f86:	f7fc fbfd 	bl	10005784 <__aeabi_uidivmod>
10008f8a:	0424      	lsls	r4, r4, #16
10008f8c:	0409      	lsls	r1, r1, #16
10008f8e:	0c24      	lsrs	r4, r4, #16
10008f90:	4321      	orrs	r1, r4
10008f92:	4588      	cmp	r8, r1
10008f94:	d90c      	bls.n	10008fb0 <__aeabi_ddiv+0x368>
10008f96:	9b03      	ldr	r3, [sp, #12]
10008f98:	1989      	adds	r1, r1, r6
10008f9a:	3b01      	subs	r3, #1
10008f9c:	428e      	cmp	r6, r1
10008f9e:	d900      	bls.n	10008fa2 <__aeabi_ddiv+0x35a>
10008fa0:	e0dc      	b.n	1000915c <__aeabi_ddiv+0x514>
10008fa2:	4588      	cmp	r8, r1
10008fa4:	d800      	bhi.n	10008fa8 <__aeabi_ddiv+0x360>
10008fa6:	e0d9      	b.n	1000915c <__aeabi_ddiv+0x514>
10008fa8:	9b03      	ldr	r3, [sp, #12]
10008faa:	1989      	adds	r1, r1, r6
10008fac:	3b02      	subs	r3, #2
10008fae:	9303      	str	r3, [sp, #12]
10008fb0:	4643      	mov	r3, r8
10008fb2:	1ac9      	subs	r1, r1, r3
10008fb4:	9b02      	ldr	r3, [sp, #8]
10008fb6:	9a03      	ldr	r2, [sp, #12]
10008fb8:	041b      	lsls	r3, r3, #16
10008fba:	9c05      	ldr	r4, [sp, #20]
10008fbc:	431a      	orrs	r2, r3
10008fbe:	0c10      	lsrs	r0, r2, #16
10008fc0:	0413      	lsls	r3, r2, #16
10008fc2:	4691      	mov	r9, r2
10008fc4:	1c22      	adds	r2, r4, #0
10008fc6:	9f04      	ldr	r7, [sp, #16]
10008fc8:	0c1b      	lsrs	r3, r3, #16
10008fca:	435a      	muls	r2, r3
10008fcc:	4344      	muls	r4, r0
10008fce:	437b      	muls	r3, r7
10008fd0:	4378      	muls	r0, r7
10008fd2:	18e3      	adds	r3, r4, r3
10008fd4:	0c17      	lsrs	r7, r2, #16
10008fd6:	19db      	adds	r3, r3, r7
10008fd8:	429c      	cmp	r4, r3
10008fda:	d903      	bls.n	10008fe4 <__aeabi_ddiv+0x39c>
10008fdc:	2480      	movs	r4, #128	; 0x80
10008fde:	0264      	lsls	r4, r4, #9
10008fe0:	46a4      	mov	ip, r4
10008fe2:	4460      	add	r0, ip
10008fe4:	0c1c      	lsrs	r4, r3, #16
10008fe6:	0412      	lsls	r2, r2, #16
10008fe8:	041b      	lsls	r3, r3, #16
10008fea:	0c12      	lsrs	r2, r2, #16
10008fec:	1900      	adds	r0, r0, r4
10008fee:	189b      	adds	r3, r3, r2
10008ff0:	4281      	cmp	r1, r0
10008ff2:	d200      	bcs.n	10008ff6 <__aeabi_ddiv+0x3ae>
10008ff4:	e096      	b.n	10009124 <__aeabi_ddiv+0x4dc>
10008ff6:	d100      	bne.n	10008ffa <__aeabi_ddiv+0x3b2>
10008ff8:	e0fc      	b.n	100091f4 <__aeabi_ddiv+0x5ac>
10008ffa:	464a      	mov	r2, r9
10008ffc:	2301      	movs	r3, #1
10008ffe:	431a      	orrs	r2, r3
10009000:	4691      	mov	r9, r2
10009002:	4b9b      	ldr	r3, [pc, #620]	; (10009270 <__aeabi_ddiv+0x628>)
10009004:	18eb      	adds	r3, r5, r3
10009006:	2b00      	cmp	r3, #0
10009008:	dc00      	bgt.n	1000900c <__aeabi_ddiv+0x3c4>
1000900a:	e099      	b.n	10009140 <__aeabi_ddiv+0x4f8>
1000900c:	464a      	mov	r2, r9
1000900e:	0752      	lsls	r2, r2, #29
10009010:	d00a      	beq.n	10009028 <__aeabi_ddiv+0x3e0>
10009012:	220f      	movs	r2, #15
10009014:	4649      	mov	r1, r9
10009016:	400a      	ands	r2, r1
10009018:	2a04      	cmp	r2, #4
1000901a:	d005      	beq.n	10009028 <__aeabi_ddiv+0x3e0>
1000901c:	3104      	adds	r1, #4
1000901e:	4549      	cmp	r1, r9
10009020:	4192      	sbcs	r2, r2
10009022:	4689      	mov	r9, r1
10009024:	4252      	negs	r2, r2
10009026:	4493      	add	fp, r2
10009028:	465a      	mov	r2, fp
1000902a:	01d2      	lsls	r2, r2, #7
1000902c:	d506      	bpl.n	1000903c <__aeabi_ddiv+0x3f4>
1000902e:	465a      	mov	r2, fp
10009030:	4b90      	ldr	r3, [pc, #576]	; (10009274 <__aeabi_ddiv+0x62c>)
10009032:	401a      	ands	r2, r3
10009034:	2380      	movs	r3, #128	; 0x80
10009036:	4693      	mov	fp, r2
10009038:	00db      	lsls	r3, r3, #3
1000903a:	18eb      	adds	r3, r5, r3
1000903c:	4a8e      	ldr	r2, [pc, #568]	; (10009278 <__aeabi_ddiv+0x630>)
1000903e:	4293      	cmp	r3, r2
10009040:	dd00      	ble.n	10009044 <__aeabi_ddiv+0x3fc>
10009042:	e662      	b.n	10008d0a <__aeabi_ddiv+0xc2>
10009044:	464a      	mov	r2, r9
10009046:	4659      	mov	r1, fp
10009048:	08d2      	lsrs	r2, r2, #3
1000904a:	0749      	lsls	r1, r1, #29
1000904c:	4311      	orrs	r1, r2
1000904e:	465a      	mov	r2, fp
10009050:	4689      	mov	r9, r1
10009052:	0257      	lsls	r7, r2, #9
10009054:	4651      	mov	r1, sl
10009056:	2201      	movs	r2, #1
10009058:	055b      	lsls	r3, r3, #21
1000905a:	0b3f      	lsrs	r7, r7, #12
1000905c:	0d5b      	lsrs	r3, r3, #21
1000905e:	400a      	ands	r2, r1
10009060:	e65a      	b.n	10008d18 <__aeabi_ddiv+0xd0>
10009062:	2080      	movs	r0, #128	; 0x80
10009064:	465a      	mov	r2, fp
10009066:	0300      	lsls	r0, r0, #12
10009068:	4202      	tst	r2, r0
1000906a:	d008      	beq.n	1000907e <__aeabi_ddiv+0x436>
1000906c:	4207      	tst	r7, r0
1000906e:	d106      	bne.n	1000907e <__aeabi_ddiv+0x436>
10009070:	4307      	orrs	r7, r0
10009072:	033f      	lsls	r7, r7, #12
10009074:	4699      	mov	r9, r3
10009076:	0b3f      	lsrs	r7, r7, #12
10009078:	4642      	mov	r2, r8
1000907a:	4b80      	ldr	r3, [pc, #512]	; (1000927c <__aeabi_ddiv+0x634>)
1000907c:	e64c      	b.n	10008d18 <__aeabi_ddiv+0xd0>
1000907e:	465f      	mov	r7, fp
10009080:	4307      	orrs	r7, r0
10009082:	033f      	lsls	r7, r7, #12
10009084:	0b3f      	lsrs	r7, r7, #12
10009086:	1c22      	adds	r2, r4, #0
10009088:	4b7c      	ldr	r3, [pc, #496]	; (1000927c <__aeabi_ddiv+0x634>)
1000908a:	e645      	b.n	10008d18 <__aeabi_ddiv+0xd0>
1000908c:	f7fc fc76 	bl	1000597c <__clzsi2>
10009090:	1c03      	adds	r3, r0, #0
10009092:	3020      	adds	r0, #32
10009094:	2827      	cmp	r0, #39	; 0x27
10009096:	dc00      	bgt.n	1000909a <__aeabi_ddiv+0x452>
10009098:	e65e      	b.n	10008d58 <__aeabi_ddiv+0x110>
1000909a:	3b08      	subs	r3, #8
1000909c:	409e      	lsls	r6, r3
1000909e:	2300      	movs	r3, #0
100090a0:	46b3      	mov	fp, r6
100090a2:	4699      	mov	r9, r3
100090a4:	e665      	b.n	10008d72 <__aeabi_ddiv+0x12a>
100090a6:	4650      	mov	r0, sl
100090a8:	f7fc fc68 	bl	1000597c <__clzsi2>
100090ac:	1c02      	adds	r2, r0, #0
100090ae:	3220      	adds	r2, #32
100090b0:	2a27      	cmp	r2, #39	; 0x27
100090b2:	dc00      	bgt.n	100090b6 <__aeabi_ddiv+0x46e>
100090b4:	e675      	b.n	10008da2 <__aeabi_ddiv+0x15a>
100090b6:	4657      	mov	r7, sl
100090b8:	3808      	subs	r0, #8
100090ba:	4087      	lsls	r7, r0
100090bc:	2300      	movs	r3, #0
100090be:	e67b      	b.n	10008db8 <__aeabi_ddiv+0x170>
100090c0:	4599      	cmp	r9, r3
100090c2:	d200      	bcs.n	100090c6 <__aeabi_ddiv+0x47e>
100090c4:	e6af      	b.n	10008e26 <__aeabi_ddiv+0x1de>
100090c6:	465a      	mov	r2, fp
100090c8:	4659      	mov	r1, fp
100090ca:	0854      	lsrs	r4, r2, #1
100090cc:	464a      	mov	r2, r9
100090ce:	07c8      	lsls	r0, r1, #31
100090d0:	0852      	lsrs	r2, r2, #1
100090d2:	4302      	orrs	r2, r0
100090d4:	9203      	str	r2, [sp, #12]
100090d6:	464a      	mov	r2, r9
100090d8:	07d2      	lsls	r2, r2, #31
100090da:	4690      	mov	r8, r2
100090dc:	e6a9      	b.n	10008e32 <__aeabi_ddiv+0x1ea>
100090de:	2700      	movs	r7, #0
100090e0:	4588      	cmp	r8, r1
100090e2:	d300      	bcc.n	100090e6 <__aeabi_ddiv+0x49e>
100090e4:	e71c      	b.n	10008f20 <__aeabi_ddiv+0x2d8>
100090e6:	9f01      	ldr	r7, [sp, #4]
100090e8:	465a      	mov	r2, fp
100090ea:	46bc      	mov	ip, r7
100090ec:	44e0      	add	r8, ip
100090ee:	45b8      	cmp	r8, r7
100090f0:	41bf      	sbcs	r7, r7
100090f2:	427f      	negs	r7, r7
100090f4:	19bf      	adds	r7, r7, r6
100090f6:	18ff      	adds	r7, r7, r3
100090f8:	3a01      	subs	r2, #1
100090fa:	42be      	cmp	r6, r7
100090fc:	d206      	bcs.n	1000910c <__aeabi_ddiv+0x4c4>
100090fe:	42bc      	cmp	r4, r7
10009100:	d85f      	bhi.n	100091c2 <__aeabi_ddiv+0x57a>
10009102:	d100      	bne.n	10009106 <__aeabi_ddiv+0x4be>
10009104:	e09f      	b.n	10009246 <__aeabi_ddiv+0x5fe>
10009106:	1b3f      	subs	r7, r7, r4
10009108:	4693      	mov	fp, r2
1000910a:	e709      	b.n	10008f20 <__aeabi_ddiv+0x2d8>
1000910c:	42b7      	cmp	r7, r6
1000910e:	d1fa      	bne.n	10009106 <__aeabi_ddiv+0x4be>
10009110:	9b01      	ldr	r3, [sp, #4]
10009112:	4543      	cmp	r3, r8
10009114:	d9f3      	bls.n	100090fe <__aeabi_ddiv+0x4b6>
10009116:	1b37      	subs	r7, r6, r4
10009118:	4693      	mov	fp, r2
1000911a:	e701      	b.n	10008f20 <__aeabi_ddiv+0x2d8>
1000911c:	4693      	mov	fp, r2
1000911e:	e6d4      	b.n	10008eca <__aeabi_ddiv+0x282>
10009120:	9302      	str	r3, [sp, #8]
10009122:	e6b1      	b.n	10008e88 <__aeabi_ddiv+0x240>
10009124:	464a      	mov	r2, r9
10009126:	1989      	adds	r1, r1, r6
10009128:	3a01      	subs	r2, #1
1000912a:	428e      	cmp	r6, r1
1000912c:	d918      	bls.n	10009160 <__aeabi_ddiv+0x518>
1000912e:	4691      	mov	r9, r2
10009130:	4281      	cmp	r1, r0
10009132:	d000      	beq.n	10009136 <__aeabi_ddiv+0x4ee>
10009134:	e761      	b.n	10008ffa <__aeabi_ddiv+0x3b2>
10009136:	9a01      	ldr	r2, [sp, #4]
10009138:	429a      	cmp	r2, r3
1000913a:	d000      	beq.n	1000913e <__aeabi_ddiv+0x4f6>
1000913c:	e75d      	b.n	10008ffa <__aeabi_ddiv+0x3b2>
1000913e:	e760      	b.n	10009002 <__aeabi_ddiv+0x3ba>
10009140:	4f4f      	ldr	r7, [pc, #316]	; (10009280 <__aeabi_ddiv+0x638>)
10009142:	1b7f      	subs	r7, r7, r5
10009144:	2f38      	cmp	r7, #56	; 0x38
10009146:	dd13      	ble.n	10009170 <__aeabi_ddiv+0x528>
10009148:	2201      	movs	r2, #1
1000914a:	4653      	mov	r3, sl
1000914c:	401a      	ands	r2, r3
1000914e:	e64f      	b.n	10008df0 <__aeabi_ddiv+0x1a8>
10009150:	2301      	movs	r3, #1
10009152:	425b      	negs	r3, r3
10009154:	4699      	mov	r9, r3
10009156:	e754      	b.n	10009002 <__aeabi_ddiv+0x3ba>
10009158:	9302      	str	r3, [sp, #8]
1000915a:	e708      	b.n	10008f6e <__aeabi_ddiv+0x326>
1000915c:	9303      	str	r3, [sp, #12]
1000915e:	e727      	b.n	10008fb0 <__aeabi_ddiv+0x368>
10009160:	4288      	cmp	r0, r1
10009162:	d83c      	bhi.n	100091de <__aeabi_ddiv+0x596>
10009164:	d074      	beq.n	10009250 <__aeabi_ddiv+0x608>
10009166:	4691      	mov	r9, r2
10009168:	e747      	b.n	10008ffa <__aeabi_ddiv+0x3b2>
1000916a:	9b01      	ldr	r3, [sp, #4]
1000916c:	469a      	mov	sl, r3
1000916e:	e748      	b.n	10009002 <__aeabi_ddiv+0x3ba>
10009170:	2f1f      	cmp	r7, #31
10009172:	dc44      	bgt.n	100091fe <__aeabi_ddiv+0x5b6>
10009174:	4b43      	ldr	r3, [pc, #268]	; (10009284 <__aeabi_ddiv+0x63c>)
10009176:	464a      	mov	r2, r9
10009178:	469c      	mov	ip, r3
1000917a:	465b      	mov	r3, fp
1000917c:	4465      	add	r5, ip
1000917e:	40fa      	lsrs	r2, r7
10009180:	40ab      	lsls	r3, r5
10009182:	4313      	orrs	r3, r2
10009184:	464a      	mov	r2, r9
10009186:	40aa      	lsls	r2, r5
10009188:	1c15      	adds	r5, r2, #0
1000918a:	1e6a      	subs	r2, r5, #1
1000918c:	4195      	sbcs	r5, r2
1000918e:	465a      	mov	r2, fp
10009190:	40fa      	lsrs	r2, r7
10009192:	432b      	orrs	r3, r5
10009194:	1c17      	adds	r7, r2, #0
10009196:	075a      	lsls	r2, r3, #29
10009198:	d009      	beq.n	100091ae <__aeabi_ddiv+0x566>
1000919a:	220f      	movs	r2, #15
1000919c:	401a      	ands	r2, r3
1000919e:	2a04      	cmp	r2, #4
100091a0:	d005      	beq.n	100091ae <__aeabi_ddiv+0x566>
100091a2:	1d1a      	adds	r2, r3, #4
100091a4:	429a      	cmp	r2, r3
100091a6:	419b      	sbcs	r3, r3
100091a8:	425b      	negs	r3, r3
100091aa:	18ff      	adds	r7, r7, r3
100091ac:	1c13      	adds	r3, r2, #0
100091ae:	023a      	lsls	r2, r7, #8
100091b0:	d53e      	bpl.n	10009230 <__aeabi_ddiv+0x5e8>
100091b2:	4653      	mov	r3, sl
100091b4:	2201      	movs	r2, #1
100091b6:	2100      	movs	r1, #0
100091b8:	401a      	ands	r2, r3
100091ba:	2700      	movs	r7, #0
100091bc:	2301      	movs	r3, #1
100091be:	4689      	mov	r9, r1
100091c0:	e5aa      	b.n	10008d18 <__aeabi_ddiv+0xd0>
100091c2:	2302      	movs	r3, #2
100091c4:	425b      	negs	r3, r3
100091c6:	469c      	mov	ip, r3
100091c8:	9a01      	ldr	r2, [sp, #4]
100091ca:	44e3      	add	fp, ip
100091cc:	4694      	mov	ip, r2
100091ce:	44e0      	add	r8, ip
100091d0:	4590      	cmp	r8, r2
100091d2:	419b      	sbcs	r3, r3
100091d4:	425b      	negs	r3, r3
100091d6:	199b      	adds	r3, r3, r6
100091d8:	19df      	adds	r7, r3, r7
100091da:	1b3f      	subs	r7, r7, r4
100091dc:	e6a0      	b.n	10008f20 <__aeabi_ddiv+0x2d8>
100091de:	9f01      	ldr	r7, [sp, #4]
100091e0:	464a      	mov	r2, r9
100091e2:	007c      	lsls	r4, r7, #1
100091e4:	42bc      	cmp	r4, r7
100091e6:	41bf      	sbcs	r7, r7
100091e8:	427f      	negs	r7, r7
100091ea:	19bf      	adds	r7, r7, r6
100091ec:	3a02      	subs	r2, #2
100091ee:	19c9      	adds	r1, r1, r7
100091f0:	9401      	str	r4, [sp, #4]
100091f2:	e79c      	b.n	1000912e <__aeabi_ddiv+0x4e6>
100091f4:	2b00      	cmp	r3, #0
100091f6:	d195      	bne.n	10009124 <__aeabi_ddiv+0x4dc>
100091f8:	2200      	movs	r2, #0
100091fa:	9201      	str	r2, [sp, #4]
100091fc:	e79b      	b.n	10009136 <__aeabi_ddiv+0x4ee>
100091fe:	465a      	mov	r2, fp
10009200:	4b21      	ldr	r3, [pc, #132]	; (10009288 <__aeabi_ddiv+0x640>)
10009202:	1b5b      	subs	r3, r3, r5
10009204:	40da      	lsrs	r2, r3
10009206:	2f20      	cmp	r7, #32
10009208:	d027      	beq.n	1000925a <__aeabi_ddiv+0x612>
1000920a:	4b20      	ldr	r3, [pc, #128]	; (1000928c <__aeabi_ddiv+0x644>)
1000920c:	469c      	mov	ip, r3
1000920e:	465b      	mov	r3, fp
10009210:	4465      	add	r5, ip
10009212:	40ab      	lsls	r3, r5
10009214:	4649      	mov	r1, r9
10009216:	430b      	orrs	r3, r1
10009218:	1e59      	subs	r1, r3, #1
1000921a:	418b      	sbcs	r3, r1
1000921c:	4313      	orrs	r3, r2
1000921e:	2207      	movs	r2, #7
10009220:	2700      	movs	r7, #0
10009222:	401a      	ands	r2, r3
10009224:	d007      	beq.n	10009236 <__aeabi_ddiv+0x5ee>
10009226:	220f      	movs	r2, #15
10009228:	2700      	movs	r7, #0
1000922a:	401a      	ands	r2, r3
1000922c:	2a04      	cmp	r2, #4
1000922e:	d1b8      	bne.n	100091a2 <__aeabi_ddiv+0x55a>
10009230:	077a      	lsls	r2, r7, #29
10009232:	027f      	lsls	r7, r7, #9
10009234:	0b3f      	lsrs	r7, r7, #12
10009236:	08db      	lsrs	r3, r3, #3
10009238:	4313      	orrs	r3, r2
1000923a:	4699      	mov	r9, r3
1000923c:	2201      	movs	r2, #1
1000923e:	4653      	mov	r3, sl
10009240:	401a      	ands	r2, r3
10009242:	2300      	movs	r3, #0
10009244:	e568      	b.n	10008d18 <__aeabi_ddiv+0xd0>
10009246:	4541      	cmp	r1, r8
10009248:	d8bb      	bhi.n	100091c2 <__aeabi_ddiv+0x57a>
1000924a:	4693      	mov	fp, r2
1000924c:	2700      	movs	r7, #0
1000924e:	e667      	b.n	10008f20 <__aeabi_ddiv+0x2d8>
10009250:	9c01      	ldr	r4, [sp, #4]
10009252:	429c      	cmp	r4, r3
10009254:	d3c3      	bcc.n	100091de <__aeabi_ddiv+0x596>
10009256:	4691      	mov	r9, r2
10009258:	e76d      	b.n	10009136 <__aeabi_ddiv+0x4ee>
1000925a:	2300      	movs	r3, #0
1000925c:	e7da      	b.n	10009214 <__aeabi_ddiv+0x5cc>
1000925e:	2780      	movs	r7, #128	; 0x80
10009260:	465b      	mov	r3, fp
10009262:	033f      	lsls	r7, r7, #12
10009264:	431f      	orrs	r7, r3
10009266:	033f      	lsls	r7, r7, #12
10009268:	0b3f      	lsrs	r7, r7, #12
1000926a:	9a01      	ldr	r2, [sp, #4]
1000926c:	4b03      	ldr	r3, [pc, #12]	; (1000927c <__aeabi_ddiv+0x634>)
1000926e:	e553      	b.n	10008d18 <__aeabi_ddiv+0xd0>
10009270:	000003ff 	.word	0x000003ff
10009274:	feffffff 	.word	0xfeffffff
10009278:	000007fe 	.word	0x000007fe
1000927c:	000007ff 	.word	0x000007ff
10009280:	fffffc02 	.word	0xfffffc02
10009284:	0000041e 	.word	0x0000041e
10009288:	fffffbe2 	.word	0xfffffbe2
1000928c:	0000043e 	.word	0x0000043e

10009290 <__eqdf2>:
10009290:	b5f0      	push	{r4, r5, r6, r7, lr}
10009292:	465f      	mov	r7, fp
10009294:	464d      	mov	r5, r9
10009296:	4644      	mov	r4, r8
10009298:	4656      	mov	r6, sl
1000929a:	b4f0      	push	{r4, r5, r6, r7}
1000929c:	031f      	lsls	r7, r3, #12
1000929e:	005c      	lsls	r4, r3, #1
100092a0:	0fdb      	lsrs	r3, r3, #31
100092a2:	4699      	mov	r9, r3
100092a4:	4b1b      	ldr	r3, [pc, #108]	; (10009314 <__eqdf2+0x84>)
100092a6:	030e      	lsls	r6, r1, #12
100092a8:	004d      	lsls	r5, r1, #1
100092aa:	0fc9      	lsrs	r1, r1, #31
100092ac:	4684      	mov	ip, r0
100092ae:	0b36      	lsrs	r6, r6, #12
100092b0:	0d6d      	lsrs	r5, r5, #21
100092b2:	468b      	mov	fp, r1
100092b4:	4690      	mov	r8, r2
100092b6:	0b3f      	lsrs	r7, r7, #12
100092b8:	0d64      	lsrs	r4, r4, #21
100092ba:	429d      	cmp	r5, r3
100092bc:	d00c      	beq.n	100092d8 <__eqdf2+0x48>
100092be:	4b15      	ldr	r3, [pc, #84]	; (10009314 <__eqdf2+0x84>)
100092c0:	429c      	cmp	r4, r3
100092c2:	d010      	beq.n	100092e6 <__eqdf2+0x56>
100092c4:	2301      	movs	r3, #1
100092c6:	42a5      	cmp	r5, r4
100092c8:	d014      	beq.n	100092f4 <__eqdf2+0x64>
100092ca:	1c18      	adds	r0, r3, #0
100092cc:	bc3c      	pop	{r2, r3, r4, r5}
100092ce:	4690      	mov	r8, r2
100092d0:	4699      	mov	r9, r3
100092d2:	46a2      	mov	sl, r4
100092d4:	46ab      	mov	fp, r5
100092d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
100092d8:	1c31      	adds	r1, r6, #0
100092da:	2301      	movs	r3, #1
100092dc:	4301      	orrs	r1, r0
100092de:	d1f4      	bne.n	100092ca <__eqdf2+0x3a>
100092e0:	4b0c      	ldr	r3, [pc, #48]	; (10009314 <__eqdf2+0x84>)
100092e2:	429c      	cmp	r4, r3
100092e4:	d1ee      	bne.n	100092c4 <__eqdf2+0x34>
100092e6:	433a      	orrs	r2, r7
100092e8:	2301      	movs	r3, #1
100092ea:	2a00      	cmp	r2, #0
100092ec:	d1ed      	bne.n	100092ca <__eqdf2+0x3a>
100092ee:	2301      	movs	r3, #1
100092f0:	42a5      	cmp	r5, r4
100092f2:	d1ea      	bne.n	100092ca <__eqdf2+0x3a>
100092f4:	42be      	cmp	r6, r7
100092f6:	d1e8      	bne.n	100092ca <__eqdf2+0x3a>
100092f8:	45c4      	cmp	ip, r8
100092fa:	d1e6      	bne.n	100092ca <__eqdf2+0x3a>
100092fc:	45cb      	cmp	fp, r9
100092fe:	d006      	beq.n	1000930e <__eqdf2+0x7e>
10009300:	2d00      	cmp	r5, #0
10009302:	d1e2      	bne.n	100092ca <__eqdf2+0x3a>
10009304:	4330      	orrs	r0, r6
10009306:	1c03      	adds	r3, r0, #0
10009308:	1e58      	subs	r0, r3, #1
1000930a:	4183      	sbcs	r3, r0
1000930c:	e7dd      	b.n	100092ca <__eqdf2+0x3a>
1000930e:	2300      	movs	r3, #0
10009310:	e7db      	b.n	100092ca <__eqdf2+0x3a>
10009312:	46c0      	nop			; (mov r8, r8)
10009314:	000007ff 	.word	0x000007ff

10009318 <__gedf2>:
10009318:	b5f0      	push	{r4, r5, r6, r7, lr}
1000931a:	4657      	mov	r7, sl
1000931c:	4645      	mov	r5, r8
1000931e:	464e      	mov	r6, r9
10009320:	b4e0      	push	{r5, r6, r7}
10009322:	030f      	lsls	r7, r1, #12
10009324:	004e      	lsls	r6, r1, #1
10009326:	0fc9      	lsrs	r1, r1, #31
10009328:	468a      	mov	sl, r1
1000932a:	4932      	ldr	r1, [pc, #200]	; (100093f4 <__gedf2+0xdc>)
1000932c:	031d      	lsls	r5, r3, #12
1000932e:	005c      	lsls	r4, r3, #1
10009330:	4684      	mov	ip, r0
10009332:	0b3f      	lsrs	r7, r7, #12
10009334:	0d76      	lsrs	r6, r6, #21
10009336:	4690      	mov	r8, r2
10009338:	0b2d      	lsrs	r5, r5, #12
1000933a:	0d64      	lsrs	r4, r4, #21
1000933c:	0fdb      	lsrs	r3, r3, #31
1000933e:	428e      	cmp	r6, r1
10009340:	d00f      	beq.n	10009362 <__gedf2+0x4a>
10009342:	428c      	cmp	r4, r1
10009344:	d039      	beq.n	100093ba <__gedf2+0xa2>
10009346:	2e00      	cmp	r6, #0
10009348:	d110      	bne.n	1000936c <__gedf2+0x54>
1000934a:	4338      	orrs	r0, r7
1000934c:	4241      	negs	r1, r0
1000934e:	4141      	adcs	r1, r0
10009350:	4689      	mov	r9, r1
10009352:	2c00      	cmp	r4, #0
10009354:	d127      	bne.n	100093a6 <__gedf2+0x8e>
10009356:	432a      	orrs	r2, r5
10009358:	d125      	bne.n	100093a6 <__gedf2+0x8e>
1000935a:	2000      	movs	r0, #0
1000935c:	2900      	cmp	r1, #0
1000935e:	d10e      	bne.n	1000937e <__gedf2+0x66>
10009360:	e008      	b.n	10009374 <__gedf2+0x5c>
10009362:	1c39      	adds	r1, r7, #0
10009364:	4301      	orrs	r1, r0
10009366:	d12e      	bne.n	100093c6 <__gedf2+0xae>
10009368:	42b4      	cmp	r4, r6
1000936a:	d026      	beq.n	100093ba <__gedf2+0xa2>
1000936c:	2c00      	cmp	r4, #0
1000936e:	d00b      	beq.n	10009388 <__gedf2+0x70>
10009370:	459a      	cmp	sl, r3
10009372:	d00d      	beq.n	10009390 <__gedf2+0x78>
10009374:	4653      	mov	r3, sl
10009376:	4259      	negs	r1, r3
10009378:	2301      	movs	r3, #1
1000937a:	4319      	orrs	r1, r3
1000937c:	1c08      	adds	r0, r1, #0
1000937e:	bc1c      	pop	{r2, r3, r4}
10009380:	4690      	mov	r8, r2
10009382:	4699      	mov	r9, r3
10009384:	46a2      	mov	sl, r4
10009386:	bdf0      	pop	{r4, r5, r6, r7, pc}
10009388:	432a      	orrs	r2, r5
1000938a:	d0f3      	beq.n	10009374 <__gedf2+0x5c>
1000938c:	459a      	cmp	sl, r3
1000938e:	d1f1      	bne.n	10009374 <__gedf2+0x5c>
10009390:	42a6      	cmp	r6, r4
10009392:	dcef      	bgt.n	10009374 <__gedf2+0x5c>
10009394:	da1a      	bge.n	100093cc <__gedf2+0xb4>
10009396:	4650      	mov	r0, sl
10009398:	4241      	negs	r1, r0
1000939a:	4148      	adcs	r0, r1
1000939c:	2301      	movs	r3, #1
1000939e:	4241      	negs	r1, r0
100093a0:	4319      	orrs	r1, r3
100093a2:	1c08      	adds	r0, r1, #0
100093a4:	e7eb      	b.n	1000937e <__gedf2+0x66>
100093a6:	464a      	mov	r2, r9
100093a8:	2a00      	cmp	r2, #0
100093aa:	d0e1      	beq.n	10009370 <__gedf2+0x58>
100093ac:	4258      	negs	r0, r3
100093ae:	4158      	adcs	r0, r3
100093b0:	2201      	movs	r2, #1
100093b2:	4241      	negs	r1, r0
100093b4:	4311      	orrs	r1, r2
100093b6:	1c08      	adds	r0, r1, #0
100093b8:	e7e1      	b.n	1000937e <__gedf2+0x66>
100093ba:	1c29      	adds	r1, r5, #0
100093bc:	4311      	orrs	r1, r2
100093be:	d102      	bne.n	100093c6 <__gedf2+0xae>
100093c0:	2e00      	cmp	r6, #0
100093c2:	d0c2      	beq.n	1000934a <__gedf2+0x32>
100093c4:	e7d4      	b.n	10009370 <__gedf2+0x58>
100093c6:	2002      	movs	r0, #2
100093c8:	4240      	negs	r0, r0
100093ca:	e7d8      	b.n	1000937e <__gedf2+0x66>
100093cc:	42af      	cmp	r7, r5
100093ce:	d8d1      	bhi.n	10009374 <__gedf2+0x5c>
100093d0:	d009      	beq.n	100093e6 <__gedf2+0xce>
100093d2:	2000      	movs	r0, #0
100093d4:	42af      	cmp	r7, r5
100093d6:	d2d2      	bcs.n	1000937e <__gedf2+0x66>
100093d8:	4650      	mov	r0, sl
100093da:	4241      	negs	r1, r0
100093dc:	4148      	adcs	r0, r1
100093de:	2301      	movs	r3, #1
100093e0:	4240      	negs	r0, r0
100093e2:	4318      	orrs	r0, r3
100093e4:	e7cb      	b.n	1000937e <__gedf2+0x66>
100093e6:	45c4      	cmp	ip, r8
100093e8:	d8c4      	bhi.n	10009374 <__gedf2+0x5c>
100093ea:	2000      	movs	r0, #0
100093ec:	45c4      	cmp	ip, r8
100093ee:	d3f3      	bcc.n	100093d8 <__gedf2+0xc0>
100093f0:	e7c5      	b.n	1000937e <__gedf2+0x66>
100093f2:	46c0      	nop			; (mov r8, r8)
100093f4:	000007ff 	.word	0x000007ff

100093f8 <__ledf2>:
100093f8:	b5f0      	push	{r4, r5, r6, r7, lr}
100093fa:	465f      	mov	r7, fp
100093fc:	464d      	mov	r5, r9
100093fe:	4644      	mov	r4, r8
10009400:	4656      	mov	r6, sl
10009402:	4680      	mov	r8, r0
10009404:	b4f0      	push	{r4, r5, r6, r7}
10009406:	1c06      	adds	r6, r0, #0
10009408:	0308      	lsls	r0, r1, #12
1000940a:	0b00      	lsrs	r0, r0, #12
1000940c:	4684      	mov	ip, r0
1000940e:	482c      	ldr	r0, [pc, #176]	; (100094c0 <__ledf2+0xc8>)
10009410:	004c      	lsls	r4, r1, #1
10009412:	031f      	lsls	r7, r3, #12
10009414:	005d      	lsls	r5, r3, #1
10009416:	0fc9      	lsrs	r1, r1, #31
10009418:	0d64      	lsrs	r4, r4, #21
1000941a:	468b      	mov	fp, r1
1000941c:	4691      	mov	r9, r2
1000941e:	0b3f      	lsrs	r7, r7, #12
10009420:	0d6d      	lsrs	r5, r5, #21
10009422:	0fdb      	lsrs	r3, r3, #31
10009424:	4284      	cmp	r4, r0
10009426:	d012      	beq.n	1000944e <__ledf2+0x56>
10009428:	4285      	cmp	r5, r0
1000942a:	d025      	beq.n	10009478 <__ledf2+0x80>
1000942c:	2c00      	cmp	r4, #0
1000942e:	d114      	bne.n	1000945a <__ledf2+0x62>
10009430:	4661      	mov	r1, ip
10009432:	430e      	orrs	r6, r1
10009434:	4270      	negs	r0, r6
10009436:	4146      	adcs	r6, r0
10009438:	2d00      	cmp	r5, #0
1000943a:	d035      	beq.n	100094a8 <__ledf2+0xb0>
1000943c:	2e00      	cmp	r6, #0
1000943e:	d021      	beq.n	10009484 <__ledf2+0x8c>
10009440:	4258      	negs	r0, r3
10009442:	4158      	adcs	r0, r3
10009444:	2101      	movs	r1, #1
10009446:	4243      	negs	r3, r0
10009448:	430b      	orrs	r3, r1
1000944a:	1c18      	adds	r0, r3, #0
1000944c:	e00e      	b.n	1000946c <__ledf2+0x74>
1000944e:	4661      	mov	r1, ip
10009450:	2002      	movs	r0, #2
10009452:	4331      	orrs	r1, r6
10009454:	d10a      	bne.n	1000946c <__ledf2+0x74>
10009456:	42a5      	cmp	r5, r4
10009458:	d00e      	beq.n	10009478 <__ledf2+0x80>
1000945a:	2d00      	cmp	r5, #0
1000945c:	d112      	bne.n	10009484 <__ledf2+0x8c>
1000945e:	433a      	orrs	r2, r7
10009460:	d110      	bne.n	10009484 <__ledf2+0x8c>
10009462:	465b      	mov	r3, fp
10009464:	4259      	negs	r1, r3
10009466:	2301      	movs	r3, #1
10009468:	4319      	orrs	r1, r3
1000946a:	1c08      	adds	r0, r1, #0
1000946c:	bc3c      	pop	{r2, r3, r4, r5}
1000946e:	4690      	mov	r8, r2
10009470:	4699      	mov	r9, r3
10009472:	46a2      	mov	sl, r4
10009474:	46ab      	mov	fp, r5
10009476:	bdf0      	pop	{r4, r5, r6, r7, pc}
10009478:	1c39      	adds	r1, r7, #0
1000947a:	2002      	movs	r0, #2
1000947c:	4311      	orrs	r1, r2
1000947e:	d1f5      	bne.n	1000946c <__ledf2+0x74>
10009480:	2c00      	cmp	r4, #0
10009482:	d0d5      	beq.n	10009430 <__ledf2+0x38>
10009484:	459b      	cmp	fp, r3
10009486:	d1ec      	bne.n	10009462 <__ledf2+0x6a>
10009488:	42ac      	cmp	r4, r5
1000948a:	dcea      	bgt.n	10009462 <__ledf2+0x6a>
1000948c:	db05      	blt.n	1000949a <__ledf2+0xa2>
1000948e:	45bc      	cmp	ip, r7
10009490:	d8e7      	bhi.n	10009462 <__ledf2+0x6a>
10009492:	d00f      	beq.n	100094b4 <__ledf2+0xbc>
10009494:	2000      	movs	r0, #0
10009496:	45bc      	cmp	ip, r7
10009498:	d2e8      	bcs.n	1000946c <__ledf2+0x74>
1000949a:	4658      	mov	r0, fp
1000949c:	4241      	negs	r1, r0
1000949e:	4148      	adcs	r0, r1
100094a0:	4241      	negs	r1, r0
100094a2:	2001      	movs	r0, #1
100094a4:	4308      	orrs	r0, r1
100094a6:	e7e1      	b.n	1000946c <__ledf2+0x74>
100094a8:	433a      	orrs	r2, r7
100094aa:	d1c7      	bne.n	1000943c <__ledf2+0x44>
100094ac:	2000      	movs	r0, #0
100094ae:	2e00      	cmp	r6, #0
100094b0:	d1dc      	bne.n	1000946c <__ledf2+0x74>
100094b2:	e7d6      	b.n	10009462 <__ledf2+0x6a>
100094b4:	45c8      	cmp	r8, r9
100094b6:	d8d4      	bhi.n	10009462 <__ledf2+0x6a>
100094b8:	2000      	movs	r0, #0
100094ba:	45c8      	cmp	r8, r9
100094bc:	d3ed      	bcc.n	1000949a <__ledf2+0xa2>
100094be:	e7d5      	b.n	1000946c <__ledf2+0x74>
100094c0:	000007ff 	.word	0x000007ff

100094c4 <__aeabi_dmul>:
100094c4:	b5f0      	push	{r4, r5, r6, r7, lr}
100094c6:	465f      	mov	r7, fp
100094c8:	4656      	mov	r6, sl
100094ca:	464d      	mov	r5, r9
100094cc:	4644      	mov	r4, r8
100094ce:	b4f0      	push	{r4, r5, r6, r7}
100094d0:	1c05      	adds	r5, r0, #0
100094d2:	1c06      	adds	r6, r0, #0
100094d4:	0308      	lsls	r0, r1, #12
100094d6:	b087      	sub	sp, #28
100094d8:	4699      	mov	r9, r3
100094da:	004f      	lsls	r7, r1, #1
100094dc:	0b03      	lsrs	r3, r0, #12
100094de:	0fcc      	lsrs	r4, r1, #31
100094e0:	4692      	mov	sl, r2
100094e2:	469b      	mov	fp, r3
100094e4:	0d7f      	lsrs	r7, r7, #21
100094e6:	9401      	str	r4, [sp, #4]
100094e8:	d067      	beq.n	100095ba <__aeabi_dmul+0xf6>
100094ea:	4b6c      	ldr	r3, [pc, #432]	; (1000969c <__aeabi_dmul+0x1d8>)
100094ec:	429f      	cmp	r7, r3
100094ee:	d036      	beq.n	1000955e <__aeabi_dmul+0x9a>
100094f0:	2080      	movs	r0, #128	; 0x80
100094f2:	465b      	mov	r3, fp
100094f4:	0340      	lsls	r0, r0, #13
100094f6:	4318      	orrs	r0, r3
100094f8:	00c0      	lsls	r0, r0, #3
100094fa:	0f6b      	lsrs	r3, r5, #29
100094fc:	4318      	orrs	r0, r3
100094fe:	4b68      	ldr	r3, [pc, #416]	; (100096a0 <__aeabi_dmul+0x1dc>)
10009500:	4683      	mov	fp, r0
10009502:	469c      	mov	ip, r3
10009504:	2300      	movs	r3, #0
10009506:	4698      	mov	r8, r3
10009508:	00ee      	lsls	r6, r5, #3
1000950a:	4467      	add	r7, ip
1000950c:	9300      	str	r3, [sp, #0]
1000950e:	464b      	mov	r3, r9
10009510:	4649      	mov	r1, r9
10009512:	031d      	lsls	r5, r3, #12
10009514:	0fc9      	lsrs	r1, r1, #31
10009516:	005b      	lsls	r3, r3, #1
10009518:	4652      	mov	r2, sl
1000951a:	0b2d      	lsrs	r5, r5, #12
1000951c:	0d5b      	lsrs	r3, r3, #21
1000951e:	4689      	mov	r9, r1
10009520:	d100      	bne.n	10009524 <__aeabi_dmul+0x60>
10009522:	e06e      	b.n	10009602 <__aeabi_dmul+0x13e>
10009524:	495d      	ldr	r1, [pc, #372]	; (1000969c <__aeabi_dmul+0x1d8>)
10009526:	428b      	cmp	r3, r1
10009528:	d064      	beq.n	100095f4 <__aeabi_dmul+0x130>
1000952a:	2080      	movs	r0, #128	; 0x80
1000952c:	495c      	ldr	r1, [pc, #368]	; (100096a0 <__aeabi_dmul+0x1dc>)
1000952e:	0340      	lsls	r0, r0, #13
10009530:	468c      	mov	ip, r1
10009532:	2100      	movs	r1, #0
10009534:	4305      	orrs	r5, r0
10009536:	00ed      	lsls	r5, r5, #3
10009538:	0f50      	lsrs	r0, r2, #29
1000953a:	4305      	orrs	r5, r0
1000953c:	00d2      	lsls	r2, r2, #3
1000953e:	4463      	add	r3, ip
10009540:	4648      	mov	r0, r9
10009542:	18ff      	adds	r7, r7, r3
10009544:	1c7b      	adds	r3, r7, #1
10009546:	469a      	mov	sl, r3
10009548:	9b00      	ldr	r3, [sp, #0]
1000954a:	4060      	eors	r0, r4
1000954c:	9002      	str	r0, [sp, #8]
1000954e:	430b      	orrs	r3, r1
10009550:	2b0f      	cmp	r3, #15
10009552:	d900      	bls.n	10009556 <__aeabi_dmul+0x92>
10009554:	e0ac      	b.n	100096b0 <__aeabi_dmul+0x1ec>
10009556:	4853      	ldr	r0, [pc, #332]	; (100096a4 <__aeabi_dmul+0x1e0>)
10009558:	009b      	lsls	r3, r3, #2
1000955a:	58c3      	ldr	r3, [r0, r3]
1000955c:	469f      	mov	pc, r3
1000955e:	465b      	mov	r3, fp
10009560:	431d      	orrs	r5, r3
10009562:	d000      	beq.n	10009566 <__aeabi_dmul+0xa2>
10009564:	e082      	b.n	1000966c <__aeabi_dmul+0x1a8>
10009566:	2308      	movs	r3, #8
10009568:	9300      	str	r3, [sp, #0]
1000956a:	2300      	movs	r3, #0
1000956c:	469b      	mov	fp, r3
1000956e:	3302      	adds	r3, #2
10009570:	2600      	movs	r6, #0
10009572:	4698      	mov	r8, r3
10009574:	e7cb      	b.n	1000950e <__aeabi_dmul+0x4a>
10009576:	9b02      	ldr	r3, [sp, #8]
10009578:	9301      	str	r3, [sp, #4]
1000957a:	4643      	mov	r3, r8
1000957c:	2b02      	cmp	r3, #2
1000957e:	d159      	bne.n	10009634 <__aeabi_dmul+0x170>
10009580:	2401      	movs	r4, #1
10009582:	2500      	movs	r5, #0
10009584:	2600      	movs	r6, #0
10009586:	9b01      	ldr	r3, [sp, #4]
10009588:	401c      	ands	r4, r3
1000958a:	4b44      	ldr	r3, [pc, #272]	; (1000969c <__aeabi_dmul+0x1d8>)
1000958c:	2100      	movs	r1, #0
1000958e:	032d      	lsls	r5, r5, #12
10009590:	0d0a      	lsrs	r2, r1, #20
10009592:	0512      	lsls	r2, r2, #20
10009594:	0b2d      	lsrs	r5, r5, #12
10009596:	4315      	orrs	r5, r2
10009598:	4a43      	ldr	r2, [pc, #268]	; (100096a8 <__aeabi_dmul+0x1e4>)
1000959a:	051b      	lsls	r3, r3, #20
1000959c:	4015      	ands	r5, r2
1000959e:	431d      	orrs	r5, r3
100095a0:	006d      	lsls	r5, r5, #1
100095a2:	07e4      	lsls	r4, r4, #31
100095a4:	086d      	lsrs	r5, r5, #1
100095a6:	4325      	orrs	r5, r4
100095a8:	1c30      	adds	r0, r6, #0
100095aa:	1c29      	adds	r1, r5, #0
100095ac:	b007      	add	sp, #28
100095ae:	bc3c      	pop	{r2, r3, r4, r5}
100095b0:	4690      	mov	r8, r2
100095b2:	4699      	mov	r9, r3
100095b4:	46a2      	mov	sl, r4
100095b6:	46ab      	mov	fp, r5
100095b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
100095ba:	432b      	orrs	r3, r5
100095bc:	d04e      	beq.n	1000965c <__aeabi_dmul+0x198>
100095be:	465b      	mov	r3, fp
100095c0:	2b00      	cmp	r3, #0
100095c2:	d100      	bne.n	100095c6 <__aeabi_dmul+0x102>
100095c4:	e185      	b.n	100098d2 <__aeabi_dmul+0x40e>
100095c6:	4658      	mov	r0, fp
100095c8:	f7fc f9d8 	bl	1000597c <__clzsi2>
100095cc:	1c02      	adds	r2, r0, #0
100095ce:	2328      	movs	r3, #40	; 0x28
100095d0:	1c29      	adds	r1, r5, #0
100095d2:	1a9b      	subs	r3, r3, r2
100095d4:	1c16      	adds	r6, r2, #0
100095d6:	4658      	mov	r0, fp
100095d8:	40d9      	lsrs	r1, r3
100095da:	3e08      	subs	r6, #8
100095dc:	40b0      	lsls	r0, r6
100095de:	1c0b      	adds	r3, r1, #0
100095e0:	40b5      	lsls	r5, r6
100095e2:	4303      	orrs	r3, r0
100095e4:	469b      	mov	fp, r3
100095e6:	1c2e      	adds	r6, r5, #0
100095e8:	2300      	movs	r3, #0
100095ea:	4f30      	ldr	r7, [pc, #192]	; (100096ac <__aeabi_dmul+0x1e8>)
100095ec:	9300      	str	r3, [sp, #0]
100095ee:	1abf      	subs	r7, r7, r2
100095f0:	4698      	mov	r8, r3
100095f2:	e78c      	b.n	1000950e <__aeabi_dmul+0x4a>
100095f4:	4651      	mov	r1, sl
100095f6:	4329      	orrs	r1, r5
100095f8:	d12e      	bne.n	10009658 <__aeabi_dmul+0x194>
100095fa:	2500      	movs	r5, #0
100095fc:	2200      	movs	r2, #0
100095fe:	2102      	movs	r1, #2
10009600:	e79e      	b.n	10009540 <__aeabi_dmul+0x7c>
10009602:	4651      	mov	r1, sl
10009604:	4329      	orrs	r1, r5
10009606:	d023      	beq.n	10009650 <__aeabi_dmul+0x18c>
10009608:	2d00      	cmp	r5, #0
1000960a:	d100      	bne.n	1000960e <__aeabi_dmul+0x14a>
1000960c:	e154      	b.n	100098b8 <__aeabi_dmul+0x3f4>
1000960e:	1c28      	adds	r0, r5, #0
10009610:	f7fc f9b4 	bl	1000597c <__clzsi2>
10009614:	1c03      	adds	r3, r0, #0
10009616:	2128      	movs	r1, #40	; 0x28
10009618:	4650      	mov	r0, sl
1000961a:	1ac9      	subs	r1, r1, r3
1000961c:	1c1a      	adds	r2, r3, #0
1000961e:	40c8      	lsrs	r0, r1
10009620:	4651      	mov	r1, sl
10009622:	3a08      	subs	r2, #8
10009624:	4091      	lsls	r1, r2
10009626:	4095      	lsls	r5, r2
10009628:	1c0a      	adds	r2, r1, #0
1000962a:	4305      	orrs	r5, r0
1000962c:	481f      	ldr	r0, [pc, #124]	; (100096ac <__aeabi_dmul+0x1e8>)
1000962e:	2100      	movs	r1, #0
10009630:	1ac3      	subs	r3, r0, r3
10009632:	e785      	b.n	10009540 <__aeabi_dmul+0x7c>
10009634:	2b03      	cmp	r3, #3
10009636:	d100      	bne.n	1000963a <__aeabi_dmul+0x176>
10009638:	e1c2      	b.n	100099c0 <__aeabi_dmul+0x4fc>
1000963a:	2b01      	cmp	r3, #1
1000963c:	d000      	beq.n	10009640 <__aeabi_dmul+0x17c>
1000963e:	e16d      	b.n	1000991c <__aeabi_dmul+0x458>
10009640:	4644      	mov	r4, r8
10009642:	9b01      	ldr	r3, [sp, #4]
10009644:	2500      	movs	r5, #0
10009646:	401c      	ands	r4, r3
10009648:	b2e4      	uxtb	r4, r4
1000964a:	2300      	movs	r3, #0
1000964c:	2600      	movs	r6, #0
1000964e:	e79d      	b.n	1000958c <__aeabi_dmul+0xc8>
10009650:	2500      	movs	r5, #0
10009652:	2200      	movs	r2, #0
10009654:	2101      	movs	r1, #1
10009656:	e773      	b.n	10009540 <__aeabi_dmul+0x7c>
10009658:	2103      	movs	r1, #3
1000965a:	e771      	b.n	10009540 <__aeabi_dmul+0x7c>
1000965c:	2304      	movs	r3, #4
1000965e:	9300      	str	r3, [sp, #0]
10009660:	2300      	movs	r3, #0
10009662:	469b      	mov	fp, r3
10009664:	3301      	adds	r3, #1
10009666:	2600      	movs	r6, #0
10009668:	4698      	mov	r8, r3
1000966a:	e750      	b.n	1000950e <__aeabi_dmul+0x4a>
1000966c:	230c      	movs	r3, #12
1000966e:	9300      	str	r3, [sp, #0]
10009670:	3b09      	subs	r3, #9
10009672:	4698      	mov	r8, r3
10009674:	e74b      	b.n	1000950e <__aeabi_dmul+0x4a>
10009676:	2580      	movs	r5, #128	; 0x80
10009678:	2400      	movs	r4, #0
1000967a:	032d      	lsls	r5, r5, #12
1000967c:	2600      	movs	r6, #0
1000967e:	4b07      	ldr	r3, [pc, #28]	; (1000969c <__aeabi_dmul+0x1d8>)
10009680:	e784      	b.n	1000958c <__aeabi_dmul+0xc8>
10009682:	464b      	mov	r3, r9
10009684:	46ab      	mov	fp, r5
10009686:	1c16      	adds	r6, r2, #0
10009688:	9301      	str	r3, [sp, #4]
1000968a:	4688      	mov	r8, r1
1000968c:	e775      	b.n	1000957a <__aeabi_dmul+0xb6>
1000968e:	9b02      	ldr	r3, [sp, #8]
10009690:	46ab      	mov	fp, r5
10009692:	1c16      	adds	r6, r2, #0
10009694:	9301      	str	r3, [sp, #4]
10009696:	4688      	mov	r8, r1
10009698:	e76f      	b.n	1000957a <__aeabi_dmul+0xb6>
1000969a:	46c0      	nop			; (mov r8, r8)
1000969c:	000007ff 	.word	0x000007ff
100096a0:	fffffc01 	.word	0xfffffc01
100096a4:	1000a9b0 	.word	0x1000a9b0
100096a8:	800fffff 	.word	0x800fffff
100096ac:	fffffc0d 	.word	0xfffffc0d
100096b0:	0c33      	lsrs	r3, r6, #16
100096b2:	0436      	lsls	r6, r6, #16
100096b4:	0c36      	lsrs	r6, r6, #16
100096b6:	469c      	mov	ip, r3
100096b8:	1c33      	adds	r3, r6, #0
100096ba:	0c14      	lsrs	r4, r2, #16
100096bc:	0412      	lsls	r2, r2, #16
100096be:	0c12      	lsrs	r2, r2, #16
100096c0:	4353      	muls	r3, r2
100096c2:	4698      	mov	r8, r3
100096c4:	4663      	mov	r3, ip
100096c6:	4353      	muls	r3, r2
100096c8:	4699      	mov	r9, r3
100096ca:	4663      	mov	r3, ip
100096cc:	4363      	muls	r3, r4
100096ce:	9301      	str	r3, [sp, #4]
100096d0:	1c33      	adds	r3, r6, #0
100096d2:	4641      	mov	r1, r8
100096d4:	4363      	muls	r3, r4
100096d6:	0c09      	lsrs	r1, r1, #16
100096d8:	444b      	add	r3, r9
100096da:	185b      	adds	r3, r3, r1
100096dc:	4599      	cmp	r9, r3
100096de:	d905      	bls.n	100096ec <__aeabi_dmul+0x228>
100096e0:	2080      	movs	r0, #128	; 0x80
100096e2:	0240      	lsls	r0, r0, #9
100096e4:	4681      	mov	r9, r0
100096e6:	9901      	ldr	r1, [sp, #4]
100096e8:	4449      	add	r1, r9
100096ea:	9101      	str	r1, [sp, #4]
100096ec:	0c19      	lsrs	r1, r3, #16
100096ee:	9103      	str	r1, [sp, #12]
100096f0:	4641      	mov	r1, r8
100096f2:	0409      	lsls	r1, r1, #16
100096f4:	0c09      	lsrs	r1, r1, #16
100096f6:	041b      	lsls	r3, r3, #16
100096f8:	185b      	adds	r3, r3, r1
100096fa:	9304      	str	r3, [sp, #16]
100096fc:	0c2b      	lsrs	r3, r5, #16
100096fe:	4698      	mov	r8, r3
10009700:	1c33      	adds	r3, r6, #0
10009702:	042d      	lsls	r5, r5, #16
10009704:	0c29      	lsrs	r1, r5, #16
10009706:	434b      	muls	r3, r1
10009708:	4660      	mov	r0, ip
1000970a:	9300      	str	r3, [sp, #0]
1000970c:	4643      	mov	r3, r8
1000970e:	4665      	mov	r5, ip
10009710:	4358      	muls	r0, r3
10009712:	435e      	muls	r6, r3
10009714:	9b00      	ldr	r3, [sp, #0]
10009716:	434d      	muls	r5, r1
10009718:	0c1b      	lsrs	r3, r3, #16
1000971a:	4699      	mov	r9, r3
1000971c:	19ae      	adds	r6, r5, r6
1000971e:	444e      	add	r6, r9
10009720:	4684      	mov	ip, r0
10009722:	42b5      	cmp	r5, r6
10009724:	d903      	bls.n	1000972e <__aeabi_dmul+0x26a>
10009726:	2380      	movs	r3, #128	; 0x80
10009728:	025b      	lsls	r3, r3, #9
1000972a:	4699      	mov	r9, r3
1000972c:	44cc      	add	ip, r9
1000972e:	0c35      	lsrs	r5, r6, #16
10009730:	1c2b      	adds	r3, r5, #0
10009732:	9803      	ldr	r0, [sp, #12]
10009734:	4463      	add	r3, ip
10009736:	4684      	mov	ip, r0
10009738:	9305      	str	r3, [sp, #20]
1000973a:	9b00      	ldr	r3, [sp, #0]
1000973c:	0436      	lsls	r6, r6, #16
1000973e:	041b      	lsls	r3, r3, #16
10009740:	0c1b      	lsrs	r3, r3, #16
10009742:	18f3      	adds	r3, r6, r3
10009744:	449c      	add	ip, r3
10009746:	4660      	mov	r0, ip
10009748:	9003      	str	r0, [sp, #12]
1000974a:	4658      	mov	r0, fp
1000974c:	0405      	lsls	r5, r0, #16
1000974e:	0c06      	lsrs	r6, r0, #16
10009750:	0c28      	lsrs	r0, r5, #16
10009752:	4684      	mov	ip, r0
10009754:	4350      	muls	r0, r2
10009756:	1c35      	adds	r5, r6, #0
10009758:	4681      	mov	r9, r0
1000975a:	4660      	mov	r0, ip
1000975c:	4365      	muls	r5, r4
1000975e:	4344      	muls	r4, r0
10009760:	4648      	mov	r0, r9
10009762:	0c00      	lsrs	r0, r0, #16
10009764:	4683      	mov	fp, r0
10009766:	4372      	muls	r2, r6
10009768:	1914      	adds	r4, r2, r4
1000976a:	445c      	add	r4, fp
1000976c:	42a2      	cmp	r2, r4
1000976e:	d903      	bls.n	10009778 <__aeabi_dmul+0x2b4>
10009770:	2280      	movs	r2, #128	; 0x80
10009772:	0252      	lsls	r2, r2, #9
10009774:	4693      	mov	fp, r2
10009776:	445d      	add	r5, fp
10009778:	0c22      	lsrs	r2, r4, #16
1000977a:	18ad      	adds	r5, r5, r2
1000977c:	464a      	mov	r2, r9
1000977e:	0412      	lsls	r2, r2, #16
10009780:	0c12      	lsrs	r2, r2, #16
10009782:	0424      	lsls	r4, r4, #16
10009784:	4640      	mov	r0, r8
10009786:	18a4      	adds	r4, r4, r2
10009788:	4662      	mov	r2, ip
1000978a:	434a      	muls	r2, r1
1000978c:	4371      	muls	r1, r6
1000978e:	4346      	muls	r6, r0
10009790:	4660      	mov	r0, ip
10009792:	9600      	str	r6, [sp, #0]
10009794:	4646      	mov	r6, r8
10009796:	4370      	muls	r0, r6
10009798:	4680      	mov	r8, r0
1000979a:	0c10      	lsrs	r0, r2, #16
1000979c:	4684      	mov	ip, r0
1000979e:	4488      	add	r8, r1
100097a0:	44e0      	add	r8, ip
100097a2:	4541      	cmp	r1, r8
100097a4:	d905      	bls.n	100097b2 <__aeabi_dmul+0x2ee>
100097a6:	2180      	movs	r1, #128	; 0x80
100097a8:	0249      	lsls	r1, r1, #9
100097aa:	468c      	mov	ip, r1
100097ac:	9900      	ldr	r1, [sp, #0]
100097ae:	4461      	add	r1, ip
100097b0:	9100      	str	r1, [sp, #0]
100097b2:	9801      	ldr	r0, [sp, #4]
100097b4:	9903      	ldr	r1, [sp, #12]
100097b6:	4684      	mov	ip, r0
100097b8:	4461      	add	r1, ip
100097ba:	4299      	cmp	r1, r3
100097bc:	419b      	sbcs	r3, r3
100097be:	425b      	negs	r3, r3
100097c0:	4699      	mov	r9, r3
100097c2:	9805      	ldr	r0, [sp, #20]
100097c4:	4643      	mov	r3, r8
100097c6:	4684      	mov	ip, r0
100097c8:	0412      	lsls	r2, r2, #16
100097ca:	0c12      	lsrs	r2, r2, #16
100097cc:	041b      	lsls	r3, r3, #16
100097ce:	189b      	adds	r3, r3, r2
100097d0:	4463      	add	r3, ip
100097d2:	469c      	mov	ip, r3
100097d4:	46ab      	mov	fp, r5
100097d6:	4283      	cmp	r3, r0
100097d8:	419b      	sbcs	r3, r3
100097da:	4640      	mov	r0, r8
100097dc:	190a      	adds	r2, r1, r4
100097de:	44cc      	add	ip, r9
100097e0:	42a2      	cmp	r2, r4
100097e2:	4189      	sbcs	r1, r1
100097e4:	44e3      	add	fp, ip
100097e6:	45cc      	cmp	ip, r9
100097e8:	41b6      	sbcs	r6, r6
100097ea:	465c      	mov	r4, fp
100097ec:	0c00      	lsrs	r0, r0, #16
100097ee:	4680      	mov	r8, r0
100097f0:	4249      	negs	r1, r1
100097f2:	4276      	negs	r6, r6
100097f4:	425b      	negs	r3, r3
100097f6:	1864      	adds	r4, r4, r1
100097f8:	4333      	orrs	r3, r6
100097fa:	4498      	add	r8, r3
100097fc:	428c      	cmp	r4, r1
100097fe:	4189      	sbcs	r1, r1
10009800:	45ab      	cmp	fp, r5
10009802:	419b      	sbcs	r3, r3
10009804:	4249      	negs	r1, r1
10009806:	425b      	negs	r3, r3
10009808:	4319      	orrs	r1, r3
1000980a:	1c0d      	adds	r5, r1, #0
1000980c:	9b00      	ldr	r3, [sp, #0]
1000980e:	4445      	add	r5, r8
10009810:	18ee      	adds	r6, r5, r3
10009812:	0276      	lsls	r6, r6, #9
10009814:	0de5      	lsrs	r5, r4, #23
10009816:	432e      	orrs	r6, r5
10009818:	46b3      	mov	fp, r6
1000981a:	9b04      	ldr	r3, [sp, #16]
1000981c:	0256      	lsls	r6, r2, #9
1000981e:	431e      	orrs	r6, r3
10009820:	1e73      	subs	r3, r6, #1
10009822:	419e      	sbcs	r6, r3
10009824:	465b      	mov	r3, fp
10009826:	0dd2      	lsrs	r2, r2, #23
10009828:	4332      	orrs	r2, r6
1000982a:	0266      	lsls	r6, r4, #9
1000982c:	4316      	orrs	r6, r2
1000982e:	01db      	lsls	r3, r3, #7
10009830:	d50a      	bpl.n	10009848 <__aeabi_dmul+0x384>
10009832:	2301      	movs	r3, #1
10009834:	4033      	ands	r3, r6
10009836:	0876      	lsrs	r6, r6, #1
10009838:	431e      	orrs	r6, r3
1000983a:	465b      	mov	r3, fp
1000983c:	07db      	lsls	r3, r3, #31
1000983e:	431e      	orrs	r6, r3
10009840:	465b      	mov	r3, fp
10009842:	085b      	lsrs	r3, r3, #1
10009844:	469b      	mov	fp, r3
10009846:	4657      	mov	r7, sl
10009848:	4b63      	ldr	r3, [pc, #396]	; (100099d8 <__aeabi_dmul+0x514>)
1000984a:	18fb      	adds	r3, r7, r3
1000984c:	2b00      	cmp	r3, #0
1000984e:	dd5a      	ble.n	10009906 <__aeabi_dmul+0x442>
10009850:	0772      	lsls	r2, r6, #29
10009852:	d009      	beq.n	10009868 <__aeabi_dmul+0x3a4>
10009854:	220f      	movs	r2, #15
10009856:	4032      	ands	r2, r6
10009858:	2a04      	cmp	r2, #4
1000985a:	d005      	beq.n	10009868 <__aeabi_dmul+0x3a4>
1000985c:	1d32      	adds	r2, r6, #4
1000985e:	42b2      	cmp	r2, r6
10009860:	41b6      	sbcs	r6, r6
10009862:	4276      	negs	r6, r6
10009864:	44b3      	add	fp, r6
10009866:	1c16      	adds	r6, r2, #0
10009868:	465a      	mov	r2, fp
1000986a:	01d2      	lsls	r2, r2, #7
1000986c:	d506      	bpl.n	1000987c <__aeabi_dmul+0x3b8>
1000986e:	465a      	mov	r2, fp
10009870:	4b5a      	ldr	r3, [pc, #360]	; (100099dc <__aeabi_dmul+0x518>)
10009872:	401a      	ands	r2, r3
10009874:	2380      	movs	r3, #128	; 0x80
10009876:	4693      	mov	fp, r2
10009878:	00db      	lsls	r3, r3, #3
1000987a:	18fb      	adds	r3, r7, r3
1000987c:	4a58      	ldr	r2, [pc, #352]	; (100099e0 <__aeabi_dmul+0x51c>)
1000987e:	4293      	cmp	r3, r2
10009880:	dd34      	ble.n	100098ec <__aeabi_dmul+0x428>
10009882:	2401      	movs	r4, #1
10009884:	9b02      	ldr	r3, [sp, #8]
10009886:	2500      	movs	r5, #0
10009888:	401c      	ands	r4, r3
1000988a:	2600      	movs	r6, #0
1000988c:	4b55      	ldr	r3, [pc, #340]	; (100099e4 <__aeabi_dmul+0x520>)
1000988e:	e67d      	b.n	1000958c <__aeabi_dmul+0xc8>
10009890:	2080      	movs	r0, #128	; 0x80
10009892:	465b      	mov	r3, fp
10009894:	0300      	lsls	r0, r0, #12
10009896:	4203      	tst	r3, r0
10009898:	d008      	beq.n	100098ac <__aeabi_dmul+0x3e8>
1000989a:	4205      	tst	r5, r0
1000989c:	d106      	bne.n	100098ac <__aeabi_dmul+0x3e8>
1000989e:	4305      	orrs	r5, r0
100098a0:	032d      	lsls	r5, r5, #12
100098a2:	0b2d      	lsrs	r5, r5, #12
100098a4:	464c      	mov	r4, r9
100098a6:	1c16      	adds	r6, r2, #0
100098a8:	4b4e      	ldr	r3, [pc, #312]	; (100099e4 <__aeabi_dmul+0x520>)
100098aa:	e66f      	b.n	1000958c <__aeabi_dmul+0xc8>
100098ac:	465d      	mov	r5, fp
100098ae:	4305      	orrs	r5, r0
100098b0:	032d      	lsls	r5, r5, #12
100098b2:	0b2d      	lsrs	r5, r5, #12
100098b4:	4b4b      	ldr	r3, [pc, #300]	; (100099e4 <__aeabi_dmul+0x520>)
100098b6:	e669      	b.n	1000958c <__aeabi_dmul+0xc8>
100098b8:	4650      	mov	r0, sl
100098ba:	f7fc f85f 	bl	1000597c <__clzsi2>
100098be:	1c03      	adds	r3, r0, #0
100098c0:	3320      	adds	r3, #32
100098c2:	2b27      	cmp	r3, #39	; 0x27
100098c4:	dc00      	bgt.n	100098c8 <__aeabi_dmul+0x404>
100098c6:	e6a6      	b.n	10009616 <__aeabi_dmul+0x152>
100098c8:	4655      	mov	r5, sl
100098ca:	3808      	subs	r0, #8
100098cc:	4085      	lsls	r5, r0
100098ce:	2200      	movs	r2, #0
100098d0:	e6ac      	b.n	1000962c <__aeabi_dmul+0x168>
100098d2:	1c28      	adds	r0, r5, #0
100098d4:	f7fc f852 	bl	1000597c <__clzsi2>
100098d8:	1c02      	adds	r2, r0, #0
100098da:	3220      	adds	r2, #32
100098dc:	2a27      	cmp	r2, #39	; 0x27
100098de:	dc00      	bgt.n	100098e2 <__aeabi_dmul+0x41e>
100098e0:	e675      	b.n	100095ce <__aeabi_dmul+0x10a>
100098e2:	3808      	subs	r0, #8
100098e4:	4085      	lsls	r5, r0
100098e6:	2600      	movs	r6, #0
100098e8:	46ab      	mov	fp, r5
100098ea:	e67d      	b.n	100095e8 <__aeabi_dmul+0x124>
100098ec:	465a      	mov	r2, fp
100098ee:	08f6      	lsrs	r6, r6, #3
100098f0:	0752      	lsls	r2, r2, #29
100098f2:	4316      	orrs	r6, r2
100098f4:	465a      	mov	r2, fp
100098f6:	2401      	movs	r4, #1
100098f8:	0255      	lsls	r5, r2, #9
100098fa:	9a02      	ldr	r2, [sp, #8]
100098fc:	055b      	lsls	r3, r3, #21
100098fe:	0b2d      	lsrs	r5, r5, #12
10009900:	0d5b      	lsrs	r3, r3, #21
10009902:	4014      	ands	r4, r2
10009904:	e642      	b.n	1000958c <__aeabi_dmul+0xc8>
10009906:	4d38      	ldr	r5, [pc, #224]	; (100099e8 <__aeabi_dmul+0x524>)
10009908:	1bed      	subs	r5, r5, r7
1000990a:	2d38      	cmp	r5, #56	; 0x38
1000990c:	dd0a      	ble.n	10009924 <__aeabi_dmul+0x460>
1000990e:	2401      	movs	r4, #1
10009910:	9b02      	ldr	r3, [sp, #8]
10009912:	2500      	movs	r5, #0
10009914:	401c      	ands	r4, r3
10009916:	2600      	movs	r6, #0
10009918:	2300      	movs	r3, #0
1000991a:	e637      	b.n	1000958c <__aeabi_dmul+0xc8>
1000991c:	9b01      	ldr	r3, [sp, #4]
1000991e:	4657      	mov	r7, sl
10009920:	9302      	str	r3, [sp, #8]
10009922:	e791      	b.n	10009848 <__aeabi_dmul+0x384>
10009924:	2d1f      	cmp	r5, #31
10009926:	dc25      	bgt.n	10009974 <__aeabi_dmul+0x4b0>
10009928:	4b30      	ldr	r3, [pc, #192]	; (100099ec <__aeabi_dmul+0x528>)
1000992a:	1c32      	adds	r2, r6, #0
1000992c:	469c      	mov	ip, r3
1000992e:	4467      	add	r7, ip
10009930:	40be      	lsls	r6, r7
10009932:	465b      	mov	r3, fp
10009934:	40bb      	lsls	r3, r7
10009936:	1c37      	adds	r7, r6, #0
10009938:	40ea      	lsrs	r2, r5
1000993a:	1e7e      	subs	r6, r7, #1
1000993c:	41b7      	sbcs	r7, r6
1000993e:	4313      	orrs	r3, r2
10009940:	433b      	orrs	r3, r7
10009942:	1c1e      	adds	r6, r3, #0
10009944:	465b      	mov	r3, fp
10009946:	40eb      	lsrs	r3, r5
10009948:	1c1d      	adds	r5, r3, #0
1000994a:	0773      	lsls	r3, r6, #29
1000994c:	d009      	beq.n	10009962 <__aeabi_dmul+0x49e>
1000994e:	230f      	movs	r3, #15
10009950:	4033      	ands	r3, r6
10009952:	2b04      	cmp	r3, #4
10009954:	d005      	beq.n	10009962 <__aeabi_dmul+0x49e>
10009956:	1d33      	adds	r3, r6, #4
10009958:	42b3      	cmp	r3, r6
1000995a:	41b6      	sbcs	r6, r6
1000995c:	4276      	negs	r6, r6
1000995e:	19ad      	adds	r5, r5, r6
10009960:	1c1e      	adds	r6, r3, #0
10009962:	022b      	lsls	r3, r5, #8
10009964:	d520      	bpl.n	100099a8 <__aeabi_dmul+0x4e4>
10009966:	2401      	movs	r4, #1
10009968:	9b02      	ldr	r3, [sp, #8]
1000996a:	2500      	movs	r5, #0
1000996c:	401c      	ands	r4, r3
1000996e:	2600      	movs	r6, #0
10009970:	2301      	movs	r3, #1
10009972:	e60b      	b.n	1000958c <__aeabi_dmul+0xc8>
10009974:	465a      	mov	r2, fp
10009976:	4b1e      	ldr	r3, [pc, #120]	; (100099f0 <__aeabi_dmul+0x52c>)
10009978:	1bdb      	subs	r3, r3, r7
1000997a:	40da      	lsrs	r2, r3
1000997c:	1c13      	adds	r3, r2, #0
1000997e:	2d20      	cmp	r5, #32
10009980:	d01c      	beq.n	100099bc <__aeabi_dmul+0x4f8>
10009982:	4a1c      	ldr	r2, [pc, #112]	; (100099f4 <__aeabi_dmul+0x530>)
10009984:	4694      	mov	ip, r2
10009986:	465a      	mov	r2, fp
10009988:	4467      	add	r7, ip
1000998a:	40ba      	lsls	r2, r7
1000998c:	1c17      	adds	r7, r2, #0
1000998e:	433e      	orrs	r6, r7
10009990:	1e72      	subs	r2, r6, #1
10009992:	4196      	sbcs	r6, r2
10009994:	431e      	orrs	r6, r3
10009996:	2307      	movs	r3, #7
10009998:	2500      	movs	r5, #0
1000999a:	4033      	ands	r3, r6
1000999c:	d007      	beq.n	100099ae <__aeabi_dmul+0x4ea>
1000999e:	230f      	movs	r3, #15
100099a0:	2500      	movs	r5, #0
100099a2:	4033      	ands	r3, r6
100099a4:	2b04      	cmp	r3, #4
100099a6:	d1d6      	bne.n	10009956 <__aeabi_dmul+0x492>
100099a8:	076b      	lsls	r3, r5, #29
100099aa:	026d      	lsls	r5, r5, #9
100099ac:	0b2d      	lsrs	r5, r5, #12
100099ae:	2401      	movs	r4, #1
100099b0:	08f6      	lsrs	r6, r6, #3
100099b2:	431e      	orrs	r6, r3
100099b4:	9b02      	ldr	r3, [sp, #8]
100099b6:	401c      	ands	r4, r3
100099b8:	2300      	movs	r3, #0
100099ba:	e5e7      	b.n	1000958c <__aeabi_dmul+0xc8>
100099bc:	2700      	movs	r7, #0
100099be:	e7e6      	b.n	1000998e <__aeabi_dmul+0x4ca>
100099c0:	2580      	movs	r5, #128	; 0x80
100099c2:	465b      	mov	r3, fp
100099c4:	2401      	movs	r4, #1
100099c6:	032d      	lsls	r5, r5, #12
100099c8:	431d      	orrs	r5, r3
100099ca:	9b01      	ldr	r3, [sp, #4]
100099cc:	032d      	lsls	r5, r5, #12
100099ce:	4023      	ands	r3, r4
100099d0:	1c1c      	adds	r4, r3, #0
100099d2:	0b2d      	lsrs	r5, r5, #12
100099d4:	4b03      	ldr	r3, [pc, #12]	; (100099e4 <__aeabi_dmul+0x520>)
100099d6:	e5d9      	b.n	1000958c <__aeabi_dmul+0xc8>
100099d8:	000003ff 	.word	0x000003ff
100099dc:	feffffff 	.word	0xfeffffff
100099e0:	000007fe 	.word	0x000007fe
100099e4:	000007ff 	.word	0x000007ff
100099e8:	fffffc02 	.word	0xfffffc02
100099ec:	0000041e 	.word	0x0000041e
100099f0:	fffffbe2 	.word	0xfffffbe2
100099f4:	0000043e 	.word	0x0000043e

100099f8 <__aeabi_dsub>:
100099f8:	b5f0      	push	{r4, r5, r6, r7, lr}
100099fa:	464d      	mov	r5, r9
100099fc:	4644      	mov	r4, r8
100099fe:	465f      	mov	r7, fp
10009a00:	4656      	mov	r6, sl
10009a02:	b4f0      	push	{r4, r5, r6, r7}
10009a04:	1c0e      	adds	r6, r1, #0
10009a06:	1c11      	adds	r1, r2, #0
10009a08:	0332      	lsls	r2, r6, #12
10009a0a:	0a52      	lsrs	r2, r2, #9
10009a0c:	0f47      	lsrs	r7, r0, #29
10009a0e:	4317      	orrs	r7, r2
10009a10:	00c5      	lsls	r5, r0, #3
10009a12:	031a      	lsls	r2, r3, #12
10009a14:	0058      	lsls	r0, r3, #1
10009a16:	0fdb      	lsrs	r3, r3, #31
10009a18:	4699      	mov	r9, r3
10009a1a:	0a52      	lsrs	r2, r2, #9
10009a1c:	0f4b      	lsrs	r3, r1, #29
10009a1e:	b083      	sub	sp, #12
10009a20:	431a      	orrs	r2, r3
10009a22:	00cb      	lsls	r3, r1, #3
10009a24:	9301      	str	r3, [sp, #4]
10009a26:	4bcf      	ldr	r3, [pc, #828]	; (10009d64 <__aeabi_dsub+0x36c>)
10009a28:	0074      	lsls	r4, r6, #1
10009a2a:	0ff6      	lsrs	r6, r6, #31
10009a2c:	0d64      	lsrs	r4, r4, #21
10009a2e:	46b0      	mov	r8, r6
10009a30:	0d40      	lsrs	r0, r0, #21
10009a32:	4298      	cmp	r0, r3
10009a34:	d100      	bne.n	10009a38 <__aeabi_dsub+0x40>
10009a36:	e0e8      	b.n	10009c0a <__aeabi_dsub+0x212>
10009a38:	2301      	movs	r3, #1
10009a3a:	4649      	mov	r1, r9
10009a3c:	4059      	eors	r1, r3
10009a3e:	1c0b      	adds	r3, r1, #0
10009a40:	429e      	cmp	r6, r3
10009a42:	d100      	bne.n	10009a46 <__aeabi_dsub+0x4e>
10009a44:	e0b1      	b.n	10009baa <__aeabi_dsub+0x1b2>
10009a46:	1a26      	subs	r6, r4, r0
10009a48:	2e00      	cmp	r6, #0
10009a4a:	dc00      	bgt.n	10009a4e <__aeabi_dsub+0x56>
10009a4c:	e11c      	b.n	10009c88 <__aeabi_dsub+0x290>
10009a4e:	2800      	cmp	r0, #0
10009a50:	d142      	bne.n	10009ad8 <__aeabi_dsub+0xe0>
10009a52:	1c13      	adds	r3, r2, #0
10009a54:	9901      	ldr	r1, [sp, #4]
10009a56:	430b      	orrs	r3, r1
10009a58:	d000      	beq.n	10009a5c <__aeabi_dsub+0x64>
10009a5a:	e0e6      	b.n	10009c2a <__aeabi_dsub+0x232>
10009a5c:	076b      	lsls	r3, r5, #29
10009a5e:	d100      	bne.n	10009a62 <__aeabi_dsub+0x6a>
10009a60:	e08e      	b.n	10009b80 <__aeabi_dsub+0x188>
10009a62:	230f      	movs	r3, #15
10009a64:	402b      	ands	r3, r5
10009a66:	2b04      	cmp	r3, #4
10009a68:	d100      	bne.n	10009a6c <__aeabi_dsub+0x74>
10009a6a:	e089      	b.n	10009b80 <__aeabi_dsub+0x188>
10009a6c:	1d2a      	adds	r2, r5, #4
10009a6e:	42aa      	cmp	r2, r5
10009a70:	41ad      	sbcs	r5, r5
10009a72:	2380      	movs	r3, #128	; 0x80
10009a74:	2601      	movs	r6, #1
10009a76:	4641      	mov	r1, r8
10009a78:	426d      	negs	r5, r5
10009a7a:	197f      	adds	r7, r7, r5
10009a7c:	041b      	lsls	r3, r3, #16
10009a7e:	403b      	ands	r3, r7
10009a80:	400e      	ands	r6, r1
10009a82:	1c15      	adds	r5, r2, #0
10009a84:	2b00      	cmp	r3, #0
10009a86:	d100      	bne.n	10009a8a <__aeabi_dsub+0x92>
10009a88:	e083      	b.n	10009b92 <__aeabi_dsub+0x19a>
10009a8a:	4bb6      	ldr	r3, [pc, #728]	; (10009d64 <__aeabi_dsub+0x36c>)
10009a8c:	3401      	adds	r4, #1
10009a8e:	429c      	cmp	r4, r3
10009a90:	d100      	bne.n	10009a94 <__aeabi_dsub+0x9c>
10009a92:	e116      	b.n	10009cc2 <__aeabi_dsub+0x2ca>
10009a94:	1c3a      	adds	r2, r7, #0
10009a96:	4bb4      	ldr	r3, [pc, #720]	; (10009d68 <__aeabi_dsub+0x370>)
10009a98:	08ed      	lsrs	r5, r5, #3
10009a9a:	401a      	ands	r2, r3
10009a9c:	0750      	lsls	r0, r2, #29
10009a9e:	0564      	lsls	r4, r4, #21
10009aa0:	0252      	lsls	r2, r2, #9
10009aa2:	4305      	orrs	r5, r0
10009aa4:	0b12      	lsrs	r2, r2, #12
10009aa6:	0d64      	lsrs	r4, r4, #21
10009aa8:	2100      	movs	r1, #0
10009aaa:	0312      	lsls	r2, r2, #12
10009aac:	0d0b      	lsrs	r3, r1, #20
10009aae:	051b      	lsls	r3, r3, #20
10009ab0:	0564      	lsls	r4, r4, #21
10009ab2:	0b12      	lsrs	r2, r2, #12
10009ab4:	431a      	orrs	r2, r3
10009ab6:	0863      	lsrs	r3, r4, #1
10009ab8:	4cac      	ldr	r4, [pc, #688]	; (10009d6c <__aeabi_dsub+0x374>)
10009aba:	07f6      	lsls	r6, r6, #31
10009abc:	4014      	ands	r4, r2
10009abe:	431c      	orrs	r4, r3
10009ac0:	0064      	lsls	r4, r4, #1
10009ac2:	0864      	lsrs	r4, r4, #1
10009ac4:	4334      	orrs	r4, r6
10009ac6:	1c28      	adds	r0, r5, #0
10009ac8:	1c21      	adds	r1, r4, #0
10009aca:	b003      	add	sp, #12
10009acc:	bc3c      	pop	{r2, r3, r4, r5}
10009ace:	4690      	mov	r8, r2
10009ad0:	4699      	mov	r9, r3
10009ad2:	46a2      	mov	sl, r4
10009ad4:	46ab      	mov	fp, r5
10009ad6:	bdf0      	pop	{r4, r5, r6, r7, pc}
10009ad8:	4ba2      	ldr	r3, [pc, #648]	; (10009d64 <__aeabi_dsub+0x36c>)
10009ada:	429c      	cmp	r4, r3
10009adc:	d0be      	beq.n	10009a5c <__aeabi_dsub+0x64>
10009ade:	2380      	movs	r3, #128	; 0x80
10009ae0:	041b      	lsls	r3, r3, #16
10009ae2:	431a      	orrs	r2, r3
10009ae4:	2e38      	cmp	r6, #56	; 0x38
10009ae6:	dd00      	ble.n	10009aea <__aeabi_dsub+0xf2>
10009ae8:	e103      	b.n	10009cf2 <__aeabi_dsub+0x2fa>
10009aea:	2e1f      	cmp	r6, #31
10009aec:	dd00      	ble.n	10009af0 <__aeabi_dsub+0xf8>
10009aee:	e13f      	b.n	10009d70 <__aeabi_dsub+0x378>
10009af0:	2020      	movs	r0, #32
10009af2:	1b83      	subs	r3, r0, r6
10009af4:	4699      	mov	r9, r3
10009af6:	1c13      	adds	r3, r2, #0
10009af8:	4649      	mov	r1, r9
10009afa:	408b      	lsls	r3, r1
10009afc:	469c      	mov	ip, r3
10009afe:	9b01      	ldr	r3, [sp, #4]
10009b00:	4660      	mov	r0, ip
10009b02:	40f3      	lsrs	r3, r6
10009b04:	4303      	orrs	r3, r0
10009b06:	9801      	ldr	r0, [sp, #4]
10009b08:	40f2      	lsrs	r2, r6
10009b0a:	4088      	lsls	r0, r1
10009b0c:	1c01      	adds	r1, r0, #0
10009b0e:	1e48      	subs	r0, r1, #1
10009b10:	4181      	sbcs	r1, r0
10009b12:	430b      	orrs	r3, r1
10009b14:	1aeb      	subs	r3, r5, r3
10009b16:	429d      	cmp	r5, r3
10009b18:	4180      	sbcs	r0, r0
10009b1a:	1c1d      	adds	r5, r3, #0
10009b1c:	1aba      	subs	r2, r7, r2
10009b1e:	4240      	negs	r0, r0
10009b20:	1a17      	subs	r7, r2, r0
10009b22:	023b      	lsls	r3, r7, #8
10009b24:	d400      	bmi.n	10009b28 <__aeabi_dsub+0x130>
10009b26:	e0a8      	b.n	10009c7a <__aeabi_dsub+0x282>
10009b28:	027a      	lsls	r2, r7, #9
10009b2a:	0a56      	lsrs	r6, r2, #9
10009b2c:	2e00      	cmp	r6, #0
10009b2e:	d100      	bne.n	10009b32 <__aeabi_dsub+0x13a>
10009b30:	e0ca      	b.n	10009cc8 <__aeabi_dsub+0x2d0>
10009b32:	1c30      	adds	r0, r6, #0
10009b34:	f7fb ff22 	bl	1000597c <__clzsi2>
10009b38:	1c03      	adds	r3, r0, #0
10009b3a:	3b08      	subs	r3, #8
10009b3c:	2b1f      	cmp	r3, #31
10009b3e:	dd00      	ble.n	10009b42 <__aeabi_dsub+0x14a>
10009b40:	e0cb      	b.n	10009cda <__aeabi_dsub+0x2e2>
10009b42:	2228      	movs	r2, #40	; 0x28
10009b44:	1c29      	adds	r1, r5, #0
10009b46:	1a12      	subs	r2, r2, r0
10009b48:	40d1      	lsrs	r1, r2
10009b4a:	409e      	lsls	r6, r3
10009b4c:	1c0a      	adds	r2, r1, #0
10009b4e:	409d      	lsls	r5, r3
10009b50:	4332      	orrs	r2, r6
10009b52:	429c      	cmp	r4, r3
10009b54:	dd00      	ble.n	10009b58 <__aeabi_dsub+0x160>
10009b56:	e0c8      	b.n	10009cea <__aeabi_dsub+0x2f2>
10009b58:	1b1c      	subs	r4, r3, r4
10009b5a:	1c67      	adds	r7, r4, #1
10009b5c:	2f1f      	cmp	r7, #31
10009b5e:	dd00      	ble.n	10009b62 <__aeabi_dsub+0x16a>
10009b60:	e0ed      	b.n	10009d3e <__aeabi_dsub+0x346>
10009b62:	231f      	movs	r3, #31
10009b64:	1c29      	adds	r1, r5, #0
10009b66:	1b1c      	subs	r4, r3, r4
10009b68:	1c13      	adds	r3, r2, #0
10009b6a:	40a5      	lsls	r5, r4
10009b6c:	40a3      	lsls	r3, r4
10009b6e:	40f9      	lsrs	r1, r7
10009b70:	1e6c      	subs	r4, r5, #1
10009b72:	41a5      	sbcs	r5, r4
10009b74:	40fa      	lsrs	r2, r7
10009b76:	4319      	orrs	r1, r3
10009b78:	430d      	orrs	r5, r1
10009b7a:	1c17      	adds	r7, r2, #0
10009b7c:	2400      	movs	r4, #0
10009b7e:	e76d      	b.n	10009a5c <__aeabi_dsub+0x64>
10009b80:	2380      	movs	r3, #128	; 0x80
10009b82:	2601      	movs	r6, #1
10009b84:	4642      	mov	r2, r8
10009b86:	041b      	lsls	r3, r3, #16
10009b88:	403b      	ands	r3, r7
10009b8a:	4016      	ands	r6, r2
10009b8c:	2b00      	cmp	r3, #0
10009b8e:	d000      	beq.n	10009b92 <__aeabi_dsub+0x19a>
10009b90:	e77b      	b.n	10009a8a <__aeabi_dsub+0x92>
10009b92:	4b74      	ldr	r3, [pc, #464]	; (10009d64 <__aeabi_dsub+0x36c>)
10009b94:	08ed      	lsrs	r5, r5, #3
10009b96:	0778      	lsls	r0, r7, #29
10009b98:	4305      	orrs	r5, r0
10009b9a:	08fa      	lsrs	r2, r7, #3
10009b9c:	429c      	cmp	r4, r3
10009b9e:	d03b      	beq.n	10009c18 <__aeabi_dsub+0x220>
10009ba0:	0312      	lsls	r2, r2, #12
10009ba2:	0564      	lsls	r4, r4, #21
10009ba4:	0b12      	lsrs	r2, r2, #12
10009ba6:	0d64      	lsrs	r4, r4, #21
10009ba8:	e77e      	b.n	10009aa8 <__aeabi_dsub+0xb0>
10009baa:	1a23      	subs	r3, r4, r0
10009bac:	469a      	mov	sl, r3
10009bae:	2b00      	cmp	r3, #0
10009bb0:	dc00      	bgt.n	10009bb4 <__aeabi_dsub+0x1bc>
10009bb2:	e0a5      	b.n	10009d00 <__aeabi_dsub+0x308>
10009bb4:	2800      	cmp	r0, #0
10009bb6:	d044      	beq.n	10009c42 <__aeabi_dsub+0x24a>
10009bb8:	486a      	ldr	r0, [pc, #424]	; (10009d64 <__aeabi_dsub+0x36c>)
10009bba:	4284      	cmp	r4, r0
10009bbc:	d100      	bne.n	10009bc0 <__aeabi_dsub+0x1c8>
10009bbe:	e74d      	b.n	10009a5c <__aeabi_dsub+0x64>
10009bc0:	2080      	movs	r0, #128	; 0x80
10009bc2:	0400      	lsls	r0, r0, #16
10009bc4:	4302      	orrs	r2, r0
10009bc6:	4653      	mov	r3, sl
10009bc8:	2b38      	cmp	r3, #56	; 0x38
10009bca:	dc00      	bgt.n	10009bce <__aeabi_dsub+0x1d6>
10009bcc:	e11c      	b.n	10009e08 <__aeabi_dsub+0x410>
10009bce:	9b01      	ldr	r3, [sp, #4]
10009bd0:	431a      	orrs	r2, r3
10009bd2:	1e51      	subs	r1, r2, #1
10009bd4:	418a      	sbcs	r2, r1
10009bd6:	b2d1      	uxtb	r1, r2
10009bd8:	2200      	movs	r2, #0
10009bda:	1949      	adds	r1, r1, r5
10009bdc:	42a9      	cmp	r1, r5
10009bde:	4180      	sbcs	r0, r0
10009be0:	1c0d      	adds	r5, r1, #0
10009be2:	19d2      	adds	r2, r2, r7
10009be4:	4240      	negs	r0, r0
10009be6:	1817      	adds	r7, r2, r0
10009be8:	023b      	lsls	r3, r7, #8
10009bea:	d546      	bpl.n	10009c7a <__aeabi_dsub+0x282>
10009bec:	4b5d      	ldr	r3, [pc, #372]	; (10009d64 <__aeabi_dsub+0x36c>)
10009bee:	3401      	adds	r4, #1
10009bf0:	429c      	cmp	r4, r3
10009bf2:	d100      	bne.n	10009bf6 <__aeabi_dsub+0x1fe>
10009bf4:	e169      	b.n	10009eca <__aeabi_dsub+0x4d2>
10009bf6:	2001      	movs	r0, #1
10009bf8:	4a5b      	ldr	r2, [pc, #364]	; (10009d68 <__aeabi_dsub+0x370>)
10009bfa:	086b      	lsrs	r3, r5, #1
10009bfc:	403a      	ands	r2, r7
10009bfe:	4028      	ands	r0, r5
10009c00:	4318      	orrs	r0, r3
10009c02:	07d5      	lsls	r5, r2, #31
10009c04:	4305      	orrs	r5, r0
10009c06:	0857      	lsrs	r7, r2, #1
10009c08:	e728      	b.n	10009a5c <__aeabi_dsub+0x64>
10009c0a:	1c13      	adds	r3, r2, #0
10009c0c:	9901      	ldr	r1, [sp, #4]
10009c0e:	430b      	orrs	r3, r1
10009c10:	d100      	bne.n	10009c14 <__aeabi_dsub+0x21c>
10009c12:	e711      	b.n	10009a38 <__aeabi_dsub+0x40>
10009c14:	464b      	mov	r3, r9
10009c16:	e713      	b.n	10009a40 <__aeabi_dsub+0x48>
10009c18:	1c2b      	adds	r3, r5, #0
10009c1a:	4313      	orrs	r3, r2
10009c1c:	d051      	beq.n	10009cc2 <__aeabi_dsub+0x2ca>
10009c1e:	2380      	movs	r3, #128	; 0x80
10009c20:	031b      	lsls	r3, r3, #12
10009c22:	431a      	orrs	r2, r3
10009c24:	0312      	lsls	r2, r2, #12
10009c26:	0b12      	lsrs	r2, r2, #12
10009c28:	e73e      	b.n	10009aa8 <__aeabi_dsub+0xb0>
10009c2a:	3e01      	subs	r6, #1
10009c2c:	2e00      	cmp	r6, #0
10009c2e:	d000      	beq.n	10009c32 <__aeabi_dsub+0x23a>
10009c30:	e080      	b.n	10009d34 <__aeabi_dsub+0x33c>
10009c32:	1a69      	subs	r1, r5, r1
10009c34:	428d      	cmp	r5, r1
10009c36:	419b      	sbcs	r3, r3
10009c38:	1aba      	subs	r2, r7, r2
10009c3a:	425b      	negs	r3, r3
10009c3c:	1ad7      	subs	r7, r2, r3
10009c3e:	1c0d      	adds	r5, r1, #0
10009c40:	e76f      	b.n	10009b22 <__aeabi_dsub+0x12a>
10009c42:	1c10      	adds	r0, r2, #0
10009c44:	9b01      	ldr	r3, [sp, #4]
10009c46:	4318      	orrs	r0, r3
10009c48:	d100      	bne.n	10009c4c <__aeabi_dsub+0x254>
10009c4a:	e707      	b.n	10009a5c <__aeabi_dsub+0x64>
10009c4c:	2301      	movs	r3, #1
10009c4e:	425b      	negs	r3, r3
10009c50:	469c      	mov	ip, r3
10009c52:	44e2      	add	sl, ip
10009c54:	4653      	mov	r3, sl
10009c56:	2b00      	cmp	r3, #0
10009c58:	d000      	beq.n	10009c5c <__aeabi_dsub+0x264>
10009c5a:	e102      	b.n	10009e62 <__aeabi_dsub+0x46a>
10009c5c:	9b01      	ldr	r3, [sp, #4]
10009c5e:	19d2      	adds	r2, r2, r7
10009c60:	1959      	adds	r1, r3, r5
10009c62:	42a9      	cmp	r1, r5
10009c64:	419b      	sbcs	r3, r3
10009c66:	425b      	negs	r3, r3
10009c68:	18d7      	adds	r7, r2, r3
10009c6a:	1c0d      	adds	r5, r1, #0
10009c6c:	e7bc      	b.n	10009be8 <__aeabi_dsub+0x1f0>
10009c6e:	4663      	mov	r3, ip
10009c70:	4303      	orrs	r3, r0
10009c72:	d100      	bne.n	10009c76 <__aeabi_dsub+0x27e>
10009c74:	e128      	b.n	10009ec8 <__aeabi_dsub+0x4d0>
10009c76:	1c07      	adds	r7, r0, #0
10009c78:	4665      	mov	r5, ip
10009c7a:	076b      	lsls	r3, r5, #29
10009c7c:	d000      	beq.n	10009c80 <__aeabi_dsub+0x288>
10009c7e:	e6f0      	b.n	10009a62 <__aeabi_dsub+0x6a>
10009c80:	2601      	movs	r6, #1
10009c82:	4643      	mov	r3, r8
10009c84:	401e      	ands	r6, r3
10009c86:	e784      	b.n	10009b92 <__aeabi_dsub+0x19a>
10009c88:	2e00      	cmp	r6, #0
10009c8a:	d000      	beq.n	10009c8e <__aeabi_dsub+0x296>
10009c8c:	e081      	b.n	10009d92 <__aeabi_dsub+0x39a>
10009c8e:	1c60      	adds	r0, r4, #1
10009c90:	0540      	lsls	r0, r0, #21
10009c92:	0d40      	lsrs	r0, r0, #21
10009c94:	2801      	cmp	r0, #1
10009c96:	dc00      	bgt.n	10009c9a <__aeabi_dsub+0x2a2>
10009c98:	e107      	b.n	10009eaa <__aeabi_dsub+0x4b2>
10009c9a:	9901      	ldr	r1, [sp, #4]
10009c9c:	1a68      	subs	r0, r5, r1
10009c9e:	4684      	mov	ip, r0
10009ca0:	4565      	cmp	r5, ip
10009ca2:	41b6      	sbcs	r6, r6
10009ca4:	1ab8      	subs	r0, r7, r2
10009ca6:	4276      	negs	r6, r6
10009ca8:	1b86      	subs	r6, r0, r6
10009caa:	0230      	lsls	r0, r6, #8
10009cac:	d400      	bmi.n	10009cb0 <__aeabi_dsub+0x2b8>
10009cae:	e0a1      	b.n	10009df4 <__aeabi_dsub+0x3fc>
10009cb0:	468c      	mov	ip, r1
10009cb2:	1b4d      	subs	r5, r1, r5
10009cb4:	45ac      	cmp	ip, r5
10009cb6:	4189      	sbcs	r1, r1
10009cb8:	1bd2      	subs	r2, r2, r7
10009cba:	4249      	negs	r1, r1
10009cbc:	1a56      	subs	r6, r2, r1
10009cbe:	4698      	mov	r8, r3
10009cc0:	e734      	b.n	10009b2c <__aeabi_dsub+0x134>
10009cc2:	2200      	movs	r2, #0
10009cc4:	2500      	movs	r5, #0
10009cc6:	e6ef      	b.n	10009aa8 <__aeabi_dsub+0xb0>
10009cc8:	1c28      	adds	r0, r5, #0
10009cca:	f7fb fe57 	bl	1000597c <__clzsi2>
10009cce:	3020      	adds	r0, #32
10009cd0:	1c03      	adds	r3, r0, #0
10009cd2:	3b08      	subs	r3, #8
10009cd4:	2b1f      	cmp	r3, #31
10009cd6:	dc00      	bgt.n	10009cda <__aeabi_dsub+0x2e2>
10009cd8:	e733      	b.n	10009b42 <__aeabi_dsub+0x14a>
10009cda:	1c02      	adds	r2, r0, #0
10009cdc:	3a28      	subs	r2, #40	; 0x28
10009cde:	4095      	lsls	r5, r2
10009ce0:	1c2a      	adds	r2, r5, #0
10009ce2:	2500      	movs	r5, #0
10009ce4:	429c      	cmp	r4, r3
10009ce6:	dc00      	bgt.n	10009cea <__aeabi_dsub+0x2f2>
10009ce8:	e736      	b.n	10009b58 <__aeabi_dsub+0x160>
10009cea:	4f1f      	ldr	r7, [pc, #124]	; (10009d68 <__aeabi_dsub+0x370>)
10009cec:	1ae4      	subs	r4, r4, r3
10009cee:	4017      	ands	r7, r2
10009cf0:	e6b4      	b.n	10009a5c <__aeabi_dsub+0x64>
10009cf2:	9b01      	ldr	r3, [sp, #4]
10009cf4:	431a      	orrs	r2, r3
10009cf6:	1e51      	subs	r1, r2, #1
10009cf8:	418a      	sbcs	r2, r1
10009cfa:	b2d3      	uxtb	r3, r2
10009cfc:	2200      	movs	r2, #0
10009cfe:	e709      	b.n	10009b14 <__aeabi_dsub+0x11c>
10009d00:	2b00      	cmp	r3, #0
10009d02:	d000      	beq.n	10009d06 <__aeabi_dsub+0x30e>
10009d04:	e101      	b.n	10009f0a <__aeabi_dsub+0x512>
10009d06:	1c60      	adds	r0, r4, #1
10009d08:	0543      	lsls	r3, r0, #21
10009d0a:	0d5b      	lsrs	r3, r3, #21
10009d0c:	2b01      	cmp	r3, #1
10009d0e:	dc00      	bgt.n	10009d12 <__aeabi_dsub+0x31a>
10009d10:	e0b0      	b.n	10009e74 <__aeabi_dsub+0x47c>
10009d12:	4b14      	ldr	r3, [pc, #80]	; (10009d64 <__aeabi_dsub+0x36c>)
10009d14:	4298      	cmp	r0, r3
10009d16:	d100      	bne.n	10009d1a <__aeabi_dsub+0x322>
10009d18:	e11e      	b.n	10009f58 <__aeabi_dsub+0x560>
10009d1a:	9b01      	ldr	r3, [sp, #4]
10009d1c:	19d2      	adds	r2, r2, r7
10009d1e:	1959      	adds	r1, r3, r5
10009d20:	42a9      	cmp	r1, r5
10009d22:	419b      	sbcs	r3, r3
10009d24:	425b      	negs	r3, r3
10009d26:	18d2      	adds	r2, r2, r3
10009d28:	0849      	lsrs	r1, r1, #1
10009d2a:	07d5      	lsls	r5, r2, #31
10009d2c:	430d      	orrs	r5, r1
10009d2e:	0857      	lsrs	r7, r2, #1
10009d30:	1c04      	adds	r4, r0, #0
10009d32:	e693      	b.n	10009a5c <__aeabi_dsub+0x64>
10009d34:	4b0b      	ldr	r3, [pc, #44]	; (10009d64 <__aeabi_dsub+0x36c>)
10009d36:	429c      	cmp	r4, r3
10009d38:	d000      	beq.n	10009d3c <__aeabi_dsub+0x344>
10009d3a:	e6d3      	b.n	10009ae4 <__aeabi_dsub+0xec>
10009d3c:	e68e      	b.n	10009a5c <__aeabi_dsub+0x64>
10009d3e:	1c21      	adds	r1, r4, #0
10009d40:	1c13      	adds	r3, r2, #0
10009d42:	391f      	subs	r1, #31
10009d44:	40cb      	lsrs	r3, r1
10009d46:	1c19      	adds	r1, r3, #0
10009d48:	2f20      	cmp	r7, #32
10009d4a:	d100      	bne.n	10009d4e <__aeabi_dsub+0x356>
10009d4c:	e08e      	b.n	10009e6c <__aeabi_dsub+0x474>
10009d4e:	233f      	movs	r3, #63	; 0x3f
10009d50:	1b1c      	subs	r4, r3, r4
10009d52:	40a2      	lsls	r2, r4
10009d54:	4315      	orrs	r5, r2
10009d56:	1e6a      	subs	r2, r5, #1
10009d58:	4195      	sbcs	r5, r2
10009d5a:	2700      	movs	r7, #0
10009d5c:	430d      	orrs	r5, r1
10009d5e:	2400      	movs	r4, #0
10009d60:	e78b      	b.n	10009c7a <__aeabi_dsub+0x282>
10009d62:	46c0      	nop			; (mov r8, r8)
10009d64:	000007ff 	.word	0x000007ff
10009d68:	ff7fffff 	.word	0xff7fffff
10009d6c:	800fffff 	.word	0x800fffff
10009d70:	1c33      	adds	r3, r6, #0
10009d72:	1c10      	adds	r0, r2, #0
10009d74:	3b20      	subs	r3, #32
10009d76:	40d8      	lsrs	r0, r3
10009d78:	2e20      	cmp	r6, #32
10009d7a:	d079      	beq.n	10009e70 <__aeabi_dsub+0x478>
10009d7c:	2340      	movs	r3, #64	; 0x40
10009d7e:	1b9b      	subs	r3, r3, r6
10009d80:	409a      	lsls	r2, r3
10009d82:	1c13      	adds	r3, r2, #0
10009d84:	9a01      	ldr	r2, [sp, #4]
10009d86:	4313      	orrs	r3, r2
10009d88:	1e59      	subs	r1, r3, #1
10009d8a:	418b      	sbcs	r3, r1
10009d8c:	2200      	movs	r2, #0
10009d8e:	4303      	orrs	r3, r0
10009d90:	e6c0      	b.n	10009b14 <__aeabi_dsub+0x11c>
10009d92:	2c00      	cmp	r4, #0
10009d94:	d053      	beq.n	10009e3e <__aeabi_dsub+0x446>
10009d96:	4cc7      	ldr	r4, [pc, #796]	; (1000a0b4 <__aeabi_dsub+0x6bc>)
10009d98:	42a0      	cmp	r0, r4
10009d9a:	d100      	bne.n	10009d9e <__aeabi_dsub+0x3a6>
10009d9c:	e0b0      	b.n	10009f00 <__aeabi_dsub+0x508>
10009d9e:	2480      	movs	r4, #128	; 0x80
10009da0:	4271      	negs	r1, r6
10009da2:	4689      	mov	r9, r1
10009da4:	0424      	lsls	r4, r4, #16
10009da6:	4327      	orrs	r7, r4
10009da8:	4649      	mov	r1, r9
10009daa:	2938      	cmp	r1, #56	; 0x38
10009dac:	dd00      	ble.n	10009db0 <__aeabi_dsub+0x3b8>
10009dae:	e0cd      	b.n	10009f4c <__aeabi_dsub+0x554>
10009db0:	291f      	cmp	r1, #31
10009db2:	dd00      	ble.n	10009db6 <__aeabi_dsub+0x3be>
10009db4:	e159      	b.n	1000a06a <__aeabi_dsub+0x672>
10009db6:	2420      	movs	r4, #32
10009db8:	1c3e      	adds	r6, r7, #0
10009dba:	1a61      	subs	r1, r4, r1
10009dbc:	408e      	lsls	r6, r1
10009dbe:	468a      	mov	sl, r1
10009dc0:	46b0      	mov	r8, r6
10009dc2:	4649      	mov	r1, r9
10009dc4:	1c2e      	adds	r6, r5, #0
10009dc6:	40ce      	lsrs	r6, r1
10009dc8:	4651      	mov	r1, sl
10009dca:	46b4      	mov	ip, r6
10009dcc:	408d      	lsls	r5, r1
10009dce:	4664      	mov	r4, ip
10009dd0:	4646      	mov	r6, r8
10009dd2:	4649      	mov	r1, r9
10009dd4:	4326      	orrs	r6, r4
10009dd6:	1e6c      	subs	r4, r5, #1
10009dd8:	41a5      	sbcs	r5, r4
10009dda:	40cf      	lsrs	r7, r1
10009ddc:	4335      	orrs	r5, r6
10009dde:	9901      	ldr	r1, [sp, #4]
10009de0:	1bd7      	subs	r7, r2, r7
10009de2:	468c      	mov	ip, r1
10009de4:	1b4d      	subs	r5, r1, r5
10009de6:	45ac      	cmp	ip, r5
10009de8:	4192      	sbcs	r2, r2
10009dea:	4252      	negs	r2, r2
10009dec:	1abf      	subs	r7, r7, r2
10009dee:	1c04      	adds	r4, r0, #0
10009df0:	4698      	mov	r8, r3
10009df2:	e696      	b.n	10009b22 <__aeabi_dsub+0x12a>
10009df4:	4663      	mov	r3, ip
10009df6:	4665      	mov	r5, ip
10009df8:	4333      	orrs	r3, r6
10009dfa:	d000      	beq.n	10009dfe <__aeabi_dsub+0x406>
10009dfc:	e696      	b.n	10009b2c <__aeabi_dsub+0x134>
10009dfe:	2600      	movs	r6, #0
10009e00:	2700      	movs	r7, #0
10009e02:	2400      	movs	r4, #0
10009e04:	2500      	movs	r5, #0
10009e06:	e6c4      	b.n	10009b92 <__aeabi_dsub+0x19a>
10009e08:	2b1f      	cmp	r3, #31
10009e0a:	dc61      	bgt.n	10009ed0 <__aeabi_dsub+0x4d8>
10009e0c:	2020      	movs	r0, #32
10009e0e:	1ac3      	subs	r3, r0, r3
10009e10:	469b      	mov	fp, r3
10009e12:	1c13      	adds	r3, r2, #0
10009e14:	4659      	mov	r1, fp
10009e16:	408b      	lsls	r3, r1
10009e18:	4651      	mov	r1, sl
10009e1a:	4699      	mov	r9, r3
10009e1c:	9b01      	ldr	r3, [sp, #4]
10009e1e:	40cb      	lsrs	r3, r1
10009e20:	469c      	mov	ip, r3
10009e22:	464b      	mov	r3, r9
10009e24:	4660      	mov	r0, ip
10009e26:	4303      	orrs	r3, r0
10009e28:	469c      	mov	ip, r3
10009e2a:	465b      	mov	r3, fp
10009e2c:	9901      	ldr	r1, [sp, #4]
10009e2e:	4099      	lsls	r1, r3
10009e30:	4663      	mov	r3, ip
10009e32:	1e48      	subs	r0, r1, #1
10009e34:	4181      	sbcs	r1, r0
10009e36:	4319      	orrs	r1, r3
10009e38:	4653      	mov	r3, sl
10009e3a:	40da      	lsrs	r2, r3
10009e3c:	e6cd      	b.n	10009bda <__aeabi_dsub+0x1e2>
10009e3e:	1c3c      	adds	r4, r7, #0
10009e40:	432c      	orrs	r4, r5
10009e42:	d05d      	beq.n	10009f00 <__aeabi_dsub+0x508>
10009e44:	43f1      	mvns	r1, r6
10009e46:	4689      	mov	r9, r1
10009e48:	2900      	cmp	r1, #0
10009e4a:	d155      	bne.n	10009ef8 <__aeabi_dsub+0x500>
10009e4c:	9901      	ldr	r1, [sp, #4]
10009e4e:	1bd2      	subs	r2, r2, r7
10009e50:	468c      	mov	ip, r1
10009e52:	1b4d      	subs	r5, r1, r5
10009e54:	45ac      	cmp	ip, r5
10009e56:	4189      	sbcs	r1, r1
10009e58:	4249      	negs	r1, r1
10009e5a:	1a57      	subs	r7, r2, r1
10009e5c:	1c04      	adds	r4, r0, #0
10009e5e:	4698      	mov	r8, r3
10009e60:	e65f      	b.n	10009b22 <__aeabi_dsub+0x12a>
10009e62:	4894      	ldr	r0, [pc, #592]	; (1000a0b4 <__aeabi_dsub+0x6bc>)
10009e64:	4284      	cmp	r4, r0
10009e66:	d000      	beq.n	10009e6a <__aeabi_dsub+0x472>
10009e68:	e6ad      	b.n	10009bc6 <__aeabi_dsub+0x1ce>
10009e6a:	e5f7      	b.n	10009a5c <__aeabi_dsub+0x64>
10009e6c:	2200      	movs	r2, #0
10009e6e:	e771      	b.n	10009d54 <__aeabi_dsub+0x35c>
10009e70:	2300      	movs	r3, #0
10009e72:	e787      	b.n	10009d84 <__aeabi_dsub+0x38c>
10009e74:	1c3b      	adds	r3, r7, #0
10009e76:	432b      	orrs	r3, r5
10009e78:	2c00      	cmp	r4, #0
10009e7a:	d000      	beq.n	10009e7e <__aeabi_dsub+0x486>
10009e7c:	e0da      	b.n	1000a034 <__aeabi_dsub+0x63c>
10009e7e:	2b00      	cmp	r3, #0
10009e80:	d100      	bne.n	10009e84 <__aeabi_dsub+0x48c>
10009e82:	e113      	b.n	1000a0ac <__aeabi_dsub+0x6b4>
10009e84:	1c13      	adds	r3, r2, #0
10009e86:	9901      	ldr	r1, [sp, #4]
10009e88:	430b      	orrs	r3, r1
10009e8a:	d100      	bne.n	10009e8e <__aeabi_dsub+0x496>
10009e8c:	e5e6      	b.n	10009a5c <__aeabi_dsub+0x64>
10009e8e:	1949      	adds	r1, r1, r5
10009e90:	42a9      	cmp	r1, r5
10009e92:	419b      	sbcs	r3, r3
10009e94:	19d2      	adds	r2, r2, r7
10009e96:	425b      	negs	r3, r3
10009e98:	18d7      	adds	r7, r2, r3
10009e9a:	023b      	lsls	r3, r7, #8
10009e9c:	d400      	bmi.n	10009ea0 <__aeabi_dsub+0x4a8>
10009e9e:	e121      	b.n	1000a0e4 <__aeabi_dsub+0x6ec>
10009ea0:	4b85      	ldr	r3, [pc, #532]	; (1000a0b8 <__aeabi_dsub+0x6c0>)
10009ea2:	1c0d      	adds	r5, r1, #0
10009ea4:	401f      	ands	r7, r3
10009ea6:	1c04      	adds	r4, r0, #0
10009ea8:	e5d8      	b.n	10009a5c <__aeabi_dsub+0x64>
10009eaa:	1c38      	adds	r0, r7, #0
10009eac:	4328      	orrs	r0, r5
10009eae:	2c00      	cmp	r4, #0
10009eb0:	d140      	bne.n	10009f34 <__aeabi_dsub+0x53c>
10009eb2:	2800      	cmp	r0, #0
10009eb4:	d000      	beq.n	10009eb8 <__aeabi_dsub+0x4c0>
10009eb6:	e083      	b.n	10009fc0 <__aeabi_dsub+0x5c8>
10009eb8:	1c10      	adds	r0, r2, #0
10009eba:	9901      	ldr	r1, [sp, #4]
10009ebc:	4308      	orrs	r0, r1
10009ebe:	d003      	beq.n	10009ec8 <__aeabi_dsub+0x4d0>
10009ec0:	1c17      	adds	r7, r2, #0
10009ec2:	1c0d      	adds	r5, r1, #0
10009ec4:	4698      	mov	r8, r3
10009ec6:	e5c9      	b.n	10009a5c <__aeabi_dsub+0x64>
10009ec8:	2600      	movs	r6, #0
10009eca:	2700      	movs	r7, #0
10009ecc:	2500      	movs	r5, #0
10009ece:	e660      	b.n	10009b92 <__aeabi_dsub+0x19a>
10009ed0:	4650      	mov	r0, sl
10009ed2:	1c13      	adds	r3, r2, #0
10009ed4:	3820      	subs	r0, #32
10009ed6:	40c3      	lsrs	r3, r0
10009ed8:	1c18      	adds	r0, r3, #0
10009eda:	4653      	mov	r3, sl
10009edc:	2b20      	cmp	r3, #32
10009ede:	d100      	bne.n	10009ee2 <__aeabi_dsub+0x4ea>
10009ee0:	e0c1      	b.n	1000a066 <__aeabi_dsub+0x66e>
10009ee2:	2340      	movs	r3, #64	; 0x40
10009ee4:	4651      	mov	r1, sl
10009ee6:	1a5b      	subs	r3, r3, r1
10009ee8:	409a      	lsls	r2, r3
10009eea:	9901      	ldr	r1, [sp, #4]
10009eec:	4311      	orrs	r1, r2
10009eee:	1e4a      	subs	r2, r1, #1
10009ef0:	4191      	sbcs	r1, r2
10009ef2:	2200      	movs	r2, #0
10009ef4:	4301      	orrs	r1, r0
10009ef6:	e670      	b.n	10009bda <__aeabi_dsub+0x1e2>
10009ef8:	4c6e      	ldr	r4, [pc, #440]	; (1000a0b4 <__aeabi_dsub+0x6bc>)
10009efa:	42a0      	cmp	r0, r4
10009efc:	d000      	beq.n	10009f00 <__aeabi_dsub+0x508>
10009efe:	e753      	b.n	10009da8 <__aeabi_dsub+0x3b0>
10009f00:	1c17      	adds	r7, r2, #0
10009f02:	9d01      	ldr	r5, [sp, #4]
10009f04:	1c04      	adds	r4, r0, #0
10009f06:	4698      	mov	r8, r3
10009f08:	e5a8      	b.n	10009a5c <__aeabi_dsub+0x64>
10009f0a:	2c00      	cmp	r4, #0
10009f0c:	d128      	bne.n	10009f60 <__aeabi_dsub+0x568>
10009f0e:	1c3c      	adds	r4, r7, #0
10009f10:	432c      	orrs	r4, r5
10009f12:	d100      	bne.n	10009f16 <__aeabi_dsub+0x51e>
10009f14:	e08a      	b.n	1000a02c <__aeabi_dsub+0x634>
10009f16:	43db      	mvns	r3, r3
10009f18:	469a      	mov	sl, r3
10009f1a:	2b00      	cmp	r3, #0
10009f1c:	d000      	beq.n	10009f20 <__aeabi_dsub+0x528>
10009f1e:	e082      	b.n	1000a026 <__aeabi_dsub+0x62e>
10009f20:	9b01      	ldr	r3, [sp, #4]
10009f22:	19d2      	adds	r2, r2, r7
10009f24:	469c      	mov	ip, r3
10009f26:	4465      	add	r5, ip
10009f28:	429d      	cmp	r5, r3
10009f2a:	4189      	sbcs	r1, r1
10009f2c:	4249      	negs	r1, r1
10009f2e:	1857      	adds	r7, r2, r1
10009f30:	1c04      	adds	r4, r0, #0
10009f32:	e659      	b.n	10009be8 <__aeabi_dsub+0x1f0>
10009f34:	2800      	cmp	r0, #0
10009f36:	d15b      	bne.n	10009ff0 <__aeabi_dsub+0x5f8>
10009f38:	1c10      	adds	r0, r2, #0
10009f3a:	9901      	ldr	r1, [sp, #4]
10009f3c:	4308      	orrs	r0, r1
10009f3e:	d100      	bne.n	10009f42 <__aeabi_dsub+0x54a>
10009f40:	e0a4      	b.n	1000a08c <__aeabi_dsub+0x694>
10009f42:	1c17      	adds	r7, r2, #0
10009f44:	1c0d      	adds	r5, r1, #0
10009f46:	4698      	mov	r8, r3
10009f48:	4c5a      	ldr	r4, [pc, #360]	; (1000a0b4 <__aeabi_dsub+0x6bc>)
10009f4a:	e587      	b.n	10009a5c <__aeabi_dsub+0x64>
10009f4c:	433d      	orrs	r5, r7
10009f4e:	1e6f      	subs	r7, r5, #1
10009f50:	41bd      	sbcs	r5, r7
10009f52:	2700      	movs	r7, #0
10009f54:	b2ed      	uxtb	r5, r5
10009f56:	e742      	b.n	10009dde <__aeabi_dsub+0x3e6>
10009f58:	1c04      	adds	r4, r0, #0
10009f5a:	2700      	movs	r7, #0
10009f5c:	2500      	movs	r5, #0
10009f5e:	e618      	b.n	10009b92 <__aeabi_dsub+0x19a>
10009f60:	4c54      	ldr	r4, [pc, #336]	; (1000a0b4 <__aeabi_dsub+0x6bc>)
10009f62:	42a0      	cmp	r0, r4
10009f64:	d062      	beq.n	1000a02c <__aeabi_dsub+0x634>
10009f66:	4653      	mov	r3, sl
10009f68:	2480      	movs	r4, #128	; 0x80
10009f6a:	425b      	negs	r3, r3
10009f6c:	469a      	mov	sl, r3
10009f6e:	0424      	lsls	r4, r4, #16
10009f70:	4327      	orrs	r7, r4
10009f72:	4653      	mov	r3, sl
10009f74:	2b38      	cmp	r3, #56	; 0x38
10009f76:	dd00      	ble.n	10009f7a <__aeabi_dsub+0x582>
10009f78:	e08e      	b.n	1000a098 <__aeabi_dsub+0x6a0>
10009f7a:	2b1f      	cmp	r3, #31
10009f7c:	dd00      	ble.n	10009f80 <__aeabi_dsub+0x588>
10009f7e:	e09d      	b.n	1000a0bc <__aeabi_dsub+0x6c4>
10009f80:	2420      	movs	r4, #32
10009f82:	1ae3      	subs	r3, r4, r3
10009f84:	469b      	mov	fp, r3
10009f86:	1c3b      	adds	r3, r7, #0
10009f88:	4659      	mov	r1, fp
10009f8a:	408b      	lsls	r3, r1
10009f8c:	4651      	mov	r1, sl
10009f8e:	4699      	mov	r9, r3
10009f90:	1c2b      	adds	r3, r5, #0
10009f92:	40cb      	lsrs	r3, r1
10009f94:	469c      	mov	ip, r3
10009f96:	464b      	mov	r3, r9
10009f98:	4664      	mov	r4, ip
10009f9a:	4323      	orrs	r3, r4
10009f9c:	469c      	mov	ip, r3
10009f9e:	465b      	mov	r3, fp
10009fa0:	409d      	lsls	r5, r3
10009fa2:	4663      	mov	r3, ip
10009fa4:	1e6c      	subs	r4, r5, #1
10009fa6:	41a5      	sbcs	r5, r4
10009fa8:	40cf      	lsrs	r7, r1
10009faa:	431d      	orrs	r5, r3
10009fac:	9b01      	ldr	r3, [sp, #4]
10009fae:	18bf      	adds	r7, r7, r2
10009fb0:	469c      	mov	ip, r3
10009fb2:	4465      	add	r5, ip
10009fb4:	429d      	cmp	r5, r3
10009fb6:	4192      	sbcs	r2, r2
10009fb8:	4252      	negs	r2, r2
10009fba:	18bf      	adds	r7, r7, r2
10009fbc:	1c04      	adds	r4, r0, #0
10009fbe:	e613      	b.n	10009be8 <__aeabi_dsub+0x1f0>
10009fc0:	1c10      	adds	r0, r2, #0
10009fc2:	9901      	ldr	r1, [sp, #4]
10009fc4:	4308      	orrs	r0, r1
10009fc6:	d100      	bne.n	10009fca <__aeabi_dsub+0x5d2>
10009fc8:	e548      	b.n	10009a5c <__aeabi_dsub+0x64>
10009fca:	1a68      	subs	r0, r5, r1
10009fcc:	4684      	mov	ip, r0
10009fce:	4285      	cmp	r5, r0
10009fd0:	4180      	sbcs	r0, r0
10009fd2:	1abe      	subs	r6, r7, r2
10009fd4:	4240      	negs	r0, r0
10009fd6:	1a30      	subs	r0, r6, r0
10009fd8:	0206      	lsls	r6, r0, #8
10009fda:	d400      	bmi.n	10009fde <__aeabi_dsub+0x5e6>
10009fdc:	e647      	b.n	10009c6e <__aeabi_dsub+0x276>
10009fde:	468c      	mov	ip, r1
10009fe0:	1b4d      	subs	r5, r1, r5
10009fe2:	45ac      	cmp	ip, r5
10009fe4:	4189      	sbcs	r1, r1
10009fe6:	1bd2      	subs	r2, r2, r7
10009fe8:	4249      	negs	r1, r1
10009fea:	1a57      	subs	r7, r2, r1
10009fec:	4698      	mov	r8, r3
10009fee:	e535      	b.n	10009a5c <__aeabi_dsub+0x64>
10009ff0:	1c10      	adds	r0, r2, #0
10009ff2:	9901      	ldr	r1, [sp, #4]
10009ff4:	4308      	orrs	r0, r1
10009ff6:	d034      	beq.n	1000a062 <__aeabi_dsub+0x66a>
10009ff8:	2480      	movs	r4, #128	; 0x80
10009ffa:	0778      	lsls	r0, r7, #29
10009ffc:	08ed      	lsrs	r5, r5, #3
10009ffe:	08ff      	lsrs	r7, r7, #3
1000a000:	0324      	lsls	r4, r4, #12
1000a002:	4328      	orrs	r0, r5
1000a004:	4227      	tst	r7, r4
1000a006:	d008      	beq.n	1000a01a <__aeabi_dsub+0x622>
1000a008:	08d6      	lsrs	r6, r2, #3
1000a00a:	4226      	tst	r6, r4
1000a00c:	d105      	bne.n	1000a01a <__aeabi_dsub+0x622>
1000a00e:	08c9      	lsrs	r1, r1, #3
1000a010:	0752      	lsls	r2, r2, #29
1000a012:	430a      	orrs	r2, r1
1000a014:	1c10      	adds	r0, r2, #0
1000a016:	1c37      	adds	r7, r6, #0
1000a018:	4698      	mov	r8, r3
1000a01a:	00ff      	lsls	r7, r7, #3
1000a01c:	0f42      	lsrs	r2, r0, #29
1000a01e:	4317      	orrs	r7, r2
1000a020:	00c5      	lsls	r5, r0, #3
1000a022:	4c24      	ldr	r4, [pc, #144]	; (1000a0b4 <__aeabi_dsub+0x6bc>)
1000a024:	e51a      	b.n	10009a5c <__aeabi_dsub+0x64>
1000a026:	4c23      	ldr	r4, [pc, #140]	; (1000a0b4 <__aeabi_dsub+0x6bc>)
1000a028:	42a0      	cmp	r0, r4
1000a02a:	d1a2      	bne.n	10009f72 <__aeabi_dsub+0x57a>
1000a02c:	1c17      	adds	r7, r2, #0
1000a02e:	9d01      	ldr	r5, [sp, #4]
1000a030:	1c04      	adds	r4, r0, #0
1000a032:	e513      	b.n	10009a5c <__aeabi_dsub+0x64>
1000a034:	2b00      	cmp	r3, #0
1000a036:	d035      	beq.n	1000a0a4 <__aeabi_dsub+0x6ac>
1000a038:	1c13      	adds	r3, r2, #0
1000a03a:	9901      	ldr	r1, [sp, #4]
1000a03c:	430b      	orrs	r3, r1
1000a03e:	d010      	beq.n	1000a062 <__aeabi_dsub+0x66a>
1000a040:	2480      	movs	r4, #128	; 0x80
1000a042:	0778      	lsls	r0, r7, #29
1000a044:	08ed      	lsrs	r5, r5, #3
1000a046:	08ff      	lsrs	r7, r7, #3
1000a048:	0324      	lsls	r4, r4, #12
1000a04a:	4328      	orrs	r0, r5
1000a04c:	4227      	tst	r7, r4
1000a04e:	d0e4      	beq.n	1000a01a <__aeabi_dsub+0x622>
1000a050:	08d3      	lsrs	r3, r2, #3
1000a052:	4223      	tst	r3, r4
1000a054:	d1e1      	bne.n	1000a01a <__aeabi_dsub+0x622>
1000a056:	08c9      	lsrs	r1, r1, #3
1000a058:	0752      	lsls	r2, r2, #29
1000a05a:	430a      	orrs	r2, r1
1000a05c:	1c10      	adds	r0, r2, #0
1000a05e:	1c1f      	adds	r7, r3, #0
1000a060:	e7db      	b.n	1000a01a <__aeabi_dsub+0x622>
1000a062:	4c14      	ldr	r4, [pc, #80]	; (1000a0b4 <__aeabi_dsub+0x6bc>)
1000a064:	e4fa      	b.n	10009a5c <__aeabi_dsub+0x64>
1000a066:	2200      	movs	r2, #0
1000a068:	e73f      	b.n	10009eea <__aeabi_dsub+0x4f2>
1000a06a:	464c      	mov	r4, r9
1000a06c:	1c3e      	adds	r6, r7, #0
1000a06e:	3c20      	subs	r4, #32
1000a070:	40e6      	lsrs	r6, r4
1000a072:	4649      	mov	r1, r9
1000a074:	1c34      	adds	r4, r6, #0
1000a076:	2920      	cmp	r1, #32
1000a078:	d032      	beq.n	1000a0e0 <__aeabi_dsub+0x6e8>
1000a07a:	2640      	movs	r6, #64	; 0x40
1000a07c:	1a76      	subs	r6, r6, r1
1000a07e:	40b7      	lsls	r7, r6
1000a080:	433d      	orrs	r5, r7
1000a082:	1e6f      	subs	r7, r5, #1
1000a084:	41bd      	sbcs	r5, r7
1000a086:	2700      	movs	r7, #0
1000a088:	4325      	orrs	r5, r4
1000a08a:	e6a8      	b.n	10009dde <__aeabi_dsub+0x3e6>
1000a08c:	2780      	movs	r7, #128	; 0x80
1000a08e:	2600      	movs	r6, #0
1000a090:	03ff      	lsls	r7, r7, #15
1000a092:	4c08      	ldr	r4, [pc, #32]	; (1000a0b4 <__aeabi_dsub+0x6bc>)
1000a094:	2500      	movs	r5, #0
1000a096:	e57c      	b.n	10009b92 <__aeabi_dsub+0x19a>
1000a098:	433d      	orrs	r5, r7
1000a09a:	1e6f      	subs	r7, r5, #1
1000a09c:	41bd      	sbcs	r5, r7
1000a09e:	2700      	movs	r7, #0
1000a0a0:	b2ed      	uxtb	r5, r5
1000a0a2:	e783      	b.n	10009fac <__aeabi_dsub+0x5b4>
1000a0a4:	1c17      	adds	r7, r2, #0
1000a0a6:	9d01      	ldr	r5, [sp, #4]
1000a0a8:	4c02      	ldr	r4, [pc, #8]	; (1000a0b4 <__aeabi_dsub+0x6bc>)
1000a0aa:	e4d7      	b.n	10009a5c <__aeabi_dsub+0x64>
1000a0ac:	1c17      	adds	r7, r2, #0
1000a0ae:	9d01      	ldr	r5, [sp, #4]
1000a0b0:	e4d4      	b.n	10009a5c <__aeabi_dsub+0x64>
1000a0b2:	46c0      	nop			; (mov r8, r8)
1000a0b4:	000007ff 	.word	0x000007ff
1000a0b8:	ff7fffff 	.word	0xff7fffff
1000a0bc:	4654      	mov	r4, sl
1000a0be:	1c3b      	adds	r3, r7, #0
1000a0c0:	3c20      	subs	r4, #32
1000a0c2:	40e3      	lsrs	r3, r4
1000a0c4:	1c1c      	adds	r4, r3, #0
1000a0c6:	4653      	mov	r3, sl
1000a0c8:	2b20      	cmp	r3, #32
1000a0ca:	d00d      	beq.n	1000a0e8 <__aeabi_dsub+0x6f0>
1000a0cc:	2340      	movs	r3, #64	; 0x40
1000a0ce:	4651      	mov	r1, sl
1000a0d0:	1a5b      	subs	r3, r3, r1
1000a0d2:	409f      	lsls	r7, r3
1000a0d4:	433d      	orrs	r5, r7
1000a0d6:	1e6f      	subs	r7, r5, #1
1000a0d8:	41bd      	sbcs	r5, r7
1000a0da:	2700      	movs	r7, #0
1000a0dc:	4325      	orrs	r5, r4
1000a0de:	e765      	b.n	10009fac <__aeabi_dsub+0x5b4>
1000a0e0:	2700      	movs	r7, #0
1000a0e2:	e7cd      	b.n	1000a080 <__aeabi_dsub+0x688>
1000a0e4:	1c0d      	adds	r5, r1, #0
1000a0e6:	e5c8      	b.n	10009c7a <__aeabi_dsub+0x282>
1000a0e8:	2700      	movs	r7, #0
1000a0ea:	e7f3      	b.n	1000a0d4 <__aeabi_dsub+0x6dc>

1000a0ec <__aeabi_d2iz>:
1000a0ec:	030b      	lsls	r3, r1, #12
1000a0ee:	b530      	push	{r4, r5, lr}
1000a0f0:	4c13      	ldr	r4, [pc, #76]	; (1000a140 <__aeabi_d2iz+0x54>)
1000a0f2:	0b1a      	lsrs	r2, r3, #12
1000a0f4:	004b      	lsls	r3, r1, #1
1000a0f6:	1c05      	adds	r5, r0, #0
1000a0f8:	0d5b      	lsrs	r3, r3, #21
1000a0fa:	0fc9      	lsrs	r1, r1, #31
1000a0fc:	2000      	movs	r0, #0
1000a0fe:	42a3      	cmp	r3, r4
1000a100:	dd10      	ble.n	1000a124 <__aeabi_d2iz+0x38>
1000a102:	4810      	ldr	r0, [pc, #64]	; (1000a144 <__aeabi_d2iz+0x58>)
1000a104:	4283      	cmp	r3, r0
1000a106:	dc0e      	bgt.n	1000a126 <__aeabi_d2iz+0x3a>
1000a108:	2080      	movs	r0, #128	; 0x80
1000a10a:	4c0f      	ldr	r4, [pc, #60]	; (1000a148 <__aeabi_d2iz+0x5c>)
1000a10c:	0340      	lsls	r0, r0, #13
1000a10e:	4302      	orrs	r2, r0
1000a110:	1ae4      	subs	r4, r4, r3
1000a112:	2c1f      	cmp	r4, #31
1000a114:	dd0a      	ble.n	1000a12c <__aeabi_d2iz+0x40>
1000a116:	480d      	ldr	r0, [pc, #52]	; (1000a14c <__aeabi_d2iz+0x60>)
1000a118:	1ac3      	subs	r3, r0, r3
1000a11a:	40da      	lsrs	r2, r3
1000a11c:	1c13      	adds	r3, r2, #0
1000a11e:	4248      	negs	r0, r1
1000a120:	4043      	eors	r3, r0
1000a122:	1858      	adds	r0, r3, r1
1000a124:	bd30      	pop	{r4, r5, pc}
1000a126:	4b0a      	ldr	r3, [pc, #40]	; (1000a150 <__aeabi_d2iz+0x64>)
1000a128:	18c8      	adds	r0, r1, r3
1000a12a:	e7fb      	b.n	1000a124 <__aeabi_d2iz+0x38>
1000a12c:	1c28      	adds	r0, r5, #0
1000a12e:	40e0      	lsrs	r0, r4
1000a130:	4c08      	ldr	r4, [pc, #32]	; (1000a154 <__aeabi_d2iz+0x68>)
1000a132:	46a4      	mov	ip, r4
1000a134:	4463      	add	r3, ip
1000a136:	409a      	lsls	r2, r3
1000a138:	1c13      	adds	r3, r2, #0
1000a13a:	4303      	orrs	r3, r0
1000a13c:	e7ef      	b.n	1000a11e <__aeabi_d2iz+0x32>
1000a13e:	46c0      	nop			; (mov r8, r8)
1000a140:	000003fe 	.word	0x000003fe
1000a144:	0000041d 	.word	0x0000041d
1000a148:	00000433 	.word	0x00000433
1000a14c:	00000413 	.word	0x00000413
1000a150:	7fffffff 	.word	0x7fffffff
1000a154:	fffffbed 	.word	0xfffffbed

1000a158 <__aeabi_i2d>:
1000a158:	b538      	push	{r3, r4, r5, lr}
1000a15a:	1e04      	subs	r4, r0, #0
1000a15c:	d016      	beq.n	1000a18c <__aeabi_i2d+0x34>
1000a15e:	0fc5      	lsrs	r5, r0, #31
1000a160:	d000      	beq.n	1000a164 <__aeabi_i2d+0xc>
1000a162:	4244      	negs	r4, r0
1000a164:	1c20      	adds	r0, r4, #0
1000a166:	f7fb fc09 	bl	1000597c <__clzsi2>
1000a16a:	4b17      	ldr	r3, [pc, #92]	; (1000a1c8 <__aeabi_i2d+0x70>)
1000a16c:	1a1b      	subs	r3, r3, r0
1000a16e:	280a      	cmp	r0, #10
1000a170:	dc21      	bgt.n	1000a1b6 <__aeabi_i2d+0x5e>
1000a172:	1c02      	adds	r2, r0, #0
1000a174:	1c21      	adds	r1, r4, #0
1000a176:	3215      	adds	r2, #21
1000a178:	4091      	lsls	r1, r2
1000a17a:	1c0a      	adds	r2, r1, #0
1000a17c:	210b      	movs	r1, #11
1000a17e:	1a08      	subs	r0, r1, r0
1000a180:	40c4      	lsrs	r4, r0
1000a182:	055b      	lsls	r3, r3, #21
1000a184:	0324      	lsls	r4, r4, #12
1000a186:	0b24      	lsrs	r4, r4, #12
1000a188:	0d5b      	lsrs	r3, r3, #21
1000a18a:	e003      	b.n	1000a194 <__aeabi_i2d+0x3c>
1000a18c:	2500      	movs	r5, #0
1000a18e:	2300      	movs	r3, #0
1000a190:	2400      	movs	r4, #0
1000a192:	2200      	movs	r2, #0
1000a194:	2100      	movs	r1, #0
1000a196:	1c10      	adds	r0, r2, #0
1000a198:	0324      	lsls	r4, r4, #12
1000a19a:	0d0a      	lsrs	r2, r1, #20
1000a19c:	0512      	lsls	r2, r2, #20
1000a19e:	0b24      	lsrs	r4, r4, #12
1000a1a0:	4314      	orrs	r4, r2
1000a1a2:	4a0a      	ldr	r2, [pc, #40]	; (1000a1cc <__aeabi_i2d+0x74>)
1000a1a4:	051b      	lsls	r3, r3, #20
1000a1a6:	4014      	ands	r4, r2
1000a1a8:	431c      	orrs	r4, r3
1000a1aa:	0064      	lsls	r4, r4, #1
1000a1ac:	07ed      	lsls	r5, r5, #31
1000a1ae:	0864      	lsrs	r4, r4, #1
1000a1b0:	432c      	orrs	r4, r5
1000a1b2:	1c21      	adds	r1, r4, #0
1000a1b4:	bd38      	pop	{r3, r4, r5, pc}
1000a1b6:	380b      	subs	r0, #11
1000a1b8:	4084      	lsls	r4, r0
1000a1ba:	055b      	lsls	r3, r3, #21
1000a1bc:	0324      	lsls	r4, r4, #12
1000a1be:	0b24      	lsrs	r4, r4, #12
1000a1c0:	0d5b      	lsrs	r3, r3, #21
1000a1c2:	2200      	movs	r2, #0
1000a1c4:	e7e6      	b.n	1000a194 <__aeabi_i2d+0x3c>
1000a1c6:	46c0      	nop			; (mov r8, r8)
1000a1c8:	0000041e 	.word	0x0000041e
1000a1cc:	800fffff 	.word	0x800fffff

1000a1d0 <__aeabi_ui2d>:
1000a1d0:	b510      	push	{r4, lr}
1000a1d2:	1e04      	subs	r4, r0, #0
1000a1d4:	d010      	beq.n	1000a1f8 <__aeabi_ui2d+0x28>
1000a1d6:	f7fb fbd1 	bl	1000597c <__clzsi2>
1000a1da:	4a14      	ldr	r2, [pc, #80]	; (1000a22c <__aeabi_ui2d+0x5c>)
1000a1dc:	1a12      	subs	r2, r2, r0
1000a1de:	280a      	cmp	r0, #10
1000a1e0:	dc1a      	bgt.n	1000a218 <__aeabi_ui2d+0x48>
1000a1e2:	230b      	movs	r3, #11
1000a1e4:	1c21      	adds	r1, r4, #0
1000a1e6:	1a1b      	subs	r3, r3, r0
1000a1e8:	40d9      	lsrs	r1, r3
1000a1ea:	3015      	adds	r0, #21
1000a1ec:	030b      	lsls	r3, r1, #12
1000a1ee:	0552      	lsls	r2, r2, #21
1000a1f0:	4084      	lsls	r4, r0
1000a1f2:	0b1b      	lsrs	r3, r3, #12
1000a1f4:	0d52      	lsrs	r2, r2, #21
1000a1f6:	e001      	b.n	1000a1fc <__aeabi_ui2d+0x2c>
1000a1f8:	2200      	movs	r2, #0
1000a1fa:	2300      	movs	r3, #0
1000a1fc:	2100      	movs	r1, #0
1000a1fe:	031b      	lsls	r3, r3, #12
1000a200:	1c20      	adds	r0, r4, #0
1000a202:	0b1c      	lsrs	r4, r3, #12
1000a204:	0d0b      	lsrs	r3, r1, #20
1000a206:	051b      	lsls	r3, r3, #20
1000a208:	4323      	orrs	r3, r4
1000a20a:	4c09      	ldr	r4, [pc, #36]	; (1000a230 <__aeabi_ui2d+0x60>)
1000a20c:	0512      	lsls	r2, r2, #20
1000a20e:	4023      	ands	r3, r4
1000a210:	4313      	orrs	r3, r2
1000a212:	005b      	lsls	r3, r3, #1
1000a214:	0859      	lsrs	r1, r3, #1
1000a216:	bd10      	pop	{r4, pc}
1000a218:	1c03      	adds	r3, r0, #0
1000a21a:	3b0b      	subs	r3, #11
1000a21c:	409c      	lsls	r4, r3
1000a21e:	0552      	lsls	r2, r2, #21
1000a220:	0323      	lsls	r3, r4, #12
1000a222:	0b1b      	lsrs	r3, r3, #12
1000a224:	0d52      	lsrs	r2, r2, #21
1000a226:	2400      	movs	r4, #0
1000a228:	e7e8      	b.n	1000a1fc <__aeabi_ui2d+0x2c>
1000a22a:	46c0      	nop			; (mov r8, r8)
1000a22c:	0000041e 	.word	0x0000041e
1000a230:	800fffff 	.word	0x800fffff

1000a234 <findslot>:
1000a234:	4b0a      	ldr	r3, [pc, #40]	; (1000a260 <findslot+0x2c>)
1000a236:	b510      	push	{r4, lr}
1000a238:	1c04      	adds	r4, r0, #0
1000a23a:	6818      	ldr	r0, [r3, #0]
1000a23c:	2800      	cmp	r0, #0
1000a23e:	d004      	beq.n	1000a24a <findslot+0x16>
1000a240:	6983      	ldr	r3, [r0, #24]
1000a242:	2b00      	cmp	r3, #0
1000a244:	d101      	bne.n	1000a24a <findslot+0x16>
1000a246:	f7fd fa0b 	bl	10007660 <__sinit>
1000a24a:	2000      	movs	r0, #0
1000a24c:	2c13      	cmp	r4, #19
1000a24e:	d805      	bhi.n	1000a25c <findslot+0x28>
1000a250:	4b04      	ldr	r3, [pc, #16]	; (1000a264 <findslot+0x30>)
1000a252:	00e4      	lsls	r4, r4, #3
1000a254:	58e2      	ldr	r2, [r4, r3]
1000a256:	3201      	adds	r2, #1
1000a258:	d000      	beq.n	1000a25c <findslot+0x28>
1000a25a:	1918      	adds	r0, r3, r4
1000a25c:	bd10      	pop	{r4, pc}
1000a25e:	46c0      	nop			; (mov r8, r8)
1000a260:	20000664 	.word	0x20000664
1000a264:	20000834 	.word	0x20000834

1000a268 <error>:
1000a268:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
1000a26a:	1c05      	adds	r5, r0, #0
1000a26c:	f7fb fba4 	bl	100059b8 <__errno>
1000a270:	2700      	movs	r7, #0
1000a272:	1c06      	adds	r6, r0, #0
1000a274:	2413      	movs	r4, #19
1000a276:	1c20      	adds	r0, r4, #0
1000a278:	1c39      	adds	r1, r7, #0
1000a27a:	beab      	bkpt	0x00ab
1000a27c:	1c04      	adds	r4, r0, #0
1000a27e:	1c28      	adds	r0, r5, #0
1000a280:	6034      	str	r4, [r6, #0]
1000a282:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

1000a284 <checkerror>:
1000a284:	b508      	push	{r3, lr}
1000a286:	1c43      	adds	r3, r0, #1
1000a288:	d101      	bne.n	1000a28e <checkerror+0xa>
1000a28a:	f7ff ffed 	bl	1000a268 <error>
1000a28e:	bd08      	pop	{r3, pc}

1000a290 <initialise_monitor_handles>:
1000a290:	b5f0      	push	{r4, r5, r6, r7, lr}
1000a292:	4b20      	ldr	r3, [pc, #128]	; (1000a314 <initialise_monitor_handles+0x84>)
1000a294:	b085      	sub	sp, #20
1000a296:	9301      	str	r3, [sp, #4]
1000a298:	2303      	movs	r3, #3
1000a29a:	ac01      	add	r4, sp, #4
1000a29c:	60a3      	str	r3, [r4, #8]
1000a29e:	2300      	movs	r3, #0
1000a2a0:	2501      	movs	r5, #1
1000a2a2:	6063      	str	r3, [r4, #4]
1000a2a4:	1c28      	adds	r0, r5, #0
1000a2a6:	1c21      	adds	r1, r4, #0
1000a2a8:	beab      	bkpt	0x00ab
1000a2aa:	1c06      	adds	r6, r0, #0
1000a2ac:	4b19      	ldr	r3, [pc, #100]	; (1000a314 <initialise_monitor_handles+0x84>)
1000a2ae:	4f1a      	ldr	r7, [pc, #104]	; (1000a318 <initialise_monitor_handles+0x88>)
1000a2b0:	9301      	str	r3, [sp, #4]
1000a2b2:	2303      	movs	r3, #3
1000a2b4:	60a3      	str	r3, [r4, #8]
1000a2b6:	195b      	adds	r3, r3, r5
1000a2b8:	603e      	str	r6, [r7, #0]
1000a2ba:	6063      	str	r3, [r4, #4]
1000a2bc:	1c28      	adds	r0, r5, #0
1000a2be:	1c21      	adds	r1, r4, #0
1000a2c0:	beab      	bkpt	0x00ab
1000a2c2:	1c06      	adds	r6, r0, #0
1000a2c4:	1c33      	adds	r3, r6, #0
1000a2c6:	4e15      	ldr	r6, [pc, #84]	; (1000a31c <initialise_monitor_handles+0x8c>)
1000a2c8:	6033      	str	r3, [r6, #0]
1000a2ca:	4b12      	ldr	r3, [pc, #72]	; (1000a314 <initialise_monitor_handles+0x84>)
1000a2cc:	9301      	str	r3, [sp, #4]
1000a2ce:	2303      	movs	r3, #3
1000a2d0:	60a3      	str	r3, [r4, #8]
1000a2d2:	3305      	adds	r3, #5
1000a2d4:	6063      	str	r3, [r4, #4]
1000a2d6:	1c28      	adds	r0, r5, #0
1000a2d8:	1c21      	adds	r1, r4, #0
1000a2da:	beab      	bkpt	0x00ab
1000a2dc:	1c04      	adds	r4, r0, #0
1000a2de:	4a10      	ldr	r2, [pc, #64]	; (1000a320 <initialise_monitor_handles+0x90>)
1000a2e0:	1c39      	adds	r1, r7, #0
1000a2e2:	6014      	str	r4, [r2, #0]
1000a2e4:	1c63      	adds	r3, r4, #1
1000a2e6:	d101      	bne.n	1000a2ec <initialise_monitor_handles+0x5c>
1000a2e8:	6833      	ldr	r3, [r6, #0]
1000a2ea:	6013      	str	r3, [r2, #0]
1000a2ec:	2000      	movs	r0, #0
1000a2ee:	2401      	movs	r4, #1
1000a2f0:	4b0c      	ldr	r3, [pc, #48]	; (1000a324 <initialise_monitor_handles+0x94>)
1000a2f2:	4264      	negs	r4, r4
1000a2f4:	50c4      	str	r4, [r0, r3]
1000a2f6:	3008      	adds	r0, #8
1000a2f8:	28a0      	cmp	r0, #160	; 0xa0
1000a2fa:	d1f8      	bne.n	1000a2ee <initialise_monitor_handles+0x5e>
1000a2fc:	6809      	ldr	r1, [r1, #0]
1000a2fe:	6830      	ldr	r0, [r6, #0]
1000a300:	6019      	str	r1, [r3, #0]
1000a302:	2100      	movs	r1, #0
1000a304:	6812      	ldr	r2, [r2, #0]
1000a306:	6059      	str	r1, [r3, #4]
1000a308:	6098      	str	r0, [r3, #8]
1000a30a:	60d9      	str	r1, [r3, #12]
1000a30c:	611a      	str	r2, [r3, #16]
1000a30e:	6159      	str	r1, [r3, #20]
1000a310:	b005      	add	sp, #20
1000a312:	bdf0      	pop	{r4, r5, r6, r7, pc}
1000a314:	1000a9f0 	.word	0x1000a9f0
1000a318:	2000082c 	.word	0x2000082c
1000a31c:	20000828 	.word	0x20000828
1000a320:	20000830 	.word	0x20000830
1000a324:	20000834 	.word	0x20000834

1000a328 <_swiread>:
1000a328:	b530      	push	{r4, r5, lr}
1000a32a:	b085      	sub	sp, #20
1000a32c:	ad01      	add	r5, sp, #4
1000a32e:	9001      	str	r0, [sp, #4]
1000a330:	9102      	str	r1, [sp, #8]
1000a332:	9203      	str	r2, [sp, #12]
1000a334:	2406      	movs	r4, #6
1000a336:	1c20      	adds	r0, r4, #0
1000a338:	1c29      	adds	r1, r5, #0
1000a33a:	beab      	bkpt	0x00ab
1000a33c:	1c04      	adds	r4, r0, #0
1000a33e:	1c20      	adds	r0, r4, #0
1000a340:	f7ff ffa0 	bl	1000a284 <checkerror>
1000a344:	b005      	add	sp, #20
1000a346:	bd30      	pop	{r4, r5, pc}

1000a348 <_read>:
1000a348:	b570      	push	{r4, r5, r6, lr}
1000a34a:	1c0e      	adds	r6, r1, #0
1000a34c:	1c15      	adds	r5, r2, #0
1000a34e:	f7ff ff71 	bl	1000a234 <findslot>
1000a352:	1e04      	subs	r4, r0, #0
1000a354:	d105      	bne.n	1000a362 <_read+0x1a>
1000a356:	f7fb fb2f 	bl	100059b8 <__errno>
1000a35a:	2309      	movs	r3, #9
1000a35c:	6003      	str	r3, [r0, #0]
1000a35e:	3b0a      	subs	r3, #10
1000a360:	e00b      	b.n	1000a37a <_read+0x32>
1000a362:	6800      	ldr	r0, [r0, #0]
1000a364:	1c31      	adds	r1, r6, #0
1000a366:	1c2a      	adds	r2, r5, #0
1000a368:	f7ff ffde 	bl	1000a328 <_swiread>
1000a36c:	1c03      	adds	r3, r0, #0
1000a36e:	1c42      	adds	r2, r0, #1
1000a370:	d003      	beq.n	1000a37a <_read+0x32>
1000a372:	6862      	ldr	r2, [r4, #4]
1000a374:	1a2b      	subs	r3, r5, r0
1000a376:	18d2      	adds	r2, r2, r3
1000a378:	6062      	str	r2, [r4, #4]
1000a37a:	1c18      	adds	r0, r3, #0
1000a37c:	bd70      	pop	{r4, r5, r6, pc}

1000a37e <_swilseek>:
1000a37e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
1000a380:	1c0c      	adds	r4, r1, #0
1000a382:	1c16      	adds	r6, r2, #0
1000a384:	f7ff ff56 	bl	1000a234 <findslot>
1000a388:	1e05      	subs	r5, r0, #0
1000a38a:	d103      	bne.n	1000a394 <_swilseek+0x16>
1000a38c:	f7fb fb14 	bl	100059b8 <__errno>
1000a390:	2309      	movs	r3, #9
1000a392:	e004      	b.n	1000a39e <_swilseek+0x20>
1000a394:	2e02      	cmp	r6, #2
1000a396:	d906      	bls.n	1000a3a6 <_swilseek+0x28>
1000a398:	f7fb fb0e 	bl	100059b8 <__errno>
1000a39c:	2316      	movs	r3, #22
1000a39e:	6003      	str	r3, [r0, #0]
1000a3a0:	2001      	movs	r0, #1
1000a3a2:	4240      	negs	r0, r0
1000a3a4:	e025      	b.n	1000a3f2 <_swilseek+0x74>
1000a3a6:	2e01      	cmp	r6, #1
1000a3a8:	d103      	bne.n	1000a3b2 <_swilseek+0x34>
1000a3aa:	6843      	ldr	r3, [r0, #4]
1000a3ac:	18e4      	adds	r4, r4, r3
1000a3ae:	d510      	bpl.n	1000a3d2 <_swilseek+0x54>
1000a3b0:	e7f2      	b.n	1000a398 <_swilseek+0x1a>
1000a3b2:	2e02      	cmp	r6, #2
1000a3b4:	d10d      	bne.n	1000a3d2 <_swilseek+0x54>
1000a3b6:	6803      	ldr	r3, [r0, #0]
1000a3b8:	360a      	adds	r6, #10
1000a3ba:	9300      	str	r3, [sp, #0]
1000a3bc:	466f      	mov	r7, sp
1000a3be:	1c30      	adds	r0, r6, #0
1000a3c0:	1c39      	adds	r1, r7, #0
1000a3c2:	beab      	bkpt	0x00ab
1000a3c4:	1c06      	adds	r6, r0, #0
1000a3c6:	1c30      	adds	r0, r6, #0
1000a3c8:	f7ff ff5c 	bl	1000a284 <checkerror>
1000a3cc:	1824      	adds	r4, r4, r0
1000a3ce:	1c43      	adds	r3, r0, #1
1000a3d0:	d0e6      	beq.n	1000a3a0 <_swilseek+0x22>
1000a3d2:	682b      	ldr	r3, [r5, #0]
1000a3d4:	466f      	mov	r7, sp
1000a3d6:	9300      	str	r3, [sp, #0]
1000a3d8:	9401      	str	r4, [sp, #4]
1000a3da:	260a      	movs	r6, #10
1000a3dc:	1c30      	adds	r0, r6, #0
1000a3de:	1c39      	adds	r1, r7, #0
1000a3e0:	beab      	bkpt	0x00ab
1000a3e2:	1c06      	adds	r6, r0, #0
1000a3e4:	1c30      	adds	r0, r6, #0
1000a3e6:	f7ff ff4d 	bl	1000a284 <checkerror>
1000a3ea:	2800      	cmp	r0, #0
1000a3ec:	dbd8      	blt.n	1000a3a0 <_swilseek+0x22>
1000a3ee:	1c20      	adds	r0, r4, #0
1000a3f0:	606c      	str	r4, [r5, #4]
1000a3f2:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

1000a3f4 <_lseek>:
1000a3f4:	b508      	push	{r3, lr}
1000a3f6:	f7ff ffc2 	bl	1000a37e <_swilseek>
1000a3fa:	bd08      	pop	{r3, pc}

1000a3fc <_swiwrite>:
1000a3fc:	b530      	push	{r4, r5, lr}
1000a3fe:	b085      	sub	sp, #20
1000a400:	ad01      	add	r5, sp, #4
1000a402:	9001      	str	r0, [sp, #4]
1000a404:	9102      	str	r1, [sp, #8]
1000a406:	9203      	str	r2, [sp, #12]
1000a408:	2405      	movs	r4, #5
1000a40a:	1c20      	adds	r0, r4, #0
1000a40c:	1c29      	adds	r1, r5, #0
1000a40e:	beab      	bkpt	0x00ab
1000a410:	1c04      	adds	r4, r0, #0
1000a412:	1c20      	adds	r0, r4, #0
1000a414:	f7ff ff36 	bl	1000a284 <checkerror>
1000a418:	b005      	add	sp, #20
1000a41a:	bd30      	pop	{r4, r5, pc}

1000a41c <_write>:
1000a41c:	b570      	push	{r4, r5, r6, lr}
1000a41e:	1c0e      	adds	r6, r1, #0
1000a420:	1c15      	adds	r5, r2, #0
1000a422:	f7ff ff07 	bl	1000a234 <findslot>
1000a426:	1e04      	subs	r4, r0, #0
1000a428:	d104      	bne.n	1000a434 <_write+0x18>
1000a42a:	f7fb fac5 	bl	100059b8 <__errno>
1000a42e:	2309      	movs	r3, #9
1000a430:	6003      	str	r3, [r0, #0]
1000a432:	e010      	b.n	1000a456 <_write+0x3a>
1000a434:	6800      	ldr	r0, [r0, #0]
1000a436:	1c31      	adds	r1, r6, #0
1000a438:	1c2a      	adds	r2, r5, #0
1000a43a:	f7ff ffdf 	bl	1000a3fc <_swiwrite>
1000a43e:	1e03      	subs	r3, r0, #0
1000a440:	db09      	blt.n	1000a456 <_write+0x3a>
1000a442:	6862      	ldr	r2, [r4, #4]
1000a444:	1a28      	subs	r0, r5, r0
1000a446:	1812      	adds	r2, r2, r0
1000a448:	6062      	str	r2, [r4, #4]
1000a44a:	429d      	cmp	r5, r3
1000a44c:	d105      	bne.n	1000a45a <_write+0x3e>
1000a44e:	2000      	movs	r0, #0
1000a450:	f7ff ff0a 	bl	1000a268 <error>
1000a454:	e001      	b.n	1000a45a <_write+0x3e>
1000a456:	2001      	movs	r0, #1
1000a458:	4240      	negs	r0, r0
1000a45a:	bd70      	pop	{r4, r5, r6, pc}

1000a45c <_swiclose>:
1000a45c:	b537      	push	{r0, r1, r2, r4, r5, lr}
1000a45e:	2402      	movs	r4, #2
1000a460:	9001      	str	r0, [sp, #4]
1000a462:	ad01      	add	r5, sp, #4
1000a464:	1c20      	adds	r0, r4, #0
1000a466:	1c29      	adds	r1, r5, #0
1000a468:	beab      	bkpt	0x00ab
1000a46a:	1c04      	adds	r4, r0, #0
1000a46c:	1c20      	adds	r0, r4, #0
1000a46e:	f7ff ff09 	bl	1000a284 <checkerror>
1000a472:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}

1000a474 <_close>:
1000a474:	b538      	push	{r3, r4, r5, lr}
1000a476:	1c05      	adds	r5, r0, #0
1000a478:	f7ff fedc 	bl	1000a234 <findslot>
1000a47c:	1e04      	subs	r4, r0, #0
1000a47e:	d106      	bne.n	1000a48e <_close+0x1a>
1000a480:	f7fb fa9a 	bl	100059b8 <__errno>
1000a484:	2309      	movs	r3, #9
1000a486:	6003      	str	r3, [r0, #0]
1000a488:	2001      	movs	r0, #1
1000a48a:	4240      	negs	r0, r0
1000a48c:	e014      	b.n	1000a4b8 <_close+0x44>
1000a48e:	3d01      	subs	r5, #1
1000a490:	2d01      	cmp	r5, #1
1000a492:	d809      	bhi.n	1000a4a8 <_close+0x34>
1000a494:	4b09      	ldr	r3, [pc, #36]	; (1000a4bc <_close+0x48>)
1000a496:	689a      	ldr	r2, [r3, #8]
1000a498:	691b      	ldr	r3, [r3, #16]
1000a49a:	429a      	cmp	r2, r3
1000a49c:	d104      	bne.n	1000a4a8 <_close+0x34>
1000a49e:	2301      	movs	r3, #1
1000a4a0:	425b      	negs	r3, r3
1000a4a2:	6003      	str	r3, [r0, #0]
1000a4a4:	2000      	movs	r0, #0
1000a4a6:	e007      	b.n	1000a4b8 <_close+0x44>
1000a4a8:	6820      	ldr	r0, [r4, #0]
1000a4aa:	f7ff ffd7 	bl	1000a45c <_swiclose>
1000a4ae:	2800      	cmp	r0, #0
1000a4b0:	d102      	bne.n	1000a4b8 <_close+0x44>
1000a4b2:	2301      	movs	r3, #1
1000a4b4:	425b      	negs	r3, r3
1000a4b6:	6023      	str	r3, [r4, #0]
1000a4b8:	bd38      	pop	{r3, r4, r5, pc}
1000a4ba:	46c0      	nop			; (mov r8, r8)
1000a4bc:	20000834 	.word	0x20000834

1000a4c0 <_swistat>:
1000a4c0:	b570      	push	{r4, r5, r6, lr}
1000a4c2:	1c0c      	adds	r4, r1, #0
1000a4c4:	f7ff feb6 	bl	1000a234 <findslot>
1000a4c8:	1e06      	subs	r6, r0, #0
1000a4ca:	d105      	bne.n	1000a4d8 <_swistat+0x18>
1000a4cc:	f7fb fa74 	bl	100059b8 <__errno>
1000a4d0:	2309      	movs	r3, #9
1000a4d2:	6003      	str	r3, [r0, #0]
1000a4d4:	3b0a      	subs	r3, #10
1000a4d6:	e014      	b.n	1000a502 <_swistat+0x42>
1000a4d8:	2380      	movs	r3, #128	; 0x80
1000a4da:	6862      	ldr	r2, [r4, #4]
1000a4dc:	019b      	lsls	r3, r3, #6
1000a4de:	4313      	orrs	r3, r2
1000a4e0:	6063      	str	r3, [r4, #4]
1000a4e2:	2380      	movs	r3, #128	; 0x80
1000a4e4:	00db      	lsls	r3, r3, #3
1000a4e6:	62e3      	str	r3, [r4, #44]	; 0x2c
1000a4e8:	250c      	movs	r5, #12
1000a4ea:	1c28      	adds	r0, r5, #0
1000a4ec:	1c31      	adds	r1, r6, #0
1000a4ee:	beab      	bkpt	0x00ab
1000a4f0:	1c05      	adds	r5, r0, #0
1000a4f2:	1c28      	adds	r0, r5, #0
1000a4f4:	f7ff fec6 	bl	1000a284 <checkerror>
1000a4f8:	1c03      	adds	r3, r0, #0
1000a4fa:	1c42      	adds	r2, r0, #1
1000a4fc:	d001      	beq.n	1000a502 <_swistat+0x42>
1000a4fe:	2300      	movs	r3, #0
1000a500:	6120      	str	r0, [r4, #16]
1000a502:	1c18      	adds	r0, r3, #0
1000a504:	bd70      	pop	{r4, r5, r6, pc}

1000a506 <_fstat>:
1000a506:	b538      	push	{r3, r4, r5, lr}
1000a508:	1c05      	adds	r5, r0, #0
1000a50a:	1c0c      	adds	r4, r1, #0
1000a50c:	223c      	movs	r2, #60	; 0x3c
1000a50e:	1c08      	adds	r0, r1, #0
1000a510:	2100      	movs	r1, #0
1000a512:	f7fb fa74 	bl	100059fe <memset>
1000a516:	1c28      	adds	r0, r5, #0
1000a518:	1c21      	adds	r1, r4, #0
1000a51a:	f7ff ffd1 	bl	1000a4c0 <_swistat>
1000a51e:	bd38      	pop	{r3, r4, r5, pc}

1000a520 <_isatty>:
1000a520:	b570      	push	{r4, r5, r6, lr}
1000a522:	f7ff fe87 	bl	1000a234 <findslot>
1000a526:	2509      	movs	r5, #9
1000a528:	1e04      	subs	r4, r0, #0
1000a52a:	d103      	bne.n	1000a534 <_isatty+0x14>
1000a52c:	f7fb fa44 	bl	100059b8 <__errno>
1000a530:	6005      	str	r5, [r0, #0]
1000a532:	e010      	b.n	1000a556 <_isatty+0x36>
1000a534:	1c28      	adds	r0, r5, #0
1000a536:	1c21      	adds	r1, r4, #0
1000a538:	beab      	bkpt	0x00ab
1000a53a:	1c04      	adds	r4, r0, #0
1000a53c:	2001      	movs	r0, #1
1000a53e:	4284      	cmp	r4, r0
1000a540:	d00a      	beq.n	1000a558 <_isatty+0x38>
1000a542:	f7fb fa39 	bl	100059b8 <__errno>
1000a546:	2400      	movs	r4, #0
1000a548:	1c06      	adds	r6, r0, #0
1000a54a:	2513      	movs	r5, #19
1000a54c:	1c28      	adds	r0, r5, #0
1000a54e:	1c21      	adds	r1, r4, #0
1000a550:	beab      	bkpt	0x00ab
1000a552:	1c05      	adds	r5, r0, #0
1000a554:	6035      	str	r5, [r6, #0]
1000a556:	1c20      	adds	r0, r4, #0
1000a558:	bd70      	pop	{r4, r5, r6, pc}
1000a55a:	0000      	movs	r0, r0
1000a55c:	100015fa 	.word	0x100015fa
1000a560:	100015fa 	.word	0x100015fa
1000a564:	10001604 	.word	0x10001604
1000a568:	10001604 	.word	0x10001604
1000a56c:	10001632 	.word	0x10001632
1000a570:	10001632 	.word	0x10001632
1000a574:	10001632 	.word	0x10001632
1000a578:	10001632 	.word	0x10001632
1000a57c:	1000160e 	.word	0x1000160e
1000a580:	1000161a 	.word	0x1000161a
1000a584:	10001626 	.word	0x10001626
1000a588:	10001626 	.word	0x10001626

1000a58c <UART_BLUETOOTH_channel_config>:
1000a58c:	00002580 01080800 00000010              .%..........

1000a598 <UART_BLUETOOTH_tx_pin_config>:
1000a598:	000000b8 00000001                       ........

1000a5a0 <UART_BLUETOOTH_tx_pin>:
1000a5a0:	40040100 00000003 1000a598              ...@........

1000a5ac <UART_BLUETOOTH_config>:
1000a5ac:	1000a58c 100023f9 00000000 00000000     .....#..........
	...
1000a5d0:	1000a5a0 04000000 00000104              ............

1000a5dc <UART_BLUETOOTH_rx_pin_config>:
1000a5dc:	00000000 00000001                       ........

1000a5e4 <TRIGGER_IN_compare_config>:
1000a5e4:	00000000 0000000a                       ........

1000a5ec <TRIGGER_IN_gpio_out_config>:
1000a5ec:	00000090 00010000                       ........

1000a5f4 <TRIGGER_OUT_compare_config>:
1000a5f4:	00000000 0000000a                       ........

1000a5fc <TRIGGER_OUT_gpio_out_config>:
1000a5fc:	00000090 00010000                       ........

1000a604 <INTERRUPT_ECHO_IN>:
1000a604:	00010317                                ....

1000a608 <INTERRUPT_ECHO_OUT>:
1000a608:	00010318 454c4449 00000000 09632509     ....IDLE.....%c.
1000a618:	25097525 75250975 00000a0d 20726d54     %u.%u.%u....Tmr 
1000a628:	00637653 51726d54 00000000 10004cfe     Svc.TmrQ.....L..
1000a638:	10004cfe 10004cfe 10004d72 10004d86     .L...L..rM...M..
1000a648:	10004dc2 10004cfe 10004cfe 10004d72     .M...L...L..rM..
1000a658:	10004d86                                .M..

1000a65c <ECHO_OUT>:
1000a65c:	40040200 00000000 00000000 00000001     ...@............

1000a66c <ECHO_IN>:
1000a66c:	40040100 00000000 00000000 00000000     ...@............

1000a67c <GREEN_LED>:
1000a67c:	40040000 00000080 00010000 00000008     ...@............

1000a68c <RED_LED>:
1000a68c:	40040000 00000080 00010000 0000000c     ...@............
1000a69c:	00000100 00010000 00000000 45564144     ............DAVE
1000a6ac:	50504120 6e692073 61697469 617a696c      APPs initializa
1000a6bc:	6e6f6974 69616620 0064656c 72617453     tion failed.Star
1000a6cc:	00000074 636f7250 69737365 5420676e     t...Processing T
1000a6dc:	006b7361 6d6d6f43 63696e75 6f697461     ask.Communicatio
1000a6ec:	6154206e 00006b73 636f7250 69737365     n Task..Processi
1000a6fc:	6154676e 64206b73 74617275 3a6e6f69     ngTask duration:
1000a70c:	756c2520 0a737520 00000000 7563636f      %lu us.....occu
1000a71c:	64656970 6170735f 20736563 6c25203d     pied_spaces = %l
1000a72c:	00000a75 65657246 61707320 3a736563     u...Free spaces:
1000a73c:	0a642520 00000000 72746e45 65636e61      %d.....Entrance
1000a74c:	6f6c6220 64656b63 00000a21 74736964      blocked!...dist
1000a75c:	65636e61 206e695f 6c25203d 00000a75     ance_in = %lu...
1000a76c:	7261430a 206e4920 65746564 64657463     .Car In detected
1000a77c:	00000000 74736964 65636e61 74756f5f     ....distance_out
1000a78c:	25203d20 000a756c 7261430a 74754f20      = %lu...Car Out
1000a79c:	74656420 65746365 00000064 00000043      detected...C...

1000a7ac <_global_impure_ptr>:
1000a7ac:	20000604 00464e49 00666e69 004e414e     ... INF.inf.NAN.
1000a7bc:	006e616e 31300030 35343332 39383736     nan.0.0123456789
1000a7cc:	44434241 30004645 34333231 38373635     ABCDEF.012345678
1000a7dc:	63626139 00666564 69666e49 7974696e     9abcdef.Infinity
1000a7ec:	4e614e00 00000000                       .NaN....

1000a7f4 <__sf_fake_stdin>:
	...

1000a814 <__sf_fake_stdout>:
	...

1000a834 <__sf_fake_stderr>:
	...
1000a854:	49534f50 002e0058 00000000              POSIX.......

1000a860 <__mprec_tens>:
1000a860:	00000000 3ff00000 00000000 40240000     .......?......$@
1000a870:	00000000 40590000 00000000 408f4000     ......Y@.....@.@
1000a880:	00000000 40c38800 00000000 40f86a00     .......@.....j.@
1000a890:	00000000 412e8480 00000000 416312d0     .......A......cA
1000a8a0:	00000000 4197d784 00000000 41cdcd65     .......A....e..A
1000a8b0:	20000000 4202a05f e8000000 42374876     ... _..B....vH7B
1000a8c0:	a2000000 426d1a94 e5400000 42a2309c     ......mB..@..0.B
1000a8d0:	1e900000 42d6bcc4 26340000 430c6bf5     .......B..4&.k.C
1000a8e0:	37e08000 4341c379 85d8a000 43763457     ...7y.AC....W4vC
1000a8f0:	674ec800 43abc16d 60913d00 43e158e4     ..Ngm..C.=.`.X.C
1000a900:	78b58c40 4415af1d d6e2ef50 444b1ae4     @..x...DP.....KD
1000a910:	064dd592 4480f0cf c7e14af6 44b52d02     ..M....D.J...-.D
1000a920:	79d99db4 44ea7843                       ...yCx.D

1000a928 <__mprec_bigtens>:
1000a928:	37e08000 4341c379 b5056e17 4693b8b5     ...7y.AC.n.....F
1000a938:	e93ff9f5 4d384f03 f9301d32 5a827748     ..?..O8M2.0.Hw.Z
1000a948:	7f73bf3c 75154fdd                       <.s..O.u

1000a950 <p05.5277>:
1000a950:	00000005 00000019 0000007d 2b302d23     ........}...#-0+
1000a960:	6c680020 6665004c 47464567 00000000      .hlL.efgEFG....
1000a970:	10008e1c 10008d0a 10008df0 10008cf6     ................
1000a980:	10008df0 10008dfa 10008df0 10008cf6     ................
1000a990:	10008d0a 10008d0a 10008dfa 10008cf6     ................
1000a9a0:	10008d00 10008d00 10008d00 10009062     ............b...
1000a9b0:	100096b0 1000968e 1000968e 10009682     ................
1000a9c0:	10009576 10009576 10009676 10009682     v...v...v.......
1000a9d0:	10009576 10009676 10009576 10009682     v...v...v.......
1000a9e0:	1000957a 1000957a 1000957a 10009890     z...z...z.......
1000a9f0:	0074743a                                :tt.

Disassembly of section .VENEER_Code:

2000000c <HardFault_Veneer>:
    
    .align 1
    
    .globl HardFault_Veneer
HardFault_Veneer:
    LDR R0, =HardFault_Handler
2000000c:	482c      	ldr	r0, [pc, #176]	; (200000c0 <CCU40_3_Veneer+0x20>)
    MOV PC,R0
2000000e:	4687      	mov	pc, r0
	...

2000002c <SVC_Veneer>:
    .long 0
    
/* ======================================================================== */
    .globl SVC_Veneer
SVC_Veneer:
    LDR R0, =SVC_Handler
2000002c:	4825      	ldr	r0, [pc, #148]	; (200000c4 <CCU40_3_Veneer+0x24>)
    MOV PC,R0
2000002e:	4687      	mov	pc, r0
	...

20000038 <PendSV_Veneer>:
    .long 0
    .long 0
/* ======================================================================== */
    .globl PendSV_Veneer
PendSV_Veneer:
    LDR R0, =PendSV_Handler
20000038:	4823      	ldr	r0, [pc, #140]	; (200000c8 <CCU40_3_Veneer+0x28>)
    MOV PC,R0
2000003a:	4687      	mov	pc, r0

2000003c <SysTick_Veneer>:
/* ======================================================================== */
    .globl SysTick_Veneer 
SysTick_Veneer:
    LDR R0, =SysTick_Handler
2000003c:	4823      	ldr	r0, [pc, #140]	; (200000cc <CCU40_3_Veneer+0x2c>)
    MOV PC,R0
2000003e:	4687      	mov	pc, r0

20000040 <SCU_0_Veneer>:
/* ======================================================================== */
    .globl SCU_0_Veneer 
SCU_0_Veneer:
    LDR R0, =SCU_0_IRQHandler
20000040:	4823      	ldr	r0, [pc, #140]	; (200000d0 <CCU40_3_Veneer+0x30>)
    MOV PC,R0
20000042:	4687      	mov	pc, r0

20000044 <SCU_1_Veneer>:
/* ======================================================================== */
    .globl SCU_1_Veneer 
SCU_1_Veneer:
    LDR R0, =SCU_1_IRQHandler
20000044:	4823      	ldr	r0, [pc, #140]	; (200000d4 <CCU40_3_Veneer+0x34>)
    MOV PC,R0
20000046:	4687      	mov	pc, r0

20000048 <SCU_2_Veneer>:
/* ======================================================================== */
    .globl SCU_2_Veneer
SCU_2_Veneer:
    LDR R0, =SCU_2_IRQHandler
20000048:	4823      	ldr	r0, [pc, #140]	; (200000d8 <CCU40_3_Veneer+0x38>)
    MOV PC,R0
2000004a:	4687      	mov	pc, r0

2000004c <SCU_3_Veneer>:
/* ======================================================================== */
    .globl SCU_3_Veneer 
SCU_3_Veneer:
    LDR R0, =ERU0_0_IRQHandler
2000004c:	4823      	ldr	r0, [pc, #140]	; (200000dc <CCU40_3_Veneer+0x3c>)
    MOV PC,R0
2000004e:	4687      	mov	pc, r0

20000050 <SCU_4_Veneer>:
/* ======================================================================== */
    .globl SCU_4_Veneer 
SCU_4_Veneer:
    LDR R0, =ERU0_1_IRQHandler
20000050:	4823      	ldr	r0, [pc, #140]	; (200000e0 <CCU40_3_Veneer+0x40>)
    MOV PC,R0
20000052:	4687      	mov	pc, r0

20000054 <SCU_5_Veneer>:
/* ======================================================================== */
    .globl SCU_5_Veneer 
SCU_5_Veneer:
    LDR R0, =ERU0_2_IRQHandler
20000054:	4823      	ldr	r0, [pc, #140]	; (200000e4 <CCU40_3_Veneer+0x44>)
    MOV PC,R0
20000056:	4687      	mov	pc, r0

20000058 <SCU_6_Veneer>:
/* ======================================================================== */
    .globl SCU_6_Veneer 
SCU_6_Veneer:
    LDR R0, =ERU0_3_IRQHandler
20000058:	4823      	ldr	r0, [pc, #140]	; (200000e8 <CCU40_3_Veneer+0x48>)
    MOV PC,R0
2000005a:	4687      	mov	pc, r0
	...

20000064 <USIC0_0_Veneer>:
    .long 0
    .long 0
/* ======================================================================== */
    .globl USIC0_0_Veneer
USIC0_0_Veneer:
    LDR R0, =USIC0_0_IRQHandler
20000064:	4821      	ldr	r0, [pc, #132]	; (200000ec <CCU40_3_Veneer+0x4c>)
    MOV PC,R0
20000066:	4687      	mov	pc, r0

20000068 <USIC0_1_Veneer>:
/* ======================================================================== */
    .globl USIC0_1_Veneer
USIC0_1_Veneer:
    LDR R0, =USIC0_1_IRQHandler
20000068:	4821      	ldr	r0, [pc, #132]	; (200000f0 <CCU40_3_Veneer+0x50>)
    MOV PC,R0
2000006a:	4687      	mov	pc, r0

2000006c <USIC0_2_Veneer>:
/* ======================================================================== */
    .globl USIC0_2_Veneer
USIC0_2_Veneer:
    LDR R0, =USIC0_2_IRQHandler
2000006c:	4821      	ldr	r0, [pc, #132]	; (200000f4 <CCU40_3_Veneer+0x54>)
    MOV PC,R0
2000006e:	4687      	mov	pc, r0

20000070 <USIC0_3_Veneer>:
/* ======================================================================== */
    .globl USIC0_3_Veneer
USIC0_3_Veneer:
    LDR R0, =USIC0_3_IRQHandler
20000070:	4821      	ldr	r0, [pc, #132]	; (200000f8 <CCU40_3_Veneer+0x58>)
    MOV PC,R0
20000072:	4687      	mov	pc, r0

20000074 <USIC0_4_Veneer>:
/* ======================================================================== */
    .globl USIC0_4_Veneer
USIC0_4_Veneer:
    LDR R0, =USIC0_4_IRQHandler
20000074:	4821      	ldr	r0, [pc, #132]	; (200000fc <CCU40_3_Veneer+0x5c>)
    MOV PC,R0
20000076:	4687      	mov	pc, r0

20000078 <USIC0_5_Veneer>:
/* ======================================================================== */
    .globl USIC0_5_Veneer
USIC0_5_Veneer:
    LDR R0, =USIC0_5_IRQHandler
20000078:	4821      	ldr	r0, [pc, #132]	; (20000100 <CCU40_3_Veneer+0x60>)
    MOV PC,R0
2000007a:	4687      	mov	pc, r0

2000007c <VADC0_C0_0_Veneer>:
/* ======================================================================== */
    .globl VADC0_C0_0_Veneer 
VADC0_C0_0_Veneer:
    LDR R0, =VADC0_C0_0_IRQHandler
2000007c:	4821      	ldr	r0, [pc, #132]	; (20000104 <CCU40_3_Veneer+0x64>)
    MOV PC,R0
2000007e:	4687      	mov	pc, r0

20000080 <VADC0_C0_1_Veneer>:
/* ======================================================================== */
    .globl VADC0_C0_1_Veneer
VADC0_C0_1_Veneer:
    LDR R0, =VADC0_C0_1_IRQHandler
20000080:	4821      	ldr	r0, [pc, #132]	; (20000108 <CCU40_3_Veneer+0x68>)
    MOV PC,R0
20000082:	4687      	mov	pc, r0
	...

20000094 <CCU40_0_Veneer>:
    .long 0
    .long 0
/* ======================================================================== */
    .globl CCU40_0_Veneer
CCU40_0_Veneer:
    LDR R0, =CCU40_0_IRQHandler
20000094:	481d      	ldr	r0, [pc, #116]	; (2000010c <CCU40_3_Veneer+0x6c>)
    MOV PC,R0
20000096:	4687      	mov	pc, r0

20000098 <CCU40_1_Veneer>:
/* ======================================================================== */
    .globl CCU40_1_Veneer
CCU40_1_Veneer:
    LDR R0, =CCU40_1_IRQHandler
20000098:	481d      	ldr	r0, [pc, #116]	; (20000110 <CCU40_3_Veneer+0x70>)
    MOV PC,R0
2000009a:	4687      	mov	pc, r0

2000009c <CCU40_2_Veneer>:
/* ======================================================================== */
    .globl CCU40_2_Veneer
CCU40_2_Veneer:
    LDR R0, =CCU40_2_IRQHandler
2000009c:	481d      	ldr	r0, [pc, #116]	; (20000114 <CCU40_3_Veneer+0x74>)
    MOV PC,R0
2000009e:	4687      	mov	pc, r0

200000a0 <CCU40_3_Veneer>:
/* ======================================================================== */
    .globl CCU40_3_Veneer
CCU40_3_Veneer:
    LDR R0, =CCU40_3_IRQHandler
200000a0:	481d      	ldr	r0, [pc, #116]	; (20000118 <CCU40_3_Veneer+0x78>)
    MOV PC,R0
200000a2:	4687      	mov	pc, r0
	...
    
    .align 1
    
    .globl HardFault_Veneer
HardFault_Veneer:
    LDR R0, =HardFault_Handler
200000c0:	10001091 	.word	0x10001091
    .long 0
    
/* ======================================================================== */
    .globl SVC_Veneer
SVC_Veneer:
    LDR R0, =SVC_Handler
200000c4:	10002bf5 	.word	0x10002bf5
    .long 0
    .long 0
/* ======================================================================== */
    .globl PendSV_Veneer
PendSV_Veneer:
    LDR R0, =PendSV_Handler
200000c8:	10002d11 	.word	0x10002d11
    MOV PC,R0
/* ======================================================================== */
    .globl SysTick_Veneer 
SysTick_Veneer:
    LDR R0, =SysTick_Handler
200000cc:	10002d61 	.word	0x10002d61
    MOV PC,R0
/* ======================================================================== */
    .globl SCU_0_Veneer 
SCU_0_Veneer:
    LDR R0, =SCU_0_IRQHandler
200000d0:	10001091 	.word	0x10001091
    MOV PC,R0
/* ======================================================================== */
    .globl SCU_1_Veneer 
SCU_1_Veneer:
    LDR R0, =SCU_1_IRQHandler
200000d4:	10001091 	.word	0x10001091
    MOV PC,R0
/* ======================================================================== */
    .globl SCU_2_Veneer
SCU_2_Veneer:
    LDR R0, =SCU_2_IRQHandler
200000d8:	10001091 	.word	0x10001091
    MOV PC,R0
/* ======================================================================== */
    .globl SCU_3_Veneer 
SCU_3_Veneer:
    LDR R0, =ERU0_0_IRQHandler
200000dc:	10001091 	.word	0x10001091
    MOV PC,R0
/* ======================================================================== */
    .globl SCU_4_Veneer 
SCU_4_Veneer:
    LDR R0, =ERU0_1_IRQHandler
200000e0:	10001091 	.word	0x10001091
    MOV PC,R0
/* ======================================================================== */
    .globl SCU_5_Veneer 
SCU_5_Veneer:
    LDR R0, =ERU0_2_IRQHandler
200000e4:	10001091 	.word	0x10001091
    MOV PC,R0
/* ======================================================================== */
    .globl SCU_6_Veneer 
SCU_6_Veneer:
    LDR R0, =ERU0_3_IRQHandler
200000e8:	10001091 	.word	0x10001091
    .long 0
    .long 0
/* ======================================================================== */
    .globl USIC0_0_Veneer
USIC0_0_Veneer:
    LDR R0, =USIC0_0_IRQHandler
200000ec:	100024f5 	.word	0x100024f5
    MOV PC,R0
/* ======================================================================== */
    .globl USIC0_1_Veneer
USIC0_1_Veneer:
    LDR R0, =USIC0_1_IRQHandler
200000f0:	100024e1 	.word	0x100024e1
    MOV PC,R0
/* ======================================================================== */
    .globl USIC0_2_Veneer
USIC0_2_Veneer:
    LDR R0, =USIC0_2_IRQHandler
200000f4:	10001091 	.word	0x10001091
    MOV PC,R0
/* ======================================================================== */
    .globl USIC0_3_Veneer
USIC0_3_Veneer:
    LDR R0, =USIC0_3_IRQHandler
200000f8:	10001091 	.word	0x10001091
    MOV PC,R0
/* ======================================================================== */
    .globl USIC0_4_Veneer
USIC0_4_Veneer:
    LDR R0, =USIC0_4_IRQHandler
200000fc:	10001091 	.word	0x10001091
    MOV PC,R0
/* ======================================================================== */
    .globl USIC0_5_Veneer
USIC0_5_Veneer:
    LDR R0, =USIC0_5_IRQHandler
20000100:	10001091 	.word	0x10001091
    MOV PC,R0
/* ======================================================================== */
    .globl VADC0_C0_0_Veneer 
VADC0_C0_0_Veneer:
    LDR R0, =VADC0_C0_0_IRQHandler
20000104:	10001091 	.word	0x10001091
    MOV PC,R0
/* ======================================================================== */
    .globl VADC0_C0_1_Veneer
VADC0_C0_1_Veneer:
    LDR R0, =VADC0_C0_1_IRQHandler
20000108:	10001091 	.word	0x10001091
    .long 0
    .long 0
/* ======================================================================== */
    .globl CCU40_0_Veneer
CCU40_0_Veneer:
    LDR R0, =CCU40_0_IRQHandler
2000010c:	10001091 	.word	0x10001091
    MOV PC,R0
/* ======================================================================== */
    .globl CCU40_1_Veneer
CCU40_1_Veneer:
    LDR R0, =CCU40_1_IRQHandler
20000110:	10001091 	.word	0x10001091
    MOV PC,R0
/* ======================================================================== */
    .globl CCU40_2_Veneer
CCU40_2_Veneer:
    LDR R0, =CCU40_2_IRQHandler
20000114:	1000563d 	.word	0x1000563d
    MOV PC,R0
/* ======================================================================== */
    .globl CCU40_3_Veneer
CCU40_3_Veneer:
    LDR R0, =CCU40_3_IRQHandler
20000118:	10005661 	.word	0x10005661
