
Intelligent-parking-system.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000095ac  10001000  10001000  00001000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .eh_frame     00000000  1000a5ac  1000a5ac  0000a5ac  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .VENEER_Code  00000110  2000000c  1000a5ac  0001000c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 Stack         00000404  2000011c  00000000  0000011c  2**0
                  ALLOC
  4 .data         00000180  20000520  1000a6bc  00010520  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          00000290  200006a0  00000584  000106a0  2**2
                  ALLOC
  6 .no_init      00000004  20003ffc  00003ee0  0000011c  2**2
                  ALLOC
  7 .debug_aranges 00000f40  00000000  00000000  000106a0  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   00013dc8  00000000  00000000  000115e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 0000329b  00000000  00000000  000253a8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   00009cbf  00000000  00000000  00028643  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  00004448  00000000  00000000  00032304  2**2
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    00007d15  00000000  00000000  0003674c  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    000052c7  00000000  00000000  0003e461  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000d20  00000000  00000000  00043728  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .build_attributes 00000f78  00000000  00000000  00044448  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

10001000 <__Vectors>:
10001000:	20 05 00 20 19 10 00 10 00 00 00 00 91 10 00 10      .. ............
10001010:	00 04 01 00 00 00 00 80                             ........

10001018 <Reset_Handler>:
    .thumb_func 
    .globl  Reset_Handler
    .type   Reset_Handler, %function
Reset_Handler: 
/* Initialize interrupt veneer */
	ldr	r1, =eROData
10001018:	4910      	ldr	r1, [pc, #64]	; (1000105c <__copy_data+0xe>)
	ldr	r2, =VeneerStart
1000101a:	4a11      	ldr	r2, [pc, #68]	; (10001060 <__copy_data+0x12>)
	ldr	r3, =VeneerEnd
1000101c:	4b11      	ldr	r3, [pc, #68]	; (10001064 <__copy_data+0x16>)
	bl  __copy_data
1000101e:	f000 f816 	bl	1000104e <__copy_data>

    ldr  r0, =SystemInit
10001022:	4811      	ldr	r0, [pc, #68]	; (10001068 <__copy_data+0x1a>)
    blx  r0
10001024:	4780      	blx	r0
	
/* Initialize data */
	ldr	r1, =DataLoadAddr
10001026:	4911      	ldr	r1, [pc, #68]	; (1000106c <__copy_data+0x1e>)
	ldr	r2, =__data_start
10001028:	4a11      	ldr	r2, [pc, #68]	; (10001070 <__copy_data+0x22>)
	ldr	r3, =__data_end
1000102a:	4b12      	ldr	r3, [pc, #72]	; (10001074 <__copy_data+0x26>)
	bl  __copy_data
1000102c:	f000 f80f 	bl	1000104e <__copy_data>

/* RAM code */
	ldr	r1, =__ram_code_load
10001030:	4911      	ldr	r1, [pc, #68]	; (10001078 <__copy_data+0x2a>)
	ldr	r2, =__ram_code_start
10001032:	4a12      	ldr	r2, [pc, #72]	; (1000107c <__copy_data+0x2e>)
	ldr	r3, =__ram_code_end
10001034:	4b12      	ldr	r3, [pc, #72]	; (10001080 <__copy_data+0x32>)
	bl  __copy_data
10001036:	f000 f80a 	bl	1000104e <__copy_data>
 *    __bss_end__: end of the BSS section.
 *
 *  Both addresses must be aligned to 4 bytes boundary.
 */
#ifndef __SKIP_BSS_CLEAR
	ldr	r1, =__bss_start
1000103a:	4912      	ldr	r1, [pc, #72]	; (10001084 <__copy_data+0x36>)
	ldr	r2, =__bss_end
1000103c:	4a12      	ldr	r2, [pc, #72]	; (10001088 <__copy_data+0x3a>)

	movs	r0, 0
1000103e:	2000      	movs	r0, #0

	subs	r2, r1
10001040:	1a52      	subs	r2, r2, r1
	ble	.L_loop3_done
10001042:	dd02      	ble.n	1000104a <Reset_Handler+0x32>

.L_loop3:
	subs	r2, #4
10001044:	3a04      	subs	r2, #4
	str	r0, [r1, r2]
10001046:	5088      	str	r0, [r1, r2]
	bgt	.L_loop3
10001048:	dcfc      	bgt.n	10001044 <Reset_Handler+0x2c>
#ifndef __SKIP_LIBC_INIT_ARRAY
    ldr  r0, =__libc_init_array
    blx  r0
#endif

    ldr  r0, =main
1000104a:	4810      	ldr	r0, [pc, #64]	; (1000108c <__copy_data+0x3e>)
    blx  r0
1000104c:	4780      	blx	r0

1000104e <__copy_data>:
 *    r3: end of the section to copy to
 *
 *  All addresses must be aligned to 4 bytes boundary.
 *  Uses r0
 */
	subs	r3, r2
1000104e:	1a9b      	subs	r3, r3, r2
	ble	.L_loop_done
10001050:	dd03      	ble.n	1000105a <__copy_data+0xc>

.L_loop:
	subs	r3, #4
10001052:	3b04      	subs	r3, #4
	ldr	r0, [r1,r3]
10001054:	58c8      	ldr	r0, [r1, r3]
	str	r0, [r2,r3]
10001056:	50d0      	str	r0, [r2, r3]
	bgt	.L_loop
10001058:	dcfb      	bgt.n	10001052 <__copy_data+0x4>

.L_loop_done:
	bx  lr
1000105a:	4770      	bx	lr
    .thumb_func 
    .globl  Reset_Handler
    .type   Reset_Handler, %function
Reset_Handler: 
/* Initialize interrupt veneer */
	ldr	r1, =eROData
1000105c:	1000a5ac 	.word	0x1000a5ac
	ldr	r2, =VeneerStart
10001060:	2000000c 	.word	0x2000000c
	ldr	r3, =VeneerEnd
10001064:	2000011c 	.word	0x2000011c
	bl  __copy_data

    ldr  r0, =SystemInit
10001068:	10001095 	.word	0x10001095
    blx  r0
	
/* Initialize data */
	ldr	r1, =DataLoadAddr
1000106c:	1000a6bc 	.word	0x1000a6bc
	ldr	r2, =__data_start
10001070:	20000520 	.word	0x20000520
	ldr	r3, =__data_end
10001074:	200006a0 	.word	0x200006a0
	bl  __copy_data

/* RAM code */
	ldr	r1, =__ram_code_load
10001078:	1000a83c 	.word	0x1000a83c
	ldr	r2, =__ram_code_start
1000107c:	200006a0 	.word	0x200006a0
	ldr	r3, =__ram_code_end
10001080:	200006a0 	.word	0x200006a0
 *    __bss_end__: end of the BSS section.
 *
 *  Both addresses must be aligned to 4 bytes boundary.
 */
#ifndef __SKIP_BSS_CLEAR
	ldr	r1, =__bss_start
10001084:	200006a0 	.word	0x200006a0
	ldr	r2, =__bss_end
10001088:	2000092c 	.word	0x2000092c
#ifndef __SKIP_LIBC_INIT_ARRAY
    ldr  r0, =__libc_init_array
    blx  r0
#endif

    ldr  r0, =main
1000108c:	10004e25 	.word	0x10004e25

10001090 <CCU40_0_IRQHandler>:
    
    .thumb_func
    .weak Default_handler
    .type Default_handler, %function
Default_handler:
    b  .
10001090:	e7fe      	b.n	10001090 <CCU40_0_IRQHandler>
	...

10001094 <SystemInit>:
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

__WEAK void SystemInit(void)
{    
10001094:	b580      	push	{r7, lr}
10001096:	af00      	add	r7, sp, #0
  SystemCoreSetup();
10001098:	f003 fd62 	bl	10004b60 <SystemCoreSetup>
  SystemCoreClockSetup();
1000109c:	f003 fda6 	bl	10004bec <SystemCoreClockSetup>
}
100010a0:	46bd      	mov	sp, r7
100010a2:	bd80      	pop	{r7, pc}

100010a4 <SystemCoreClockUpdate>:
  
  SystemCoreClockUpdate();
}

__WEAK void SystemCoreClockUpdate(void)
{
100010a4:	b580      	push	{r7, lr}
100010a6:	af00      	add	r7, sp, #0
  static uint32_t IDIV, FDIV;

  IDIV = ((SCU_CLK->CLKCR) & SCU_CLK_CLKCR_IDIV_Msk) >> SCU_CLK_CLKCR_IDIV_Pos;
100010a8:	4b12      	ldr	r3, [pc, #72]	; (100010f4 <SystemCoreClockUpdate+0x50>)
100010aa:	681a      	ldr	r2, [r3, #0]
100010ac:	23ff      	movs	r3, #255	; 0xff
100010ae:	021b      	lsls	r3, r3, #8
100010b0:	4013      	ands	r3, r2
100010b2:	0a1a      	lsrs	r2, r3, #8
100010b4:	4b10      	ldr	r3, [pc, #64]	; (100010f8 <SystemCoreClockUpdate+0x54>)
100010b6:	601a      	str	r2, [r3, #0]
  FDIV = ((SCU_CLK->CLKCR) & SCU_CLK_CLKCR_FDIV_Msk) >> SCU_CLK_CLKCR_FDIV_Pos;
100010b8:	4b0e      	ldr	r3, [pc, #56]	; (100010f4 <SystemCoreClockUpdate+0x50>)
100010ba:	681b      	ldr	r3, [r3, #0]
100010bc:	22ff      	movs	r2, #255	; 0xff
100010be:	401a      	ands	r2, r3
100010c0:	4b0e      	ldr	r3, [pc, #56]	; (100010fc <SystemCoreClockUpdate+0x58>)
100010c2:	601a      	str	r2, [r3, #0]
  
  if (IDIV != 0)
100010c4:	4b0c      	ldr	r3, [pc, #48]	; (100010f8 <SystemCoreClockUpdate+0x54>)
100010c6:	681b      	ldr	r3, [r3, #0]
100010c8:	2b00      	cmp	r3, #0
100010ca:	d00e      	beq.n	100010ea <SystemCoreClockUpdate+0x46>
  {
    /* Fractional divider is enabled and used */
    SystemCoreClock = ((DCO1_FREQUENCY << 6U) / ((IDIV << 8) + FDIV)) << 1U;
100010cc:	4b0a      	ldr	r3, [pc, #40]	; (100010f8 <SystemCoreClockUpdate+0x54>)
100010ce:	681b      	ldr	r3, [r3, #0]
100010d0:	021a      	lsls	r2, r3, #8
100010d2:	4b0a      	ldr	r3, [pc, #40]	; (100010fc <SystemCoreClockUpdate+0x58>)
100010d4:	681b      	ldr	r3, [r3, #0]
100010d6:	18d3      	adds	r3, r2, r3
100010d8:	4809      	ldr	r0, [pc, #36]	; (10001100 <SystemCoreClockUpdate+0x5c>)
100010da:	1c19      	adds	r1, r3, #0
100010dc:	f004 f89c 	bl	10005218 <__aeabi_uidiv>
100010e0:	1c03      	adds	r3, r0, #0
100010e2:	005a      	lsls	r2, r3, #1
100010e4:	4b07      	ldr	r3, [pc, #28]	; (10001104 <SystemCoreClockUpdate+0x60>)
100010e6:	601a      	str	r2, [r3, #0]
100010e8:	e002      	b.n	100010f0 <SystemCoreClockUpdate+0x4c>
  }
  else
  {
    /* Fractional divider bypassed. Simply divide DCO_DCLK by 2 */
    SystemCoreClock = DCO1_FREQUENCY >> 1U;
100010ea:	4b06      	ldr	r3, [pc, #24]	; (10001104 <SystemCoreClockUpdate+0x60>)
100010ec:	4a06      	ldr	r2, [pc, #24]	; (10001108 <SystemCoreClockUpdate+0x64>)
100010ee:	601a      	str	r2, [r3, #0]
  }
}
100010f0:	46bd      	mov	sp, r7
100010f2:	bd80      	pop	{r7, pc}
100010f4:	40010300 	.word	0x40010300
100010f8:	200006a0 	.word	0x200006a0
100010fc:	200006a4 	.word	0x200006a4
10001100:	f4240000 	.word	0xf4240000
10001104:	20003ffc 	.word	0x20003ffc
10001108:	01e84800 	.word	0x01e84800

1000110c <XMC_GPIO_Init>:
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

void XMC_GPIO_Init(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_CONFIG_t *const config)
{
1000110c:	b590      	push	{r4, r7, lr}
1000110e:	b085      	sub	sp, #20
10001110:	af00      	add	r7, sp, #0
10001112:	60f8      	str	r0, [r7, #12]
10001114:	607a      	str	r2, [r7, #4]
10001116:	230b      	movs	r3, #11
10001118:	18fb      	adds	r3, r7, r3
1000111a:	1c0a      	adds	r2, r1, #0
1000111c:	701a      	strb	r2, [r3, #0]
  XMC_ASSERT("XMC_GPIO_Init: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_Init: Invalid mode", XMC_GPIO_IsModeValid(config->mode));
  XMC_ASSERT("XMC_GPIO_Init: Invalid input hysteresis", XMC_GPIO_CHECK_INPUT_HYSTERESIS(config->input_hysteresis));

  /* Switch to input */
  port->IOCR[pin >> 2U] &= ~(uint32_t)((uint32_t)PORT_IOCR_PC_Msk << (PORT_IOCR_PC_Size * (pin & 0x3U)));
1000111e:	230b      	movs	r3, #11
10001120:	18fb      	adds	r3, r7, r3
10001122:	781b      	ldrb	r3, [r3, #0]
10001124:	089b      	lsrs	r3, r3, #2
10001126:	b2db      	uxtb	r3, r3
10001128:	1c18      	adds	r0, r3, #0
1000112a:	230b      	movs	r3, #11
1000112c:	18fb      	adds	r3, r7, r3
1000112e:	781b      	ldrb	r3, [r3, #0]
10001130:	089b      	lsrs	r3, r3, #2
10001132:	b2db      	uxtb	r3, r3
10001134:	1c1a      	adds	r2, r3, #0
10001136:	68fb      	ldr	r3, [r7, #12]
10001138:	3204      	adds	r2, #4
1000113a:	0092      	lsls	r2, r2, #2
1000113c:	58d3      	ldr	r3, [r2, r3]
1000113e:	220b      	movs	r2, #11
10001140:	18ba      	adds	r2, r7, r2
10001142:	7812      	ldrb	r2, [r2, #0]
10001144:	2103      	movs	r1, #3
10001146:	400a      	ands	r2, r1
10001148:	00d2      	lsls	r2, r2, #3
1000114a:	1c11      	adds	r1, r2, #0
1000114c:	22f8      	movs	r2, #248	; 0xf8
1000114e:	408a      	lsls	r2, r1
10001150:	43d2      	mvns	r2, r2
10001152:	401a      	ands	r2, r3
10001154:	1c11      	adds	r1, r2, #0
10001156:	68fb      	ldr	r3, [r7, #12]
10001158:	1d02      	adds	r2, r0, #4
1000115a:	0092      	lsls	r2, r2, #2
1000115c:	50d1      	str	r1, [r2, r3]

  /* HW port control is disabled */
  port->HWSEL &= ~(uint32_t)((uint32_t)PORT_HWSEL_Msk << ((uint32_t)pin << 1U));
1000115e:	68fb      	ldr	r3, [r7, #12]
10001160:	6f5b      	ldr	r3, [r3, #116]	; 0x74
10001162:	220b      	movs	r2, #11
10001164:	18ba      	adds	r2, r7, r2
10001166:	7812      	ldrb	r2, [r2, #0]
10001168:	0052      	lsls	r2, r2, #1
1000116a:	1c11      	adds	r1, r2, #0
1000116c:	2203      	movs	r2, #3
1000116e:	408a      	lsls	r2, r1
10001170:	43d2      	mvns	r2, r2
10001172:	401a      	ands	r2, r3
10001174:	68fb      	ldr	r3, [r7, #12]
10001176:	675a      	str	r2, [r3, #116]	; 0x74

  /* Set input hysteresis */
  port->PHCR[(uint32_t)pin >> 3U] &= ~(uint32_t)((uint32_t)PORT_PHCR_Msk << ((uint32_t)PORT_PHCR_Size * ((uint32_t)pin & 0x7U)));
10001178:	230b      	movs	r3, #11
1000117a:	18fb      	adds	r3, r7, r3
1000117c:	781b      	ldrb	r3, [r3, #0]
1000117e:	08db      	lsrs	r3, r3, #3
10001180:	b2db      	uxtb	r3, r3
10001182:	1c18      	adds	r0, r3, #0
10001184:	230b      	movs	r3, #11
10001186:	18fb      	adds	r3, r7, r3
10001188:	781b      	ldrb	r3, [r3, #0]
1000118a:	08db      	lsrs	r3, r3, #3
1000118c:	b2db      	uxtb	r3, r3
1000118e:	1c1a      	adds	r2, r3, #0
10001190:	68fb      	ldr	r3, [r7, #12]
10001192:	3210      	adds	r2, #16
10001194:	0092      	lsls	r2, r2, #2
10001196:	58d3      	ldr	r3, [r2, r3]
10001198:	220b      	movs	r2, #11
1000119a:	18ba      	adds	r2, r7, r2
1000119c:	7812      	ldrb	r2, [r2, #0]
1000119e:	2107      	movs	r1, #7
100011a0:	400a      	ands	r2, r1
100011a2:	0092      	lsls	r2, r2, #2
100011a4:	1c11      	adds	r1, r2, #0
100011a6:	2204      	movs	r2, #4
100011a8:	408a      	lsls	r2, r1
100011aa:	43d2      	mvns	r2, r2
100011ac:	401a      	ands	r2, r3
100011ae:	1c11      	adds	r1, r2, #0
100011b0:	68fb      	ldr	r3, [r7, #12]
100011b2:	1c02      	adds	r2, r0, #0
100011b4:	3210      	adds	r2, #16
100011b6:	0092      	lsls	r2, r2, #2
100011b8:	50d1      	str	r1, [r2, r3]
  port->PHCR[(uint32_t)pin >> 3U] |= (uint32_t)config->input_hysteresis << ((uint32_t)PORT_PHCR_Size * ((uint32_t)pin & 0x7U));
100011ba:	230b      	movs	r3, #11
100011bc:	18fb      	adds	r3, r7, r3
100011be:	781b      	ldrb	r3, [r3, #0]
100011c0:	08db      	lsrs	r3, r3, #3
100011c2:	b2db      	uxtb	r3, r3
100011c4:	1c18      	adds	r0, r3, #0
100011c6:	230b      	movs	r3, #11
100011c8:	18fb      	adds	r3, r7, r3
100011ca:	781b      	ldrb	r3, [r3, #0]
100011cc:	08db      	lsrs	r3, r3, #3
100011ce:	b2db      	uxtb	r3, r3
100011d0:	1c1a      	adds	r2, r3, #0
100011d2:	68fb      	ldr	r3, [r7, #12]
100011d4:	3210      	adds	r2, #16
100011d6:	0092      	lsls	r2, r2, #2
100011d8:	58d2      	ldr	r2, [r2, r3]
100011da:	687b      	ldr	r3, [r7, #4]
100011dc:	785b      	ldrb	r3, [r3, #1]
100011de:	1c1c      	adds	r4, r3, #0
100011e0:	230b      	movs	r3, #11
100011e2:	18fb      	adds	r3, r7, r3
100011e4:	781b      	ldrb	r3, [r3, #0]
100011e6:	2107      	movs	r1, #7
100011e8:	400b      	ands	r3, r1
100011ea:	009b      	lsls	r3, r3, #2
100011ec:	409c      	lsls	r4, r3
100011ee:	1c23      	adds	r3, r4, #0
100011f0:	431a      	orrs	r2, r3
100011f2:	1c11      	adds	r1, r2, #0
100011f4:	68fb      	ldr	r3, [r7, #12]
100011f6:	1c02      	adds	r2, r0, #0
100011f8:	3210      	adds	r2, #16
100011fa:	0092      	lsls	r2, r2, #2
100011fc:	50d1      	str	r1, [r2, r3]

  /* Enable digital input */
  if (XMC_GPIO_CHECK_ANALOG_PORT(port))
100011fe:	68fb      	ldr	r3, [r7, #12]
10001200:	4a20      	ldr	r2, [pc, #128]	; (10001284 <XMC_GPIO_Init+0x178>)
10001202:	4293      	cmp	r3, r2
10001204:	d10b      	bne.n	1000121e <XMC_GPIO_Init+0x112>
  {
    port->PDISC &= ~(uint32_t)((uint32_t)0x1U << pin);
10001206:	68fb      	ldr	r3, [r7, #12]
10001208:	6e1b      	ldr	r3, [r3, #96]	; 0x60
1000120a:	220b      	movs	r2, #11
1000120c:	18ba      	adds	r2, r7, r2
1000120e:	7812      	ldrb	r2, [r2, #0]
10001210:	2101      	movs	r1, #1
10001212:	4091      	lsls	r1, r2
10001214:	1c0a      	adds	r2, r1, #0
10001216:	43d2      	mvns	r2, r2
10001218:	401a      	ands	r2, r3
1000121a:	68fb      	ldr	r3, [r7, #12]
1000121c:	661a      	str	r2, [r3, #96]	; 0x60
  }

  if ((config->mode & XMC_GPIO_MODE_OE) != 0)
1000121e:	687b      	ldr	r3, [r7, #4]
10001220:	781b      	ldrb	r3, [r3, #0]
10001222:	b2db      	uxtb	r3, r3
10001224:	b25b      	sxtb	r3, r3
10001226:	2b00      	cmp	r3, #0
10001228:	da07      	bge.n	1000123a <XMC_GPIO_Init+0x12e>
  {
    /* If output is enabled */

    /* Set output level */
    port->OMR = (uint32_t)config->output_level << pin;
1000122a:	687b      	ldr	r3, [r7, #4]
1000122c:	685a      	ldr	r2, [r3, #4]
1000122e:	230b      	movs	r3, #11
10001230:	18fb      	adds	r3, r7, r3
10001232:	781b      	ldrb	r3, [r3, #0]
10001234:	409a      	lsls	r2, r3
10001236:	68fb      	ldr	r3, [r7, #12]
10001238:	605a      	str	r2, [r3, #4]
  }

  /* Set mode */
  port->IOCR[pin >> 2U] |= (uint32_t)config->mode << (PORT_IOCR_PC_Size * (pin & 0x3U));
1000123a:	230b      	movs	r3, #11
1000123c:	18fb      	adds	r3, r7, r3
1000123e:	781b      	ldrb	r3, [r3, #0]
10001240:	089b      	lsrs	r3, r3, #2
10001242:	b2db      	uxtb	r3, r3
10001244:	1c18      	adds	r0, r3, #0
10001246:	230b      	movs	r3, #11
10001248:	18fb      	adds	r3, r7, r3
1000124a:	781b      	ldrb	r3, [r3, #0]
1000124c:	089b      	lsrs	r3, r3, #2
1000124e:	b2db      	uxtb	r3, r3
10001250:	1c1a      	adds	r2, r3, #0
10001252:	68fb      	ldr	r3, [r7, #12]
10001254:	3204      	adds	r2, #4
10001256:	0092      	lsls	r2, r2, #2
10001258:	58d2      	ldr	r2, [r2, r3]
1000125a:	687b      	ldr	r3, [r7, #4]
1000125c:	781b      	ldrb	r3, [r3, #0]
1000125e:	1c1c      	adds	r4, r3, #0
10001260:	230b      	movs	r3, #11
10001262:	18fb      	adds	r3, r7, r3
10001264:	781b      	ldrb	r3, [r3, #0]
10001266:	2103      	movs	r1, #3
10001268:	400b      	ands	r3, r1
1000126a:	00db      	lsls	r3, r3, #3
1000126c:	409c      	lsls	r4, r3
1000126e:	1c23      	adds	r3, r4, #0
10001270:	431a      	orrs	r2, r3
10001272:	1c11      	adds	r1, r2, #0
10001274:	68fb      	ldr	r3, [r7, #12]
10001276:	1d02      	adds	r2, r0, #4
10001278:	0092      	lsls	r2, r2, #2
1000127a:	50d1      	str	r1, [r2, r3]
}
1000127c:	46bd      	mov	sp, r7
1000127e:	b005      	add	sp, #20
10001280:	bd90      	pop	{r4, r7, pc}
10001282:	46c0      	nop			; (mov r8, r8)
10001284:	40040200 	.word	0x40040200

10001288 <XMC_SCU_LockProtectedBits>:
#endif
}

/* API to lock protected bitfields from being modified */
void XMC_SCU_LockProtectedBits(void)
{
10001288:	b580      	push	{r7, lr}
1000128a:	af00      	add	r7, sp, #0
  SCU_GENERAL->PASSWD = SCU_GCU_PASSWD_PROT_ENABLE;
1000128c:	4b02      	ldr	r3, [pc, #8]	; (10001298 <XMC_SCU_LockProtectedBits+0x10>)
1000128e:	22c3      	movs	r2, #195	; 0xc3
10001290:	625a      	str	r2, [r3, #36]	; 0x24
}
10001292:	46bd      	mov	sp, r7
10001294:	bd80      	pop	{r7, pc}
10001296:	46c0      	nop			; (mov r8, r8)
10001298:	40010000 	.word	0x40010000

1000129c <XMC_SCU_UnlockProtectedBits>:

/* API to make protected bitfields available for modification */
void XMC_SCU_UnlockProtectedBits(void)
{
1000129c:	b580      	push	{r7, lr}
1000129e:	af00      	add	r7, sp, #0
  SCU_GENERAL->PASSWD = SCU_GCU_PASSWD_PROT_DISABLE;
100012a0:	4b05      	ldr	r3, [pc, #20]	; (100012b8 <XMC_SCU_UnlockProtectedBits+0x1c>)
100012a2:	22c0      	movs	r2, #192	; 0xc0
100012a4:	625a      	str	r2, [r3, #36]	; 0x24

  while (((SCU_GENERAL->PASSWD) & SCU_GENERAL_PASSWD_PROTS_Msk))
100012a6:	46c0      	nop			; (mov r8, r8)
100012a8:	4b03      	ldr	r3, [pc, #12]	; (100012b8 <XMC_SCU_UnlockProtectedBits+0x1c>)
100012aa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
100012ac:	2204      	movs	r2, #4
100012ae:	4013      	ands	r3, r2
100012b0:	d1fa      	bne.n	100012a8 <XMC_SCU_UnlockProtectedBits+0xc>
  {
    /* Loop until the lock is removed */
  }
}
100012b2:	46bd      	mov	sp, r7
100012b4:	bd80      	pop	{r7, pc}
100012b6:	46c0      	nop			; (mov r8, r8)
100012b8:	40010000 	.word	0x40010000

100012bc <XMC_SCU_CLOCK_Init>:
}


/* API which initializes the clock tree ofthe device */
void XMC_SCU_CLOCK_Init(const XMC_SCU_CLOCK_CONFIG_t *const config)
{
100012bc:	b580      	push	{r7, lr}
100012be:	b082      	sub	sp, #8
100012c0:	af00      	add	r7, sp, #0
100012c2:	6078      	str	r0, [r7, #4]
  /* Remove protection */
  XMC_SCU_UnlockProtectedBits();
100012c4:	f7ff ffea 	bl	1000129c <XMC_SCU_UnlockProtectedBits>
  SCU_CLK->CLKCR1 = (SCU_CLK->CLKCR1 & ~SCU_CLK_CLKCR1_DCLKSEL_Msk) |
                    config->dclk_src;

#endif
  /* Update PCLK selection mux. */
  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_PCLKSEL_Msk | SCU_CLK_CLKCR_RTCCLKSEL_Msk)) |
100012c8:	4a0c      	ldr	r2, [pc, #48]	; (100012fc <XMC_SCU_CLOCK_Init+0x40>)
100012ca:	4b0c      	ldr	r3, [pc, #48]	; (100012fc <XMC_SCU_CLOCK_Init+0x40>)
100012cc:	681b      	ldr	r3, [r3, #0]
100012ce:	490c      	ldr	r1, [pc, #48]	; (10001300 <XMC_SCU_CLOCK_Init+0x44>)
100012d0:	4019      	ands	r1, r3
                   config->rtc_src |
100012d2:	687b      	ldr	r3, [r7, #4]
100012d4:	689b      	ldr	r3, [r3, #8]
  SCU_CLK->CLKCR1 = (SCU_CLK->CLKCR1 & ~SCU_CLK_CLKCR1_DCLKSEL_Msk) |
                    config->dclk_src;

#endif
  /* Update PCLK selection mux. */
  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_PCLKSEL_Msk | SCU_CLK_CLKCR_RTCCLKSEL_Msk)) |
100012d6:	4319      	orrs	r1, r3
                   config->rtc_src |
                   config->pclk_src;
100012d8:	687b      	ldr	r3, [r7, #4]
100012da:	685b      	ldr	r3, [r3, #4]
                    config->dclk_src;

#endif
  /* Update PCLK selection mux. */
  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_PCLKSEL_Msk | SCU_CLK_CLKCR_RTCCLKSEL_Msk)) |
                   config->rtc_src |
100012dc:	430b      	orrs	r3, r1
  SCU_CLK->CLKCR1 = (SCU_CLK->CLKCR1 & ~SCU_CLK_CLKCR1_DCLKSEL_Msk) |
                    config->dclk_src;

#endif
  /* Update PCLK selection mux. */
  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_PCLKSEL_Msk | SCU_CLK_CLKCR_RTCCLKSEL_Msk)) |
100012de:	6013      	str	r3, [r2, #0]
                   config->rtc_src |
                   config->pclk_src;

  /* Close the lock opened above. */
  XMC_SCU_LockProtectedBits();
100012e0:	f7ff ffd2 	bl	10001288 <XMC_SCU_LockProtectedBits>

  /* Update the dividers now */
  XMC_SCU_CLOCK_ScaleMCLKFrequency(config->idiv, config->fdiv);
100012e4:	687b      	ldr	r3, [r7, #4]
100012e6:	785b      	ldrb	r3, [r3, #1]
100012e8:	1c1a      	adds	r2, r3, #0
100012ea:	687b      	ldr	r3, [r7, #4]
100012ec:	781b      	ldrb	r3, [r3, #0]
100012ee:	1c10      	adds	r0, r2, #0
100012f0:	1c19      	adds	r1, r3, #0
100012f2:	f000 f839 	bl	10001368 <XMC_SCU_CLOCK_ScaleMCLKFrequency>

}
100012f6:	46bd      	mov	sp, r7
100012f8:	b002      	add	sp, #8
100012fa:	bd80      	pop	{r7, pc}
100012fc:	40010300 	.word	0x40010300
10001300:	fff0ffff 	.word	0xfff0ffff

10001304 <XMC_SCU_CLOCK_UngatePeripheralClock>:
  XMC_SCU_LockProtectedBits();
}

/* API which ungates a clock note at its source */
void XMC_SCU_CLOCK_UngatePeripheralClock(const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)
{
10001304:	b580      	push	{r7, lr}
10001306:	b082      	sub	sp, #8
10001308:	af00      	add	r7, sp, #0
1000130a:	1c02      	adds	r2, r0, #0
1000130c:	1dbb      	adds	r3, r7, #6
1000130e:	801a      	strh	r2, [r3, #0]
  XMC_SCU_UnlockProtectedBits();
10001310:	f7ff ffc4 	bl	1000129c <XMC_SCU_UnlockProtectedBits>
  SCU_CLK->CGATCLR0 |= (uint32_t)peripheral;
10001314:	4b09      	ldr	r3, [pc, #36]	; (1000133c <XMC_SCU_CLOCK_UngatePeripheralClock+0x38>)
10001316:	4a09      	ldr	r2, [pc, #36]	; (1000133c <XMC_SCU_CLOCK_UngatePeripheralClock+0x38>)
10001318:	6911      	ldr	r1, [r2, #16]
1000131a:	1dba      	adds	r2, r7, #6
1000131c:	8812      	ldrh	r2, [r2, #0]
1000131e:	430a      	orrs	r2, r1
10001320:	611a      	str	r2, [r3, #16]
  while ((SCU_CLK->CLKCR) & SCU_CLK_CLKCR_VDDC2LOW_Msk)
10001322:	46c0      	nop			; (mov r8, r8)
10001324:	4b05      	ldr	r3, [pc, #20]	; (1000133c <XMC_SCU_CLOCK_UngatePeripheralClock+0x38>)
10001326:	681a      	ldr	r2, [r3, #0]
10001328:	2380      	movs	r3, #128	; 0x80
1000132a:	05db      	lsls	r3, r3, #23
1000132c:	4013      	ands	r3, r2
1000132e:	d1f9      	bne.n	10001324 <XMC_SCU_CLOCK_UngatePeripheralClock+0x20>
  {
    /* Wait voltage suply stabilization */
  }
  XMC_SCU_LockProtectedBits();
10001330:	f7ff ffaa 	bl	10001288 <XMC_SCU_LockProtectedBits>
}
10001334:	46bd      	mov	sp, r7
10001336:	b002      	add	sp, #8
10001338:	bd80      	pop	{r7, pc}
1000133a:	46c0      	nop			; (mov r8, r8)
1000133c:	40010300 	.word	0x40010300

10001340 <XMC_SCU_CLOCK_IsPeripheralClockGated>:

/* Checks the status of peripheral clock gating */
bool XMC_SCU_CLOCK_IsPeripheralClockGated(const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)
{
10001340:	b580      	push	{r7, lr}
10001342:	b082      	sub	sp, #8
10001344:	af00      	add	r7, sp, #0
10001346:	1c02      	adds	r2, r0, #0
10001348:	1dbb      	adds	r3, r7, #6
1000134a:	801a      	strh	r2, [r3, #0]
  return (bool)((SCU_CLK->CGATSTAT0 & peripheral) != 0);
1000134c:	4b05      	ldr	r3, [pc, #20]	; (10001364 <XMC_SCU_CLOCK_IsPeripheralClockGated+0x24>)
1000134e:	689b      	ldr	r3, [r3, #8]
10001350:	1dba      	adds	r2, r7, #6
10001352:	8812      	ldrh	r2, [r2, #0]
10001354:	4013      	ands	r3, r2
10001356:	1e5a      	subs	r2, r3, #1
10001358:	4193      	sbcs	r3, r2
1000135a:	b2db      	uxtb	r3, r3
}
1000135c:	1c18      	adds	r0, r3, #0
1000135e:	46bd      	mov	sp, r7
10001360:	b002      	add	sp, #8
10001362:	bd80      	pop	{r7, pc}
10001364:	40010300 	.word	0x40010300

10001368 <XMC_SCU_CLOCK_ScaleMCLKFrequency>:
}


/* A utility routine which updates the fractional dividers in steps */
void XMC_SCU_CLOCK_ScaleMCLKFrequency(uint32_t idiv, uint32_t fdiv)
{
10001368:	b580      	push	{r7, lr}
1000136a:	b084      	sub	sp, #16
1000136c:	af00      	add	r7, sp, #0
1000136e:	6078      	str	r0, [r7, #4]
10001370:	6039      	str	r1, [r7, #0]
  /* Find out current and target value of idiv */
  uint32_t curr_idiv;

  XMC_SCU_UnlockProtectedBits();
10001372:	f7ff ff93 	bl	1000129c <XMC_SCU_UnlockProtectedBits>

  /* Take a snapshot of value already programmed into IDIV */
  curr_idiv = (SCU_CLK->CLKCR & SCU_CLK_CLKCR_IDIV_Msk) >> SCU_CLK_CLKCR_IDIV_Pos;
10001376:	4b21      	ldr	r3, [pc, #132]	; (100013fc <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x94>)
10001378:	681a      	ldr	r2, [r3, #0]
1000137a:	23ff      	movs	r3, #255	; 0xff
1000137c:	021b      	lsls	r3, r3, #8
1000137e:	4013      	ands	r3, r2
10001380:	0a1b      	lsrs	r3, r3, #8
10001382:	60fb      	str	r3, [r7, #12]

  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_FDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
                   (uint32_t)((fdiv & 0xffU) << SCU_CLK_CLKCR_FDIV_Pos) |
                   (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);
#else
  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_FDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
10001384:	4b1d      	ldr	r3, [pc, #116]	; (100013fc <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x94>)
10001386:	4a1d      	ldr	r2, [pc, #116]	; (100013fc <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x94>)
10001388:	6812      	ldr	r2, [r2, #0]
1000138a:	491d      	ldr	r1, [pc, #116]	; (10001400 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x98>)
1000138c:	4011      	ands	r1, r2
1000138e:	683a      	ldr	r2, [r7, #0]
10001390:	430a      	orrs	r2, r1
                   (uint32_t)(fdiv << SCU_CLK_CLKCR_FDIV_Pos) |
10001392:	491c      	ldr	r1, [pc, #112]	; (10001404 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x9c>)
10001394:	430a      	orrs	r2, r1

  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_FDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
                   (uint32_t)((fdiv & 0xffU) << SCU_CLK_CLKCR_FDIV_Pos) |
                   (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);
#else
  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_FDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
10001396:	601a      	str	r2, [r3, #0]
                   (uint32_t)(fdiv << SCU_CLK_CLKCR_FDIV_Pos) |
                   (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);
#endif

  while ((SCU_CLK->CLKCR)& SCU_CLK_CLKCR_VDDC2LOW_Msk)
10001398:	46c0      	nop			; (mov r8, r8)
1000139a:	4b18      	ldr	r3, [pc, #96]	; (100013fc <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x94>)
1000139c:	681a      	ldr	r2, [r3, #0]
1000139e:	2380      	movs	r3, #128	; 0x80
100013a0:	05db      	lsls	r3, r3, #23
100013a2:	4013      	ands	r3, r2
100013a4:	d1f9      	bne.n	1000139a <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x32>
  {
    /* Spin until the core supply stabilizes */
  }

  if (curr_idiv <= idiv)
100013a6:	68fa      	ldr	r2, [r7, #12]
100013a8:	687b      	ldr	r3, [r7, #4]
100013aa:	429a      	cmp	r2, r3
100013ac:	d806      	bhi.n	100013bc <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x54>
  {
    /* Requested IDIV is greater than currently programmed IDIV. So downscale the frequency */
    XMC_SCU_CLOCK_lFrequencyDownScaling(curr_idiv, idiv);
100013ae:	68fa      	ldr	r2, [r7, #12]
100013b0:	687b      	ldr	r3, [r7, #4]
100013b2:	1c10      	adds	r0, r2, #0
100013b4:	1c19      	adds	r1, r3, #0
100013b6:	f000 f853 	bl	10001460 <XMC_SCU_CLOCK_lFrequencyDownScaling>
100013ba:	e005      	b.n	100013c8 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x60>
  }
  else
  {
    /* Requested IDIV is lower than currently programmed IDIV. So upscale the frequency */
    XMC_SCU_CLOCK_lFrequencyUpScaling(curr_idiv, idiv);
100013bc:	68fa      	ldr	r2, [r7, #12]
100013be:	687b      	ldr	r3, [r7, #4]
100013c0:	1c10      	adds	r0, r2, #0
100013c2:	1c19      	adds	r1, r3, #0
100013c4:	f000 f822 	bl	1000140c <XMC_SCU_CLOCK_lFrequencyUpScaling>
  }

  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
100013c8:	4b0c      	ldr	r3, [pc, #48]	; (100013fc <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x94>)
100013ca:	4a0c      	ldr	r2, [pc, #48]	; (100013fc <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x94>)
100013cc:	6812      	ldr	r2, [r2, #0]
100013ce:	490e      	ldr	r1, [pc, #56]	; (10001408 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xa0>)
100013d0:	4011      	ands	r1, r2
                   (uint32_t)(idiv << SCU_CLK_CLKCR_IDIV_Pos) | (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);
100013d2:	687a      	ldr	r2, [r7, #4]
100013d4:	0212      	lsls	r2, r2, #8
  {
    /* Requested IDIV is lower than currently programmed IDIV. So upscale the frequency */
    XMC_SCU_CLOCK_lFrequencyUpScaling(curr_idiv, idiv);
  }

  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
100013d6:	430a      	orrs	r2, r1
                   (uint32_t)(idiv << SCU_CLK_CLKCR_IDIV_Pos) | (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);
100013d8:	490a      	ldr	r1, [pc, #40]	; (10001404 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x9c>)
100013da:	430a      	orrs	r2, r1
  {
    /* Requested IDIV is lower than currently programmed IDIV. So upscale the frequency */
    XMC_SCU_CLOCK_lFrequencyUpScaling(curr_idiv, idiv);
  }

  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
100013dc:	601a      	str	r2, [r3, #0]
                   (uint32_t)(idiv << SCU_CLK_CLKCR_IDIV_Pos) | (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);

  while ((SCU_CLK->CLKCR) & SCU_CLK_CLKCR_VDDC2LOW_Msk)
100013de:	46c0      	nop			; (mov r8, r8)
100013e0:	4b06      	ldr	r3, [pc, #24]	; (100013fc <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x94>)
100013e2:	681a      	ldr	r2, [r3, #0]
100013e4:	2380      	movs	r3, #128	; 0x80
100013e6:	05db      	lsls	r3, r3, #23
100013e8:	4013      	ands	r3, r2
100013ea:	d1f9      	bne.n	100013e0 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x78>
  {
    /* Wait voltage suply stabilization */
  }

  XMC_SCU_LockProtectedBits();
100013ec:	f7ff ff4c 	bl	10001288 <XMC_SCU_LockProtectedBits>

  SystemCoreClockUpdate();
100013f0:	f7ff fe58 	bl	100010a4 <SystemCoreClockUpdate>

}
100013f4:	46bd      	mov	sp, r7
100013f6:	b004      	add	sp, #16
100013f8:	bd80      	pop	{r7, pc}
100013fa:	46c0      	nop			; (mov r8, r8)
100013fc:	40010300 	.word	0x40010300
10001400:	c00fff00 	.word	0xc00fff00
10001404:	3ff00000 	.word	0x3ff00000
10001408:	c00f00ff 	.word	0xc00f00ff

1000140c <XMC_SCU_CLOCK_lFrequencyUpScaling>:

/* Utility routine to perform frequency up scaling */
static void XMC_SCU_CLOCK_lFrequencyUpScaling(uint32_t curr_idiv, uint32_t target_idiv)
{
1000140c:	b580      	push	{r7, lr}
1000140e:	b082      	sub	sp, #8
10001410:	af00      	add	r7, sp, #0
10001412:	6078      	str	r0, [r7, #4]
10001414:	6039      	str	r1, [r7, #0]
  while (curr_idiv > (target_idiv * 4UL))
10001416:	e014      	b.n	10001442 <XMC_SCU_CLOCK_lFrequencyUpScaling+0x36>
  {
    curr_idiv = (uint32_t)(curr_idiv >> 2UL);   /* Divide by 4. */
10001418:	687b      	ldr	r3, [r7, #4]
1000141a:	089b      	lsrs	r3, r3, #2
1000141c:	607b      	str	r3, [r7, #4]

    SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
1000141e:	4b0d      	ldr	r3, [pc, #52]	; (10001454 <XMC_SCU_CLOCK_lFrequencyUpScaling+0x48>)
10001420:	4a0c      	ldr	r2, [pc, #48]	; (10001454 <XMC_SCU_CLOCK_lFrequencyUpScaling+0x48>)
10001422:	6812      	ldr	r2, [r2, #0]
10001424:	490c      	ldr	r1, [pc, #48]	; (10001458 <XMC_SCU_CLOCK_lFrequencyUpScaling+0x4c>)
10001426:	4011      	ands	r1, r2
                     (uint32_t)(curr_idiv << SCU_CLK_CLKCR_IDIV_Pos) |
10001428:	687a      	ldr	r2, [r7, #4]
1000142a:	0212      	lsls	r2, r2, #8
{
  while (curr_idiv > (target_idiv * 4UL))
  {
    curr_idiv = (uint32_t)(curr_idiv >> 2UL);   /* Divide by 4. */

    SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
1000142c:	430a      	orrs	r2, r1
                     (uint32_t)(curr_idiv << SCU_CLK_CLKCR_IDIV_Pos) |
1000142e:	490b      	ldr	r1, [pc, #44]	; (1000145c <XMC_SCU_CLOCK_lFrequencyUpScaling+0x50>)
10001430:	430a      	orrs	r2, r1
{
  while (curr_idiv > (target_idiv * 4UL))
  {
    curr_idiv = (uint32_t)(curr_idiv >> 2UL);   /* Divide by 4. */

    SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
10001432:	601a      	str	r2, [r3, #0]
                     (uint32_t)(curr_idiv << SCU_CLK_CLKCR_IDIV_Pos) |
                     (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);

    while (SCU_CLK->CLKCR & SCU_CLK_CLKCR_VDDC2LOW_Msk)
10001434:	46c0      	nop			; (mov r8, r8)
10001436:	4b07      	ldr	r3, [pc, #28]	; (10001454 <XMC_SCU_CLOCK_lFrequencyUpScaling+0x48>)
10001438:	681a      	ldr	r2, [r3, #0]
1000143a:	2380      	movs	r3, #128	; 0x80
1000143c:	05db      	lsls	r3, r3, #23
1000143e:	4013      	ands	r3, r2
10001440:	d1f9      	bne.n	10001436 <XMC_SCU_CLOCK_lFrequencyUpScaling+0x2a>
}

/* Utility routine to perform frequency up scaling */
static void XMC_SCU_CLOCK_lFrequencyUpScaling(uint32_t curr_idiv, uint32_t target_idiv)
{
  while (curr_idiv > (target_idiv * 4UL))
10001442:	683b      	ldr	r3, [r7, #0]
10001444:	009a      	lsls	r2, r3, #2
10001446:	687b      	ldr	r3, [r7, #4]
10001448:	429a      	cmp	r2, r3
1000144a:	d3e5      	bcc.n	10001418 <XMC_SCU_CLOCK_lFrequencyUpScaling+0xc>
    while (SCU_CLK->CLKCR & SCU_CLK_CLKCR_VDDC2LOW_Msk)
    {
      /* Wait voltage suply stabilization */
    }
  }
}
1000144c:	46bd      	mov	sp, r7
1000144e:	b002      	add	sp, #8
10001450:	bd80      	pop	{r7, pc}
10001452:	46c0      	nop			; (mov r8, r8)
10001454:	40010300 	.word	0x40010300
10001458:	c00f00ff 	.word	0xc00f00ff
1000145c:	3ff00000 	.word	0x3ff00000

10001460 <XMC_SCU_CLOCK_lFrequencyDownScaling>:

/* Utility routine to perform frequency down scaling */
static void XMC_SCU_CLOCK_lFrequencyDownScaling(uint32_t curr_idiv, uint32_t target_idiv)
{
10001460:	b580      	push	{r7, lr}
10001462:	b082      	sub	sp, #8
10001464:	af00      	add	r7, sp, #0
10001466:	6078      	str	r0, [r7, #4]
10001468:	6039      	str	r1, [r7, #0]

  while ((curr_idiv * 4UL) < target_idiv)
1000146a:	e019      	b.n	100014a0 <XMC_SCU_CLOCK_lFrequencyDownScaling+0x40>
  {
    if (0U == curr_idiv)
1000146c:	687b      	ldr	r3, [r7, #4]
1000146e:	2b00      	cmp	r3, #0
10001470:	d101      	bne.n	10001476 <XMC_SCU_CLOCK_lFrequencyDownScaling+0x16>
    {
      curr_idiv = 1U;
10001472:	2301      	movs	r3, #1
10001474:	607b      	str	r3, [r7, #4]
    }
    curr_idiv  = (uint32_t)(curr_idiv << 2UL);   /* Multiply by 4. */
10001476:	687b      	ldr	r3, [r7, #4]
10001478:	009b      	lsls	r3, r3, #2
1000147a:	607b      	str	r3, [r7, #4]
    SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
1000147c:	4b0c      	ldr	r3, [pc, #48]	; (100014b0 <XMC_SCU_CLOCK_lFrequencyDownScaling+0x50>)
1000147e:	4a0c      	ldr	r2, [pc, #48]	; (100014b0 <XMC_SCU_CLOCK_lFrequencyDownScaling+0x50>)
10001480:	6812      	ldr	r2, [r2, #0]
10001482:	490c      	ldr	r1, [pc, #48]	; (100014b4 <XMC_SCU_CLOCK_lFrequencyDownScaling+0x54>)
10001484:	4011      	ands	r1, r2
                     (uint32_t)(curr_idiv << SCU_CLK_CLKCR_IDIV_Pos) |
10001486:	687a      	ldr	r2, [r7, #4]
10001488:	0212      	lsls	r2, r2, #8
    if (0U == curr_idiv)
    {
      curr_idiv = 1U;
    }
    curr_idiv  = (uint32_t)(curr_idiv << 2UL);   /* Multiply by 4. */
    SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
1000148a:	430a      	orrs	r2, r1
                     (uint32_t)(curr_idiv << SCU_CLK_CLKCR_IDIV_Pos) |
1000148c:	490a      	ldr	r1, [pc, #40]	; (100014b8 <XMC_SCU_CLOCK_lFrequencyDownScaling+0x58>)
1000148e:	430a      	orrs	r2, r1
    if (0U == curr_idiv)
    {
      curr_idiv = 1U;
    }
    curr_idiv  = (uint32_t)(curr_idiv << 2UL);   /* Multiply by 4. */
    SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
10001490:	601a      	str	r2, [r3, #0]
                     (uint32_t)(curr_idiv << SCU_CLK_CLKCR_IDIV_Pos) |
                     (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);

    while (SCU_CLK->CLKCR & SCU_CLK_CLKCR_VDDC2LOW_Msk)
10001492:	46c0      	nop			; (mov r8, r8)
10001494:	4b06      	ldr	r3, [pc, #24]	; (100014b0 <XMC_SCU_CLOCK_lFrequencyDownScaling+0x50>)
10001496:	681a      	ldr	r2, [r3, #0]
10001498:	2380      	movs	r3, #128	; 0x80
1000149a:	05db      	lsls	r3, r3, #23
1000149c:	4013      	ands	r3, r2
1000149e:	d1f9      	bne.n	10001494 <XMC_SCU_CLOCK_lFrequencyDownScaling+0x34>

/* Utility routine to perform frequency down scaling */
static void XMC_SCU_CLOCK_lFrequencyDownScaling(uint32_t curr_idiv, uint32_t target_idiv)
{

  while ((curr_idiv * 4UL) < target_idiv)
100014a0:	687b      	ldr	r3, [r7, #4]
100014a2:	009a      	lsls	r2, r3, #2
100014a4:	683b      	ldr	r3, [r7, #0]
100014a6:	429a      	cmp	r2, r3
100014a8:	d3e0      	bcc.n	1000146c <XMC_SCU_CLOCK_lFrequencyDownScaling+0xc>
    while (SCU_CLK->CLKCR & SCU_CLK_CLKCR_VDDC2LOW_Msk)
    {
      /* Wait voltage suply stabilization */
    }
  }
}
100014aa:	46bd      	mov	sp, r7
100014ac:	b002      	add	sp, #8
100014ae:	bd80      	pop	{r7, pc}
100014b0:	40010300 	.word	0x40010300
100014b4:	c00f00ff 	.word	0xc00f00ff
100014b8:	3ff00000 	.word	0x3ff00000

100014bc <XMC_SCU_CLOCK_GetPeripheralClockFrequency>:

/*
 * API to retrieve clock frequency of peripherals on the peripheral bus using a shared functional clock
 */
uint32_t XMC_SCU_CLOCK_GetPeripheralClockFrequency(void)
{
100014bc:	b580      	push	{r7, lr}
100014be:	af00      	add	r7, sp, #0
  return (SystemCoreClock);
100014c0:	4b02      	ldr	r3, [pc, #8]	; (100014cc <XMC_SCU_CLOCK_GetPeripheralClockFrequency+0x10>)
100014c2:	681b      	ldr	r3, [r3, #0]
}
100014c4:	1c18      	adds	r0, r3, #0
100014c6:	46bd      	mov	sp, r7
100014c8:	bd80      	pop	{r7, pc}
100014ca:	46c0      	nop			; (mov r8, r8)
100014cc:	20003ffc 	.word	0x20003ffc

100014d0 <XMC_CCU4_StartPrescaler>:
 * \par<b>Related APIs:</b><br>
 * XMC_CCU4_Init()<BR> XMC_CCU4_EnableClock()<BR> XMC_CCU4_DisableClock()<BR> XMC_CCU4_StartPrescaler()<BR>
 * XMC_CCU4_StopPrescaler().
 */
__STATIC_INLINE void XMC_CCU4_StartPrescaler(XMC_CCU4_MODULE_t *const module)
{
100014d0:	b580      	push	{r7, lr}
100014d2:	b082      	sub	sp, #8
100014d4:	af00      	add	r7, sp, #0
100014d6:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_CCU4_StartPrescaler:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));
  module->GIDLC = (uint32_t) CCU4_GIDLC_SPRB_Msk;
100014d8:	687b      	ldr	r3, [r7, #4]
100014da:	2280      	movs	r2, #128	; 0x80
100014dc:	0052      	lsls	r2, r2, #1
100014de:	60da      	str	r2, [r3, #12]
}
100014e0:	46bd      	mov	sp, r7
100014e2:	b002      	add	sp, #8
100014e4:	bd80      	pop	{r7, pc}
100014e6:	46c0      	nop			; (mov r8, r8)

100014e8 <XMC_CCU4_lUngateClock>:
    XMC_ASSERT("XMC_CCU4_lGateClock:Invalid Module Pointer", 0);
  }
}

__STATIC_INLINE void XMC_CCU4_lUngateClock(const XMC_CCU4_MODULE_t *const module)
{
100014e8:	b580      	push	{r7, lr}
100014ea:	b082      	sub	sp, #8
100014ec:	af00      	add	r7, sp, #0
100014ee:	6078      	str	r0, [r7, #4]
  if (module == CCU40)
100014f0:	687b      	ldr	r3, [r7, #4]
100014f2:	4a04      	ldr	r2, [pc, #16]	; (10001504 <XMC_CCU4_lUngateClock+0x1c>)
100014f4:	4293      	cmp	r3, r2
100014f6:	d102      	bne.n	100014fe <XMC_CCU4_lUngateClock+0x16>
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU40);
100014f8:	2004      	movs	r0, #4
100014fa:	f7ff ff03 	bl	10001304 <XMC_SCU_CLOCK_UngatePeripheralClock>
#endif
  else
  {
    XMC_ASSERT("XMC_CCU4_lUngateClock:Invalid Module Pointer", 0);
  }
}
100014fe:	46bd      	mov	sp, r7
10001500:	b002      	add	sp, #8
10001502:	bd80      	pop	{r7, pc}
10001504:	48040000 	.word	0x48040000

10001508 <XMC_CCU4_EnableModule>:
/*********************************************************************************************************************
 * API IMPLEMENTATION
 ********************************************************************************************************************/

void XMC_CCU4_EnableModule(XMC_CCU4_MODULE_t *const module)
{
10001508:	b580      	push	{r7, lr}
1000150a:	b082      	sub	sp, #8
1000150c:	af00      	add	r7, sp, #0
1000150e:	6078      	str	r0, [r7, #4]
  /* Enable CCU4 module clock */
  XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_CCU);
#endif

#if defined(CLOCK_GATING_SUPPORTED)
  XMC_CCU4_lUngateClock(module);
10001510:	687b      	ldr	r3, [r7, #4]
10001512:	1c18      	adds	r0, r3, #0
10001514:	f7ff ffe8 	bl	100014e8 <XMC_CCU4_lUngateClock>
#endif

#if defined(PERIPHERAL_RESET_SUPPORTED)
  XMC_CCU4_lDeassertReset(module);
#endif
}
10001518:	46bd      	mov	sp, r7
1000151a:	b002      	add	sp, #8
1000151c:	bd80      	pop	{r7, pc}
1000151e:	46c0      	nop			; (mov r8, r8)

10001520 <XMC_CCU4_Init>:
#endif
}

/* API to initialize CCU4 global resources  */
void XMC_CCU4_Init(XMC_CCU4_MODULE_t *const module, const XMC_CCU4_SLICE_MCMS_ACTION_t mcs_action)
{
10001520:	b580      	push	{r7, lr}
10001522:	b084      	sub	sp, #16
10001524:	af00      	add	r7, sp, #0
10001526:	6078      	str	r0, [r7, #4]
10001528:	1c0a      	adds	r2, r1, #0
1000152a:	1cfb      	adds	r3, r7, #3
1000152c:	701a      	strb	r2, [r3, #0]

  XMC_ASSERT("XMC_CCU4_Init:Invalid module pointer", XMC_CCU4_IsValidModule(module));
  XMC_ASSERT("XMC_CCU4_Init:Invalid mcs action", XMC_CCU4_SLICE_CHECK_MCS_ACTION(mcs_action));

  /* Enable CCU4 module */
  XMC_CCU4_EnableModule(module);
1000152e:	687b      	ldr	r3, [r7, #4]
10001530:	1c18      	adds	r0, r3, #0
10001532:	f7ff ffe9 	bl	10001508 <XMC_CCU4_EnableModule>
  /* Start the prescaler */
  XMC_CCU4_StartPrescaler(module);
10001536:	687b      	ldr	r3, [r7, #4]
10001538:	1c18      	adds	r0, r3, #0
1000153a:	f7ff ffc9 	bl	100014d0 <XMC_CCU4_StartPrescaler>

  gctrl = module->GCTRL;
1000153e:	687b      	ldr	r3, [r7, #4]
10001540:	681b      	ldr	r3, [r3, #0]
10001542:	60fb      	str	r3, [r7, #12]
  gctrl &= ~((uint32_t) CCU4_GCTRL_MSDE_Msk);
10001544:	68fb      	ldr	r3, [r7, #12]
10001546:	4a07      	ldr	r2, [pc, #28]	; (10001564 <XMC_CCU4_Init+0x44>)
10001548:	4013      	ands	r3, r2
1000154a:	60fb      	str	r3, [r7, #12]
  gctrl |= ((uint32_t) mcs_action) << CCU4_GCTRL_MSDE_Pos;
1000154c:	1cfb      	adds	r3, r7, #3
1000154e:	781b      	ldrb	r3, [r3, #0]
10001550:	039b      	lsls	r3, r3, #14
10001552:	68fa      	ldr	r2, [r7, #12]
10001554:	4313      	orrs	r3, r2
10001556:	60fb      	str	r3, [r7, #12]

  module->GCTRL = gctrl;
10001558:	687b      	ldr	r3, [r7, #4]
1000155a:	68fa      	ldr	r2, [r7, #12]
1000155c:	601a      	str	r2, [r3, #0]
}
1000155e:	46bd      	mov	sp, r7
10001560:	b004      	add	sp, #16
10001562:	bd80      	pop	{r7, pc}
10001564:	ffff3fff 	.word	0xffff3fff

10001568 <XMC_CCU4_SLICE_CompareInit>:
}

/* API to configure CC4 Slice as Timer */
void XMC_CCU4_SLICE_CompareInit(XMC_CCU4_SLICE_t *const slice,
                                const XMC_CCU4_SLICE_COMPARE_CONFIG_t *const compare_init)
{
10001568:	b580      	push	{r7, lr}
1000156a:	b082      	sub	sp, #8
1000156c:	af00      	add	r7, sp, #0
1000156e:	6078      	str	r0, [r7, #4]
10001570:	6039      	str	r1, [r7, #0]
  XMC_ASSERT("XMC_CCU4_SLICE_CompareInit:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_CompareInit:Compare Init Pointer is NULL",
             (XMC_CCU4_SLICE_COMPARE_CONFIG_t *) NULL != compare_init);

  /* Program the timer mode */
  slice->TC = compare_init->tc;
10001572:	683b      	ldr	r3, [r7, #0]
10001574:	681a      	ldr	r2, [r3, #0]
10001576:	687b      	ldr	r3, [r7, #4]
10001578:	615a      	str	r2, [r3, #20]
  /* Enable the timer concatenation */
  slice->CMC = ((uint32_t) compare_init->timer_concatenation << CCU4_CC4_CMC_TCE_Pos);
1000157a:	683b      	ldr	r3, [r7, #0]
1000157c:	795b      	ldrb	r3, [r3, #5]
1000157e:	069b      	lsls	r3, r3, #26
10001580:	0fdb      	lsrs	r3, r3, #31
10001582:	b2db      	uxtb	r3, r3
10001584:	051a      	lsls	r2, r3, #20
10001586:	687b      	ldr	r3, [r7, #4]
10001588:	605a      	str	r2, [r3, #4]
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) compare_init->prescaler_initval;
1000158a:	683b      	ldr	r3, [r7, #0]
1000158c:	791b      	ldrb	r3, [r3, #4]
1000158e:	071b      	lsls	r3, r3, #28
10001590:	0f1b      	lsrs	r3, r3, #28
10001592:	b2db      	uxtb	r3, r3
10001594:	1c1a      	adds	r2, r3, #0
10001596:	687b      	ldr	r3, [r7, #4]
10001598:	625a      	str	r2, [r3, #36]	; 0x24
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
1000159a:	683b      	ldr	r3, [r7, #0]
1000159c:	795b      	ldrb	r3, [r3, #5]
1000159e:	071b      	lsls	r3, r3, #28
100015a0:	0f1b      	lsrs	r3, r3, #28
100015a2:	b2db      	uxtb	r3, r3
100015a4:	1c1a      	adds	r2, r3, #0
100015a6:	687b      	ldr	r3, [r7, #4]
100015a8:	621a      	str	r2, [r3, #32]
  /* Program timer output passive level */
  slice->PSL = (uint32_t) compare_init->passive_level;
100015aa:	683b      	ldr	r3, [r7, #0]
100015ac:	795b      	ldrb	r3, [r3, #5]
100015ae:	06db      	lsls	r3, r3, #27
100015b0:	0fdb      	lsrs	r3, r3, #31
100015b2:	b2db      	uxtb	r3, r3
100015b4:	1c1a      	adds	r2, r3, #0
100015b6:	687b      	ldr	r3, [r7, #4]
100015b8:	619a      	str	r2, [r3, #24]
  /* Program floating prescaler compare value */
  slice->FPCS = (uint32_t) compare_init->float_limit;
100015ba:	683b      	ldr	r3, [r7, #0]
100015bc:	791b      	ldrb	r3, [r3, #4]
100015be:	061b      	lsls	r3, r3, #24
100015c0:	0f1b      	lsrs	r3, r3, #28
100015c2:	b2db      	uxtb	r3, r3
100015c4:	1c1a      	adds	r2, r3, #0
100015c6:	687b      	ldr	r3, [r7, #4]
100015c8:	62da      	str	r2, [r3, #44]	; 0x2c
}
100015ca:	46bd      	mov	sp, r7
100015cc:	b002      	add	sp, #8
100015ce:	bd80      	pop	{r7, pc}

100015d0 <XMC_CCU4_SLICE_SetInterruptNode>:

/* Binds a capcom event to an NVIC node  */
void XMC_CCU4_SLICE_SetInterruptNode(XMC_CCU4_SLICE_t *const slice,
                                     const XMC_CCU4_SLICE_IRQ_ID_t event,
                                     const XMC_CCU4_SLICE_SR_ID_t sr)
{
100015d0:	b580      	push	{r7, lr}
100015d2:	b086      	sub	sp, #24
100015d4:	af00      	add	r7, sp, #0
100015d6:	6078      	str	r0, [r7, #4]
100015d8:	1c08      	adds	r0, r1, #0
100015da:	1c11      	adds	r1, r2, #0
100015dc:	1cfb      	adds	r3, r7, #3
100015de:	1c02      	adds	r2, r0, #0
100015e0:	701a      	strb	r2, [r3, #0]
100015e2:	1cbb      	adds	r3, r7, #2
100015e4:	1c0a      	adds	r2, r1, #0
100015e6:	701a      	strb	r2, [r3, #0]

  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid SR ID ", XMC_CCU4_SLICE_CHECK_SR_ID(sr));
  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid event", XMC_CCU4_SLICE_CHECK_INTERRUPT(event));

  switch (event)
100015e8:	1cfb      	adds	r3, r7, #3
100015ea:	781b      	ldrb	r3, [r3, #0]
100015ec:	2b0b      	cmp	r3, #11
100015ee:	d820      	bhi.n	10001632 <XMC_CCU4_SLICE_SetInterruptNode+0x62>
100015f0:	009a      	lsls	r2, r3, #2
100015f2:	4b20      	ldr	r3, [pc, #128]	; (10001674 <XMC_CCU4_SLICE_SetInterruptNode+0xa4>)
100015f4:	18d3      	adds	r3, r2, r3
100015f6:	681b      	ldr	r3, [r3, #0]
100015f8:	469f      	mov	pc, r3
  {
    case XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH:
    case XMC_CCU4_SLICE_IRQ_ID_ONE_MATCH:
      mask = ((uint32_t) CCU4_CC4_SRS_POSR_Msk);
100015fa:	2303      	movs	r3, #3
100015fc:	613b      	str	r3, [r7, #16]
      pos  = CCU4_CC4_SRS_POSR_Pos;
100015fe:	2300      	movs	r3, #0
10001600:	617b      	str	r3, [r7, #20]
      break;
10001602:	e01b      	b.n	1000163c <XMC_CCU4_SLICE_SetInterruptNode+0x6c>

    case XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_UP:
    case XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_DOWN:
      mask = ((uint32_t) CCU4_CC4_SRS_CMSR_Msk);
10001604:	230c      	movs	r3, #12
10001606:	613b      	str	r3, [r7, #16]
      pos  = CCU4_CC4_SRS_CMSR_Pos;
10001608:	2302      	movs	r3, #2
1000160a:	617b      	str	r3, [r7, #20]
      break;
1000160c:	e016      	b.n	1000163c <XMC_CCU4_SLICE_SetInterruptNode+0x6c>

    case XMC_CCU4_SLICE_IRQ_ID_EVENT0:
      mask = ((uint32_t) CCU4_CC4_SRS_E0SR_Msk);
1000160e:	23c0      	movs	r3, #192	; 0xc0
10001610:	009b      	lsls	r3, r3, #2
10001612:	613b      	str	r3, [r7, #16]
      pos  = CCU4_CC4_SRS_E0SR_Pos;
10001614:	2308      	movs	r3, #8
10001616:	617b      	str	r3, [r7, #20]
      break;
10001618:	e010      	b.n	1000163c <XMC_CCU4_SLICE_SetInterruptNode+0x6c>

    case XMC_CCU4_SLICE_IRQ_ID_EVENT1:
      mask = ((uint32_t) CCU4_CC4_SRS_E1SR_Msk);
1000161a:	23c0      	movs	r3, #192	; 0xc0
1000161c:	011b      	lsls	r3, r3, #4
1000161e:	613b      	str	r3, [r7, #16]
      pos  = CCU4_CC4_SRS_E1SR_Pos;
10001620:	230a      	movs	r3, #10
10001622:	617b      	str	r3, [r7, #20]
      break;
10001624:	e00a      	b.n	1000163c <XMC_CCU4_SLICE_SetInterruptNode+0x6c>

    case XMC_CCU4_SLICE_IRQ_ID_EVENT2:
    case XMC_CCU4_SLICE_IRQ_ID_TRAP:
      mask = ((uint32_t) CCU4_CC4_SRS_E2SR_Msk);
10001626:	23c0      	movs	r3, #192	; 0xc0
10001628:	019b      	lsls	r3, r3, #6
1000162a:	613b      	str	r3, [r7, #16]
      pos  = CCU4_CC4_SRS_E2SR_Pos;
1000162c:	230c      	movs	r3, #12
1000162e:	617b      	str	r3, [r7, #20]
      break;
10001630:	e004      	b.n	1000163c <XMC_CCU4_SLICE_SetInterruptNode+0x6c>
	  
	default:
	  mask = 0;
10001632:	2300      	movs	r3, #0
10001634:	613b      	str	r3, [r7, #16]
	  pos = 0;
10001636:	2300      	movs	r3, #0
10001638:	617b      	str	r3, [r7, #20]
	  break;
1000163a:	46c0      	nop			; (mov r8, r8)
  }

  if (mask != 0)
1000163c:	693b      	ldr	r3, [r7, #16]
1000163e:	2b00      	cmp	r3, #0
10001640:	d014      	beq.n	1000166c <XMC_CCU4_SLICE_SetInterruptNode+0x9c>
  {
    srs = slice->SRS;
10001642:	687b      	ldr	r3, [r7, #4]
10001644:	22a8      	movs	r2, #168	; 0xa8
10001646:	589b      	ldr	r3, [r3, r2]
10001648:	60fb      	str	r3, [r7, #12]
    srs &= ~mask;
1000164a:	693b      	ldr	r3, [r7, #16]
1000164c:	43da      	mvns	r2, r3
1000164e:	68fb      	ldr	r3, [r7, #12]
10001650:	4013      	ands	r3, r2
10001652:	60fb      	str	r3, [r7, #12]
    srs |= (uint32_t)sr << pos;
10001654:	1cbb      	adds	r3, r7, #2
10001656:	781a      	ldrb	r2, [r3, #0]
10001658:	697b      	ldr	r3, [r7, #20]
1000165a:	409a      	lsls	r2, r3
1000165c:	1c13      	adds	r3, r2, #0
1000165e:	68fa      	ldr	r2, [r7, #12]
10001660:	4313      	orrs	r3, r2
10001662:	60fb      	str	r3, [r7, #12]
    slice->SRS = srs;
10001664:	687b      	ldr	r3, [r7, #4]
10001666:	21a8      	movs	r1, #168	; 0xa8
10001668:	68fa      	ldr	r2, [r7, #12]
1000166a:	505a      	str	r2, [r3, r1]
  }
}
1000166c:	46bd      	mov	sp, r7
1000166e:	b006      	add	sp, #24
10001670:	bd80      	pop	{r7, pc}
10001672:	46c0      	nop			; (mov r8, r8)
10001674:	1000a0fc 	.word	0x1000a0fc

10001678 <XMC_GPIO_SetHardwareControl>:
  port->IOCR[(uint32_t)pin >> 2U] &= ~(uint32_t)((uint32_t)PORT_IOCR_PC_Msk << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U)));
  port->IOCR[(uint32_t)pin >> 2U] |= (uint32_t)mode << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U));
}

void XMC_GPIO_SetHardwareControl(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_HWCTRL_t hwctrl)
{
10001678:	b580      	push	{r7, lr}
1000167a:	b082      	sub	sp, #8
1000167c:	af00      	add	r7, sp, #0
1000167e:	6078      	str	r0, [r7, #4]
10001680:	1c08      	adds	r0, r1, #0
10001682:	1c11      	adds	r1, r2, #0
10001684:	1cfb      	adds	r3, r7, #3
10001686:	1c02      	adds	r2, r0, #0
10001688:	701a      	strb	r2, [r3, #0]
1000168a:	1cbb      	adds	r3, r7, #2
1000168c:	1c0a      	adds	r2, r1, #0
1000168e:	701a      	strb	r2, [r3, #0]
  XMC_ASSERT("XMC_GPIO_SetHardwareControl: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_SetHardwareControl: Invalid hwctrl", XMC_GPIO_CHECK_HWCTRL(hwctrl));

  port->HWSEL &= ~(uint32_t)((uint32_t)PORT_HWSEL_Msk << ((uint32_t)pin << 1U));
10001690:	687b      	ldr	r3, [r7, #4]
10001692:	6f5b      	ldr	r3, [r3, #116]	; 0x74
10001694:	1cfa      	adds	r2, r7, #3
10001696:	7812      	ldrb	r2, [r2, #0]
10001698:	0052      	lsls	r2, r2, #1
1000169a:	1c11      	adds	r1, r2, #0
1000169c:	2203      	movs	r2, #3
1000169e:	408a      	lsls	r2, r1
100016a0:	43d2      	mvns	r2, r2
100016a2:	401a      	ands	r2, r3
100016a4:	687b      	ldr	r3, [r7, #4]
100016a6:	675a      	str	r2, [r3, #116]	; 0x74
  port->HWSEL |= (uint32_t)hwctrl << ((uint32_t)pin << 1U);
100016a8:	687b      	ldr	r3, [r7, #4]
100016aa:	6f5a      	ldr	r2, [r3, #116]	; 0x74
100016ac:	1cbb      	adds	r3, r7, #2
100016ae:	781b      	ldrb	r3, [r3, #0]
100016b0:	1cf9      	adds	r1, r7, #3
100016b2:	7809      	ldrb	r1, [r1, #0]
100016b4:	0049      	lsls	r1, r1, #1
100016b6:	408b      	lsls	r3, r1
100016b8:	431a      	orrs	r2, r3
100016ba:	687b      	ldr	r3, [r7, #4]
100016bc:	675a      	str	r2, [r3, #116]	; 0x74
}
100016be:	46bd      	mov	sp, r7
100016c0:	b002      	add	sp, #8
100016c2:	bd80      	pop	{r7, pc}

100016c4 <XMC_USIC_CH_GetTransmitBufferStatus>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_SetDataOutputMode() \n\n\n
 */
__STATIC_INLINE XMC_USIC_CH_TBUF_STATUS_t XMC_USIC_CH_GetTransmitBufferStatus(XMC_USIC_CH_t *const channel)
{
100016c4:	b580      	push	{r7, lr}
100016c6:	b082      	sub	sp, #8
100016c8:	af00      	add	r7, sp, #0
100016ca:	6078      	str	r0, [r7, #4]
  return (XMC_USIC_CH_TBUF_STATUS_t)(channel->TCSR & USIC_CH_TCSR_TDV_Msk);
100016cc:	687b      	ldr	r3, [r7, #4]
100016ce:	6b9b      	ldr	r3, [r3, #56]	; 0x38
100016d0:	b2db      	uxtb	r3, r3
100016d2:	227f      	movs	r2, #127	; 0x7f
100016d4:	4393      	bics	r3, r2
100016d6:	b2db      	uxtb	r3, r3
}
100016d8:	1c18      	adds	r0, r3, #0
100016da:	46bd      	mov	sp, r7
100016dc:	b002      	add	sp, #8
100016de:	bd80      	pop	{r7, pc}

100016e0 <XMC_UART_CH_ClearStatusFlag>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_UART_CH_DisableEvent(),  XMC_UART_CH_GetStatusFlag()\n\n\n
 */
__STATIC_INLINE void XMC_UART_CH_ClearStatusFlag(XMC_USIC_CH_t *const channel, const uint32_t flag)
{
100016e0:	b580      	push	{r7, lr}
100016e2:	b082      	sub	sp, #8
100016e4:	af00      	add	r7, sp, #0
100016e6:	6078      	str	r0, [r7, #4]
100016e8:	6039      	str	r1, [r7, #0]
  channel->PSCR = flag;
100016ea:	687b      	ldr	r3, [r7, #4]
100016ec:	683a      	ldr	r2, [r7, #0]
100016ee:	64da      	str	r2, [r3, #76]	; 0x4c
}
100016f0:	46bd      	mov	sp, r7
100016f2:	b002      	add	sp, #8
100016f4:	bd80      	pop	{r7, pc}
100016f6:	46c0      	nop			; (mov r8, r8)

100016f8 <XMC_UART_CH_InitEx>:
/*********************************************************************************************************************
 * API IMPLEMENTATION
 *********************************************************************************************************************/

void XMC_UART_CH_InitEx(XMC_USIC_CH_t *channel, const XMC_UART_CH_CONFIG_t *const config, bool init_brg)
{
100016f8:	b580      	push	{r7, lr}
100016fa:	b086      	sub	sp, #24
100016fc:	af00      	add	r7, sp, #0
100016fe:	60f8      	str	r0, [r7, #12]
10001700:	60b9      	str	r1, [r7, #8]
10001702:	1dfb      	adds	r3, r7, #7
10001704:	701a      	strb	r2, [r3, #0]
  uint32_t oversampling = XMC_UART_CH_OVERSAMPLING;
10001706:	2310      	movs	r3, #16
10001708:	617b      	str	r3, [r7, #20]

  /* USIC channel switched on*/
  XMC_USIC_CH_Enable(channel);
1000170a:	68fb      	ldr	r3, [r7, #12]
1000170c:	1c18      	adds	r0, r3, #0
1000170e:	f000 f8af 	bl	10001870 <XMC_USIC_CH_Enable>

  if (config->oversampling != 0U)
10001712:	68bb      	ldr	r3, [r7, #8]
10001714:	7a1b      	ldrb	r3, [r3, #8]
10001716:	2b00      	cmp	r3, #0
10001718:	d002      	beq.n	10001720 <XMC_UART_CH_InitEx+0x28>
  {
    oversampling = (uint32_t)config->oversampling;
1000171a:	68bb      	ldr	r3, [r7, #8]
1000171c:	7a1b      	ldrb	r3, [r3, #8]
1000171e:	617b      	str	r3, [r7, #20]
  }

  if (init_brg)
10001720:	1dfb      	adds	r3, r7, #7
10001722:	781b      	ldrb	r3, [r3, #0]
10001724:	2b00      	cmp	r3, #0
10001726:	d016      	beq.n	10001756 <XMC_UART_CH_InitEx+0x5e>
  {
    /* Configure baud rate */
    if (config->normal_divider_mode)
10001728:	68bb      	ldr	r3, [r7, #8]
1000172a:	791b      	ldrb	r3, [r3, #4]
1000172c:	2b00      	cmp	r3, #0
1000172e:	d009      	beq.n	10001744 <XMC_UART_CH_InitEx+0x4c>
    {
      /* Normal divider mode */
      (void)XMC_USIC_CH_SetBaudrateEx(channel, config->baudrate, oversampling);
10001730:	68bb      	ldr	r3, [r7, #8]
10001732:	681b      	ldr	r3, [r3, #0]
10001734:	1c19      	adds	r1, r3, #0
10001736:	697b      	ldr	r3, [r7, #20]
10001738:	68fa      	ldr	r2, [r7, #12]
1000173a:	1c10      	adds	r0, r2, #0
1000173c:	1c1a      	adds	r2, r3, #0
1000173e:	f000 f939 	bl	100019b4 <XMC_USIC_CH_SetBaudrateEx>
10001742:	e008      	b.n	10001756 <XMC_UART_CH_InitEx+0x5e>
    }
    else
    {
      /* Fractional divider mode */
      (void)XMC_USIC_CH_SetBaudrate(channel, config->baudrate, oversampling);
10001744:	68bb      	ldr	r3, [r7, #8]
10001746:	681a      	ldr	r2, [r3, #0]
10001748:	68f9      	ldr	r1, [r7, #12]
1000174a:	697b      	ldr	r3, [r7, #20]
1000174c:	1c08      	adds	r0, r1, #0
1000174e:	1c11      	adds	r1, r2, #0
10001750:	1c1a      	adds	r2, r3, #0
10001752:	f000 f8b5 	bl	100018c0 <XMC_USIC_CH_SetBaudrate>
   * i.e. the 0 level is signaled during the complete bit time
   * Sampling point set equal to the half of the oversampling period
   * Enable Sample Majority Decision
   * Enable Transfer Status BUSY
   */
  channel->PCR_ASCMode = (uint32_t)(((config->stop_bits - 1UL) << USIC_CH_PCR_ASCMode_STPB_Pos) |
10001756:	68bb      	ldr	r3, [r7, #8]
10001758:	79db      	ldrb	r3, [r3, #7]
1000175a:	3b01      	subs	r3, #1
1000175c:	005a      	lsls	r2, r3, #1
                                    (((oversampling >> 1UL) + 1UL) << USIC_CH_PCR_ASCMode_SP_Pos) |
1000175e:	697b      	ldr	r3, [r7, #20]
10001760:	085b      	lsrs	r3, r3, #1
10001762:	3301      	adds	r3, #1
10001764:	021b      	lsls	r3, r3, #8
   * i.e. the 0 level is signaled during the complete bit time
   * Sampling point set equal to the half of the oversampling period
   * Enable Sample Majority Decision
   * Enable Transfer Status BUSY
   */
  channel->PCR_ASCMode = (uint32_t)(((config->stop_bits - 1UL) << USIC_CH_PCR_ASCMode_STPB_Pos) |
10001766:	4313      	orrs	r3, r2
10001768:	4a19      	ldr	r2, [pc, #100]	; (100017d0 <XMC_UART_CH_InitEx+0xd8>)
1000176a:	431a      	orrs	r2, r3
1000176c:	68fb      	ldr	r3, [r7, #12]
1000176e:	63da      	str	r2, [r3, #60]	; 0x3c
  /* Set passive data level, high
     Set word length. Data bits - 1
     If frame length is > 0, frame_lemgth-1; else, FLE = WLE (Data bits - 1)
     Transmission Mode: The shift control signal is considered active if it
     is at 1-level. This is the setting to be programmed to allow data transfers */
  channel->SCTR = (uint32_t)((((uint32_t)config->data_bits - 1UL) << USIC_CH_SCTR_WLE_Pos) |
10001770:	68bb      	ldr	r3, [r7, #8]
10001772:	795b      	ldrb	r3, [r3, #5]
10001774:	3b01      	subs	r3, #1
10001776:	061b      	lsls	r3, r3, #24
10001778:	2281      	movs	r2, #129	; 0x81
1000177a:	0052      	lsls	r2, r2, #1
1000177c:	431a      	orrs	r2, r3
1000177e:	68fb      	ldr	r3, [r7, #12]
10001780:	635a      	str	r2, [r3, #52]	; 0x34
                             ((0x1UL << USIC_CH_SCTR_TRM_Pos) | USIC_CH_SCTR_PDL_Msk));

  if (config->frame_length != 0U)
10001782:	68bb      	ldr	r3, [r7, #8]
10001784:	799b      	ldrb	r3, [r3, #6]
10001786:	2b00      	cmp	r3, #0
10001788:	d009      	beq.n	1000179e <XMC_UART_CH_InitEx+0xa6>
  {
    channel->SCTR |= (uint32_t)(((uint32_t)config->frame_length - 1UL) << USIC_CH_SCTR_FLE_Pos);
1000178a:	68fb      	ldr	r3, [r7, #12]
1000178c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
1000178e:	68bb      	ldr	r3, [r7, #8]
10001790:	799b      	ldrb	r3, [r3, #6]
10001792:	3b01      	subs	r3, #1
10001794:	041b      	lsls	r3, r3, #16
10001796:	431a      	orrs	r2, r3
10001798:	68fb      	ldr	r3, [r7, #12]
1000179a:	635a      	str	r2, [r3, #52]	; 0x34
1000179c:	e008      	b.n	100017b0 <XMC_UART_CH_InitEx+0xb8>
  }
  else
  {
    channel->SCTR |= (uint32_t)(((uint32_t)config->data_bits - 1UL) << USIC_CH_SCTR_FLE_Pos);
1000179e:	68fb      	ldr	r3, [r7, #12]
100017a0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
100017a2:	68bb      	ldr	r3, [r7, #8]
100017a4:	795b      	ldrb	r3, [r3, #5]
100017a6:	3b01      	subs	r3, #1
100017a8:	041b      	lsls	r3, r3, #16
100017aa:	431a      	orrs	r2, r3
100017ac:	68fb      	ldr	r3, [r7, #12]
100017ae:	635a      	str	r2, [r3, #52]	; 0x34
  }

  /* Enable transfer buffer */
  channel->TCSR = (0x1UL << USIC_CH_TCSR_TDEN_Pos) |
100017b0:	68fb      	ldr	r3, [r7, #12]
100017b2:	22a0      	movs	r2, #160	; 0xa0
100017b4:	00d2      	lsls	r2, r2, #3
100017b6:	639a      	str	r2, [r3, #56]	; 0x38
                  USIC_CH_TCSR_TDSSM_Msk;

  /* Clear protocol status */
  channel->PSCR = 0xFFFFFFFFUL;
100017b8:	68fb      	ldr	r3, [r7, #12]
100017ba:	2201      	movs	r2, #1
100017bc:	4252      	negs	r2, r2
100017be:	64da      	str	r2, [r3, #76]	; 0x4c

  /* Set parity settings */
  channel->CCR = (uint32_t)config->parity_mode;
100017c0:	68bb      	ldr	r3, [r7, #8]
100017c2:	895b      	ldrh	r3, [r3, #10]
100017c4:	1c1a      	adds	r2, r3, #0
100017c6:	68fb      	ldr	r3, [r7, #12]
100017c8:	641a      	str	r2, [r3, #64]	; 0x40
}
100017ca:	46bd      	mov	sp, r7
100017cc:	b006      	add	sp, #24
100017ce:	bd80      	pop	{r7, pc}
100017d0:	00030001 	.word	0x00030001

100017d4 <XMC_UART_CH_Transmit>:

  return (XMC_UART_CH_STATUS_t)status;
}

void XMC_UART_CH_Transmit(XMC_USIC_CH_t *const channel, const uint16_t data)
{
100017d4:	b580      	push	{r7, lr}
100017d6:	b082      	sub	sp, #8
100017d8:	af00      	add	r7, sp, #0
100017da:	6078      	str	r0, [r7, #4]
100017dc:	1c0a      	adds	r2, r1, #0
100017de:	1cbb      	adds	r3, r7, #2
100017e0:	801a      	strh	r2, [r3, #0]
  /* Check FIFO size */
  if ((channel->TBCTR & USIC_CH_TBCTR_SIZE_Msk) == 0UL)
100017e2:	687a      	ldr	r2, [r7, #4]
100017e4:	2384      	movs	r3, #132	; 0x84
100017e6:	005b      	lsls	r3, r3, #1
100017e8:	58d2      	ldr	r2, [r2, r3]
100017ea:	23e0      	movs	r3, #224	; 0xe0
100017ec:	04db      	lsls	r3, r3, #19
100017ee:	4013      	ands	r3, r2
100017f0:	d114      	bne.n	1000181c <XMC_UART_CH_Transmit+0x48>
  {
    /* Wait till the Transmit Buffer is free for transmission */
    while (XMC_USIC_CH_GetTransmitBufferStatus(channel) == XMC_USIC_CH_TBUF_STATUS_BUSY)
100017f2:	46c0      	nop			; (mov r8, r8)
100017f4:	687b      	ldr	r3, [r7, #4]
100017f6:	1c18      	adds	r0, r3, #0
100017f8:	f7ff ff64 	bl	100016c4 <XMC_USIC_CH_GetTransmitBufferStatus>
100017fc:	1e03      	subs	r3, r0, #0
100017fe:	2b80      	cmp	r3, #128	; 0x80
10001800:	d0f8      	beq.n	100017f4 <XMC_UART_CH_Transmit+0x20>
    {
    }

    /* Clear the Transmit Buffer indication flag */
    XMC_UART_CH_ClearStatusFlag(channel, (uint32_t)XMC_UART_CH_STATUS_FLAG_TRANSMIT_BUFFER_INDICATION);
10001802:	687a      	ldr	r2, [r7, #4]
10001804:	2380      	movs	r3, #128	; 0x80
10001806:	019b      	lsls	r3, r3, #6
10001808:	1c10      	adds	r0, r2, #0
1000180a:	1c19      	adds	r1, r3, #0
1000180c:	f7ff ff68 	bl	100016e0 <XMC_UART_CH_ClearStatusFlag>

    /*Transmit data */
    channel->TBUF[0U] = data;
10001810:	1cbb      	adds	r3, r7, #2
10001812:	881a      	ldrh	r2, [r3, #0]
10001814:	687b      	ldr	r3, [r7, #4]
10001816:	2180      	movs	r1, #128	; 0x80
10001818:	505a      	str	r2, [r3, r1]
1000181a:	e005      	b.n	10001828 <XMC_UART_CH_Transmit+0x54>
  }
  else
  {
    channel->IN[0U] = data;
1000181c:	1cbb      	adds	r3, r7, #2
1000181e:	8819      	ldrh	r1, [r3, #0]
10001820:	687a      	ldr	r2, [r7, #4]
10001822:	23c0      	movs	r3, #192	; 0xc0
10001824:	005b      	lsls	r3, r3, #1
10001826:	50d1      	str	r1, [r2, r3]
  }
}
10001828:	46bd      	mov	sp, r7
1000182a:	b002      	add	sp, #8
1000182c:	bd80      	pop	{r7, pc}
1000182e:	46c0      	nop			; (mov r8, r8)

10001830 <XMC_UART_CH_GetReceivedData>:

uint16_t XMC_UART_CH_GetReceivedData(XMC_USIC_CH_t *const channel)
{
10001830:	b580      	push	{r7, lr}
10001832:	b084      	sub	sp, #16
10001834:	af00      	add	r7, sp, #0
10001836:	6078      	str	r0, [r7, #4]
  uint16_t retval;

  /* Check FIFO size */
  if ((channel->RBCTR & USIC_CH_RBCTR_SIZE_Msk) == 0U)
10001838:	687a      	ldr	r2, [r7, #4]
1000183a:	2386      	movs	r3, #134	; 0x86
1000183c:	005b      	lsls	r3, r3, #1
1000183e:	58d2      	ldr	r2, [r2, r3]
10001840:	23e0      	movs	r3, #224	; 0xe0
10001842:	04db      	lsls	r3, r3, #19
10001844:	4013      	ands	r3, r2
10001846:	d105      	bne.n	10001854 <XMC_UART_CH_GetReceivedData+0x24>
  {
    retval = (uint16_t)channel->RBUF;
10001848:	687b      	ldr	r3, [r7, #4]
1000184a:	6d5a      	ldr	r2, [r3, #84]	; 0x54
1000184c:	230e      	movs	r3, #14
1000184e:	18fb      	adds	r3, r7, r3
10001850:	801a      	strh	r2, [r3, #0]
10001852:	e006      	b.n	10001862 <XMC_UART_CH_GetReceivedData+0x32>
  }
  else
  {
    retval = (uint16_t)channel->OUTR;
10001854:	687a      	ldr	r2, [r7, #4]
10001856:	238e      	movs	r3, #142	; 0x8e
10001858:	005b      	lsls	r3, r3, #1
1000185a:	58d2      	ldr	r2, [r2, r3]
1000185c:	230e      	movs	r3, #14
1000185e:	18fb      	adds	r3, r7, r3
10001860:	801a      	strh	r2, [r3, #0]
  }

  return retval;
10001862:	230e      	movs	r3, #14
10001864:	18fb      	adds	r3, r7, r3
10001866:	881b      	ldrh	r3, [r3, #0]
}
10001868:	1c18      	adds	r0, r3, #0
1000186a:	46bd      	mov	sp, r7
1000186c:	b004      	add	sp, #16
1000186e:	bd80      	pop	{r7, pc}

10001870 <XMC_USIC_CH_Enable>:
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

void XMC_USIC_CH_Enable(XMC_USIC_CH_t *const channel)
{
10001870:	b580      	push	{r7, lr}
10001872:	b082      	sub	sp, #8
10001874:	af00      	add	r7, sp, #0
10001876:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_USIC_CH_Enable: channel not valid", XMC_USIC_IsChannelValid(channel));

  if ((channel == XMC_USIC0_CH0) || (channel == XMC_USIC0_CH1))
10001878:	687a      	ldr	r2, [r7, #4]
1000187a:	2390      	movs	r3, #144	; 0x90
1000187c:	05db      	lsls	r3, r3, #23
1000187e:	429a      	cmp	r2, r3
10001880:	d003      	beq.n	1000188a <XMC_USIC_CH_Enable+0x1a>
10001882:	687b      	ldr	r3, [r7, #4]
10001884:	4a0c      	ldr	r2, [pc, #48]	; (100018b8 <XMC_USIC_CH_Enable+0x48>)
10001886:	4293      	cmp	r3, r2
10001888:	d103      	bne.n	10001892 <XMC_USIC_CH_Enable+0x22>
  {
    XMC_USIC_Enable(XMC_USIC0);
1000188a:	4b0c      	ldr	r3, [pc, #48]	; (100018bc <XMC_USIC_CH_Enable+0x4c>)
1000188c:	1c18      	adds	r0, r3, #0
1000188e:	f000 f9fb 	bl	10001c88 <XMC_USIC_Enable>
  {
    XMC_ASSERT("USIC module not available", 0U/*Always*/);
  }

  /* USIC channel switched on*/
  channel->KSCFG = (USIC_CH_KSCFG_MODEN_Msk | USIC_CH_KSCFG_BPMODEN_Msk);
10001892:	687b      	ldr	r3, [r7, #4]
10001894:	2203      	movs	r2, #3
10001896:	60da      	str	r2, [r3, #12]
  while ((channel->KSCFG & USIC_CH_KSCFG_MODEN_Msk) == 0U)
10001898:	46c0      	nop			; (mov r8, r8)
1000189a:	687b      	ldr	r3, [r7, #4]
1000189c:	68db      	ldr	r3, [r3, #12]
1000189e:	2201      	movs	r2, #1
100018a0:	4013      	ands	r3, r2
100018a2:	d0fa      	beq.n	1000189a <XMC_USIC_CH_Enable+0x2a>
  {
    /* Wait till the channel is enabled */
  }

  /* Set USIC channel in IDLE mode */
  channel->CCR &= (uint32_t)~USIC_CH_CCR_MODE_Msk;
100018a4:	687b      	ldr	r3, [r7, #4]
100018a6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
100018a8:	220f      	movs	r2, #15
100018aa:	4393      	bics	r3, r2
100018ac:	1c1a      	adds	r2, r3, #0
100018ae:	687b      	ldr	r3, [r7, #4]
100018b0:	641a      	str	r2, [r3, #64]	; 0x40
}
100018b2:	46bd      	mov	sp, r7
100018b4:	b002      	add	sp, #8
100018b6:	bd80      	pop	{r7, pc}
100018b8:	48000200 	.word	0x48000200
100018bc:	48000008 	.word	0x48000008

100018c0 <XMC_USIC_CH_SetBaudrate>:
{
  channel->KSCFG = (uint32_t)((channel->KSCFG & (~USIC_CH_KSCFG_MODEN_Msk)) | USIC_CH_KSCFG_BPMODEN_Msk);
}

XMC_USIC_CH_STATUS_t XMC_USIC_CH_SetBaudrate(XMC_USIC_CH_t *const channel, uint32_t rate, uint32_t oversampling)
{
100018c0:	b580      	push	{r7, lr}
100018c2:	b08e      	sub	sp, #56	; 0x38
100018c4:	af00      	add	r7, sp, #0
100018c6:	60f8      	str	r0, [r7, #12]
100018c8:	60b9      	str	r1, [r7, #8]
100018ca:	607a      	str	r2, [r7, #4]

  uint32_t pdiv_frac;
  uint32_t pdiv_frac_min;

  /* The rate and peripheral clock are divided by 100 to be able to use only 32bit arithmetic */
  if ((rate >= 100U) && (oversampling != 0U))
100018cc:	68bb      	ldr	r3, [r7, #8]
100018ce:	2b63      	cmp	r3, #99	; 0x63
100018d0:	d960      	bls.n	10001994 <XMC_USIC_CH_SetBaudrate+0xd4>
100018d2:	687b      	ldr	r3, [r7, #4]
100018d4:	2b00      	cmp	r3, #0
100018d6:	d05d      	beq.n	10001994 <XMC_USIC_CH_SetBaudrate+0xd4>
  {
    peripheral_clock = XMC_SCU_CLOCK_GetPeripheralClockFrequency() / 100U;
100018d8:	f7ff fdf0 	bl	100014bc <XMC_SCU_CLOCK_GetPeripheralClockFrequency>
100018dc:	1c03      	adds	r3, r0, #0
100018de:	1c18      	adds	r0, r3, #0
100018e0:	2164      	movs	r1, #100	; 0x64
100018e2:	f003 fc99 	bl	10005218 <__aeabi_uidiv>
100018e6:	1c03      	adds	r3, r0, #0
100018e8:	623b      	str	r3, [r7, #32]
    rate = rate / 100U;
100018ea:	68bb      	ldr	r3, [r7, #8]
100018ec:	1c18      	adds	r0, r3, #0
100018ee:	2164      	movs	r1, #100	; 0x64
100018f0:	f003 fc92 	bl	10005218 <__aeabi_uidiv>
100018f4:	1c03      	adds	r3, r0, #0
100018f6:	60bb      	str	r3, [r7, #8]

    clock_divider_min = 1024U;
100018f8:	2380      	movs	r3, #128	; 0x80
100018fa:	00db      	lsls	r3, r3, #3
100018fc:	62fb      	str	r3, [r7, #44]	; 0x2c
    pdiv_int_min = 1U;
100018fe:	2301      	movs	r3, #1
10001900:	62bb      	str	r3, [r7, #40]	; 0x28
    pdiv_frac_min = 0x3ffU;
10001902:	4b2a      	ldr	r3, [pc, #168]	; (100019ac <XMC_USIC_CH_SetBaudrate+0xec>)
10001904:	627b      	str	r3, [r7, #36]	; 0x24

    for (clock_divider = 1024U; clock_divider > 0U; --clock_divider)
10001906:	2380      	movs	r3, #128	; 0x80
10001908:	00db      	lsls	r3, r3, #3
1000190a:	633b      	str	r3, [r7, #48]	; 0x30
1000190c:	e025      	b.n	1000195a <XMC_USIC_CH_SetBaudrate+0x9a>
    {
      pdiv = ((peripheral_clock * clock_divider) / (rate * oversampling));
1000190e:	6a3b      	ldr	r3, [r7, #32]
10001910:	6b3a      	ldr	r2, [r7, #48]	; 0x30
10001912:	435a      	muls	r2, r3
10001914:	1c11      	adds	r1, r2, #0
10001916:	68bb      	ldr	r3, [r7, #8]
10001918:	687a      	ldr	r2, [r7, #4]
1000191a:	4353      	muls	r3, r2
1000191c:	1c08      	adds	r0, r1, #0
1000191e:	1c19      	adds	r1, r3, #0
10001920:	f003 fc7a 	bl	10005218 <__aeabi_uidiv>
10001924:	1c03      	adds	r3, r0, #0
10001926:	61fb      	str	r3, [r7, #28]
      pdiv_int = pdiv >> 10U;
10001928:	69fb      	ldr	r3, [r7, #28]
1000192a:	0a9b      	lsrs	r3, r3, #10
1000192c:	61bb      	str	r3, [r7, #24]
      pdiv_frac = pdiv & 0x3ffU;
1000192e:	69fb      	ldr	r3, [r7, #28]
10001930:	059b      	lsls	r3, r3, #22
10001932:	0d9b      	lsrs	r3, r3, #22
10001934:	617b      	str	r3, [r7, #20]

      if ((pdiv_int <= 1024U) && (pdiv_frac < pdiv_frac_min))
10001936:	69ba      	ldr	r2, [r7, #24]
10001938:	2380      	movs	r3, #128	; 0x80
1000193a:	00db      	lsls	r3, r3, #3
1000193c:	429a      	cmp	r2, r3
1000193e:	d809      	bhi.n	10001954 <XMC_USIC_CH_SetBaudrate+0x94>
10001940:	697a      	ldr	r2, [r7, #20]
10001942:	6a7b      	ldr	r3, [r7, #36]	; 0x24
10001944:	429a      	cmp	r2, r3
10001946:	d205      	bcs.n	10001954 <XMC_USIC_CH_SetBaudrate+0x94>
      {
        pdiv_frac_min = pdiv_frac;
10001948:	697b      	ldr	r3, [r7, #20]
1000194a:	627b      	str	r3, [r7, #36]	; 0x24
        pdiv_int_min = pdiv_int;
1000194c:	69bb      	ldr	r3, [r7, #24]
1000194e:	62bb      	str	r3, [r7, #40]	; 0x28
        clock_divider_min = clock_divider;
10001950:	6b3b      	ldr	r3, [r7, #48]	; 0x30
10001952:	62fb      	str	r3, [r7, #44]	; 0x2c

    clock_divider_min = 1024U;
    pdiv_int_min = 1U;
    pdiv_frac_min = 0x3ffU;

    for (clock_divider = 1024U; clock_divider > 0U; --clock_divider)
10001954:	6b3b      	ldr	r3, [r7, #48]	; 0x30
10001956:	3b01      	subs	r3, #1
10001958:	633b      	str	r3, [r7, #48]	; 0x30
1000195a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
1000195c:	2b00      	cmp	r3, #0
1000195e:	d1d6      	bne.n	1000190e <XMC_USIC_CH_SetBaudrate+0x4e>
        clock_divider_min = clock_divider;
      }
    }

    channel->FDR = XMC_USIC_CH_BRG_CLOCK_DIVIDER_MODE_FRACTIONAL |
                   ((clock_divider_min - 1) << USIC_CH_FDR_STEP_Pos);
10001960:	6afb      	ldr	r3, [r7, #44]	; 0x2c
10001962:	3b01      	subs	r3, #1
        pdiv_int_min = pdiv_int;
        clock_divider_min = clock_divider;
      }
    }

    channel->FDR = XMC_USIC_CH_BRG_CLOCK_DIVIDER_MODE_FRACTIONAL |
10001964:	2280      	movs	r2, #128	; 0x80
10001966:	0212      	lsls	r2, r2, #8
10001968:	431a      	orrs	r2, r3
1000196a:	68fb      	ldr	r3, [r7, #12]
1000196c:	611a      	str	r2, [r3, #16]
                   ((clock_divider_min - 1) << USIC_CH_FDR_STEP_Pos);

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
1000196e:	68fb      	ldr	r3, [r7, #12]
10001970:	695b      	ldr	r3, [r3, #20]
10001972:	4a0f      	ldr	r2, [pc, #60]	; (100019b0 <XMC_USIC_CH_SetBaudrate+0xf0>)
10001974:	401a      	ands	r2, r3
                                     USIC_CH_BRG_PDIV_Msk |
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
10001976:	687b      	ldr	r3, [r7, #4]
10001978:	3b01      	subs	r3, #1
1000197a:	029b      	lsls	r3, r3, #10
                   ((clock_divider_min - 1) << USIC_CH_FDR_STEP_Pos);

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
                                     USIC_CH_BRG_PDIV_Msk |
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
1000197c:	431a      	orrs	r2, r3
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
                   ((pdiv_int_min - 1U) << USIC_CH_BRG_PDIV_Pos);
1000197e:	6abb      	ldr	r3, [r7, #40]	; 0x28
10001980:	3b01      	subs	r3, #1
10001982:	041b      	lsls	r3, r3, #16

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
                                     USIC_CH_BRG_PDIV_Msk |
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
10001984:	431a      	orrs	r2, r3
    }

    channel->FDR = XMC_USIC_CH_BRG_CLOCK_DIVIDER_MODE_FRACTIONAL |
                   ((clock_divider_min - 1) << USIC_CH_FDR_STEP_Pos);

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
10001986:	68fb      	ldr	r3, [r7, #12]
10001988:	615a      	str	r2, [r3, #20]
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
                   ((pdiv_int_min - 1U) << USIC_CH_BRG_PDIV_Pos);

    status = XMC_USIC_CH_STATUS_OK;
1000198a:	2337      	movs	r3, #55	; 0x37
1000198c:	18fb      	adds	r3, r7, r3
1000198e:	2200      	movs	r2, #0
10001990:	701a      	strb	r2, [r3, #0]
10001992:	e003      	b.n	1000199c <XMC_USIC_CH_SetBaudrate+0xdc>
  }
  else
  {
    status = XMC_USIC_CH_STATUS_ERROR;
10001994:	2337      	movs	r3, #55	; 0x37
10001996:	18fb      	adds	r3, r7, r3
10001998:	2201      	movs	r2, #1
1000199a:	701a      	strb	r2, [r3, #0]
  }

  return status;
1000199c:	2337      	movs	r3, #55	; 0x37
1000199e:	18fb      	adds	r3, r7, r3
100019a0:	781b      	ldrb	r3, [r3, #0]
}
100019a2:	1c18      	adds	r0, r3, #0
100019a4:	46bd      	mov	sp, r7
100019a6:	b00e      	add	sp, #56	; 0x38
100019a8:	bd80      	pop	{r7, pc}
100019aa:	46c0      	nop			; (mov r8, r8)
100019ac:	000003ff 	.word	0x000003ff
100019b0:	fc0080ef 	.word	0xfc0080ef

100019b4 <XMC_USIC_CH_SetBaudrateEx>:

XMC_USIC_CH_STATUS_t XMC_USIC_CH_SetBaudrateEx(XMC_USIC_CH_t *const channel, int32_t rate, int32_t oversampling)
{
100019b4:	b580      	push	{r7, lr}
100019b6:	b08c      	sub	sp, #48	; 0x30
100019b8:	af00      	add	r7, sp, #0
100019ba:	60f8      	str	r0, [r7, #12]
100019bc:	60b9      	str	r1, [r7, #8]
100019be:	607a      	str	r2, [r7, #4]
  int32_t peripheral_clock = XMC_SCU_CLOCK_GetPeripheralClockFrequency();
100019c0:	f7ff fd7c 	bl	100014bc <XMC_SCU_CLOCK_GetPeripheralClockFrequency>
100019c4:	1c03      	adds	r3, r0, #0
100019c6:	623b      	str	r3, [r7, #32]
  int32_t brg_clock = rate * oversampling;
100019c8:	68bb      	ldr	r3, [r7, #8]
100019ca:	687a      	ldr	r2, [r7, #4]
100019cc:	4353      	muls	r3, r2
100019ce:	61fb      	str	r3, [r7, #28]
  int32_t actual_rate_upper;
  int32_t actual_rate_lower;
  uint32_t pdiv = 1;
100019d0:	2301      	movs	r3, #1
100019d2:	62fb      	str	r3, [r7, #44]	; 0x2c
  uint32_t divider_step;
  XMC_USIC_CH_STATUS_t status;

  if (peripheral_clock > brg_clock)
100019d4:	6a3a      	ldr	r2, [r7, #32]
100019d6:	69fb      	ldr	r3, [r7, #28]
100019d8:	429a      	cmp	r2, r3
100019da:	dd62      	ble.n	10001aa2 <XMC_USIC_CH_SetBaudrateEx+0xee>
  {
    divider_step = peripheral_clock / brg_clock; // integer division gets truncated
100019dc:	6a38      	ldr	r0, [r7, #32]
100019de:	69f9      	ldr	r1, [r7, #28]
100019e0:	f003 fcaa 	bl	10005338 <__aeabi_idiv>
100019e4:	1c03      	adds	r3, r0, #0
100019e6:	62bb      	str	r3, [r7, #40]	; 0x28
    while (divider_step >= 1023)
100019e8:	e00f      	b.n	10001a0a <XMC_USIC_CH_SetBaudrateEx+0x56>
    {
      pdiv++;
100019ea:	6afb      	ldr	r3, [r7, #44]	; 0x2c
100019ec:	3301      	adds	r3, #1
100019ee:	62fb      	str	r3, [r7, #44]	; 0x2c
      brg_clock = rate * oversampling * pdiv;
100019f0:	68bb      	ldr	r3, [r7, #8]
100019f2:	687a      	ldr	r2, [r7, #4]
100019f4:	4353      	muls	r3, r2
100019f6:	1c1a      	adds	r2, r3, #0
100019f8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
100019fa:	4353      	muls	r3, r2
100019fc:	61fb      	str	r3, [r7, #28]
      divider_step = peripheral_clock / brg_clock; // integer division gets truncated
100019fe:	6a38      	ldr	r0, [r7, #32]
10001a00:	69f9      	ldr	r1, [r7, #28]
10001a02:	f003 fc99 	bl	10005338 <__aeabi_idiv>
10001a06:	1c03      	adds	r3, r0, #0
10001a08:	62bb      	str	r3, [r7, #40]	; 0x28
  XMC_USIC_CH_STATUS_t status;

  if (peripheral_clock > brg_clock)
  {
    divider_step = peripheral_clock / brg_clock; // integer division gets truncated
    while (divider_step >= 1023)
10001a0a:	6abb      	ldr	r3, [r7, #40]	; 0x28
10001a0c:	4a2a      	ldr	r2, [pc, #168]	; (10001ab8 <XMC_USIC_CH_SetBaudrateEx+0x104>)
10001a0e:	4293      	cmp	r3, r2
10001a10:	d8eb      	bhi.n	100019ea <XMC_USIC_CH_SetBaudrateEx+0x36>
    {
      pdiv++;
      brg_clock = rate * oversampling * pdiv;
      divider_step = peripheral_clock / brg_clock; // integer division gets truncated
    }
    actual_rate_upper = peripheral_clock / (divider_step * oversampling * pdiv);
10001a12:	6a39      	ldr	r1, [r7, #32]
10001a14:	687b      	ldr	r3, [r7, #4]
10001a16:	6aba      	ldr	r2, [r7, #40]	; 0x28
10001a18:	4353      	muls	r3, r2
10001a1a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
10001a1c:	4353      	muls	r3, r2
10001a1e:	1c08      	adds	r0, r1, #0
10001a20:	1c19      	adds	r1, r3, #0
10001a22:	f003 fbf9 	bl	10005218 <__aeabi_uidiv>
10001a26:	1c03      	adds	r3, r0, #0
10001a28:	61bb      	str	r3, [r7, #24]
    actual_rate_lower = peripheral_clock / ((divider_step + 1) * oversampling * pdiv);
10001a2a:	6a39      	ldr	r1, [r7, #32]
10001a2c:	6abb      	ldr	r3, [r7, #40]	; 0x28
10001a2e:	3301      	adds	r3, #1
10001a30:	687a      	ldr	r2, [r7, #4]
10001a32:	4353      	muls	r3, r2
10001a34:	6afa      	ldr	r2, [r7, #44]	; 0x2c
10001a36:	4353      	muls	r3, r2
10001a38:	1c08      	adds	r0, r1, #0
10001a3a:	1c19      	adds	r1, r3, #0
10001a3c:	f003 fbec 	bl	10005218 <__aeabi_uidiv>
10001a40:	1c03      	adds	r3, r0, #0
10001a42:	617b      	str	r3, [r7, #20]

    // choose better approximation if the peripheral frequency is not a multiple of the baudrate
    if (abs(rate - actual_rate_lower) < abs(rate - actual_rate_upper))
10001a44:	68ba      	ldr	r2, [r7, #8]
10001a46:	697b      	ldr	r3, [r7, #20]
10001a48:	1ad3      	subs	r3, r2, r3
10001a4a:	17d9      	asrs	r1, r3, #31
10001a4c:	185a      	adds	r2, r3, r1
10001a4e:	404a      	eors	r2, r1
10001a50:	68b9      	ldr	r1, [r7, #8]
10001a52:	69bb      	ldr	r3, [r7, #24]
10001a54:	1acb      	subs	r3, r1, r3
10001a56:	17d9      	asrs	r1, r3, #31
10001a58:	185b      	adds	r3, r3, r1
10001a5a:	404b      	eors	r3, r1
10001a5c:	429a      	cmp	r2, r3
10001a5e:	da02      	bge.n	10001a66 <XMC_USIC_CH_SetBaudrateEx+0xb2>
    {
      divider_step += 1;
10001a60:	6abb      	ldr	r3, [r7, #40]	; 0x28
10001a62:	3301      	adds	r3, #1
10001a64:	62bb      	str	r3, [r7, #40]	; 0x28
    }

    divider_step = 1024 - divider_step;
10001a66:	6abb      	ldr	r3, [r7, #40]	; 0x28
10001a68:	2280      	movs	r2, #128	; 0x80
10001a6a:	00d2      	lsls	r2, r2, #3
10001a6c:	1ad3      	subs	r3, r2, r3
10001a6e:	62bb      	str	r3, [r7, #40]	; 0x28


    channel->FDR = XMC_USIC_CH_BRG_CLOCK_DIVIDER_MODE_NORMAL |
10001a70:	6abb      	ldr	r3, [r7, #40]	; 0x28
10001a72:	2280      	movs	r2, #128	; 0x80
10001a74:	01d2      	lsls	r2, r2, #7
10001a76:	431a      	orrs	r2, r3
10001a78:	68fb      	ldr	r3, [r7, #12]
10001a7a:	611a      	str	r2, [r3, #16]
                   (divider_step << USIC_CH_FDR_STEP_Pos);

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
10001a7c:	68fb      	ldr	r3, [r7, #12]
10001a7e:	695b      	ldr	r3, [r3, #20]
10001a80:	4a0e      	ldr	r2, [pc, #56]	; (10001abc <XMC_USIC_CH_SetBaudrateEx+0x108>)
10001a82:	401a      	ands	r2, r3
                                     USIC_CH_BRG_PDIV_Msk |
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
10001a84:	687b      	ldr	r3, [r7, #4]
10001a86:	3b01      	subs	r3, #1
10001a88:	029b      	lsls	r3, r3, #10
                   (divider_step << USIC_CH_FDR_STEP_Pos);

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
                                     USIC_CH_BRG_PDIV_Msk |
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
10001a8a:	431a      	orrs	r2, r3
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
                   ((pdiv - 1) << USIC_CH_BRG_PDIV_Pos);
10001a8c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
10001a8e:	3b01      	subs	r3, #1
10001a90:	041b      	lsls	r3, r3, #16

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
                                     USIC_CH_BRG_PDIV_Msk |
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
10001a92:	431a      	orrs	r2, r3


    channel->FDR = XMC_USIC_CH_BRG_CLOCK_DIVIDER_MODE_NORMAL |
                   (divider_step << USIC_CH_FDR_STEP_Pos);

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
10001a94:	68fb      	ldr	r3, [r7, #12]
10001a96:	615a      	str	r2, [r3, #20]
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
                   ((pdiv - 1) << USIC_CH_BRG_PDIV_Pos);

    status = XMC_USIC_CH_STATUS_OK;
10001a98:	2327      	movs	r3, #39	; 0x27
10001a9a:	18fb      	adds	r3, r7, r3
10001a9c:	2200      	movs	r2, #0
10001a9e:	701a      	strb	r2, [r3, #0]
10001aa0:	e003      	b.n	10001aaa <XMC_USIC_CH_SetBaudrateEx+0xf6>
  }
  else
  {
    status = XMC_USIC_CH_STATUS_ERROR;
10001aa2:	2327      	movs	r3, #39	; 0x27
10001aa4:	18fb      	adds	r3, r7, r3
10001aa6:	2201      	movs	r2, #1
10001aa8:	701a      	strb	r2, [r3, #0]
  }

  return status;
10001aaa:	2327      	movs	r3, #39	; 0x27
10001aac:	18fb      	adds	r3, r7, r3
10001aae:	781b      	ldrb	r3, [r3, #0]
}
10001ab0:	1c18      	adds	r0, r3, #0
10001ab2:	46bd      	mov	sp, r7
10001ab4:	b00c      	add	sp, #48	; 0x30
10001ab6:	bd80      	pop	{r7, pc}
10001ab8:	000003fe 	.word	0x000003fe
10001abc:	fc0080ef 	.word	0xfc0080ef

10001ac0 <XMC_USIC_CH_TXFIFO_Configure>:

void XMC_USIC_CH_TXFIFO_Configure(XMC_USIC_CH_t *const channel,
                                  const uint32_t data_pointer,
                                  const XMC_USIC_CH_FIFO_SIZE_t size,
                                  const uint32_t limit)
{
10001ac0:	b580      	push	{r7, lr}
10001ac2:	b084      	sub	sp, #16
10001ac4:	af00      	add	r7, sp, #0
10001ac6:	60f8      	str	r0, [r7, #12]
10001ac8:	60b9      	str	r1, [r7, #8]
10001aca:	603b      	str	r3, [r7, #0]
10001acc:	1dfb      	adds	r3, r7, #7
10001ace:	701a      	strb	r2, [r3, #0]
  /* Disable FIFO */
  channel->TBCTR &= (uint32_t)~USIC_CH_TBCTR_SIZE_Msk;
10001ad0:	68fa      	ldr	r2, [r7, #12]
10001ad2:	2384      	movs	r3, #132	; 0x84
10001ad4:	005b      	lsls	r3, r3, #1
10001ad6:	58d3      	ldr	r3, [r2, r3]
10001ad8:	4a0e      	ldr	r2, [pc, #56]	; (10001b14 <XMC_USIC_CH_TXFIFO_Configure+0x54>)
10001ada:	4013      	ands	r3, r2
10001adc:	1c19      	adds	r1, r3, #0
10001ade:	68fa      	ldr	r2, [r7, #12]
10001ae0:	2384      	movs	r3, #132	; 0x84
10001ae2:	005b      	lsls	r3, r3, #1
10001ae4:	50d1      	str	r1, [r2, r3]
  /* LOF = 0, A standard transmit buffer event occurs when the filling level equals the limit value and gets
   * lower due to transmission of a data word
   * STBTEN = 0, the trigger of the standard transmit buffer event is based on the transition of the fill level
   *  from equal to below the limit, not the fact being below
   */
  channel->TBCTR = (uint32_t)(channel->TBCTR & (uint32_t)~(USIC_CH_TBCTR_LIMIT_Msk |
10001ae6:	68fa      	ldr	r2, [r7, #12]
10001ae8:	2384      	movs	r3, #132	; 0x84
10001aea:	005b      	lsls	r3, r3, #1
10001aec:	58d3      	ldr	r3, [r2, r3]
10001aee:	4a0a      	ldr	r2, [pc, #40]	; (10001b18 <XMC_USIC_CH_TXFIFO_Configure+0x58>)
10001af0:	401a      	ands	r2, r3
                              USIC_CH_TBCTR_DPTR_Msk |
                              USIC_CH_TBCTR_SIZE_Msk)) |
                   (uint32_t)((limit << USIC_CH_TBCTR_LIMIT_Pos) |
10001af2:	683b      	ldr	r3, [r7, #0]
10001af4:	0219      	lsls	r1, r3, #8
10001af6:	68bb      	ldr	r3, [r7, #8]
10001af8:	4319      	orrs	r1, r3
                              (data_pointer << USIC_CH_TBCTR_DPTR_Pos) |
                              ((uint32_t)size << USIC_CH_TBCTR_SIZE_Pos));
10001afa:	1dfb      	adds	r3, r7, #7
10001afc:	781b      	ldrb	r3, [r3, #0]
10001afe:	061b      	lsls	r3, r3, #24
   *  from equal to below the limit, not the fact being below
   */
  channel->TBCTR = (uint32_t)(channel->TBCTR & (uint32_t)~(USIC_CH_TBCTR_LIMIT_Msk |
                              USIC_CH_TBCTR_DPTR_Msk |
                              USIC_CH_TBCTR_SIZE_Msk)) |
                   (uint32_t)((limit << USIC_CH_TBCTR_LIMIT_Pos) |
10001b00:	430b      	orrs	r3, r1
   * STBTEN = 0, the trigger of the standard transmit buffer event is based on the transition of the fill level
   *  from equal to below the limit, not the fact being below
   */
  channel->TBCTR = (uint32_t)(channel->TBCTR & (uint32_t)~(USIC_CH_TBCTR_LIMIT_Msk |
                              USIC_CH_TBCTR_DPTR_Msk |
                              USIC_CH_TBCTR_SIZE_Msk)) |
10001b02:	431a      	orrs	r2, r3
10001b04:	1c11      	adds	r1, r2, #0
  /* LOF = 0, A standard transmit buffer event occurs when the filling level equals the limit value and gets
   * lower due to transmission of a data word
   * STBTEN = 0, the trigger of the standard transmit buffer event is based on the transition of the fill level
   *  from equal to below the limit, not the fact being below
   */
  channel->TBCTR = (uint32_t)(channel->TBCTR & (uint32_t)~(USIC_CH_TBCTR_LIMIT_Msk |
10001b06:	68fa      	ldr	r2, [r7, #12]
10001b08:	2384      	movs	r3, #132	; 0x84
10001b0a:	005b      	lsls	r3, r3, #1
10001b0c:	50d1      	str	r1, [r2, r3]
                              USIC_CH_TBCTR_DPTR_Msk |
                              USIC_CH_TBCTR_SIZE_Msk)) |
                   (uint32_t)((limit << USIC_CH_TBCTR_LIMIT_Pos) |
                              (data_pointer << USIC_CH_TBCTR_DPTR_Pos) |
                              ((uint32_t)size << USIC_CH_TBCTR_SIZE_Pos));
}
10001b0e:	46bd      	mov	sp, r7
10001b10:	b004      	add	sp, #16
10001b12:	bd80      	pop	{r7, pc}
10001b14:	f8ffffff 	.word	0xf8ffffff
10001b18:	f8ffc0c0 	.word	0xf8ffc0c0

10001b1c <XMC_USIC_CH_RXFIFO_Configure>:

void XMC_USIC_CH_RXFIFO_Configure(XMC_USIC_CH_t *const channel,
                                  const uint32_t data_pointer,
                                  const XMC_USIC_CH_FIFO_SIZE_t size,
                                  const uint32_t limit)
{
10001b1c:	b580      	push	{r7, lr}
10001b1e:	b084      	sub	sp, #16
10001b20:	af00      	add	r7, sp, #0
10001b22:	60f8      	str	r0, [r7, #12]
10001b24:	60b9      	str	r1, [r7, #8]
10001b26:	603b      	str	r3, [r7, #0]
10001b28:	1dfb      	adds	r3, r7, #7
10001b2a:	701a      	strb	r2, [r3, #0]
  /* Disable FIFO */
  channel->RBCTR &= (uint32_t)~USIC_CH_RBCTR_SIZE_Msk;
10001b2c:	68fa      	ldr	r2, [r7, #12]
10001b2e:	2386      	movs	r3, #134	; 0x86
10001b30:	005b      	lsls	r3, r3, #1
10001b32:	58d3      	ldr	r3, [r2, r3]
10001b34:	4a10      	ldr	r2, [pc, #64]	; (10001b78 <XMC_USIC_CH_RXFIFO_Configure+0x5c>)
10001b36:	4013      	ands	r3, r2
10001b38:	1c19      	adds	r1, r3, #0
10001b3a:	68fa      	ldr	r2, [r7, #12]
10001b3c:	2386      	movs	r3, #134	; 0x86
10001b3e:	005b      	lsls	r3, r3, #1
10001b40:	50d1      	str	r1, [r2, r3]

  /* LOF = 1, A standard receive buffer event occurs when the filling level equals the limit value and gets bigger
   *  due to the reception of a new data word
   */
  channel->RBCTR = (uint32_t)((channel->RBCTR & (uint32_t)~(USIC_CH_RBCTR_LIMIT_Msk |
10001b42:	68fa      	ldr	r2, [r7, #12]
10001b44:	2386      	movs	r3, #134	; 0x86
10001b46:	005b      	lsls	r3, r3, #1
10001b48:	58d3      	ldr	r3, [r2, r3]
10001b4a:	4a0c      	ldr	r2, [pc, #48]	; (10001b7c <XMC_USIC_CH_RXFIFO_Configure+0x60>)
10001b4c:	401a      	ands	r2, r3
                               USIC_CH_RBCTR_DPTR_Msk |
                               USIC_CH_RBCTR_LOF_Msk)) |
                              ((limit << USIC_CH_RBCTR_LIMIT_Pos) |
10001b4e:	683b      	ldr	r3, [r7, #0]
10001b50:	0219      	lsls	r1, r3, #8
10001b52:	68bb      	ldr	r3, [r7, #8]
10001b54:	4319      	orrs	r1, r3
                               (data_pointer << USIC_CH_RBCTR_DPTR_Pos) |
                               ((uint32_t)size << USIC_CH_RBCTR_SIZE_Pos) |
10001b56:	1dfb      	adds	r3, r7, #7
10001b58:	781b      	ldrb	r3, [r3, #0]
10001b5a:	061b      	lsls	r3, r3, #24
   */
  channel->RBCTR = (uint32_t)((channel->RBCTR & (uint32_t)~(USIC_CH_RBCTR_LIMIT_Msk |
                               USIC_CH_RBCTR_DPTR_Msk |
                               USIC_CH_RBCTR_LOF_Msk)) |
                              ((limit << USIC_CH_RBCTR_LIMIT_Pos) |
                               (data_pointer << USIC_CH_RBCTR_DPTR_Pos) |
10001b5c:	430b      	orrs	r3, r1
  channel->RBCTR &= (uint32_t)~USIC_CH_RBCTR_SIZE_Msk;

  /* LOF = 1, A standard receive buffer event occurs when the filling level equals the limit value and gets bigger
   *  due to the reception of a new data word
   */
  channel->RBCTR = (uint32_t)((channel->RBCTR & (uint32_t)~(USIC_CH_RBCTR_LIMIT_Msk |
10001b5e:	4313      	orrs	r3, r2
10001b60:	2280      	movs	r2, #128	; 0x80
10001b62:	0552      	lsls	r2, r2, #21
10001b64:	431a      	orrs	r2, r3
10001b66:	1c11      	adds	r1, r2, #0
10001b68:	68fa      	ldr	r2, [r7, #12]
10001b6a:	2386      	movs	r3, #134	; 0x86
10001b6c:	005b      	lsls	r3, r3, #1
10001b6e:	50d1      	str	r1, [r2, r3]
                               USIC_CH_RBCTR_LOF_Msk)) |
                              ((limit << USIC_CH_RBCTR_LIMIT_Pos) |
                               (data_pointer << USIC_CH_RBCTR_DPTR_Pos) |
                               ((uint32_t)size << USIC_CH_RBCTR_SIZE_Pos) |
                               (uint32_t)USIC_CH_RBCTR_LOF_Msk));
}
10001b70:	46bd      	mov	sp, r7
10001b72:	b004      	add	sp, #16
10001b74:	bd80      	pop	{r7, pc}
10001b76:	46c0      	nop			; (mov r8, r8)
10001b78:	f8ffffff 	.word	0xf8ffffff
10001b7c:	efffc0c0 	.word	0xefffc0c0

10001b80 <XMC_USIC_CH_RXFIFO_SetSizeTriggerLimit>:
}

void XMC_USIC_CH_RXFIFO_SetSizeTriggerLimit(XMC_USIC_CH_t *const channel,
    const XMC_USIC_CH_FIFO_SIZE_t size,
    const uint32_t limit)
{
10001b80:	b580      	push	{r7, lr}
10001b82:	b084      	sub	sp, #16
10001b84:	af00      	add	r7, sp, #0
10001b86:	60f8      	str	r0, [r7, #12]
10001b88:	607a      	str	r2, [r7, #4]
10001b8a:	230b      	movs	r3, #11
10001b8c:	18fb      	adds	r3, r7, r3
10001b8e:	1c0a      	adds	r2, r1, #0
10001b90:	701a      	strb	r2, [r3, #0]
  XMC_UNUSED_ARG(size);

  channel->RBCTR = (uint32_t)((uint32_t)(channel->RBCTR & (uint32_t)~USIC_CH_RBCTR_LIMIT_Msk) |
10001b92:	68fa      	ldr	r2, [r7, #12]
10001b94:	2386      	movs	r3, #134	; 0x86
10001b96:	005b      	lsls	r3, r3, #1
10001b98:	58d3      	ldr	r3, [r2, r3]
10001b9a:	4a06      	ldr	r2, [pc, #24]	; (10001bb4 <XMC_USIC_CH_RXFIFO_SetSizeTriggerLimit+0x34>)
10001b9c:	401a      	ands	r2, r3
                              (limit << USIC_CH_RBCTR_LIMIT_Pos));
10001b9e:	687b      	ldr	r3, [r7, #4]
10001ba0:	021b      	lsls	r3, r3, #8
    const XMC_USIC_CH_FIFO_SIZE_t size,
    const uint32_t limit)
{
  XMC_UNUSED_ARG(size);

  channel->RBCTR = (uint32_t)((uint32_t)(channel->RBCTR & (uint32_t)~USIC_CH_RBCTR_LIMIT_Msk) |
10001ba2:	431a      	orrs	r2, r3
10001ba4:	1c11      	adds	r1, r2, #0
10001ba6:	68fa      	ldr	r2, [r7, #12]
10001ba8:	2386      	movs	r3, #134	; 0x86
10001baa:	005b      	lsls	r3, r3, #1
10001bac:	50d1      	str	r1, [r2, r3]
                              (limit << USIC_CH_RBCTR_LIMIT_Pos));
}
10001bae:	46bd      	mov	sp, r7
10001bb0:	b004      	add	sp, #16
10001bb2:	bd80      	pop	{r7, pc}
10001bb4:	ffffc0ff 	.word	0xffffc0ff

10001bb8 <XMC_USIC_CH_SetInterruptNodePointer>:

void XMC_USIC_CH_SetInterruptNodePointer(XMC_USIC_CH_t *const channel,
    const XMC_USIC_CH_INTERRUPT_NODE_POINTER_t interrupt_node,
    const uint32_t service_request)
{
10001bb8:	b580      	push	{r7, lr}
10001bba:	b084      	sub	sp, #16
10001bbc:	af00      	add	r7, sp, #0
10001bbe:	60f8      	str	r0, [r7, #12]
10001bc0:	607a      	str	r2, [r7, #4]
10001bc2:	230b      	movs	r3, #11
10001bc4:	18fb      	adds	r3, r7, r3
10001bc6:	1c0a      	adds	r2, r1, #0
10001bc8:	701a      	strb	r2, [r3, #0]
  channel->INPR = (uint32_t)((channel->INPR & (~(uint32_t)(USIC_CH_INPR_Msk << (uint32_t)interrupt_node))) |
10001bca:	68fb      	ldr	r3, [r7, #12]
10001bcc:	699b      	ldr	r3, [r3, #24]
10001bce:	220b      	movs	r2, #11
10001bd0:	18ba      	adds	r2, r7, r2
10001bd2:	7812      	ldrb	r2, [r2, #0]
10001bd4:	2107      	movs	r1, #7
10001bd6:	4091      	lsls	r1, r2
10001bd8:	1c0a      	adds	r2, r1, #0
10001bda:	43d2      	mvns	r2, r2
10001bdc:	401a      	ands	r2, r3
                             (service_request << (uint32_t)interrupt_node));
10001bde:	230b      	movs	r3, #11
10001be0:	18fb      	adds	r3, r7, r3
10001be2:	781b      	ldrb	r3, [r3, #0]
10001be4:	6879      	ldr	r1, [r7, #4]
10001be6:	4099      	lsls	r1, r3
10001be8:	1c0b      	adds	r3, r1, #0

void XMC_USIC_CH_SetInterruptNodePointer(XMC_USIC_CH_t *const channel,
    const XMC_USIC_CH_INTERRUPT_NODE_POINTER_t interrupt_node,
    const uint32_t service_request)
{
  channel->INPR = (uint32_t)((channel->INPR & (~(uint32_t)(USIC_CH_INPR_Msk << (uint32_t)interrupt_node))) |
10001bea:	431a      	orrs	r2, r3
10001bec:	68fb      	ldr	r3, [r7, #12]
10001bee:	619a      	str	r2, [r3, #24]
                             (service_request << (uint32_t)interrupt_node));
}
10001bf0:	46bd      	mov	sp, r7
10001bf2:	b004      	add	sp, #16
10001bf4:	bd80      	pop	{r7, pc}
10001bf6:	46c0      	nop			; (mov r8, r8)

10001bf8 <XMC_USIC_CH_TXFIFO_SetInterruptNodePointer>:

void XMC_USIC_CH_TXFIFO_SetInterruptNodePointer(XMC_USIC_CH_t *const channel,
    const XMC_USIC_CH_TXFIFO_INTERRUPT_NODE_POINTER_t interrupt_node,
    const uint32_t service_request)
{
10001bf8:	b580      	push	{r7, lr}
10001bfa:	b084      	sub	sp, #16
10001bfc:	af00      	add	r7, sp, #0
10001bfe:	60f8      	str	r0, [r7, #12]
10001c00:	607a      	str	r2, [r7, #4]
10001c02:	230b      	movs	r3, #11
10001c04:	18fb      	adds	r3, r7, r3
10001c06:	1c0a      	adds	r2, r1, #0
10001c08:	701a      	strb	r2, [r3, #0]
  channel->TBCTR = (uint32_t)((channel->TBCTR & (~(uint32_t)(USIC_CH_INPR_Msk << (uint32_t)interrupt_node))) |
10001c0a:	68fa      	ldr	r2, [r7, #12]
10001c0c:	2384      	movs	r3, #132	; 0x84
10001c0e:	005b      	lsls	r3, r3, #1
10001c10:	58d3      	ldr	r3, [r2, r3]
10001c12:	220b      	movs	r2, #11
10001c14:	18ba      	adds	r2, r7, r2
10001c16:	7812      	ldrb	r2, [r2, #0]
10001c18:	2107      	movs	r1, #7
10001c1a:	4091      	lsls	r1, r2
10001c1c:	1c0a      	adds	r2, r1, #0
10001c1e:	43d2      	mvns	r2, r2
10001c20:	401a      	ands	r2, r3
                              (service_request << (uint32_t)interrupt_node));
10001c22:	230b      	movs	r3, #11
10001c24:	18fb      	adds	r3, r7, r3
10001c26:	781b      	ldrb	r3, [r3, #0]
10001c28:	6879      	ldr	r1, [r7, #4]
10001c2a:	4099      	lsls	r1, r3
10001c2c:	1c0b      	adds	r3, r1, #0

void XMC_USIC_CH_TXFIFO_SetInterruptNodePointer(XMC_USIC_CH_t *const channel,
    const XMC_USIC_CH_TXFIFO_INTERRUPT_NODE_POINTER_t interrupt_node,
    const uint32_t service_request)
{
  channel->TBCTR = (uint32_t)((channel->TBCTR & (~(uint32_t)(USIC_CH_INPR_Msk << (uint32_t)interrupt_node))) |
10001c2e:	431a      	orrs	r2, r3
10001c30:	1c11      	adds	r1, r2, #0
10001c32:	68fa      	ldr	r2, [r7, #12]
10001c34:	2384      	movs	r3, #132	; 0x84
10001c36:	005b      	lsls	r3, r3, #1
10001c38:	50d1      	str	r1, [r2, r3]
                              (service_request << (uint32_t)interrupt_node));
}
10001c3a:	46bd      	mov	sp, r7
10001c3c:	b004      	add	sp, #16
10001c3e:	bd80      	pop	{r7, pc}

10001c40 <XMC_USIC_CH_RXFIFO_SetInterruptNodePointer>:

void XMC_USIC_CH_RXFIFO_SetInterruptNodePointer(XMC_USIC_CH_t *const channel,
    const XMC_USIC_CH_RXFIFO_INTERRUPT_NODE_POINTER_t interrupt_node,
    const uint32_t service_request)
{
10001c40:	b580      	push	{r7, lr}
10001c42:	b084      	sub	sp, #16
10001c44:	af00      	add	r7, sp, #0
10001c46:	60f8      	str	r0, [r7, #12]
10001c48:	607a      	str	r2, [r7, #4]
10001c4a:	230b      	movs	r3, #11
10001c4c:	18fb      	adds	r3, r7, r3
10001c4e:	1c0a      	adds	r2, r1, #0
10001c50:	701a      	strb	r2, [r3, #0]
  channel->RBCTR = (uint32_t)((channel->RBCTR & (~(uint32_t)(USIC_CH_INPR_Msk << (uint32_t)interrupt_node))) |
10001c52:	68fa      	ldr	r2, [r7, #12]
10001c54:	2386      	movs	r3, #134	; 0x86
10001c56:	005b      	lsls	r3, r3, #1
10001c58:	58d3      	ldr	r3, [r2, r3]
10001c5a:	220b      	movs	r2, #11
10001c5c:	18ba      	adds	r2, r7, r2
10001c5e:	7812      	ldrb	r2, [r2, #0]
10001c60:	2107      	movs	r1, #7
10001c62:	4091      	lsls	r1, r2
10001c64:	1c0a      	adds	r2, r1, #0
10001c66:	43d2      	mvns	r2, r2
10001c68:	401a      	ands	r2, r3
                              (service_request << (uint32_t)interrupt_node));
10001c6a:	230b      	movs	r3, #11
10001c6c:	18fb      	adds	r3, r7, r3
10001c6e:	781b      	ldrb	r3, [r3, #0]
10001c70:	6879      	ldr	r1, [r7, #4]
10001c72:	4099      	lsls	r1, r3
10001c74:	1c0b      	adds	r3, r1, #0

void XMC_USIC_CH_RXFIFO_SetInterruptNodePointer(XMC_USIC_CH_t *const channel,
    const XMC_USIC_CH_RXFIFO_INTERRUPT_NODE_POINTER_t interrupt_node,
    const uint32_t service_request)
{
  channel->RBCTR = (uint32_t)((channel->RBCTR & (~(uint32_t)(USIC_CH_INPR_Msk << (uint32_t)interrupt_node))) |
10001c76:	431a      	orrs	r2, r3
10001c78:	1c11      	adds	r1, r2, #0
10001c7a:	68fa      	ldr	r2, [r7, #12]
10001c7c:	2386      	movs	r3, #134	; 0x86
10001c7e:	005b      	lsls	r3, r3, #1
10001c80:	50d1      	str	r1, [r2, r3]
                              (service_request << (uint32_t)interrupt_node));
}
10001c82:	46bd      	mov	sp, r7
10001c84:	b004      	add	sp, #16
10001c86:	bd80      	pop	{r7, pc}

10001c88 <XMC_USIC_Enable>:

void XMC_USIC_Enable(XMC_USIC_t *const usic)
{
10001c88:	b580      	push	{r7, lr}
10001c8a:	b082      	sub	sp, #8
10001c8c:	af00      	add	r7, sp, #0
10001c8e:	6078      	str	r0, [r7, #4]
  if (usic == USIC0)
10001c90:	687b      	ldr	r3, [r7, #4]
10001c92:	4a07      	ldr	r2, [pc, #28]	; (10001cb0 <XMC_USIC_Enable+0x28>)
10001c94:	4293      	cmp	r3, r2
10001c96:	d108      	bne.n	10001caa <XMC_USIC_Enable+0x22>
  {
#if defined(CLOCK_GATING_SUPPORTED)
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_USIC0);
10001c98:	2008      	movs	r0, #8
10001c9a:	f7ff fb33 	bl	10001304 <XMC_SCU_CLOCK_UngatePeripheralClock>
    while (XMC_SCU_CLOCK_IsPeripheralClockGated(XMC_SCU_PERIPHERAL_CLOCK_USIC0));
10001c9e:	46c0      	nop			; (mov r8, r8)
10001ca0:	2008      	movs	r0, #8
10001ca2:	f7ff fb4d 	bl	10001340 <XMC_SCU_CLOCK_IsPeripheralClockGated>
10001ca6:	1e03      	subs	r3, r0, #0
10001ca8:	d1fa      	bne.n	10001ca0 <XMC_USIC_Enable+0x18>
#endif
  else
  {
    XMC_ASSERT("USIC module not available", 0/*Always*/);
  }
}
10001caa:	46bd      	mov	sp, r7
10001cac:	b002      	add	sp, #8
10001cae:	bd80      	pop	{r7, pc}
10001cb0:	48000008 	.word	0x48000008

10001cb4 <_sbrk>:

// defined in linker script
extern caddr_t Heap_Bank1_Start;
extern caddr_t Heap_Bank1_End;
caddr_t _sbrk(int nbytes)
{
10001cb4:	b580      	push	{r7, lr}
10001cb6:	b084      	sub	sp, #16
10001cb8:	af00      	add	r7, sp, #0
10001cba:	6078      	str	r0, [r7, #4]
  static caddr_t heap_ptr = NULL;
  caddr_t base;

  if (heap_ptr == NULL) {
10001cbc:	4b14      	ldr	r3, [pc, #80]	; (10001d10 <_sbrk+0x5c>)
10001cbe:	681b      	ldr	r3, [r3, #0]
10001cc0:	2b00      	cmp	r3, #0
10001cc2:	d102      	bne.n	10001cca <_sbrk+0x16>
    heap_ptr = (caddr_t)&Heap_Bank1_Start;
10001cc4:	4b12      	ldr	r3, [pc, #72]	; (10001d10 <_sbrk+0x5c>)
10001cc6:	4a13      	ldr	r2, [pc, #76]	; (10001d14 <_sbrk+0x60>)
10001cc8:	601a      	str	r2, [r3, #0]
  }

  base = heap_ptr;
10001cca:	4b11      	ldr	r3, [pc, #68]	; (10001d10 <_sbrk+0x5c>)
10001ccc:	681b      	ldr	r3, [r3, #0]
10001cce:	60fb      	str	r3, [r7, #12]

  /* heap word alignment */
  nbytes = (nbytes + 3) & ~0x3U;
10001cd0:	687b      	ldr	r3, [r7, #4]
10001cd2:	3303      	adds	r3, #3
10001cd4:	2203      	movs	r2, #3
10001cd6:	4393      	bics	r3, r2
10001cd8:	607b      	str	r3, [r7, #4]
  if ((caddr_t)&Heap_Bank1_End > (heap_ptr + nbytes))
10001cda:	4b0d      	ldr	r3, [pc, #52]	; (10001d10 <_sbrk+0x5c>)
10001cdc:	681a      	ldr	r2, [r3, #0]
10001cde:	687b      	ldr	r3, [r7, #4]
10001ce0:	18d2      	adds	r2, r2, r3
10001ce2:	4b0d      	ldr	r3, [pc, #52]	; (10001d18 <_sbrk+0x64>)
10001ce4:	429a      	cmp	r2, r3
10001ce6:	d207      	bcs.n	10001cf8 <_sbrk+0x44>
  {
    heap_ptr += nbytes;
10001ce8:	4b09      	ldr	r3, [pc, #36]	; (10001d10 <_sbrk+0x5c>)
10001cea:	681a      	ldr	r2, [r3, #0]
10001cec:	687b      	ldr	r3, [r7, #4]
10001cee:	18d2      	adds	r2, r2, r3
10001cf0:	4b07      	ldr	r3, [pc, #28]	; (10001d10 <_sbrk+0x5c>)
10001cf2:	601a      	str	r2, [r3, #0]
    return (base);
10001cf4:	68fb      	ldr	r3, [r7, #12]
10001cf6:	e006      	b.n	10001d06 <_sbrk+0x52>
  }
  else
  {
    /* Heap overflow */
    errno = ENOMEM;
10001cf8:	f003 fc2e 	bl	10005558 <__errno>
10001cfc:	1c03      	adds	r3, r0, #0
10001cfe:	220c      	movs	r2, #12
10001d00:	601a      	str	r2, [r3, #0]
    return ((caddr_t)-1);
10001d02:	2301      	movs	r3, #1
10001d04:	425b      	negs	r3, r3
  }
}
10001d06:	1c18      	adds	r0, r3, #0
10001d08:	46bd      	mov	sp, r7
10001d0a:	b004      	add	sp, #16
10001d0c:	bd80      	pop	{r7, pc}
10001d0e:	46c0      	nop			; (mov r8, r8)
10001d10:	200006a8 	.word	0x200006a8
10001d14:	20000930 	.word	0x20000930
10001d18:	20003ffc 	.word	0x20003ffc

10001d1c <XMC_USIC_CH_EnableEvent>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_DisableEvent(), XMC_USIC_CH_SetInterruptNodePointer() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_EnableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
{
10001d1c:	b580      	push	{r7, lr}
10001d1e:	b082      	sub	sp, #8
10001d20:	af00      	add	r7, sp, #0
10001d22:	6078      	str	r0, [r7, #4]
10001d24:	6039      	str	r1, [r7, #0]
  channel->CCR |= event;
10001d26:	687b      	ldr	r3, [r7, #4]
10001d28:	6c1a      	ldr	r2, [r3, #64]	; 0x40
10001d2a:	683b      	ldr	r3, [r7, #0]
10001d2c:	431a      	orrs	r2, r3
10001d2e:	687b      	ldr	r3, [r7, #4]
10001d30:	641a      	str	r2, [r3, #64]	; 0x40
}
10001d32:	46bd      	mov	sp, r7
10001d34:	b002      	add	sp, #8
10001d36:	bd80      	pop	{r7, pc}

10001d38 <XMC_USIC_CH_DisableEvent>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_EnableEvent(), XMC_USIC_CH_SetInterruptNodePointer() \n\n\n
*/
__STATIC_INLINE void XMC_USIC_CH_DisableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
{
10001d38:	b580      	push	{r7, lr}
10001d3a:	b082      	sub	sp, #8
10001d3c:	af00      	add	r7, sp, #0
10001d3e:	6078      	str	r0, [r7, #4]
10001d40:	6039      	str	r1, [r7, #0]
  channel->CCR &= (uint32_t)~event;
10001d42:	687b      	ldr	r3, [r7, #4]
10001d44:	6c1b      	ldr	r3, [r3, #64]	; 0x40
10001d46:	683a      	ldr	r2, [r7, #0]
10001d48:	43d2      	mvns	r2, r2
10001d4a:	401a      	ands	r2, r3
10001d4c:	687b      	ldr	r3, [r7, #4]
10001d4e:	641a      	str	r2, [r3, #64]	; 0x40
}
10001d50:	46bd      	mov	sp, r7
10001d52:	b002      	add	sp, #8
10001d54:	bd80      	pop	{r7, pc}
10001d56:	46c0      	nop			; (mov r8, r8)

10001d58 <XMC_USIC_CH_GetTransmitBufferStatus>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_SetDataOutputMode() \n\n\n
 */
__STATIC_INLINE XMC_USIC_CH_TBUF_STATUS_t XMC_USIC_CH_GetTransmitBufferStatus(XMC_USIC_CH_t *const channel)
{
10001d58:	b580      	push	{r7, lr}
10001d5a:	b082      	sub	sp, #8
10001d5c:	af00      	add	r7, sp, #0
10001d5e:	6078      	str	r0, [r7, #4]
  return (XMC_USIC_CH_TBUF_STATUS_t)(channel->TCSR & USIC_CH_TCSR_TDV_Msk);
10001d60:	687b      	ldr	r3, [r7, #4]
10001d62:	6b9b      	ldr	r3, [r3, #56]	; 0x38
10001d64:	b2db      	uxtb	r3, r3
10001d66:	227f      	movs	r2, #127	; 0x7f
10001d68:	4393      	bics	r3, r2
10001d6a:	b2db      	uxtb	r3, r3
}
10001d6c:	1c18      	adds	r0, r3, #0
10001d6e:	46bd      	mov	sp, r7
10001d70:	b002      	add	sp, #8
10001d72:	bd80      	pop	{r7, pc}

10001d74 <XMC_USIC_CH_TriggerServiceRequest>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_SetInterruptNodePointer() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_TriggerServiceRequest(XMC_USIC_CH_t *const channel, const uint32_t service_request_line)
{
10001d74:	b580      	push	{r7, lr}
10001d76:	b082      	sub	sp, #8
10001d78:	af00      	add	r7, sp, #0
10001d7a:	6078      	str	r0, [r7, #4]
10001d7c:	6039      	str	r1, [r7, #0]
  channel->FMR = (uint32_t)(USIC_CH_FMR_SIO0_Msk << service_request_line);
10001d7e:	683b      	ldr	r3, [r7, #0]
10001d80:	2280      	movs	r2, #128	; 0x80
10001d82:	0252      	lsls	r2, r2, #9
10001d84:	409a      	lsls	r2, r3
10001d86:	687b      	ldr	r3, [r7, #4]
10001d88:	669a      	str	r2, [r3, #104]	; 0x68
}
10001d8a:	46bd      	mov	sp, r7
10001d8c:	b002      	add	sp, #8
10001d8e:	bd80      	pop	{r7, pc}

10001d90 <XMC_USIC_CH_TXFIFO_EnableEvent>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_TXFIFO_SetInterruptNodePointer() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_TXFIFO_EnableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
{
10001d90:	b580      	push	{r7, lr}
10001d92:	b082      	sub	sp, #8
10001d94:	af00      	add	r7, sp, #0
10001d96:	6078      	str	r0, [r7, #4]
10001d98:	6039      	str	r1, [r7, #0]
  channel->TBCTR |= event;
10001d9a:	687a      	ldr	r2, [r7, #4]
10001d9c:	2384      	movs	r3, #132	; 0x84
10001d9e:	005b      	lsls	r3, r3, #1
10001da0:	58d2      	ldr	r2, [r2, r3]
10001da2:	683b      	ldr	r3, [r7, #0]
10001da4:	431a      	orrs	r2, r3
10001da6:	1c11      	adds	r1, r2, #0
10001da8:	687a      	ldr	r2, [r7, #4]
10001daa:	2384      	movs	r3, #132	; 0x84
10001dac:	005b      	lsls	r3, r3, #1
10001dae:	50d1      	str	r1, [r2, r3]
}
10001db0:	46bd      	mov	sp, r7
10001db2:	b002      	add	sp, #8
10001db4:	bd80      	pop	{r7, pc}
10001db6:	46c0      	nop			; (mov r8, r8)

10001db8 <XMC_USIC_CH_TXFIFO_DisableEvent>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_TXFIFO_GetEvent(), XMC_USIC_CH_TXFIFO_EnableEvent() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_TXFIFO_DisableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
{
10001db8:	b580      	push	{r7, lr}
10001dba:	b082      	sub	sp, #8
10001dbc:	af00      	add	r7, sp, #0
10001dbe:	6078      	str	r0, [r7, #4]
10001dc0:	6039      	str	r1, [r7, #0]
  channel->TBCTR &= (uint32_t)~event;
10001dc2:	687a      	ldr	r2, [r7, #4]
10001dc4:	2384      	movs	r3, #132	; 0x84
10001dc6:	005b      	lsls	r3, r3, #1
10001dc8:	58d3      	ldr	r3, [r2, r3]
10001dca:	683a      	ldr	r2, [r7, #0]
10001dcc:	43d2      	mvns	r2, r2
10001dce:	401a      	ands	r2, r3
10001dd0:	1c11      	adds	r1, r2, #0
10001dd2:	687a      	ldr	r2, [r7, #4]
10001dd4:	2384      	movs	r3, #132	; 0x84
10001dd6:	005b      	lsls	r3, r3, #1
10001dd8:	50d1      	str	r1, [r2, r3]
}
10001dda:	46bd      	mov	sp, r7
10001ddc:	b002      	add	sp, #8
10001dde:	bd80      	pop	{r7, pc}

10001de0 <XMC_USIC_CH_TXFIFO_Flush>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_TXFIFO_GetLevel() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_TXFIFO_Flush(XMC_USIC_CH_t *const channel)
{
10001de0:	b580      	push	{r7, lr}
10001de2:	b082      	sub	sp, #8
10001de4:	af00      	add	r7, sp, #0
10001de6:	6078      	str	r0, [r7, #4]
  channel->TRBSCR = (uint32_t)USIC_CH_TRBSCR_FLUSHTB_Msk;
10001de8:	687a      	ldr	r2, [r7, #4]
10001dea:	238c      	movs	r3, #140	; 0x8c
10001dec:	005b      	lsls	r3, r3, #1
10001dee:	2180      	movs	r1, #128	; 0x80
10001df0:	0209      	lsls	r1, r1, #8
10001df2:	50d1      	str	r1, [r2, r3]
}
10001df4:	46bd      	mov	sp, r7
10001df6:	b002      	add	sp, #8
10001df8:	bd80      	pop	{r7, pc}
10001dfa:	46c0      	nop			; (mov r8, r8)

10001dfc <XMC_USIC_CH_TXFIFO_IsFull>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_TXFIFO_IsEmpty(), XMC_USIC_CH_TXFIFO_Flush() \n\n\n
 */
__STATIC_INLINE bool XMC_USIC_CH_TXFIFO_IsFull(XMC_USIC_CH_t *const channel)
{
10001dfc:	b580      	push	{r7, lr}
10001dfe:	b082      	sub	sp, #8
10001e00:	af00      	add	r7, sp, #0
10001e02:	6078      	str	r0, [r7, #4]
  return (bool)(channel->TRBSR & USIC_CH_TRBSR_TFULL_Msk);
10001e04:	687a      	ldr	r2, [r7, #4]
10001e06:	238a      	movs	r3, #138	; 0x8a
10001e08:	005b      	lsls	r3, r3, #1
10001e0a:	58d2      	ldr	r2, [r2, r3]
10001e0c:	2380      	movs	r3, #128	; 0x80
10001e0e:	015b      	lsls	r3, r3, #5
10001e10:	4013      	ands	r3, r2
10001e12:	1e5a      	subs	r2, r3, #1
10001e14:	4193      	sbcs	r3, r2
10001e16:	b2db      	uxtb	r3, r3
}
10001e18:	1c18      	adds	r0, r3, #0
10001e1a:	46bd      	mov	sp, r7
10001e1c:	b002      	add	sp, #8
10001e1e:	bd80      	pop	{r7, pc}

10001e20 <XMC_USIC_CH_TXFIFO_IsEmpty>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_TXFIFO_Flush(), XMC_USIC_CH_TXFIFO_PutData() \n\n\n
 */
__STATIC_INLINE bool XMC_USIC_CH_TXFIFO_IsEmpty(XMC_USIC_CH_t *const channel)
{
10001e20:	b580      	push	{r7, lr}
10001e22:	b082      	sub	sp, #8
10001e24:	af00      	add	r7, sp, #0
10001e26:	6078      	str	r0, [r7, #4]
  return (bool)(channel->TRBSR & USIC_CH_TRBSR_TEMPTY_Msk);
10001e28:	687a      	ldr	r2, [r7, #4]
10001e2a:	238a      	movs	r3, #138	; 0x8a
10001e2c:	005b      	lsls	r3, r3, #1
10001e2e:	58d2      	ldr	r2, [r2, r3]
10001e30:	2380      	movs	r3, #128	; 0x80
10001e32:	011b      	lsls	r3, r3, #4
10001e34:	4013      	ands	r3, r2
10001e36:	1e5a      	subs	r2, r3, #1
10001e38:	4193      	sbcs	r3, r2
10001e3a:	b2db      	uxtb	r3, r3
}
10001e3c:	1c18      	adds	r0, r3, #0
10001e3e:	46bd      	mov	sp, r7
10001e40:	b002      	add	sp, #8
10001e42:	bd80      	pop	{r7, pc}

10001e44 <XMC_USIC_CH_RXFIFO_DisableEvent>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_RXFIFO_GetEvent(), XMC_USIC_CH_RXFIFO_EnableEvent() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_RXFIFO_DisableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
{
10001e44:	b580      	push	{r7, lr}
10001e46:	b082      	sub	sp, #8
10001e48:	af00      	add	r7, sp, #0
10001e4a:	6078      	str	r0, [r7, #4]
10001e4c:	6039      	str	r1, [r7, #0]
  channel->RBCTR &= (uint32_t)~event;
10001e4e:	687a      	ldr	r2, [r7, #4]
10001e50:	2386      	movs	r3, #134	; 0x86
10001e52:	005b      	lsls	r3, r3, #1
10001e54:	58d3      	ldr	r3, [r2, r3]
10001e56:	683a      	ldr	r2, [r7, #0]
10001e58:	43d2      	mvns	r2, r2
10001e5a:	401a      	ands	r2, r3
10001e5c:	1c11      	adds	r1, r2, #0
10001e5e:	687a      	ldr	r2, [r7, #4]
10001e60:	2386      	movs	r3, #134	; 0x86
10001e62:	005b      	lsls	r3, r3, #1
10001e64:	50d1      	str	r1, [r2, r3]
}
10001e66:	46bd      	mov	sp, r7
10001e68:	b002      	add	sp, #8
10001e6a:	bd80      	pop	{r7, pc}

10001e6c <XMC_USIC_CH_RXFIFO_IsEmpty>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_RXFIFO_Flush(), XMC_USIC_CH_RXFIFO_PutData() \n\n\n
 */
__STATIC_INLINE bool XMC_USIC_CH_RXFIFO_IsEmpty(XMC_USIC_CH_t *const channel)
{
10001e6c:	b580      	push	{r7, lr}
10001e6e:	b082      	sub	sp, #8
10001e70:	af00      	add	r7, sp, #0
10001e72:	6078      	str	r0, [r7, #4]
  return (bool)(channel->TRBSR & USIC_CH_TRBSR_REMPTY_Msk);
10001e74:	687a      	ldr	r2, [r7, #4]
10001e76:	238a      	movs	r3, #138	; 0x8a
10001e78:	005b      	lsls	r3, r3, #1
10001e7a:	58d3      	ldr	r3, [r2, r3]
10001e7c:	2208      	movs	r2, #8
10001e7e:	4013      	ands	r3, r2
10001e80:	1e5a      	subs	r2, r3, #1
10001e82:	4193      	sbcs	r3, r2
10001e84:	b2db      	uxtb	r3, r3
}
10001e86:	1c18      	adds	r0, r3, #0
10001e88:	46bd      	mov	sp, r7
10001e8a:	b002      	add	sp, #8
10001e8c:	bd80      	pop	{r7, pc}
10001e8e:	46c0      	nop			; (mov r8, r8)

10001e90 <UART_Init>:
 *          UART_SUCCESS: for successful UART initialization.<BR>
 *          UART_STATUS_FAILURE  : If UART initialization fails.<BR>
 *
 */
UART_STATUS_t UART_Init(const UART_t *const handle)
{
10001e90:	b590      	push	{r4, r7, lr}
10001e92:	b085      	sub	sp, #20
10001e94:	af00      	add	r7, sp, #0
10001e96:	6078      	str	r0, [r7, #4]
  UART_STATUS_t status = UART_STATUS_SUCCESS;
10001e98:	230f      	movs	r3, #15
10001e9a:	18fb      	adds	r3, r7, r3
10001e9c:	2200      	movs	r2, #0
10001e9e:	701a      	strb	r2, [r3, #0]
  XMC_ASSERT("UART_Init : UART APP handle invalid", (((handle != NULL)&&
      (handle->config != NULL)) &&((handle->config->fptr_uart_config != NULL)&&
      (handle->runtime != NULL))));

  /*Initialize the multiplexers required for UART configuration*/
  status = handle->config->fptr_uart_config();
10001ea0:	687b      	ldr	r3, [r7, #4]
10001ea2:	685b      	ldr	r3, [r3, #4]
10001ea4:	685b      	ldr	r3, [r3, #4]
10001ea6:	220f      	movs	r2, #15
10001ea8:	18bc      	adds	r4, r7, r2
10001eaa:	4798      	blx	r3
10001eac:	1c03      	adds	r3, r0, #0
10001eae:	7023      	strb	r3, [r4, #0]

  return status;
10001eb0:	230f      	movs	r3, #15
10001eb2:	18fb      	adds	r3, r7, r3
10001eb4:	781b      	ldrb	r3, [r3, #0]
}
10001eb6:	1c18      	adds	r0, r3, #0
10001eb8:	46bd      	mov	sp, r7
10001eba:	b005      	add	sp, #20
10001ebc:	bd90      	pop	{r4, r7, pc}
10001ebe:	46c0      	nop			; (mov r8, r8)

10001ec0 <UART_Transmit>:
 *          UART_STATUS_BUFFER_INVALID: Either if buffer is NULL or count is 0.<BR>
 *          UART_STATUS_MODE_MISMATCH: If the configured mode is invalid.<BR>
 *
 */
UART_STATUS_t UART_Transmit(const UART_t *const handle, uint8_t* data_ptr, uint32_t count)
{
10001ec0:	b590      	push	{r4, r7, lr}
10001ec2:	b087      	sub	sp, #28
10001ec4:	af00      	add	r7, sp, #0
10001ec6:	60f8      	str	r0, [r7, #12]
10001ec8:	60b9      	str	r1, [r7, #8]
10001eca:	607a      	str	r2, [r7, #4]
  UART_STATUS_t ret_stat = UART_STATUS_MODE_MISMATCH;
10001ecc:	2317      	movs	r3, #23
10001ece:	18fb      	adds	r3, r7, r3
10001ed0:	2204      	movs	r2, #4
10001ed2:	701a      	strb	r2, [r3, #0]

  switch(handle->config->transmit_mode)
10001ed4:	68fb      	ldr	r3, [r7, #12]
10001ed6:	685b      	ldr	r3, [r3, #4]
10001ed8:	2229      	movs	r2, #41	; 0x29
10001eda:	5c9b      	ldrb	r3, [r3, r2]
10001edc:	2b00      	cmp	r3, #0
10001ede:	d000      	beq.n	10001ee2 <UART_Transmit+0x22>
  case UART_TRANSFER_MODE_DIRECT:
    ret_stat = UART_lStartTransmitPolling(handle, data_ptr, count);
    break;
#endif
  default:
    break;
10001ee0:	e00c      	b.n	10001efc <UART_Transmit+0x3c>

  switch(handle->config->transmit_mode)
  {
#ifdef UART_TX_INTERRUPT_USED
  case UART_TRANSFER_MODE_INTERRUPT:
    ret_stat = UART_StartTransmitIRQ(handle, data_ptr, count);
10001ee2:	2317      	movs	r3, #23
10001ee4:	18fc      	adds	r4, r7, r3
10001ee6:	68f9      	ldr	r1, [r7, #12]
10001ee8:	68ba      	ldr	r2, [r7, #8]
10001eea:	687b      	ldr	r3, [r7, #4]
10001eec:	1c08      	adds	r0, r1, #0
10001eee:	1c11      	adds	r1, r2, #0
10001ef0:	1c1a      	adds	r2, r3, #0
10001ef2:	f000 f80b 	bl	10001f0c <UART_StartTransmitIRQ>
10001ef6:	1c03      	adds	r3, r0, #0
10001ef8:	7023      	strb	r3, [r4, #0]
    break;
10001efa:	46c0      	nop			; (mov r8, r8)
    break;
#endif
  default:
    break;
  }
  return ret_stat;
10001efc:	2317      	movs	r3, #23
10001efe:	18fb      	adds	r3, r7, r3
10001f00:	781b      	ldrb	r3, [r3, #0]
}
10001f02:	1c18      	adds	r0, r3, #0
10001f04:	46bd      	mov	sp, r7
10001f06:	b007      	add	sp, #28
10001f08:	bd90      	pop	{r4, r7, pc}
10001f0a:	46c0      	nop			; (mov r8, r8)

10001f0c <UART_StartTransmitIRQ>:
 * request is registered.
 *
 *
 */
UART_STATUS_t UART_StartTransmitIRQ(const UART_t *const handle, uint8_t* data_ptr, uint32_t count)
{
10001f0c:	b580      	push	{r7, lr}
10001f0e:	b086      	sub	sp, #24
10001f10:	af00      	add	r7, sp, #0
10001f12:	60f8      	str	r0, [r7, #12]
10001f14:	60b9      	str	r1, [r7, #8]
10001f16:	607a      	str	r2, [r7, #4]
  UART_STATUS_t ret_stat = UART_STATUS_MODE_MISMATCH;
10001f18:	2317      	movs	r3, #23
10001f1a:	18fb      	adds	r3, r7, r3
10001f1c:	2204      	movs	r2, #4
10001f1e:	701a      	strb	r2, [r3, #0]
  UART_RUNTIME_t * ptr_runtime = handle->runtime;
10001f20:	68fb      	ldr	r3, [r7, #12]
10001f22:	689b      	ldr	r3, [r3, #8]
10001f24:	613b      	str	r3, [r7, #16]

  XMC_ASSERT("UART_StartTransmitIRQ: UART APP handle invalid", ((handle != NULL)&&
            (handle->runtime != NULL)));

  if (handle->config->transmit_mode == UART_TRANSFER_MODE_INTERRUPT)
10001f26:	68fb      	ldr	r3, [r7, #12]
10001f28:	685b      	ldr	r3, [r3, #4]
10001f2a:	2229      	movs	r2, #41	; 0x29
10001f2c:	5c9b      	ldrb	r3, [r3, r2]
10001f2e:	2b00      	cmp	r3, #0
10001f30:	d14c      	bne.n	10001fcc <UART_StartTransmitIRQ+0xc0>
  {
    ret_stat = UART_STATUS_BUSY;
10001f32:	2317      	movs	r3, #23
10001f34:	18fb      	adds	r3, r7, r3
10001f36:	2202      	movs	r2, #2
10001f38:	701a      	strb	r2, [r3, #0]
    if (ptr_runtime->tx_busy == false)
10001f3a:	693b      	ldr	r3, [r7, #16]
10001f3c:	7e1b      	ldrb	r3, [r3, #24]
10001f3e:	b2db      	uxtb	r3, r3
10001f40:	2201      	movs	r2, #1
10001f42:	4053      	eors	r3, r2
10001f44:	b2db      	uxtb	r3, r3
10001f46:	2b00      	cmp	r3, #0
10001f48:	d040      	beq.n	10001fcc <UART_StartTransmitIRQ+0xc0>
    {
      /*If there is no transmission in progress*/
      if ((data_ptr != NULL) && (count > 0U))
10001f4a:	68bb      	ldr	r3, [r7, #8]
10001f4c:	2b00      	cmp	r3, #0
10001f4e:	d039      	beq.n	10001fc4 <UART_StartTransmitIRQ+0xb8>
10001f50:	687b      	ldr	r3, [r7, #4]
10001f52:	2b00      	cmp	r3, #0
10001f54:	d036      	beq.n	10001fc4 <UART_StartTransmitIRQ+0xb8>
      {
        /*Obtain the address of data, size of data*/
        ptr_runtime->tx_data = data_ptr;
10001f56:	693b      	ldr	r3, [r7, #16]
10001f58:	68ba      	ldr	r2, [r7, #8]
10001f5a:	601a      	str	r2, [r3, #0]
        ptr_runtime->tx_data_count = count;
10001f5c:	693b      	ldr	r3, [r7, #16]
10001f5e:	687a      	ldr	r2, [r7, #4]
10001f60:	609a      	str	r2, [r3, #8]
        /*Initialize to first index and set the busy flag*/
        ptr_runtime->tx_data_index = 0U;
10001f62:	693b      	ldr	r3, [r7, #16]
10001f64:	2200      	movs	r2, #0
10001f66:	60da      	str	r2, [r3, #12]
        ptr_runtime->tx_busy = true;
10001f68:	693b      	ldr	r3, [r7, #16]
10001f6a:	2201      	movs	r2, #1
10001f6c:	761a      	strb	r2, [r3, #24]

        /*Enable the transmit buffer event*/
        if (handle->config->tx_fifo_size != XMC_USIC_CH_FIFO_DISABLED)
10001f6e:	68fb      	ldr	r3, [r7, #12]
10001f70:	685b      	ldr	r3, [r3, #4]
10001f72:	222b      	movs	r2, #43	; 0x2b
10001f74:	5c9b      	ldrb	r3, [r3, r2]
10001f76:	2b00      	cmp	r3, #0
10001f78:	d00d      	beq.n	10001f96 <UART_StartTransmitIRQ+0x8a>
        {
          /*Clear the transmit FIFO*/
          XMC_USIC_CH_TXFIFO_Flush(handle->channel);
10001f7a:	68fb      	ldr	r3, [r7, #12]
10001f7c:	681b      	ldr	r3, [r3, #0]
10001f7e:	1c18      	adds	r0, r3, #0
10001f80:	f7ff ff2e 	bl	10001de0 <XMC_USIC_CH_TXFIFO_Flush>
          /*Enable transmit buffer interrupt*/
          XMC_USIC_CH_TXFIFO_EnableEvent(handle->channel,(uint32_t)XMC_USIC_CH_TXFIFO_EVENT_CONF_STANDARD);
10001f84:	68fb      	ldr	r3, [r7, #12]
10001f86:	681a      	ldr	r2, [r3, #0]
10001f88:	2380      	movs	r3, #128	; 0x80
10001f8a:	05db      	lsls	r3, r3, #23
10001f8c:	1c10      	adds	r0, r2, #0
10001f8e:	1c19      	adds	r1, r3, #0
10001f90:	f7ff fefe 	bl	10001d90 <XMC_USIC_CH_TXFIFO_EnableEvent>
10001f94:	e007      	b.n	10001fa6 <UART_StartTransmitIRQ+0x9a>
        }
        else
        {
          XMC_USIC_CH_EnableEvent(handle->channel, (uint32_t)XMC_USIC_CH_EVENT_TRANSMIT_BUFFER);
10001f96:	68fb      	ldr	r3, [r7, #12]
10001f98:	681a      	ldr	r2, [r3, #0]
10001f9a:	2380      	movs	r3, #128	; 0x80
10001f9c:	019b      	lsls	r3, r3, #6
10001f9e:	1c10      	adds	r0, r2, #0
10001fa0:	1c19      	adds	r1, r3, #0
10001fa2:	f7ff febb 	bl	10001d1c <XMC_USIC_CH_EnableEvent>
        }
        ret_stat = UART_STATUS_SUCCESS;
10001fa6:	2317      	movs	r3, #23
10001fa8:	18fb      	adds	r3, r7, r3
10001faa:	2200      	movs	r2, #0
10001fac:	701a      	strb	r2, [r3, #0]
        /*Trigger the transmit buffer interrupt*/
        XMC_USIC_CH_TriggerServiceRequest(handle->channel, (uint32_t)handle->config->tx_sr);
10001fae:	68fb      	ldr	r3, [r7, #12]
10001fb0:	6819      	ldr	r1, [r3, #0]
10001fb2:	68fb      	ldr	r3, [r7, #12]
10001fb4:	685b      	ldr	r3, [r3, #4]
10001fb6:	222d      	movs	r2, #45	; 0x2d
10001fb8:	5c9b      	ldrb	r3, [r3, r2]
10001fba:	1c08      	adds	r0, r1, #0
10001fbc:	1c19      	adds	r1, r3, #0
10001fbe:	f7ff fed9 	bl	10001d74 <XMC_USIC_CH_TriggerServiceRequest>
10001fc2:	e003      	b.n	10001fcc <UART_StartTransmitIRQ+0xc0>
      }
      else
      {
        ret_stat = UART_STATUS_BUFFER_INVALID;
10001fc4:	2317      	movs	r3, #23
10001fc6:	18fb      	adds	r3, r7, r3
10001fc8:	2203      	movs	r2, #3
10001fca:	701a      	strb	r2, [r3, #0]
      }
    }
  }
  return ret_stat;
10001fcc:	2317      	movs	r3, #23
10001fce:	18fb      	adds	r3, r7, r3
10001fd0:	781b      	ldrb	r3, [r3, #0]
}
10001fd2:	1c18      	adds	r0, r3, #0
10001fd4:	46bd      	mov	sp, r7
10001fd6:	b006      	add	sp, #24
10001fd8:	bd80      	pop	{r7, pc}
10001fda:	46c0      	nop			; (mov r8, r8)

10001fdc <UART_lTransmitHandler>:
 *  * param[in]  handle UART APP handle pointer of type UART_t*
 *
 *  * return void
 */
void UART_lTransmitHandler(const UART_t * const handle)
{
10001fdc:	b580      	push	{r7, lr}
10001fde:	b084      	sub	sp, #16
10001fe0:	af00      	add	r7, sp, #0
10001fe2:	6078      	str	r0, [r7, #4]
  UART_RUNTIME_t * ptr_runtime = handle->runtime;
10001fe4:	687b      	ldr	r3, [r7, #4]
10001fe6:	689b      	ldr	r3, [r3, #8]
10001fe8:	60fb      	str	r3, [r7, #12]

  if (ptr_runtime->tx_data_index < ptr_runtime->tx_data_count)
10001fea:	68fb      	ldr	r3, [r7, #12]
10001fec:	68da      	ldr	r2, [r3, #12]
10001fee:	68fb      	ldr	r3, [r7, #12]
10001ff0:	689b      	ldr	r3, [r3, #8]
10001ff2:	429a      	cmp	r2, r3
10001ff4:	d241      	bcs.n	1000207a <UART_lTransmitHandler+0x9e>
  {
    if (handle->config->tx_fifo_size != XMC_USIC_CH_FIFO_DISABLED)
10001ff6:	687b      	ldr	r3, [r7, #4]
10001ff8:	685b      	ldr	r3, [r3, #4]
10001ffa:	222b      	movs	r2, #43	; 0x2b
10001ffc:	5c9b      	ldrb	r3, [r3, r2]
10001ffe:	2b00      	cmp	r3, #0
10002000:	d028      	beq.n	10002054 <UART_lTransmitHandler+0x78>
    {
      /*When Transmit FIFO is enabled*/
      /*Fill the transmit FIFO */
      while (XMC_USIC_CH_TXFIFO_IsFull(handle->channel) == false)
10002002:	e01a      	b.n	1000203a <UART_lTransmitHandler+0x5e>
      {
        if (ptr_runtime->tx_data_index < ptr_runtime->tx_data_count)
10002004:	68fb      	ldr	r3, [r7, #12]
10002006:	68da      	ldr	r2, [r3, #12]
10002008:	68fb      	ldr	r3, [r7, #12]
1000200a:	689b      	ldr	r3, [r3, #8]
1000200c:	429a      	cmp	r2, r3
1000200e:	d212      	bcs.n	10002036 <UART_lTransmitHandler+0x5a>
        {
          /*Load the FIFO byte by byte till either FIFO is full or all data is loaded*/
          XMC_UART_CH_Transmit(handle->channel,(uint16_t)ptr_runtime->tx_data[ptr_runtime->tx_data_index]);
10002010:	687b      	ldr	r3, [r7, #4]
10002012:	6819      	ldr	r1, [r3, #0]
10002014:	68fb      	ldr	r3, [r7, #12]
10002016:	681a      	ldr	r2, [r3, #0]
10002018:	68fb      	ldr	r3, [r7, #12]
1000201a:	68db      	ldr	r3, [r3, #12]
1000201c:	18d3      	adds	r3, r2, r3
1000201e:	781b      	ldrb	r3, [r3, #0]
10002020:	b29b      	uxth	r3, r3
10002022:	1c08      	adds	r0, r1, #0
10002024:	1c19      	adds	r1, r3, #0
10002026:	f7ff fbd5 	bl	100017d4 <XMC_UART_CH_Transmit>
          (ptr_runtime->tx_data_index)++;
1000202a:	68fb      	ldr	r3, [r7, #12]
1000202c:	68db      	ldr	r3, [r3, #12]
1000202e:	1c5a      	adds	r2, r3, #1
10002030:	68fb      	ldr	r3, [r7, #12]
10002032:	60da      	str	r2, [r3, #12]
10002034:	e001      	b.n	1000203a <UART_lTransmitHandler+0x5e>
        }
        else
        {
          break;
10002036:	46c0      	nop			; (mov r8, r8)
10002038:	e055      	b.n	100020e6 <UART_lTransmitHandler+0x10a>
  {
    if (handle->config->tx_fifo_size != XMC_USIC_CH_FIFO_DISABLED)
    {
      /*When Transmit FIFO is enabled*/
      /*Fill the transmit FIFO */
      while (XMC_USIC_CH_TXFIFO_IsFull(handle->channel) == false)
1000203a:	687b      	ldr	r3, [r7, #4]
1000203c:	681b      	ldr	r3, [r3, #0]
1000203e:	1c18      	adds	r0, r3, #0
10002040:	f7ff fedc 	bl	10001dfc <XMC_USIC_CH_TXFIFO_IsFull>
10002044:	1c03      	adds	r3, r0, #0
10002046:	1c1a      	adds	r2, r3, #0
10002048:	2301      	movs	r3, #1
1000204a:	4053      	eors	r3, r2
1000204c:	b2db      	uxtb	r3, r3
1000204e:	2b00      	cmp	r3, #0
10002050:	d1d8      	bne.n	10002004 <UART_lTransmitHandler+0x28>
10002052:	e048      	b.n	100020e6 <UART_lTransmitHandler+0x10a>
      }
    }
    else
    {
      /*When Transmit FIFO is disabled*/
      XMC_UART_CH_Transmit(handle->channel,(uint16_t)ptr_runtime->tx_data[ptr_runtime->tx_data_index]);
10002054:	687b      	ldr	r3, [r7, #4]
10002056:	6819      	ldr	r1, [r3, #0]
10002058:	68fb      	ldr	r3, [r7, #12]
1000205a:	681a      	ldr	r2, [r3, #0]
1000205c:	68fb      	ldr	r3, [r7, #12]
1000205e:	68db      	ldr	r3, [r3, #12]
10002060:	18d3      	adds	r3, r2, r3
10002062:	781b      	ldrb	r3, [r3, #0]
10002064:	b29b      	uxth	r3, r3
10002066:	1c08      	adds	r0, r1, #0
10002068:	1c19      	adds	r1, r3, #0
1000206a:	f7ff fbb3 	bl	100017d4 <XMC_UART_CH_Transmit>
      (ptr_runtime->tx_data_index)++;
1000206e:	68fb      	ldr	r3, [r7, #12]
10002070:	68db      	ldr	r3, [r3, #12]
10002072:	1c5a      	adds	r2, r3, #1
10002074:	68fb      	ldr	r3, [r7, #12]
10002076:	60da      	str	r2, [r3, #12]
10002078:	e035      	b.n	100020e6 <UART_lTransmitHandler+0x10a>
    }
  }
  else
  {
    if (XMC_USIC_CH_TXFIFO_IsEmpty(handle->channel) == true)
1000207a:	687b      	ldr	r3, [r7, #4]
1000207c:	681b      	ldr	r3, [r3, #0]
1000207e:	1c18      	adds	r0, r3, #0
10002080:	f7ff fece 	bl	10001e20 <XMC_USIC_CH_TXFIFO_IsEmpty>
10002084:	1e03      	subs	r3, r0, #0
10002086:	d02e      	beq.n	100020e6 <UART_lTransmitHandler+0x10a>
    {
      if (handle->config->tx_fifo_size != XMC_USIC_CH_FIFO_DISABLED)
10002088:	687b      	ldr	r3, [r7, #4]
1000208a:	685b      	ldr	r3, [r3, #4]
1000208c:	222b      	movs	r2, #43	; 0x2b
1000208e:	5c9b      	ldrb	r3, [r3, r2]
10002090:	2b00      	cmp	r3, #0
10002092:	d008      	beq.n	100020a6 <UART_lTransmitHandler+0xca>
      {
        /*Disable the transmit FIFO event*/
        XMC_USIC_CH_TXFIFO_DisableEvent(handle->channel,(uint32_t)XMC_USIC_CH_TXFIFO_EVENT_CONF_STANDARD);
10002094:	687b      	ldr	r3, [r7, #4]
10002096:	681a      	ldr	r2, [r3, #0]
10002098:	2380      	movs	r3, #128	; 0x80
1000209a:	05db      	lsls	r3, r3, #23
1000209c:	1c10      	adds	r0, r2, #0
1000209e:	1c19      	adds	r1, r3, #0
100020a0:	f7ff fe8a 	bl	10001db8 <XMC_USIC_CH_TXFIFO_DisableEvent>
100020a4:	e007      	b.n	100020b6 <UART_lTransmitHandler+0xda>
      }
      else
      {
        /*Disable the standard transmit event*/
        XMC_USIC_CH_DisableEvent(handle->channel, (uint32_t)XMC_USIC_CH_EVENT_TRANSMIT_BUFFER);
100020a6:	687b      	ldr	r3, [r7, #4]
100020a8:	681a      	ldr	r2, [r3, #0]
100020aa:	2380      	movs	r3, #128	; 0x80
100020ac:	019b      	lsls	r3, r3, #6
100020ae:	1c10      	adds	r0, r2, #0
100020b0:	1c19      	adds	r1, r3, #0
100020b2:	f7ff fe41 	bl	10001d38 <XMC_USIC_CH_DisableEvent>
      }

      /*Wait for the transmit buffer to be free to ensure that all data is transmitted*/
      while (XMC_USIC_CH_GetTransmitBufferStatus(handle->channel) == XMC_USIC_CH_TBUF_STATUS_BUSY)
100020b6:	46c0      	nop			; (mov r8, r8)
100020b8:	687b      	ldr	r3, [r7, #4]
100020ba:	681b      	ldr	r3, [r3, #0]
100020bc:	1c18      	adds	r0, r3, #0
100020be:	f7ff fe4b 	bl	10001d58 <XMC_USIC_CH_GetTransmitBufferStatus>
100020c2:	1e03      	subs	r3, r0, #0
100020c4:	2b80      	cmp	r3, #128	; 0x80
100020c6:	d0f7      	beq.n	100020b8 <UART_lTransmitHandler+0xdc>
      {

      }
      /*All data is transmitted*/
      ptr_runtime->tx_busy = false;
100020c8:	68fb      	ldr	r3, [r7, #12]
100020ca:	2200      	movs	r2, #0
100020cc:	761a      	strb	r2, [r3, #24]
      ptr_runtime->tx_data = NULL;
100020ce:	68fb      	ldr	r3, [r7, #12]
100020d0:	2200      	movs	r2, #0
100020d2:	601a      	str	r2, [r3, #0]

      if (handle->config->tx_cbhandler != NULL)
100020d4:	687b      	ldr	r3, [r7, #4]
100020d6:	685b      	ldr	r3, [r3, #4]
100020d8:	689b      	ldr	r3, [r3, #8]
100020da:	2b00      	cmp	r3, #0
100020dc:	d003      	beq.n	100020e6 <UART_lTransmitHandler+0x10a>
      {
        /*Execute the callback function provided in the UART APP UI*/
        handle->config->tx_cbhandler();
100020de:	687b      	ldr	r3, [r7, #4]
100020e0:	685b      	ldr	r3, [r3, #4]
100020e2:	689b      	ldr	r3, [r3, #8]
100020e4:	4798      	blx	r3
      }
    }
  }
}
100020e6:	46bd      	mov	sp, r7
100020e8:	b004      	add	sp, #16
100020ea:	bd80      	pop	{r7, pc}

100020ec <UART_lReceiveHandler>:
 * param[in]  handle UART APP handle pointer of type UART_t*
 *
 * return void
 */
void UART_lReceiveHandler(const UART_t * const handle)
{
100020ec:	b590      	push	{r4, r7, lr}
100020ee:	b085      	sub	sp, #20
100020f0:	af00      	add	r7, sp, #0
100020f2:	6078      	str	r0, [r7, #4]
  UART_RUNTIME_t * ptr_runtime = handle->runtime;
100020f4:	687b      	ldr	r3, [r7, #4]
100020f6:	689b      	ldr	r3, [r3, #8]
100020f8:	60fb      	str	r3, [r7, #12]

  if (handle->config->rx_fifo_size != XMC_USIC_CH_FIFO_DISABLED)
100020fa:	687b      	ldr	r3, [r7, #4]
100020fc:	685b      	ldr	r3, [r3, #4]
100020fe:	222c      	movs	r2, #44	; 0x2c
10002100:	5c9b      	ldrb	r3, [r3, r2]
10002102:	2b00      	cmp	r3, #0
10002104:	d051      	beq.n	100021aa <UART_lReceiveHandler+0xbe>
  {
    /*When Receive FIFO is enabled*/
    while (XMC_USIC_CH_RXFIFO_IsEmpty(handle->channel) == false)
10002106:	e033      	b.n	10002170 <UART_lReceiveHandler+0x84>
    {
      if (ptr_runtime->rx_data_index < ptr_runtime->rx_data_count)
10002108:	68fb      	ldr	r3, [r7, #12]
1000210a:	695a      	ldr	r2, [r3, #20]
1000210c:	68fb      	ldr	r3, [r7, #12]
1000210e:	691b      	ldr	r3, [r3, #16]
10002110:	429a      	cmp	r2, r3
10002112:	d211      	bcs.n	10002138 <UART_lReceiveHandler+0x4c>
      {
        /*Read all the content of Receive FIFO */
        ptr_runtime->rx_data[ptr_runtime->rx_data_index] = (uint8_t)XMC_UART_CH_GetReceivedData(handle->channel);
10002114:	68fb      	ldr	r3, [r7, #12]
10002116:	685a      	ldr	r2, [r3, #4]
10002118:	68fb      	ldr	r3, [r7, #12]
1000211a:	695b      	ldr	r3, [r3, #20]
1000211c:	18d4      	adds	r4, r2, r3
1000211e:	687b      	ldr	r3, [r7, #4]
10002120:	681b      	ldr	r3, [r3, #0]
10002122:	1c18      	adds	r0, r3, #0
10002124:	f7ff fb84 	bl	10001830 <XMC_UART_CH_GetReceivedData>
10002128:	1c03      	adds	r3, r0, #0
1000212a:	b2db      	uxtb	r3, r3
1000212c:	7023      	strb	r3, [r4, #0]
        (ptr_runtime->rx_data_index)++;
1000212e:	68fb      	ldr	r3, [r7, #12]
10002130:	695b      	ldr	r3, [r3, #20]
10002132:	1c5a      	adds	r2, r3, #1
10002134:	68fb      	ldr	r3, [r7, #12]
10002136:	615a      	str	r2, [r3, #20]
      }

      if (ptr_runtime->rx_data_index == ptr_runtime->rx_data_count)
10002138:	68fb      	ldr	r3, [r7, #12]
1000213a:	695a      	ldr	r2, [r3, #20]
1000213c:	68fb      	ldr	r3, [r7, #12]
1000213e:	691b      	ldr	r3, [r3, #16]
10002140:	429a      	cmp	r2, r3
10002142:	d115      	bne.n	10002170 <UART_lReceiveHandler+0x84>
      {
        /*Reception complete*/
        ptr_runtime->rx_busy = false;
10002144:	68fb      	ldr	r3, [r7, #12]
10002146:	2200      	movs	r2, #0
10002148:	765a      	strb	r2, [r3, #25]
        /*Disable both standard receive and alternative receive FIFO events*/
        XMC_USIC_CH_RXFIFO_DisableEvent(handle->channel,
1000214a:	687b      	ldr	r3, [r7, #4]
1000214c:	681a      	ldr	r2, [r3, #0]
1000214e:	23c0      	movs	r3, #192	; 0xc0
10002150:	05db      	lsls	r3, r3, #23
10002152:	1c10      	adds	r0, r2, #0
10002154:	1c19      	adds	r1, r3, #0
10002156:	f7ff fe75 	bl	10001e44 <XMC_USIC_CH_RXFIFO_DisableEvent>
            (uint32_t)((uint32_t)XMC_USIC_CH_RXFIFO_EVENT_CONF_STANDARD |
            (uint32_t)XMC_USIC_CH_RXFIFO_EVENT_CONF_ALTERNATE));
        if (handle->config->rx_cbhandler != NULL)
1000215a:	687b      	ldr	r3, [r7, #4]
1000215c:	685b      	ldr	r3, [r3, #4]
1000215e:	68db      	ldr	r3, [r3, #12]
10002160:	2b00      	cmp	r3, #0
10002162:	d004      	beq.n	1000216e <UART_lReceiveHandler+0x82>
        {
          /*Execute the 'End of reception' callback function*/
          handle->config->rx_cbhandler();
10002164:	687b      	ldr	r3, [r7, #4]
10002166:	685b      	ldr	r3, [r3, #4]
10002168:	68db      	ldr	r3, [r3, #12]
1000216a:	4798      	blx	r3
        }
        break;
1000216c:	e00c      	b.n	10002188 <UART_lReceiveHandler+0x9c>
1000216e:	e00b      	b.n	10002188 <UART_lReceiveHandler+0x9c>
  UART_RUNTIME_t * ptr_runtime = handle->runtime;

  if (handle->config->rx_fifo_size != XMC_USIC_CH_FIFO_DISABLED)
  {
    /*When Receive FIFO is enabled*/
    while (XMC_USIC_CH_RXFIFO_IsEmpty(handle->channel) == false)
10002170:	687b      	ldr	r3, [r7, #4]
10002172:	681b      	ldr	r3, [r3, #0]
10002174:	1c18      	adds	r0, r3, #0
10002176:	f7ff fe79 	bl	10001e6c <XMC_USIC_CH_RXFIFO_IsEmpty>
1000217a:	1c03      	adds	r3, r0, #0
1000217c:	1c1a      	adds	r2, r3, #0
1000217e:	2301      	movs	r3, #1
10002180:	4053      	eors	r3, r2
10002182:	b2db      	uxtb	r3, r3
10002184:	2b00      	cmp	r3, #0
10002186:	d1bf      	bne.n	10002108 <UART_lReceiveHandler+0x1c>
        }
        break;
      }
    }
    /*Set the trigger limit if data still to be received*/
    if (ptr_runtime->rx_data_index < ptr_runtime->rx_data_count)
10002188:	68fb      	ldr	r3, [r7, #12]
1000218a:	695a      	ldr	r2, [r3, #20]
1000218c:	68fb      	ldr	r3, [r7, #12]
1000218e:	691b      	ldr	r3, [r3, #16]
10002190:	429a      	cmp	r2, r3
10002192:	d23c      	bcs.n	1000220e <UART_lReceiveHandler+0x122>
    {
      UART_lReconfigureRxFIFO(handle,
          (uint32_t)(ptr_runtime->rx_data_count - ptr_runtime->rx_data_index));
10002194:	68fb      	ldr	r3, [r7, #12]
10002196:	691a      	ldr	r2, [r3, #16]
10002198:	68fb      	ldr	r3, [r7, #12]
1000219a:	695b      	ldr	r3, [r3, #20]
      }
    }
    /*Set the trigger limit if data still to be received*/
    if (ptr_runtime->rx_data_index < ptr_runtime->rx_data_count)
    {
      UART_lReconfigureRxFIFO(handle,
1000219c:	1ad3      	subs	r3, r2, r3
1000219e:	687a      	ldr	r2, [r7, #4]
100021a0:	1c10      	adds	r0, r2, #0
100021a2:	1c19      	adds	r1, r3, #0
100021a4:	f000 f836 	bl	10002214 <UART_lReconfigureRxFIFO>
100021a8:	e031      	b.n	1000220e <UART_lReceiveHandler+0x122>
    }
  }
  else
  {
    /*When RxFIFO is disabled*/
    if (ptr_runtime->rx_data_index < ptr_runtime->rx_data_count)
100021aa:	68fb      	ldr	r3, [r7, #12]
100021ac:	695a      	ldr	r2, [r3, #20]
100021ae:	68fb      	ldr	r3, [r7, #12]
100021b0:	691b      	ldr	r3, [r3, #16]
100021b2:	429a      	cmp	r2, r3
100021b4:	d211      	bcs.n	100021da <UART_lReceiveHandler+0xee>
    {
      ptr_runtime->rx_data[ptr_runtime->rx_data_index] = (uint8_t)XMC_UART_CH_GetReceivedData(handle->channel);
100021b6:	68fb      	ldr	r3, [r7, #12]
100021b8:	685a      	ldr	r2, [r3, #4]
100021ba:	68fb      	ldr	r3, [r7, #12]
100021bc:	695b      	ldr	r3, [r3, #20]
100021be:	18d4      	adds	r4, r2, r3
100021c0:	687b      	ldr	r3, [r7, #4]
100021c2:	681b      	ldr	r3, [r3, #0]
100021c4:	1c18      	adds	r0, r3, #0
100021c6:	f7ff fb33 	bl	10001830 <XMC_UART_CH_GetReceivedData>
100021ca:	1c03      	adds	r3, r0, #0
100021cc:	b2db      	uxtb	r3, r3
100021ce:	7023      	strb	r3, [r4, #0]
      (ptr_runtime->rx_data_index)++;
100021d0:	68fb      	ldr	r3, [r7, #12]
100021d2:	695b      	ldr	r3, [r3, #20]
100021d4:	1c5a      	adds	r2, r3, #1
100021d6:	68fb      	ldr	r3, [r7, #12]
100021d8:	615a      	str	r2, [r3, #20]
    }

    if (ptr_runtime->rx_data_index == ptr_runtime->rx_data_count)
100021da:	68fb      	ldr	r3, [r7, #12]
100021dc:	695a      	ldr	r2, [r3, #20]
100021de:	68fb      	ldr	r3, [r7, #12]
100021e0:	691b      	ldr	r3, [r3, #16]
100021e2:	429a      	cmp	r2, r3
100021e4:	d113      	bne.n	1000220e <UART_lReceiveHandler+0x122>
    {
      /*Reception complete*/
      ptr_runtime->rx_busy = false;
100021e6:	68fb      	ldr	r3, [r7, #12]
100021e8:	2200      	movs	r2, #0
100021ea:	765a      	strb	r2, [r3, #25]
      /*Disable both standard receive and alternative receive FIFO events*/
      XMC_USIC_CH_DisableEvent(handle->channel,
100021ec:	687b      	ldr	r3, [r7, #4]
100021ee:	681a      	ldr	r2, [r3, #0]
100021f0:	23c0      	movs	r3, #192	; 0xc0
100021f2:	021b      	lsls	r3, r3, #8
100021f4:	1c10      	adds	r0, r2, #0
100021f6:	1c19      	adds	r1, r3, #0
100021f8:	f7ff fd9e 	bl	10001d38 <XMC_USIC_CH_DisableEvent>
          (uint32_t)((uint32_t)XMC_USIC_CH_EVENT_ALTERNATIVE_RECEIVE | (uint32_t)XMC_USIC_CH_EVENT_STANDARD_RECEIVE));

      if (handle->config->rx_cbhandler != NULL)
100021fc:	687b      	ldr	r3, [r7, #4]
100021fe:	685b      	ldr	r3, [r3, #4]
10002200:	68db      	ldr	r3, [r3, #12]
10002202:	2b00      	cmp	r3, #0
10002204:	d003      	beq.n	1000220e <UART_lReceiveHandler+0x122>
      {
        /*Execute the 'End of reception' callback function*/
        handle->config->rx_cbhandler();
10002206:	687b      	ldr	r3, [r7, #4]
10002208:	685b      	ldr	r3, [r3, #4]
1000220a:	68db      	ldr	r3, [r3, #12]
1000220c:	4798      	blx	r3
      }
    }
  }
}
1000220e:	46bd      	mov	sp, r7
10002210:	b005      	add	sp, #20
10002212:	bd90      	pop	{r4, r7, pc}

10002214 <UART_lReconfigureRxFIFO>:
 * param[in] uint8_t  number of bytes to be received.
 *
 * return void.
 */
static void UART_lReconfigureRxFIFO(const UART_t * const handle, uint32_t data_size)
{
10002214:	b580      	push	{r7, lr}
10002216:	b084      	sub	sp, #16
10002218:	af00      	add	r7, sp, #0
1000221a:	6078      	str	r0, [r7, #4]
1000221c:	6039      	str	r1, [r7, #0]
  uint32_t fifo_size;
  uint32_t ret_limit_val = 0U;
1000221e:	2300      	movs	r3, #0
10002220:	60fb      	str	r3, [r7, #12]

  /*Get FIFO size in bytes*/
  fifo_size = (uint32_t)(0x01UL << (uint8_t)(handle->config->rx_fifo_size));
10002222:	687b      	ldr	r3, [r7, #4]
10002224:	685b      	ldr	r3, [r3, #4]
10002226:	222c      	movs	r2, #44	; 0x2c
10002228:	5c9b      	ldrb	r3, [r3, r2]
1000222a:	1c1a      	adds	r2, r3, #0
1000222c:	2301      	movs	r3, #1
1000222e:	4093      	lsls	r3, r2
10002230:	60bb      	str	r3, [r7, #8]
  /*If data size is more than FIFO size, configure the limit to the FIFO size*/
  if (data_size < fifo_size)
10002232:	683a      	ldr	r2, [r7, #0]
10002234:	68bb      	ldr	r3, [r7, #8]
10002236:	429a      	cmp	r2, r3
10002238:	d203      	bcs.n	10002242 <UART_lReconfigureRxFIFO+0x2e>
  {
    ret_limit_val = (uint32_t)(data_size - 1U);
1000223a:	683b      	ldr	r3, [r7, #0]
1000223c:	3b01      	subs	r3, #1
1000223e:	60fb      	str	r3, [r7, #12]
10002240:	e002      	b.n	10002248 <UART_lReconfigureRxFIFO+0x34>
  }
  else
  {
    ret_limit_val = (uint32_t)(fifo_size - 1U);
10002242:	68bb      	ldr	r3, [r7, #8]
10002244:	3b01      	subs	r3, #1
10002246:	60fb      	str	r3, [r7, #12]
  }
  /*Set the limit value*/
  XMC_USIC_CH_RXFIFO_SetSizeTriggerLimit(handle->channel,
10002248:	687b      	ldr	r3, [r7, #4]
1000224a:	6819      	ldr	r1, [r3, #0]
        handle->config->rx_fifo_size, ret_limit_val);
1000224c:	687b      	ldr	r3, [r7, #4]
1000224e:	685b      	ldr	r3, [r3, #4]
  else
  {
    ret_limit_val = (uint32_t)(fifo_size - 1U);
  }
  /*Set the limit value*/
  XMC_USIC_CH_RXFIFO_SetSizeTriggerLimit(handle->channel,
10002250:	222c      	movs	r2, #44	; 0x2c
10002252:	5c9a      	ldrb	r2, [r3, r2]
10002254:	68fb      	ldr	r3, [r7, #12]
10002256:	1c08      	adds	r0, r1, #0
10002258:	1c11      	adds	r1, r2, #0
1000225a:	1c1a      	adds	r2, r3, #0
1000225c:	f7ff fc90 	bl	10001b80 <XMC_USIC_CH_RXFIFO_SetSizeTriggerLimit>
        handle->config->rx_fifo_size, ret_limit_val);
}
10002260:	46bd      	mov	sp, r7
10002262:	b004      	add	sp, #16
10002264:	bd80      	pop	{r7, pc}
10002266:	46c0      	nop			; (mov r8, r8)

10002268 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
10002268:	b580      	push	{r7, lr}
1000226a:	b082      	sub	sp, #8
1000226c:	af00      	add	r7, sp, #0
1000226e:	1c02      	adds	r2, r0, #0
10002270:	1dfb      	adds	r3, r7, #7
10002272:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
10002274:	1dfb      	adds	r3, r7, #7
10002276:	781b      	ldrb	r3, [r3, #0]
10002278:	2b7f      	cmp	r3, #127	; 0x7f
1000227a:	d809      	bhi.n	10002290 <__NVIC_EnableIRQ+0x28>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
1000227c:	4b06      	ldr	r3, [pc, #24]	; (10002298 <__NVIC_EnableIRQ+0x30>)
1000227e:	1dfa      	adds	r2, r7, #7
10002280:	7812      	ldrb	r2, [r2, #0]
10002282:	1c11      	adds	r1, r2, #0
10002284:	221f      	movs	r2, #31
10002286:	400a      	ands	r2, r1
10002288:	2101      	movs	r1, #1
1000228a:	4091      	lsls	r1, r2
1000228c:	1c0a      	adds	r2, r1, #0
1000228e:	601a      	str	r2, [r3, #0]
    __COMPILER_BARRIER();
  }
}
10002290:	46bd      	mov	sp, r7
10002292:	b002      	add	sp, #8
10002294:	bd80      	pop	{r7, pc}
10002296:	46c0      	nop			; (mov r8, r8)
10002298:	e000e100 	.word	0xe000e100

1000229c <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
1000229c:	b5b0      	push	{r4, r5, r7, lr}
1000229e:	b082      	sub	sp, #8
100022a0:	af00      	add	r7, sp, #0
100022a2:	1c02      	adds	r2, r0, #0
100022a4:	6039      	str	r1, [r7, #0]
100022a6:	1dfb      	adds	r3, r7, #7
100022a8:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
100022aa:	1dfb      	adds	r3, r7, #7
100022ac:	781b      	ldrb	r3, [r3, #0]
100022ae:	2b7f      	cmp	r3, #127	; 0x7f
100022b0:	d827      	bhi.n	10002302 <__NVIC_SetPriority+0x66>
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
100022b2:	4c2d      	ldr	r4, [pc, #180]	; (10002368 <__NVIC_SetPriority+0xcc>)
100022b4:	1dfb      	adds	r3, r7, #7
100022b6:	781b      	ldrb	r3, [r3, #0]
100022b8:	b25b      	sxtb	r3, r3
100022ba:	089b      	lsrs	r3, r3, #2
100022bc:	492a      	ldr	r1, [pc, #168]	; (10002368 <__NVIC_SetPriority+0xcc>)
100022be:	1dfa      	adds	r2, r7, #7
100022c0:	7812      	ldrb	r2, [r2, #0]
100022c2:	b252      	sxtb	r2, r2
100022c4:	0892      	lsrs	r2, r2, #2
100022c6:	32c0      	adds	r2, #192	; 0xc0
100022c8:	0092      	lsls	r2, r2, #2
100022ca:	5852      	ldr	r2, [r2, r1]
100022cc:	1df9      	adds	r1, r7, #7
100022ce:	7809      	ldrb	r1, [r1, #0]
100022d0:	1c08      	adds	r0, r1, #0
100022d2:	2103      	movs	r1, #3
100022d4:	4001      	ands	r1, r0
100022d6:	00c9      	lsls	r1, r1, #3
100022d8:	1c08      	adds	r0, r1, #0
100022da:	21ff      	movs	r1, #255	; 0xff
100022dc:	4081      	lsls	r1, r0
100022de:	43c9      	mvns	r1, r1
100022e0:	4011      	ands	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
100022e2:	683a      	ldr	r2, [r7, #0]
100022e4:	0192      	lsls	r2, r2, #6
100022e6:	20ff      	movs	r0, #255	; 0xff
100022e8:	4002      	ands	r2, r0
100022ea:	1df8      	adds	r0, r7, #7
100022ec:	7800      	ldrb	r0, [r0, #0]
100022ee:	1c05      	adds	r5, r0, #0
100022f0:	2003      	movs	r0, #3
100022f2:	4028      	ands	r0, r5
100022f4:	00c0      	lsls	r0, r0, #3
100022f6:	4082      	lsls	r2, r0
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
100022f8:	430a      	orrs	r2, r1
100022fa:	33c0      	adds	r3, #192	; 0xc0
100022fc:	009b      	lsls	r3, r3, #2
100022fe:	511a      	str	r2, [r3, r4]
10002300:	e02e      	b.n	10002360 <__NVIC_SetPriority+0xc4>
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
10002302:	4c1a      	ldr	r4, [pc, #104]	; (1000236c <__NVIC_SetPriority+0xd0>)
10002304:	1dfb      	adds	r3, r7, #7
10002306:	781b      	ldrb	r3, [r3, #0]
10002308:	1c1a      	adds	r2, r3, #0
1000230a:	230f      	movs	r3, #15
1000230c:	4013      	ands	r3, r2
1000230e:	3b08      	subs	r3, #8
10002310:	0899      	lsrs	r1, r3, #2
10002312:	4a16      	ldr	r2, [pc, #88]	; (1000236c <__NVIC_SetPriority+0xd0>)
10002314:	1dfb      	adds	r3, r7, #7
10002316:	781b      	ldrb	r3, [r3, #0]
10002318:	1c18      	adds	r0, r3, #0
1000231a:	230f      	movs	r3, #15
1000231c:	4003      	ands	r3, r0
1000231e:	3b08      	subs	r3, #8
10002320:	089b      	lsrs	r3, r3, #2
10002322:	3306      	adds	r3, #6
10002324:	009b      	lsls	r3, r3, #2
10002326:	18d3      	adds	r3, r2, r3
10002328:	685b      	ldr	r3, [r3, #4]
1000232a:	1dfa      	adds	r2, r7, #7
1000232c:	7812      	ldrb	r2, [r2, #0]
1000232e:	1c10      	adds	r0, r2, #0
10002330:	2203      	movs	r2, #3
10002332:	4002      	ands	r2, r0
10002334:	00d2      	lsls	r2, r2, #3
10002336:	1c10      	adds	r0, r2, #0
10002338:	22ff      	movs	r2, #255	; 0xff
1000233a:	4082      	lsls	r2, r0
1000233c:	43d2      	mvns	r2, r2
1000233e:	401a      	ands	r2, r3
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
10002340:	683b      	ldr	r3, [r7, #0]
10002342:	019b      	lsls	r3, r3, #6
10002344:	20ff      	movs	r0, #255	; 0xff
10002346:	4003      	ands	r3, r0
10002348:	1df8      	adds	r0, r7, #7
1000234a:	7800      	ldrb	r0, [r0, #0]
1000234c:	1c05      	adds	r5, r0, #0
1000234e:	2003      	movs	r0, #3
10002350:	4028      	ands	r0, r5
10002352:	00c0      	lsls	r0, r0, #3
10002354:	4083      	lsls	r3, r0
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
10002356:	431a      	orrs	r2, r3
10002358:	1d8b      	adds	r3, r1, #6
1000235a:	009b      	lsls	r3, r3, #2
1000235c:	18e3      	adds	r3, r4, r3
1000235e:	605a      	str	r2, [r3, #4]
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
}
10002360:	46bd      	mov	sp, r7
10002362:	b002      	add	sp, #8
10002364:	bdb0      	pop	{r4, r5, r7, pc}
10002366:	46c0      	nop			; (mov r8, r8)
10002368:	e000e100 	.word	0xe000e100
1000236c:	e000ed00 	.word	0xe000ed00

10002370 <XMC_USIC_CH_SetInputSource>:
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_EnableInputInversion(), XMC_USIC_CH_EnableInputDigitalFilter(), XMC_USIC_CH_EnableInputSync(),
 * XMC_USIC_CH_SetInputSamplingFreq()\n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_SetInputSource(XMC_USIC_CH_t *const channel, const XMC_USIC_CH_INPUT_t input, const uint8_t source)
{
10002370:	b580      	push	{r7, lr}
10002372:	b082      	sub	sp, #8
10002374:	af00      	add	r7, sp, #0
10002376:	6078      	str	r0, [r7, #4]
10002378:	1c08      	adds	r0, r1, #0
1000237a:	1c11      	adds	r1, r2, #0
1000237c:	1cfb      	adds	r3, r7, #3
1000237e:	1c02      	adds	r2, r0, #0
10002380:	701a      	strb	r2, [r3, #0]
10002382:	1cbb      	adds	r3, r7, #2
10002384:	1c0a      	adds	r2, r1, #0
10002386:	701a      	strb	r2, [r3, #0]
  channel->DXCR[input] = (uint32_t)((channel->DXCR[input] & (uint32_t)(~USIC_CH_DXCR_DSEL_Msk)) |
10002388:	1cfb      	adds	r3, r7, #3
1000238a:	7818      	ldrb	r0, [r3, #0]
1000238c:	1cfb      	adds	r3, r7, #3
1000238e:	781b      	ldrb	r3, [r3, #0]
10002390:	687a      	ldr	r2, [r7, #4]
10002392:	3306      	adds	r3, #6
10002394:	009b      	lsls	r3, r3, #2
10002396:	18d3      	adds	r3, r2, r3
10002398:	685b      	ldr	r3, [r3, #4]
1000239a:	2207      	movs	r2, #7
1000239c:	4393      	bics	r3, r2
1000239e:	1c1a      	adds	r2, r3, #0
                                    ((uint32_t)source << USIC_CH_DXCR_DSEL_Pos));
100023a0:	1cbb      	adds	r3, r7, #2
100023a2:	781b      	ldrb	r3, [r3, #0]
 * XMC_USIC_CH_EnableInputInversion(), XMC_USIC_CH_EnableInputDigitalFilter(), XMC_USIC_CH_EnableInputSync(),
 * XMC_USIC_CH_SetInputSamplingFreq()\n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_SetInputSource(XMC_USIC_CH_t *const channel, const XMC_USIC_CH_INPUT_t input, const uint8_t source)
{
  channel->DXCR[input] = (uint32_t)((channel->DXCR[input] & (uint32_t)(~USIC_CH_DXCR_DSEL_Msk)) |
100023a4:	431a      	orrs	r2, r3
100023a6:	6879      	ldr	r1, [r7, #4]
100023a8:	1d83      	adds	r3, r0, #6
100023aa:	009b      	lsls	r3, r3, #2
100023ac:	18cb      	adds	r3, r1, r3
100023ae:	605a      	str	r2, [r3, #4]
                                    ((uint32_t)source << USIC_CH_DXCR_DSEL_Pos));
}
100023b0:	46bd      	mov	sp, r7
100023b2:	b002      	add	sp, #8
100023b4:	bd80      	pop	{r7, pc}
100023b6:	46c0      	nop			; (mov r8, r8)

100023b8 <XMC_UART_CH_Init>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_UART_CH_Start(), XMC_UART_CH_Stop(), XMC_UART_CH_Transmit()\n\n\n
 */
__STATIC_INLINE void XMC_UART_CH_Init(XMC_USIC_CH_t *const channel, const XMC_UART_CH_CONFIG_t *const config)
{
100023b8:	b580      	push	{r7, lr}
100023ba:	b082      	sub	sp, #8
100023bc:	af00      	add	r7, sp, #0
100023be:	6078      	str	r0, [r7, #4]
100023c0:	6039      	str	r1, [r7, #0]
  XMC_UART_CH_InitEx(channel, config, true);
100023c2:	687a      	ldr	r2, [r7, #4]
100023c4:	683b      	ldr	r3, [r7, #0]
100023c6:	1c10      	adds	r0, r2, #0
100023c8:	1c19      	adds	r1, r3, #0
100023ca:	2201      	movs	r2, #1
100023cc:	f7ff f994 	bl	100016f8 <XMC_UART_CH_InitEx>
}
100023d0:	46bd      	mov	sp, r7
100023d2:	b002      	add	sp, #8
100023d4:	bd80      	pop	{r7, pc}
100023d6:	46c0      	nop			; (mov r8, r8)

100023d8 <XMC_UART_CH_Start>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_UART_CH_Stop(), XMC_UART_CH_Transmit()\n\n\n
 */
__STATIC_INLINE void XMC_UART_CH_Start(XMC_USIC_CH_t *const channel)
{
100023d8:	b580      	push	{r7, lr}
100023da:	b082      	sub	sp, #8
100023dc:	af00      	add	r7, sp, #0
100023de:	6078      	str	r0, [r7, #4]
  channel->CCR = (uint32_t)(((channel->CCR) & (~USIC_CH_CCR_MODE_Msk)) | (uint32_t)XMC_USIC_CH_OPERATING_MODE_UART);
100023e0:	687b      	ldr	r3, [r7, #4]
100023e2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
100023e4:	220f      	movs	r2, #15
100023e6:	4393      	bics	r3, r2
100023e8:	2202      	movs	r2, #2
100023ea:	431a      	orrs	r2, r3
100023ec:	687b      	ldr	r3, [r7, #4]
100023ee:	641a      	str	r2, [r3, #64]	; 0x40
}
100023f0:	46bd      	mov	sp, r7
100023f2:	b002      	add	sp, #8
100023f4:	bd80      	pop	{r7, pc}
100023f6:	46c0      	nop			; (mov r8, r8)

100023f8 <UART_BLUETOOTH_init>:
/**********************************************************************************************************************
 * API IMPLEMENTATION
 **********************************************************************************************************************/
/*Channel initialization function*/
UART_STATUS_t UART_BLUETOOTH_init()
{
100023f8:	b580      	push	{r7, lr}
100023fa:	b082      	sub	sp, #8
100023fc:	af00      	add	r7, sp, #0
  UART_STATUS_t status = UART_STATUS_SUCCESS;
100023fe:	1dfb      	adds	r3, r7, #7
10002400:	2200      	movs	r2, #0
10002402:	701a      	strb	r2, [r3, #0]
  /*Configure Receive pin*/
  XMC_GPIO_Init((XMC_GPIO_PORT_t *)PORT1_BASE, 2U, &UART_BLUETOOTH_rx_pin_config);
10002404:	4a31      	ldr	r2, [pc, #196]	; (100024cc <UART_BLUETOOTH_init+0xd4>)
10002406:	4b32      	ldr	r3, [pc, #200]	; (100024d0 <UART_BLUETOOTH_init+0xd8>)
10002408:	1c10      	adds	r0, r2, #0
1000240a:	2102      	movs	r1, #2
1000240c:	1c1a      	adds	r2, r3, #0
1000240e:	f7fe fe7d 	bl	1000110c <XMC_GPIO_Init>
  /* Initialize USIC channel in UART mode*/
  XMC_UART_CH_Init(XMC_UART0_CH1, &UART_BLUETOOTH_channel_config);
10002412:	4a30      	ldr	r2, [pc, #192]	; (100024d4 <UART_BLUETOOTH_init+0xdc>)
10002414:	4b30      	ldr	r3, [pc, #192]	; (100024d8 <UART_BLUETOOTH_init+0xe0>)
10002416:	1c10      	adds	r0, r2, #0
10002418:	1c19      	adds	r1, r3, #0
1000241a:	f7ff ffcd 	bl	100023b8 <XMC_UART_CH_Init>
  /*Set input source path*/
  XMC_USIC_CH_SetInputSource(XMC_UART0_CH1, XMC_USIC_CH_INPUT_DX0, 1U);
1000241e:	4b2d      	ldr	r3, [pc, #180]	; (100024d4 <UART_BLUETOOTH_init+0xdc>)
10002420:	1c18      	adds	r0, r3, #0
10002422:	2100      	movs	r1, #0
10002424:	2201      	movs	r2, #1
10002426:	f7ff ffa3 	bl	10002370 <XMC_USIC_CH_SetInputSource>
  XMC_USIC_CH_SetInputSource(XMC_UART0_CH1, XMC_USIC_CH_INPUT_DX3, 0U);
1000242a:	4b2a      	ldr	r3, [pc, #168]	; (100024d4 <UART_BLUETOOTH_init+0xdc>)
1000242c:	1c18      	adds	r0, r3, #0
1000242e:	2103      	movs	r1, #3
10002430:	2200      	movs	r2, #0
10002432:	f7ff ff9d 	bl	10002370 <XMC_USIC_CH_SetInputSource>
  XMC_USIC_CH_SetInputSource(XMC_UART0_CH1, XMC_USIC_CH_INPUT_DX5, 0U);
10002436:	4b27      	ldr	r3, [pc, #156]	; (100024d4 <UART_BLUETOOTH_init+0xdc>)
10002438:	1c18      	adds	r0, r3, #0
1000243a:	2105      	movs	r1, #5
1000243c:	2200      	movs	r2, #0
1000243e:	f7ff ff97 	bl	10002370 <XMC_USIC_CH_SetInputSource>
  /*Configure transmit FIFO*/
  XMC_USIC_CH_TXFIFO_Configure(XMC_UART0_CH1,
10002442:	4b24      	ldr	r3, [pc, #144]	; (100024d4 <UART_BLUETOOTH_init+0xdc>)
10002444:	1c18      	adds	r0, r3, #0
10002446:	2110      	movs	r1, #16
10002448:	2204      	movs	r2, #4
1000244a:	2301      	movs	r3, #1
1000244c:	f7ff fb38 	bl	10001ac0 <XMC_USIC_CH_TXFIFO_Configure>
        16U,
        XMC_USIC_CH_FIFO_SIZE_16WORDS,
        1U);
  /*Configure receive FIFO*/
  XMC_USIC_CH_RXFIFO_Configure(XMC_UART0_CH1,
10002450:	4b20      	ldr	r3, [pc, #128]	; (100024d4 <UART_BLUETOOTH_init+0xdc>)
10002452:	1c18      	adds	r0, r3, #0
10002454:	2100      	movs	r1, #0
10002456:	2204      	movs	r2, #4
10002458:	2300      	movs	r3, #0
1000245a:	f7ff fb5f 	bl	10001b1c <XMC_USIC_CH_RXFIFO_Configure>
        0U,
        XMC_USIC_CH_FIFO_SIZE_16WORDS,
        0U);
  /* Start UART */
  XMC_UART_CH_Start(XMC_UART0_CH1);
1000245e:	4b1d      	ldr	r3, [pc, #116]	; (100024d4 <UART_BLUETOOTH_init+0xdc>)
10002460:	1c18      	adds	r0, r3, #0
10002462:	f7ff ffb9 	bl	100023d8 <XMC_UART_CH_Start>

  /* Initialize UART TX pin */
  XMC_GPIO_Init((XMC_GPIO_PORT_t *)PORT1_BASE, 3U, &UART_BLUETOOTH_tx_pin_config);
10002466:	4a19      	ldr	r2, [pc, #100]	; (100024cc <UART_BLUETOOTH_init+0xd4>)
10002468:	4b1c      	ldr	r3, [pc, #112]	; (100024dc <UART_BLUETOOTH_init+0xe4>)
1000246a:	1c10      	adds	r0, r2, #0
1000246c:	2103      	movs	r1, #3
1000246e:	1c1a      	adds	r2, r3, #0
10002470:	f7fe fe4c 	bl	1000110c <XMC_GPIO_Init>

  /*Set service request for UART protocol events*/
  XMC_USIC_CH_SetInterruptNodePointer(XMC_UART0_CH1, XMC_USIC_CH_INTERRUPT_NODE_POINTER_PROTOCOL,
10002474:	4b17      	ldr	r3, [pc, #92]	; (100024d4 <UART_BLUETOOTH_init+0xdc>)
10002476:	1c18      	adds	r0, r3, #0
10002478:	2110      	movs	r1, #16
1000247a:	2201      	movs	r2, #1
1000247c:	f7ff fb9c 	bl	10001bb8 <XMC_USIC_CH_SetInterruptNodePointer>
     1U);
  /*Set service request for tx FIFO transmit interrupt*/
  XMC_USIC_CH_TXFIFO_SetInterruptNodePointer(XMC_UART0_CH1, XMC_USIC_CH_TXFIFO_INTERRUPT_NODE_POINTER_STANDARD,
10002480:	4b14      	ldr	r3, [pc, #80]	; (100024d4 <UART_BLUETOOTH_init+0xdc>)
10002482:	1c18      	adds	r0, r3, #0
10002484:	2110      	movs	r1, #16
10002486:	2201      	movs	r2, #1
10002488:	f7ff fbb6 	bl	10001bf8 <XMC_USIC_CH_TXFIFO_SetInterruptNodePointer>
      1U);
  /*Set service request for rx FIFO receive interrupt*/
  XMC_USIC_CH_RXFIFO_SetInterruptNodePointer(XMC_UART0_CH1, XMC_USIC_CH_RXFIFO_INTERRUPT_NODE_POINTER_STANDARD,
1000248c:	4b11      	ldr	r3, [pc, #68]	; (100024d4 <UART_BLUETOOTH_init+0xdc>)
1000248e:	1c18      	adds	r0, r3, #0
10002490:	2110      	movs	r1, #16
10002492:	2200      	movs	r2, #0
10002494:	f7ff fbd4 	bl	10001c40 <XMC_USIC_CH_RXFIFO_SetInterruptNodePointer>
       0x0U);
  XMC_USIC_CH_RXFIFO_SetInterruptNodePointer(XMC_UART0_CH1, XMC_USIC_CH_RXFIFO_INTERRUPT_NODE_POINTER_ALTERNATE,
10002498:	4b0e      	ldr	r3, [pc, #56]	; (100024d4 <UART_BLUETOOTH_init+0xdc>)
1000249a:	1c18      	adds	r0, r3, #0
1000249c:	2113      	movs	r1, #19
1000249e:	2200      	movs	r2, #0
100024a0:	f7ff fbce 	bl	10001c40 <XMC_USIC_CH_RXFIFO_SetInterruptNodePointer>
       0x0U);
  /*Set priority and enable NVIC node for transmit interrupt*/
  NVIC_SetPriority((IRQn_Type)10, 3U);
100024a4:	200a      	movs	r0, #10
100024a6:	2103      	movs	r1, #3
100024a8:	f7ff fef8 	bl	1000229c <__NVIC_SetPriority>
  NVIC_EnableIRQ((IRQn_Type)10);
100024ac:	200a      	movs	r0, #10
100024ae:	f7ff fedb 	bl	10002268 <__NVIC_EnableIRQ>
  /*Set priority and enable NVIC node for receive interrupt*/
  NVIC_SetPriority((IRQn_Type)9, 3U);
100024b2:	2009      	movs	r0, #9
100024b4:	2103      	movs	r1, #3
100024b6:	f7ff fef1 	bl	1000229c <__NVIC_SetPriority>
  NVIC_EnableIRQ((IRQn_Type)9);
100024ba:	2009      	movs	r0, #9
100024bc:	f7ff fed4 	bl	10002268 <__NVIC_EnableIRQ>
  return status;
100024c0:	1dfb      	adds	r3, r7, #7
100024c2:	781b      	ldrb	r3, [r3, #0]
}
100024c4:	1c18      	adds	r0, r3, #0
100024c6:	46bd      	mov	sp, r7
100024c8:	b002      	add	sp, #8
100024ca:	bd80      	pop	{r7, pc}
100024cc:	40040100 	.word	0x40040100
100024d0:	1000a17c 	.word	0x1000a17c
100024d4:	48000200 	.word	0x48000200
100024d8:	1000a12c 	.word	0x1000a12c
100024dc:	1000a138 	.word	0x1000a138

100024e0 <USIC0_1_IRQHandler>:
/*Interrupt handlers*/
/*Transmit ISR*/
void UART_BLUETOOTH_TX_HANDLER()
{
100024e0:	b580      	push	{r7, lr}
100024e2:	af00      	add	r7, sp, #0
  UART_lTransmitHandler(&UART_BLUETOOTH);
100024e4:	4b02      	ldr	r3, [pc, #8]	; (100024f0 <USIC0_1_IRQHandler+0x10>)
100024e6:	1c18      	adds	r0, r3, #0
100024e8:	f7ff fd78 	bl	10001fdc <UART_lTransmitHandler>
}
100024ec:	46bd      	mov	sp, r7
100024ee:	bd80      	pop	{r7, pc}
100024f0:	20000520 	.word	0x20000520

100024f4 <USIC0_0_IRQHandler>:

/*Receive ISR*/
void UART_BLUETOOTH_RX_HANDLER()
{
100024f4:	b580      	push	{r7, lr}
100024f6:	af00      	add	r7, sp, #0
  UART_lReceiveHandler(&UART_BLUETOOTH);
100024f8:	4b02      	ldr	r3, [pc, #8]	; (10002504 <USIC0_0_IRQHandler+0x10>)
100024fa:	1c18      	adds	r0, r3, #0
100024fc:	f7ff fdf6 	bl	100020ec <UART_lReceiveHandler>
}
10002500:	46bd      	mov	sp, r7
10002502:	bd80      	pop	{r7, pc}
10002504:	20000520 	.word	0x20000520

10002508 <XMC_CCU4_EnableClock>:
 *
 * \par<b>Related APIs:</b><br>
 * XMC_CCU4_DisableClock()<BR> XMC_CCU4_EnableMultipleClocks()<BR> XMC_CCU4_StartPrescaler()<BR> XMC_CCU4_StopPrescaler().
 */
__STATIC_INLINE void XMC_CCU4_EnableClock(XMC_CCU4_MODULE_t *const module, const uint8_t slice_number)
{
10002508:	b580      	push	{r7, lr}
1000250a:	b082      	sub	sp, #8
1000250c:	af00      	add	r7, sp, #0
1000250e:	6078      	str	r0, [r7, #4]
10002510:	1c0a      	adds	r2, r1, #0
10002512:	1cfb      	adds	r3, r7, #3
10002514:	701a      	strb	r2, [r3, #0]
  XMC_ASSERT("XMC_CCU4_EnableClock:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));
  XMC_ASSERT("XMC_CCU4_EnableClock:Invalid Slice Number", (slice_number < 4U));

  module->GIDLC = ((uint32_t) 1) << slice_number;
10002516:	1cfb      	adds	r3, r7, #3
10002518:	781b      	ldrb	r3, [r3, #0]
1000251a:	2201      	movs	r2, #1
1000251c:	409a      	lsls	r2, r3
1000251e:	687b      	ldr	r3, [r7, #4]
10002520:	60da      	str	r2, [r3, #12]
}
10002522:	46bd      	mov	sp, r7
10002524:	b002      	add	sp, #8
10002526:	bd80      	pop	{r7, pc}

10002528 <XMC_CCU4_SLICE_StartTimer>:
 *
 * \par<b>Related APIs:</b><br>
 *  XMC_CCU4_SLICE_StopTimer().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_StartTimer(XMC_CCU4_SLICE_t *const slice)
{
10002528:	b580      	push	{r7, lr}
1000252a:	b082      	sub	sp, #8
1000252c:	af00      	add	r7, sp, #0
1000252e:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_CCU4_SLICE_StartTimer:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TCSET = CCU4_CC4_TCSET_TRBS_Msk;
10002530:	687b      	ldr	r3, [r7, #4]
10002532:	2201      	movs	r2, #1
10002534:	60da      	str	r2, [r3, #12]
}
10002536:	46bd      	mov	sp, r7
10002538:	b002      	add	sp, #8
1000253a:	bd80      	pop	{r7, pc}

1000253c <XMC_CCU4_SLICE_ClearTimer>:
 *
 * \par<b>Related APIs:</b><br>
 *  XMC_CCU4_SLICE_StartTimer().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_ClearTimer(XMC_CCU4_SLICE_t *const slice)
{
1000253c:	b580      	push	{r7, lr}
1000253e:	b082      	sub	sp, #8
10002540:	af00      	add	r7, sp, #0
10002542:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_CCU4_SLICE_ClearTimer:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TCCLR = (uint32_t) CCU4_CC4_TCCLR_TCC_Msk;
10002544:	687b      	ldr	r3, [r7, #4]
10002546:	2202      	movs	r2, #2
10002548:	611a      	str	r2, [r3, #16]
}
1000254a:	46bd      	mov	sp, r7
1000254c:	b002      	add	sp, #8
1000254e:	bd80      	pop	{r7, pc}

10002550 <XMC_CCU4_SLICE_SetTimerPeriodMatch>:
 *
 * \par<b>Related APIs:</b><br>
 *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerPeriodMatch(XMC_CCU4_SLICE_t *const slice, const uint16_t period_val)
{
10002550:	b580      	push	{r7, lr}
10002552:	b082      	sub	sp, #8
10002554:	af00      	add	r7, sp, #0
10002556:	6078      	str	r0, [r7, #4]
10002558:	1c0a      	adds	r2, r1, #0
1000255a:	1cbb      	adds	r3, r7, #2
1000255c:	801a      	strh	r2, [r3, #0]
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerPeriodMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->PRS = (uint32_t) period_val;
1000255e:	1cbb      	adds	r3, r7, #2
10002560:	881a      	ldrh	r2, [r3, #0]
10002562:	687b      	ldr	r3, [r7, #4]
10002564:	635a      	str	r2, [r3, #52]	; 0x34
}
10002566:	46bd      	mov	sp, r7
10002568:	b002      	add	sp, #8
1000256a:	bd80      	pop	{r7, pc}

1000256c <XMC_CCU4_SLICE_SetTimerCompareMatch>:
 *
 * \par<b>Related APIs:</b><br>
 *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerCompareMatch(XMC_CCU4_SLICE_t *const slice, const uint16_t compare_val)
{
1000256c:	b580      	push	{r7, lr}
1000256e:	b082      	sub	sp, #8
10002570:	af00      	add	r7, sp, #0
10002572:	6078      	str	r0, [r7, #4]
10002574:	1c0a      	adds	r2, r1, #0
10002576:	1cbb      	adds	r3, r7, #2
10002578:	801a      	strh	r2, [r3, #0]
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerCompareMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->CRS = (uint32_t) compare_val;
1000257a:	1cbb      	adds	r3, r7, #2
1000257c:	881a      	ldrh	r2, [r3, #0]
1000257e:	687b      	ldr	r3, [r7, #4]
10002580:	63da      	str	r2, [r3, #60]	; 0x3c
}
10002582:	46bd      	mov	sp, r7
10002584:	b002      	add	sp, #8
10002586:	bd80      	pop	{r7, pc}

10002588 <XMC_CCU4_EnableShadowTransfer>:
 *
 * \par<b>Related APIs:</b><br>
 *  None.
 */
__STATIC_INLINE void XMC_CCU4_EnableShadowTransfer(XMC_CCU4_MODULE_t *const module, const uint32_t shadow_transfer_msk)
{
10002588:	b580      	push	{r7, lr}
1000258a:	b082      	sub	sp, #8
1000258c:	af00      	add	r7, sp, #0
1000258e:	6078      	str	r0, [r7, #4]
10002590:	6039      	str	r1, [r7, #0]
  XMC_ASSERT("XMC_CCU4_EnableShadowTransfer:Invalid Slice Pointer", XMC_CCU4_IsValidModule(module));
  module->GCSS = (uint32_t)shadow_transfer_msk;
10002592:	687b      	ldr	r3, [r7, #4]
10002594:	683a      	ldr	r2, [r7, #0]
10002596:	611a      	str	r2, [r3, #16]
}
10002598:	46bd      	mov	sp, r7
1000259a:	b002      	add	sp, #8
1000259c:	bd80      	pop	{r7, pc}
1000259e:	46c0      	nop			; (mov r8, r8)

100025a0 <XMC_CCU4_SLICE_EnableEvent>:
 *  XMC_CCU4_SLICE_SetInterruptNode()<BR> XMC_CCU4_SLICE_EnableMultipleEvents()<BR> XMC_CCU4_SLICE_DisableEvent()<BR>
 *  XMC_CCU4_SLICE_DisableMultipleEvents().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_EnableEvent(XMC_CCU4_SLICE_t *const slice,
    const XMC_CCU4_SLICE_IRQ_ID_t event)
{
100025a0:	b580      	push	{r7, lr}
100025a2:	b082      	sub	sp, #8
100025a4:	af00      	add	r7, sp, #0
100025a6:	6078      	str	r0, [r7, #4]
100025a8:	1c0a      	adds	r2, r1, #0
100025aa:	1cfb      	adds	r3, r7, #3
100025ac:	701a      	strb	r2, [r3, #0]
  XMC_ASSERT("XMC_CCU4_SLICE_EnableEvent:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_EnableEvent:Invalid SR event", XMC_CCU4_SLICE_CHECK_INTERRUPT(event));
  slice->INTE |= ((uint32_t) 1) << ((uint32_t) event);
100025ae:	687b      	ldr	r3, [r7, #4]
100025b0:	22a4      	movs	r2, #164	; 0xa4
100025b2:	589a      	ldr	r2, [r3, r2]
100025b4:	1cfb      	adds	r3, r7, #3
100025b6:	781b      	ldrb	r3, [r3, #0]
100025b8:	2101      	movs	r1, #1
100025ba:	4099      	lsls	r1, r3
100025bc:	1c0b      	adds	r3, r1, #0
100025be:	431a      	orrs	r2, r3
100025c0:	687b      	ldr	r3, [r7, #4]
100025c2:	21a4      	movs	r1, #164	; 0xa4
100025c4:	505a      	str	r2, [r3, r1]
}
100025c6:	46bd      	mov	sp, r7
100025c8:	b002      	add	sp, #8
100025ca:	bd80      	pop	{r7, pc}

100025cc <TIMER_Init>:
/*
 * This function initializes a TIMER APP based on user configuration.
 *
 */
TIMER_STATUS_t TIMER_Init(TIMER_t* const handle_ptr)
{
100025cc:	b590      	push	{r4, r7, lr}
100025ce:	b085      	sub	sp, #20
100025d0:	af00      	add	r7, sp, #0
100025d2:	6078      	str	r0, [r7, #4]
  TIMER_STATUS_t status;

  XMC_ASSERT("TIMER_Init:handle_ptr NULL" , (handle_ptr != NULL));

  status = TIMER_STATUS_SUCCESS;
100025d4:	230f      	movs	r3, #15
100025d6:	18fb      	adds	r3, r7, r3
100025d8:	2200      	movs	r2, #0
100025da:	701a      	strb	r2, [r3, #0]
  /* Check for APP instance is initialized or not */
  if (false == handle_ptr->initialized)
100025dc:	687b      	ldr	r3, [r7, #4]
100025de:	2226      	movs	r2, #38	; 0x26
100025e0:	5c9b      	ldrb	r3, [r3, r2]
100025e2:	2201      	movs	r2, #1
100025e4:	4053      	eors	r3, r2
100025e6:	b2db      	uxtb	r3, r3
100025e8:	2b00      	cmp	r3, #0
100025ea:	d00c      	beq.n	10002606 <TIMER_Init+0x3a>
  {
#ifdef TIMER_CCU4_USED
    if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
100025ec:	687b      	ldr	r3, [r7, #4]
100025ee:	2221      	movs	r2, #33	; 0x21
100025f0:	5c9b      	ldrb	r3, [r3, r2]
100025f2:	2b00      	cmp	r3, #0
100025f4:	d107      	bne.n	10002606 <TIMER_Init+0x3a>
    {
      /* Configure CCU4 timer for the required time tick settings */
      status = TIMER_CCU4_lInit(handle_ptr);
100025f6:	230f      	movs	r3, #15
100025f8:	18fc      	adds	r4, r7, r3
100025fa:	687b      	ldr	r3, [r7, #4]
100025fc:	1c18      	adds	r0, r3, #0
100025fe:	f000 f82d 	bl	1000265c <TIMER_CCU4_lInit>
10002602:	1c03      	adds	r3, r0, #0
10002604:	7023      	strb	r3, [r4, #0]
      status = TIMER_CCU8_lInit(handle_ptr);
    }
#endif
  }

  return (status);
10002606:	230f      	movs	r3, #15
10002608:	18fb      	adds	r3, r7, r3
1000260a:	781b      	ldrb	r3, [r3, #0]
}
1000260c:	1c18      	adds	r0, r3, #0
1000260e:	46bd      	mov	sp, r7
10002610:	b005      	add	sp, #20
10002612:	bd90      	pop	{r4, r7, pc}

10002614 <TIMER_Start>:

/*
 * This function starts the timer to generate the events for the specified time_interval value
 */
TIMER_STATUS_t TIMER_Start(TIMER_t  *const handle_ptr)
{
10002614:	b580      	push	{r7, lr}
10002616:	b084      	sub	sp, #16
10002618:	af00      	add	r7, sp, #0
1000261a:	6078      	str	r0, [r7, #4]
  TIMER_STATUS_t status;

  XMC_ASSERT("TIMER_Start:handle_ptr NULL" , (handle_ptr != NULL));

  /* Check for APP instance is initialized or not */
  if (true == handle_ptr->initialized)
1000261c:	687b      	ldr	r3, [r7, #4]
1000261e:	2226      	movs	r2, #38	; 0x26
10002620:	5c9b      	ldrb	r3, [r3, r2]
10002622:	2b00      	cmp	r3, #0
10002624:	d00e      	beq.n	10002644 <TIMER_Start+0x30>
  {
#ifdef TIMER_CCU4_USED
    if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
10002626:	687b      	ldr	r3, [r7, #4]
10002628:	2221      	movs	r2, #33	; 0x21
1000262a:	5c9b      	ldrb	r3, [r3, r2]
1000262c:	2b00      	cmp	r3, #0
1000262e:	d104      	bne.n	1000263a <TIMER_Start+0x26>
    {
      /* Start the timer manually */
      XMC_CCU4_SLICE_StartTimer(handle_ptr->ccu4_slice_ptr);
10002630:	687b      	ldr	r3, [r7, #4]
10002632:	695b      	ldr	r3, [r3, #20]
10002634:	1c18      	adds	r0, r3, #0
10002636:	f7ff ff77 	bl	10002528 <XMC_CCU4_SLICE_StartTimer>
       {
      /* Start the timer manually */
      XMC_CCU8_SLICE_StartTimer(handle_ptr->ccu8_slice_ptr);
       }
#endif
    status = TIMER_STATUS_SUCCESS;
1000263a:	230f      	movs	r3, #15
1000263c:	18fb      	adds	r3, r7, r3
1000263e:	2200      	movs	r2, #0
10002640:	701a      	strb	r2, [r3, #0]
10002642:	e003      	b.n	1000264c <TIMER_Start+0x38>
  }
  else
  {
    status = TIMER_STATUS_FAILURE;
10002644:	230f      	movs	r3, #15
10002646:	18fb      	adds	r3, r7, r3
10002648:	2201      	movs	r2, #1
1000264a:	701a      	strb	r2, [r3, #0]
  }

  return (status);
1000264c:	230f      	movs	r3, #15
1000264e:	18fb      	adds	r3, r7, r3
10002650:	781b      	ldrb	r3, [r3, #0]
}
10002652:	1c18      	adds	r0, r3, #0
10002654:	46bd      	mov	sp, r7
10002656:	b004      	add	sp, #16
10002658:	bd80      	pop	{r7, pc}
1000265a:	46c0      	nop			; (mov r8, r8)

1000265c <TIMER_CCU4_lInit>:
#ifdef TIMER_CCU4_USED
/*
 * This function configures timer ccu4 timer with required time tick value
 */
TIMER_STATUS_t TIMER_CCU4_lInit(TIMER_t* const handle_ptr)
{
1000265c:	b590      	push	{r4, r7, lr}
1000265e:	b085      	sub	sp, #20
10002660:	af00      	add	r7, sp, #0
10002662:	6078      	str	r0, [r7, #4]
  TIMER_STATUS_t status;
  /* Initialize the global registers */
  status = (TIMER_STATUS_t)GLOBAL_CCU4_Init(handle_ptr->global_ccu4_handler);
10002664:	687b      	ldr	r3, [r7, #4]
10002666:	691b      	ldr	r3, [r3, #16]
10002668:	220f      	movs	r2, #15
1000266a:	18bc      	adds	r4, r7, r2
1000266c:	1c18      	adds	r0, r3, #0
1000266e:	f000 fa61 	bl	10002b34 <GLOBAL_CCU4_Init>
10002672:	1c03      	adds	r3, r0, #0
10002674:	7023      	strb	r3, [r4, #0]

  /* Enable the clock for selected timer */
  XMC_CCU4_EnableClock(handle_ptr->global_ccu4_handler->module_ptr, handle_ptr->ccu4_slice_number);
10002676:	687b      	ldr	r3, [r7, #4]
10002678:	691b      	ldr	r3, [r3, #16]
1000267a:	689a      	ldr	r2, [r3, #8]
1000267c:	687b      	ldr	r3, [r7, #4]
1000267e:	7e1b      	ldrb	r3, [r3, #24]
10002680:	1c10      	adds	r0, r2, #0
10002682:	1c19      	adds	r1, r3, #0
10002684:	f7ff ff40 	bl	10002508 <XMC_CCU4_EnableClock>
  /* Configure the timer with required settings */
  XMC_CCU4_SLICE_CompareInit(handle_ptr->ccu4_slice_ptr, handle_ptr->ccu4_slice_config_ptr);
10002688:	687b      	ldr	r3, [r7, #4]
1000268a:	695a      	ldr	r2, [r3, #20]
1000268c:	687b      	ldr	r3, [r7, #4]
1000268e:	69db      	ldr	r3, [r3, #28]
10002690:	1c10      	adds	r0, r2, #0
10002692:	1c19      	adds	r1, r3, #0
10002694:	f7fe ff68 	bl	10001568 <XMC_CCU4_SLICE_CompareInit>
  /* programs the timer period and compare register according to time interval value and do the shadow transfer */
  TIMER_CCU4_lShadowTransfer(handle_ptr);
10002698:	687b      	ldr	r3, [r7, #4]
1000269a:	1c18      	adds	r0, r3, #0
1000269c:	f000 f830 	bl	10002700 <TIMER_CCU4_lShadowTransfer>

#ifdef  TIMER_INTERRUPT
  if (true == handle_ptr->period_match_enable)
100026a0:	687b      	ldr	r3, [r7, #4]
100026a2:	2225      	movs	r2, #37	; 0x25
100026a4:	5c9b      	ldrb	r3, [r3, r2]
100026a6:	2b00      	cmp	r3, #0
100026a8:	d00f      	beq.n	100026ca <TIMER_CCU4_lInit+0x6e>
  {
    /* Binds a period match event to an NVIC node  */
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH,
100026aa:	687b      	ldr	r3, [r7, #4]
100026ac:	6959      	ldr	r1, [r3, #20]
100026ae:	687b      	ldr	r3, [r7, #4]
100026b0:	2220      	movs	r2, #32
100026b2:	5c9b      	ldrb	r3, [r3, r2]
100026b4:	1c08      	adds	r0, r1, #0
100026b6:	2100      	movs	r1, #0
100026b8:	1c1a      	adds	r2, r3, #0
100026ba:	f7fe ff89 	bl	100015d0 <XMC_CCU4_SLICE_SetInterruptNode>
                                    handle_ptr->ccu4_period_match_node);
    /* Enables a timer(period match) event  */
    XMC_CCU4_SLICE_EnableEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH);
100026be:	687b      	ldr	r3, [r7, #4]
100026c0:	695b      	ldr	r3, [r3, #20]
100026c2:	1c18      	adds	r0, r3, #0
100026c4:	2100      	movs	r1, #0
100026c6:	f7ff ff6b 	bl	100025a0 <XMC_CCU4_SLICE_EnableEvent>
  }
#endif
  /* Clears the timer register */
  XMC_CCU4_SLICE_ClearTimer(handle_ptr->ccu4_slice_ptr);
100026ca:	687b      	ldr	r3, [r7, #4]
100026cc:	695b      	ldr	r3, [r3, #20]
100026ce:	1c18      	adds	r0, r3, #0
100026d0:	f7ff ff34 	bl	1000253c <XMC_CCU4_SLICE_ClearTimer>

  /* update the initialization flag as true for particular instance*/
  handle_ptr->initialized = true;
100026d4:	687b      	ldr	r3, [r7, #4]
100026d6:	2226      	movs	r2, #38	; 0x26
100026d8:	2101      	movs	r1, #1
100026da:	5499      	strb	r1, [r3, r2]

  /* Check whether the start of the timer is enabled during initialization or not */
  if (handle_ptr->start_control == true)
100026dc:	687b      	ldr	r3, [r7, #4]
100026de:	2224      	movs	r2, #36	; 0x24
100026e0:	5c9b      	ldrb	r3, [r3, r2]
100026e2:	2b00      	cmp	r3, #0
100026e4:	d004      	beq.n	100026f0 <TIMER_CCU4_lInit+0x94>
  {
    /* Start the timer */
    XMC_CCU4_SLICE_StartTimer(handle_ptr->ccu4_slice_ptr);
100026e6:	687b      	ldr	r3, [r7, #4]
100026e8:	695b      	ldr	r3, [r3, #20]
100026ea:	1c18      	adds	r0, r3, #0
100026ec:	f7ff ff1c 	bl	10002528 <XMC_CCU4_SLICE_StartTimer>
  }

  return (status);
100026f0:	230f      	movs	r3, #15
100026f2:	18fb      	adds	r3, r7, r3
100026f4:	781b      	ldrb	r3, [r3, #0]
}
100026f6:	1c18      	adds	r0, r3, #0
100026f8:	46bd      	mov	sp, r7
100026fa:	b005      	add	sp, #20
100026fc:	bd90      	pop	{r4, r7, pc}
100026fe:	46c0      	nop			; (mov r8, r8)

10002700 <TIMER_CCU4_lShadowTransfer>:

/*
 * This function configures timer period and compare values and triggers the shadow transfer operation
 */
void TIMER_CCU4_lShadowTransfer(TIMER_t* const handle_ptr)
{
10002700:	b580      	push	{r7, lr}
10002702:	b082      	sub	sp, #8
10002704:	af00      	add	r7, sp, #0
10002706:	6078      	str	r0, [r7, #4]
  /* programs the timer period register according to time interval value */
  XMC_CCU4_SLICE_SetTimerPeriodMatch(handle_ptr->ccu4_slice_ptr, handle_ptr->period_value);
10002708:	687b      	ldr	r3, [r7, #4]
1000270a:	695a      	ldr	r2, [r3, #20]
1000270c:	687b      	ldr	r3, [r7, #4]
1000270e:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
10002710:	1c10      	adds	r0, r2, #0
10002712:	1c19      	adds	r1, r3, #0
10002714:	f7ff ff1c 	bl	10002550 <XMC_CCU4_SLICE_SetTimerPeriodMatch>
  /* programs the timer compare register for 50% duty cycle */
  XMC_CCU4_SLICE_SetTimerCompareMatch(handle_ptr->ccu4_slice_ptr, TIMER_CMP_100_DUTY);
10002718:	687b      	ldr	r3, [r7, #4]
1000271a:	695b      	ldr	r3, [r3, #20]
1000271c:	1c18      	adds	r0, r3, #0
1000271e:	2100      	movs	r1, #0
10002720:	f7ff ff24 	bl	1000256c <XMC_CCU4_SLICE_SetTimerCompareMatch>
  /* Transfers value from shadow timer registers to actual timer registers */
  XMC_CCU4_EnableShadowTransfer(handle_ptr->global_ccu4_handler->module_ptr, handle_ptr->shadow_mask);
10002724:	687b      	ldr	r3, [r7, #4]
10002726:	691b      	ldr	r3, [r3, #16]
10002728:	689a      	ldr	r2, [r3, #8]
1000272a:	687b      	ldr	r3, [r7, #4]
1000272c:	68db      	ldr	r3, [r3, #12]
1000272e:	1c10      	adds	r0, r2, #0
10002730:	1c19      	adds	r1, r3, #0
10002732:	f7ff ff29 	bl	10002588 <XMC_CCU4_EnableShadowTransfer>
}
10002736:	46bd      	mov	sp, r7
10002738:	b002      	add	sp, #8
1000273a:	bd80      	pop	{r7, pc}

1000273c <XMC_CCU4_EnableClock>:
 *
 * \par<b>Related APIs:</b><br>
 * XMC_CCU4_DisableClock()<BR> XMC_CCU4_EnableMultipleClocks()<BR> XMC_CCU4_StartPrescaler()<BR> XMC_CCU4_StopPrescaler().
 */
__STATIC_INLINE void XMC_CCU4_EnableClock(XMC_CCU4_MODULE_t *const module, const uint8_t slice_number)
{
1000273c:	b580      	push	{r7, lr}
1000273e:	b082      	sub	sp, #8
10002740:	af00      	add	r7, sp, #0
10002742:	6078      	str	r0, [r7, #4]
10002744:	1c0a      	adds	r2, r1, #0
10002746:	1cfb      	adds	r3, r7, #3
10002748:	701a      	strb	r2, [r3, #0]
  XMC_ASSERT("XMC_CCU4_EnableClock:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));
  XMC_ASSERT("XMC_CCU4_EnableClock:Invalid Slice Number", (slice_number < 4U));

  module->GIDLC = ((uint32_t) 1) << slice_number;
1000274a:	1cfb      	adds	r3, r7, #3
1000274c:	781b      	ldrb	r3, [r3, #0]
1000274e:	2201      	movs	r2, #1
10002750:	409a      	lsls	r2, r3
10002752:	687b      	ldr	r3, [r7, #4]
10002754:	60da      	str	r2, [r3, #12]
}
10002756:	46bd      	mov	sp, r7
10002758:	b002      	add	sp, #8
1000275a:	bd80      	pop	{r7, pc}

1000275c <XMC_CCU4_SLICE_StartTimer>:
 *
 * \par<b>Related APIs:</b><br>
 *  XMC_CCU4_SLICE_StopTimer().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_StartTimer(XMC_CCU4_SLICE_t *const slice)
{
1000275c:	b580      	push	{r7, lr}
1000275e:	b082      	sub	sp, #8
10002760:	af00      	add	r7, sp, #0
10002762:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_CCU4_SLICE_StartTimer:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TCSET = CCU4_CC4_TCSET_TRBS_Msk;
10002764:	687b      	ldr	r3, [r7, #4]
10002766:	2201      	movs	r2, #1
10002768:	60da      	str	r2, [r3, #12]
}
1000276a:	46bd      	mov	sp, r7
1000276c:	b002      	add	sp, #8
1000276e:	bd80      	pop	{r7, pc}

10002770 <XMC_CCU4_SLICE_SetTimerPeriodMatch>:
 *
 * \par<b>Related APIs:</b><br>
 *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerPeriodMatch(XMC_CCU4_SLICE_t *const slice, const uint16_t period_val)
{
10002770:	b580      	push	{r7, lr}
10002772:	b082      	sub	sp, #8
10002774:	af00      	add	r7, sp, #0
10002776:	6078      	str	r0, [r7, #4]
10002778:	1c0a      	adds	r2, r1, #0
1000277a:	1cbb      	adds	r3, r7, #2
1000277c:	801a      	strh	r2, [r3, #0]
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerPeriodMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->PRS = (uint32_t) period_val;
1000277e:	1cbb      	adds	r3, r7, #2
10002780:	881a      	ldrh	r2, [r3, #0]
10002782:	687b      	ldr	r3, [r7, #4]
10002784:	635a      	str	r2, [r3, #52]	; 0x34
}
10002786:	46bd      	mov	sp, r7
10002788:	b002      	add	sp, #8
1000278a:	bd80      	pop	{r7, pc}

1000278c <XMC_CCU4_SLICE_SetTimerCompareMatch>:
 *
 * \par<b>Related APIs:</b><br>
 *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerCompareMatch(XMC_CCU4_SLICE_t *const slice, const uint16_t compare_val)
{
1000278c:	b580      	push	{r7, lr}
1000278e:	b082      	sub	sp, #8
10002790:	af00      	add	r7, sp, #0
10002792:	6078      	str	r0, [r7, #4]
10002794:	1c0a      	adds	r2, r1, #0
10002796:	1cbb      	adds	r3, r7, #2
10002798:	801a      	strh	r2, [r3, #0]
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerCompareMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->CRS = (uint32_t) compare_val;
1000279a:	1cbb      	adds	r3, r7, #2
1000279c:	881a      	ldrh	r2, [r3, #0]
1000279e:	687b      	ldr	r3, [r7, #4]
100027a0:	63da      	str	r2, [r3, #60]	; 0x3c
}
100027a2:	46bd      	mov	sp, r7
100027a4:	b002      	add	sp, #8
100027a6:	bd80      	pop	{r7, pc}

100027a8 <XMC_CCU4_EnableShadowTransfer>:
 *
 * \par<b>Related APIs:</b><br>
 *  None.
 */
__STATIC_INLINE void XMC_CCU4_EnableShadowTransfer(XMC_CCU4_MODULE_t *const module, const uint32_t shadow_transfer_msk)
{
100027a8:	b580      	push	{r7, lr}
100027aa:	b082      	sub	sp, #8
100027ac:	af00      	add	r7, sp, #0
100027ae:	6078      	str	r0, [r7, #4]
100027b0:	6039      	str	r1, [r7, #0]
  XMC_ASSERT("XMC_CCU4_EnableShadowTransfer:Invalid Slice Pointer", XMC_CCU4_IsValidModule(module));
  module->GCSS = (uint32_t)shadow_transfer_msk;
100027b2:	687b      	ldr	r3, [r7, #4]
100027b4:	683a      	ldr	r2, [r7, #0]
100027b6:	611a      	str	r2, [r3, #16]
}
100027b8:	46bd      	mov	sp, r7
100027ba:	b002      	add	sp, #8
100027bc:	bd80      	pop	{r7, pc}
100027be:	46c0      	nop			; (mov r8, r8)

100027c0 <XMC_CCU4_SLICE_EnableEvent>:
 *  XMC_CCU4_SLICE_SetInterruptNode()<BR> XMC_CCU4_SLICE_EnableMultipleEvents()<BR> XMC_CCU4_SLICE_DisableEvent()<BR>
 *  XMC_CCU4_SLICE_DisableMultipleEvents().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_EnableEvent(XMC_CCU4_SLICE_t *const slice,
    const XMC_CCU4_SLICE_IRQ_ID_t event)
{
100027c0:	b580      	push	{r7, lr}
100027c2:	b082      	sub	sp, #8
100027c4:	af00      	add	r7, sp, #0
100027c6:	6078      	str	r0, [r7, #4]
100027c8:	1c0a      	adds	r2, r1, #0
100027ca:	1cfb      	adds	r3, r7, #3
100027cc:	701a      	strb	r2, [r3, #0]
  XMC_ASSERT("XMC_CCU4_SLICE_EnableEvent:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_EnableEvent:Invalid SR event", XMC_CCU4_SLICE_CHECK_INTERRUPT(event));
  slice->INTE |= ((uint32_t) 1) << ((uint32_t) event);
100027ce:	687b      	ldr	r3, [r7, #4]
100027d0:	22a4      	movs	r2, #164	; 0xa4
100027d2:	589a      	ldr	r2, [r3, r2]
100027d4:	1cfb      	adds	r3, r7, #3
100027d6:	781b      	ldrb	r3, [r3, #0]
100027d8:	2101      	movs	r1, #1
100027da:	4099      	lsls	r1, r3
100027dc:	1c0b      	adds	r3, r1, #0
100027de:	431a      	orrs	r2, r3
100027e0:	687b      	ldr	r3, [r7, #4]
100027e2:	21a4      	movs	r1, #164	; 0xa4
100027e4:	505a      	str	r2, [r3, r1]
}
100027e6:	46bd      	mov	sp, r7
100027e8:	b002      	add	sp, #8
100027ea:	bd80      	pop	{r7, pc}

100027ec <PWM_lCCU4_Init>:

#ifdef PWM_SLICE_USED_CCU4

/*Initialize the APP and CCU4 slice. */
PWM_STATUS_t PWM_lCCU4_Init(PWM_t *const handle_ptr)
{
100027ec:	b590      	push	{r4, r7, lr}
100027ee:	b085      	sub	sp, #20
100027f0:	af00      	add	r7, sp, #0
100027f2:	6078      	str	r0, [r7, #4]
  PWM_STATUS_t status = PWM_STATUS_FAILURE;
100027f4:	230f      	movs	r3, #15
100027f6:	18fb      	adds	r3, r7, r3
100027f8:	2201      	movs	r2, #1
100027fa:	701a      	strb	r2, [r3, #0]

  XMC_ASSERT("PWM_lCCU4_Init:Invalid handle_ptr" , (handle_ptr != NULL));

  if (PWM_STATUS_UNINITIALIZED == handle_ptr->state)
100027fc:	687b      	ldr	r3, [r7, #4]
100027fe:	2229      	movs	r2, #41	; 0x29
10002800:	5c9b      	ldrb	r3, [r3, r2]
10002802:	2b02      	cmp	r3, #2
10002804:	d155      	bne.n	100028b2 <PWM_lCCU4_Init+0xc6>
  {
    /* Initialize consumed Apps */
    status = (PWM_STATUS_t)GLOBAL_CCU4_Init(handle_ptr->global_ccu4_handle);
10002806:	687b      	ldr	r3, [r7, #4]
10002808:	681b      	ldr	r3, [r3, #0]
1000280a:	220f      	movs	r2, #15
1000280c:	18bc      	adds	r4, r7, r2
1000280e:	1c18      	adds	r0, r3, #0
10002810:	f000 f990 	bl	10002b34 <GLOBAL_CCU4_Init>
10002814:	1c03      	adds	r3, r0, #0
10002816:	7023      	strb	r3, [r4, #0]

    /*Initialize CCU4 slice */
    if (PWM_STATUS_SUCCESS == status)/*check GLOBAL_CCU4_Init status*/
10002818:	230f      	movs	r3, #15
1000281a:	18fb      	adds	r3, r7, r3
1000281c:	781b      	ldrb	r3, [r3, #0]
1000281e:	2b00      	cmp	r3, #0
10002820:	d143      	bne.n	100028aa <PWM_lCCU4_Init+0xbe>
    {
      XMC_DEBUG("PWM_lCCU4_Init:Initilizing Slice")
      XMC_CCU4_SLICE_CompareInit(handle_ptr->ccu4_slice_ptr, handle_ptr->ccu4_slice_config_ptr);
10002822:	687b      	ldr	r3, [r7, #4]
10002824:	689a      	ldr	r2, [r3, #8]
10002826:	687b      	ldr	r3, [r7, #4]
10002828:	68db      	ldr	r3, [r3, #12]
1000282a:	1c10      	adds	r0, r2, #0
1000282c:	1c19      	adds	r1, r3, #0
1000282e:	f7fe fe9b 	bl	10001568 <XMC_CCU4_SLICE_CompareInit>

      /* Set the period and compare register values */
      XMC_CCU4_SLICE_SetTimerPeriodMatch(handle_ptr->ccu4_slice_ptr,
10002832:	687b      	ldr	r3, [r7, #4]
10002834:	689a      	ldr	r2, [r3, #8]
    		                             (uint16_t)handle_ptr->period_value);
10002836:	687b      	ldr	r3, [r7, #4]
10002838:	69db      	ldr	r3, [r3, #28]
    {
      XMC_DEBUG("PWM_lCCU4_Init:Initilizing Slice")
      XMC_CCU4_SLICE_CompareInit(handle_ptr->ccu4_slice_ptr, handle_ptr->ccu4_slice_config_ptr);

      /* Set the period and compare register values */
      XMC_CCU4_SLICE_SetTimerPeriodMatch(handle_ptr->ccu4_slice_ptr,
1000283a:	b29b      	uxth	r3, r3
1000283c:	1c10      	adds	r0, r2, #0
1000283e:	1c19      	adds	r1, r3, #0
10002840:	f7ff ff96 	bl	10002770 <XMC_CCU4_SLICE_SetTimerPeriodMatch>
    		                             (uint16_t)handle_ptr->period_value);

      XMC_CCU4_SLICE_SetTimerCompareMatch(handle_ptr->ccu4_slice_ptr,
10002844:	687b      	ldr	r3, [r7, #4]
10002846:	689a      	ldr	r2, [r3, #8]
    		                              (uint16_t)handle_ptr->compare_value);
10002848:	687b      	ldr	r3, [r7, #4]
1000284a:	699b      	ldr	r3, [r3, #24]

      /* Set the period and compare register values */
      XMC_CCU4_SLICE_SetTimerPeriodMatch(handle_ptr->ccu4_slice_ptr,
    		                             (uint16_t)handle_ptr->period_value);

      XMC_CCU4_SLICE_SetTimerCompareMatch(handle_ptr->ccu4_slice_ptr,
1000284c:	b29b      	uxth	r3, r3
1000284e:	1c10      	adds	r0, r2, #0
10002850:	1c19      	adds	r1, r3, #0
10002852:	f7ff ff9b 	bl	1000278c <XMC_CCU4_SLICE_SetTimerCompareMatch>
    		                              (uint16_t)handle_ptr->compare_value);

      XMC_CCU4_EnableShadowTransfer(handle_ptr->ccu4_kernel_ptr, handle_ptr->shadow_mask);
10002856:	687b      	ldr	r3, [r7, #4]
10002858:	685a      	ldr	r2, [r3, #4]
1000285a:	687b      	ldr	r3, [r7, #4]
1000285c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
1000285e:	1c10      	adds	r0, r2, #0
10002860:	1c19      	adds	r1, r3, #0
10002862:	f7ff ffa1 	bl	100027a8 <XMC_CCU4_EnableShadowTransfer>

      /* Initialize interrupts */
      PWM_lCCU4_ConfigInterrupts(handle_ptr);
10002866:	687b      	ldr	r3, [r7, #4]
10002868:	1c18      	adds	r0, r3, #0
1000286a:	f000 f829 	bl	100028c0 <PWM_lCCU4_ConfigInterrupts>

      XMC_GPIO_Init(handle_ptr->gpio_out_port,handle_ptr->gpio_out_pin,
1000286e:	687b      	ldr	r3, [r7, #4]
10002870:	6919      	ldr	r1, [r3, #16]
10002872:	687b      	ldr	r3, [r7, #4]
10002874:	222c      	movs	r2, #44	; 0x2c
10002876:	5c9a      	ldrb	r2, [r3, r2]
10002878:	687b      	ldr	r3, [r7, #4]
1000287a:	695b      	ldr	r3, [r3, #20]
1000287c:	1c08      	adds	r0, r1, #0
1000287e:	1c11      	adds	r1, r2, #0
10002880:	1c1a      	adds	r2, r3, #0
10002882:	f7fe fc43 	bl	1000110c <XMC_GPIO_Init>
    		        handle_ptr->gpio_out_config);

      handle_ptr->state = PWM_STATUS_SUCCESS;
10002886:	687b      	ldr	r3, [r7, #4]
10002888:	2229      	movs	r2, #41	; 0x29
1000288a:	2100      	movs	r1, #0
1000288c:	5499      	strb	r1, [r3, r2]

      /* Start the PWM generation if start at initialization is enabled */
      if ((bool) true == handle_ptr->start_control)
1000288e:	687b      	ldr	r3, [r7, #4]
10002890:	222f      	movs	r2, #47	; 0x2f
10002892:	5c9b      	ldrb	r3, [r3, r2]
10002894:	2b00      	cmp	r3, #0
10002896:	d003      	beq.n	100028a0 <PWM_lCCU4_Init+0xb4>
      {
        PWM_Start(handle_ptr);
10002898:	687b      	ldr	r3, [r7, #4]
1000289a:	1c18      	adds	r0, r3, #0
1000289c:	f000 f882 	bl	100029a4 <PWM_Start>
      }
      status = PWM_STATUS_SUCCESS;
100028a0:	230f      	movs	r3, #15
100028a2:	18fb      	adds	r3, r7, r3
100028a4:	2200      	movs	r2, #0
100028a6:	701a      	strb	r2, [r3, #0]
100028a8:	e003      	b.n	100028b2 <PWM_lCCU4_Init+0xc6>
    }
    else
    {
      handle_ptr->state = PWM_STATUS_UNINITIALIZED;
100028aa:	687b      	ldr	r3, [r7, #4]
100028ac:	2229      	movs	r2, #41	; 0x29
100028ae:	2102      	movs	r1, #2
100028b0:	5499      	strb	r1, [r3, r2]
    }

  }
  return (status);
100028b2:	230f      	movs	r3, #15
100028b4:	18fb      	adds	r3, r7, r3
100028b6:	781b      	ldrb	r3, [r3, #0]
} /* end of PWM_lCCU4_Init() api */
100028b8:	1c18      	adds	r0, r3, #0
100028ba:	46bd      	mov	sp, r7
100028bc:	b005      	add	sp, #20
100028be:	bd90      	pop	{r4, r7, pc}

100028c0 <PWM_lCCU4_ConfigInterrupts>:

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Initialize interrupts */
void PWM_lCCU4_ConfigInterrupts(PWM_t *const handle_ptr)
{
100028c0:	b580      	push	{r7, lr}
100028c2:	b082      	sub	sp, #8
100028c4:	af00      	add	r7, sp, #0
100028c6:	6078      	str	r0, [r7, #4]
  if ((bool) true == handle_ptr->period_match_enable)
100028c8:	687b      	ldr	r3, [r7, #4]
100028ca:	2230      	movs	r2, #48	; 0x30
100028cc:	5c9b      	ldrb	r3, [r3, r2]
100028ce:	2b00      	cmp	r3, #0
100028d0:	d00f      	beq.n	100028f2 <PWM_lCCU4_ConfigInterrupts+0x32>
  {
    XMC_DEBUG("PWM_lCCU4_ConfigInterrupts:period match enable")
    XMC_CCU4_SLICE_EnableEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH);
100028d2:	687b      	ldr	r3, [r7, #4]
100028d4:	689b      	ldr	r3, [r3, #8]
100028d6:	1c18      	adds	r0, r3, #0
100028d8:	2100      	movs	r1, #0
100028da:	f7ff ff71 	bl	100027c0 <XMC_CCU4_SLICE_EnableEvent>

    /* Bind event to Service Request Node to period match event*/
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH,
100028de:	687b      	ldr	r3, [r7, #4]
100028e0:	6899      	ldr	r1, [r3, #8]
100028e2:	687b      	ldr	r3, [r7, #4]
100028e4:	222a      	movs	r2, #42	; 0x2a
100028e6:	5c9b      	ldrb	r3, [r3, r2]
100028e8:	1c08      	adds	r0, r1, #0
100028ea:	2100      	movs	r1, #0
100028ec:	1c1a      	adds	r2, r3, #0
100028ee:	f7fe fe6f 	bl	100015d0 <XMC_CCU4_SLICE_SetInterruptNode>
                                    handle_ptr->ccu4_slice_period_match_node);
  }

  if ((bool) true == handle_ptr->compare_match_enable)
100028f2:	687b      	ldr	r3, [r7, #4]
100028f4:	2231      	movs	r2, #49	; 0x31
100028f6:	5c9b      	ldrb	r3, [r3, r2]
100028f8:	2b00      	cmp	r3, #0
100028fa:	d00f      	beq.n	1000291c <PWM_lCCU4_ConfigInterrupts+0x5c>
  {
    XMC_DEBUG("PWM_lCCU4_ConfigInterrupts:compare match enable")
    XMC_CCU4_SLICE_EnableEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_UP);
100028fc:	687b      	ldr	r3, [r7, #4]
100028fe:	689b      	ldr	r3, [r3, #8]
10002900:	1c18      	adds	r0, r3, #0
10002902:	2102      	movs	r1, #2
10002904:	f7ff ff5c 	bl	100027c0 <XMC_CCU4_SLICE_EnableEvent>

    /* Bind event to Service Request Node to compare match event */
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_UP,
10002908:	687b      	ldr	r3, [r7, #4]
1000290a:	6899      	ldr	r1, [r3, #8]
1000290c:	687b      	ldr	r3, [r7, #4]
1000290e:	222b      	movs	r2, #43	; 0x2b
10002910:	5c9b      	ldrb	r3, [r3, r2]
10002912:	1c08      	adds	r0, r1, #0
10002914:	2102      	movs	r1, #2
10002916:	1c1a      	adds	r2, r3, #0
10002918:	f7fe fe5a 	bl	100015d0 <XMC_CCU4_SLICE_SetInterruptNode>
                                    handle_ptr->ccu4_slice_compare_match_node);
  }
}
1000291c:	46bd      	mov	sp, r7
1000291e:	b002      	add	sp, #8
10002920:	bd80      	pop	{r7, pc}
10002922:	46c0      	nop			; (mov r8, r8)

10002924 <PWM_lCCU4_Start>:

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/*Starts the CCU4 slice. */
void PWM_lCCU4_Start(PWM_t *const handle_ptr)
{
10002924:	b580      	push	{r7, lr}
10002926:	b082      	sub	sp, #8
10002928:	af00      	add	r7, sp, #0
1000292a:	6078      	str	r0, [r7, #4]
  if ((PWM_STATUS_SUCCESS == handle_ptr->state) || (PWM_STATUS_STOPPED == handle_ptr->state))
1000292c:	687b      	ldr	r3, [r7, #4]
1000292e:	2229      	movs	r2, #41	; 0x29
10002930:	5c9b      	ldrb	r3, [r3, r2]
10002932:	2b00      	cmp	r3, #0
10002934:	d004      	beq.n	10002940 <PWM_lCCU4_Start+0x1c>
10002936:	687b      	ldr	r3, [r7, #4]
10002938:	2229      	movs	r2, #41	; 0x29
1000293a:	5c9b      	ldrb	r3, [r3, r2]
1000293c:	2b04      	cmp	r3, #4
1000293e:	d111      	bne.n	10002964 <PWM_lCCU4_Start+0x40>
  {
    /* Clears the IDLE mode for the slice */
    XMC_CCU4_EnableClock(handle_ptr->ccu4_kernel_ptr,handle_ptr->slice_number);
10002940:	687b      	ldr	r3, [r7, #4]
10002942:	6859      	ldr	r1, [r3, #4]
10002944:	687b      	ldr	r3, [r7, #4]
10002946:	222e      	movs	r2, #46	; 0x2e
10002948:	5c9b      	ldrb	r3, [r3, r2]
1000294a:	1c08      	adds	r0, r1, #0
1000294c:	1c19      	adds	r1, r3, #0
1000294e:	f7ff fef5 	bl	1000273c <XMC_CCU4_EnableClock>
    XMC_CCU4_SLICE_StartTimer(handle_ptr->ccu4_slice_ptr);
10002952:	687b      	ldr	r3, [r7, #4]
10002954:	689b      	ldr	r3, [r3, #8]
10002956:	1c18      	adds	r0, r3, #0
10002958:	f7ff ff00 	bl	1000275c <XMC_CCU4_SLICE_StartTimer>

    handle_ptr->state = PWM_STATUS_RUNNING;
1000295c:	687b      	ldr	r3, [r7, #4]
1000295e:	2229      	movs	r2, #41	; 0x29
10002960:	2103      	movs	r1, #3
10002962:	5499      	strb	r1, [r3, r2]
    XMC_DEBUG("PWM_lCCU4_Start:start PWM")
  }
} /* end of PWM_lCCU4_Start() api */
10002964:	46bd      	mov	sp, r7
10002966:	b002      	add	sp, #8
10002968:	bd80      	pop	{r7, pc}
1000296a:	46c0      	nop			; (mov r8, r8)

1000296c <PWM_Init>:
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* This function initializes the app */
PWM_STATUS_t PWM_Init(PWM_t *const handle_ptr)
{
1000296c:	b590      	push	{r4, r7, lr}
1000296e:	b085      	sub	sp, #20
10002970:	af00      	add	r7, sp, #0
10002972:	6078      	str	r0, [r7, #4]
  PWM_STATUS_t status;
  status = PWM_STATUS_FAILURE;
10002974:	230f      	movs	r3, #15
10002976:	18fb      	adds	r3, r7, r3
10002978:	2201      	movs	r2, #1
1000297a:	701a      	strb	r2, [r3, #0]

  XMC_ASSERT("PWM_Init:Invalid handle_ptr" , (handle_ptr != NULL));

#ifdef PWM_SLICE_USED_CCU4
  if (PWM_TIMER_SLICE_CCU4 == handle_ptr->timer_type)
1000297c:	687b      	ldr	r3, [r7, #4]
1000297e:	2228      	movs	r2, #40	; 0x28
10002980:	5c9b      	ldrb	r3, [r3, r2]
10002982:	2b00      	cmp	r3, #0
10002984:	d107      	bne.n	10002996 <PWM_Init+0x2a>
  {
    status = PWM_lCCU4_Init(handle_ptr);
10002986:	230f      	movs	r3, #15
10002988:	18fc      	adds	r4, r7, r3
1000298a:	687b      	ldr	r3, [r7, #4]
1000298c:	1c18      	adds	r0, r3, #0
1000298e:	f7ff ff2d 	bl	100027ec <PWM_lCCU4_Init>
10002992:	1c03      	adds	r3, r0, #0
10002994:	7023      	strb	r3, [r4, #0]
  {
    status = PWM_lCCU8_Init(handle_ptr);
  }
#endif

  return (status);
10002996:	230f      	movs	r3, #15
10002998:	18fb      	adds	r3, r7, r3
1000299a:	781b      	ldrb	r3, [r3, #0]
}
1000299c:	1c18      	adds	r0, r3, #0
1000299e:	46bd      	mov	sp, r7
100029a0:	b005      	add	sp, #20
100029a2:	bd90      	pop	{r4, r7, pc}

100029a4 <PWM_Start>:

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* This function starts the PWM generation. This needs to be called even if external start is configured.*/
void PWM_Start(PWM_t *const handle_ptr)
{
100029a4:	b580      	push	{r7, lr}
100029a6:	b082      	sub	sp, #8
100029a8:	af00      	add	r7, sp, #0
100029aa:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("PWM_Start:Invalid handle_ptr" , (handle_ptr != NULL));

#ifdef PWM_SLICE_USED_CCU4
  if (PWM_TIMER_SLICE_CCU4 == handle_ptr->timer_type)
100029ac:	687b      	ldr	r3, [r7, #4]
100029ae:	2228      	movs	r2, #40	; 0x28
100029b0:	5c9b      	ldrb	r3, [r3, r2]
100029b2:	2b00      	cmp	r3, #0
100029b4:	d103      	bne.n	100029be <PWM_Start+0x1a>
  {
    PWM_lCCU4_Start(handle_ptr);
100029b6:	687b      	ldr	r3, [r7, #4]
100029b8:	1c18      	adds	r0, r3, #0
100029ba:	f7ff ffb3 	bl	10002924 <PWM_lCCU4_Start>
  if (PWM_TIMER_SLICE_CCU8 == handle_ptr->timer_type)
  {
    PWM_lCCU8_Start(handle_ptr);
  }
#endif
}
100029be:	46bd      	mov	sp, r7
100029c0:	b002      	add	sp, #8
100029c2:	bd80      	pop	{r7, pc}

100029c4 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
100029c4:	b580      	push	{r7, lr}
100029c6:	b082      	sub	sp, #8
100029c8:	af00      	add	r7, sp, #0
100029ca:	1c02      	adds	r2, r0, #0
100029cc:	1dfb      	adds	r3, r7, #7
100029ce:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
100029d0:	1dfb      	adds	r3, r7, #7
100029d2:	781b      	ldrb	r3, [r3, #0]
100029d4:	2b7f      	cmp	r3, #127	; 0x7f
100029d6:	d809      	bhi.n	100029ec <__NVIC_EnableIRQ+0x28>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
100029d8:	4b06      	ldr	r3, [pc, #24]	; (100029f4 <__NVIC_EnableIRQ+0x30>)
100029da:	1dfa      	adds	r2, r7, #7
100029dc:	7812      	ldrb	r2, [r2, #0]
100029de:	1c11      	adds	r1, r2, #0
100029e0:	221f      	movs	r2, #31
100029e2:	400a      	ands	r2, r1
100029e4:	2101      	movs	r1, #1
100029e6:	4091      	lsls	r1, r2
100029e8:	1c0a      	adds	r2, r1, #0
100029ea:	601a      	str	r2, [r3, #0]
    __COMPILER_BARRIER();
  }
}
100029ec:	46bd      	mov	sp, r7
100029ee:	b002      	add	sp, #8
100029f0:	bd80      	pop	{r7, pc}
100029f2:	46c0      	nop			; (mov r8, r8)
100029f4:	e000e100 	.word	0xe000e100

100029f8 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
100029f8:	b5b0      	push	{r4, r5, r7, lr}
100029fa:	b082      	sub	sp, #8
100029fc:	af00      	add	r7, sp, #0
100029fe:	1c02      	adds	r2, r0, #0
10002a00:	6039      	str	r1, [r7, #0]
10002a02:	1dfb      	adds	r3, r7, #7
10002a04:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
10002a06:	1dfb      	adds	r3, r7, #7
10002a08:	781b      	ldrb	r3, [r3, #0]
10002a0a:	2b7f      	cmp	r3, #127	; 0x7f
10002a0c:	d827      	bhi.n	10002a5e <__NVIC_SetPriority+0x66>
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
10002a0e:	4c2d      	ldr	r4, [pc, #180]	; (10002ac4 <__NVIC_SetPriority+0xcc>)
10002a10:	1dfb      	adds	r3, r7, #7
10002a12:	781b      	ldrb	r3, [r3, #0]
10002a14:	b25b      	sxtb	r3, r3
10002a16:	089b      	lsrs	r3, r3, #2
10002a18:	492a      	ldr	r1, [pc, #168]	; (10002ac4 <__NVIC_SetPriority+0xcc>)
10002a1a:	1dfa      	adds	r2, r7, #7
10002a1c:	7812      	ldrb	r2, [r2, #0]
10002a1e:	b252      	sxtb	r2, r2
10002a20:	0892      	lsrs	r2, r2, #2
10002a22:	32c0      	adds	r2, #192	; 0xc0
10002a24:	0092      	lsls	r2, r2, #2
10002a26:	5852      	ldr	r2, [r2, r1]
10002a28:	1df9      	adds	r1, r7, #7
10002a2a:	7809      	ldrb	r1, [r1, #0]
10002a2c:	1c08      	adds	r0, r1, #0
10002a2e:	2103      	movs	r1, #3
10002a30:	4001      	ands	r1, r0
10002a32:	00c9      	lsls	r1, r1, #3
10002a34:	1c08      	adds	r0, r1, #0
10002a36:	21ff      	movs	r1, #255	; 0xff
10002a38:	4081      	lsls	r1, r0
10002a3a:	43c9      	mvns	r1, r1
10002a3c:	4011      	ands	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
10002a3e:	683a      	ldr	r2, [r7, #0]
10002a40:	0192      	lsls	r2, r2, #6
10002a42:	20ff      	movs	r0, #255	; 0xff
10002a44:	4002      	ands	r2, r0
10002a46:	1df8      	adds	r0, r7, #7
10002a48:	7800      	ldrb	r0, [r0, #0]
10002a4a:	1c05      	adds	r5, r0, #0
10002a4c:	2003      	movs	r0, #3
10002a4e:	4028      	ands	r0, r5
10002a50:	00c0      	lsls	r0, r0, #3
10002a52:	4082      	lsls	r2, r0
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
10002a54:	430a      	orrs	r2, r1
10002a56:	33c0      	adds	r3, #192	; 0xc0
10002a58:	009b      	lsls	r3, r3, #2
10002a5a:	511a      	str	r2, [r3, r4]
10002a5c:	e02e      	b.n	10002abc <__NVIC_SetPriority+0xc4>
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
10002a5e:	4c1a      	ldr	r4, [pc, #104]	; (10002ac8 <__NVIC_SetPriority+0xd0>)
10002a60:	1dfb      	adds	r3, r7, #7
10002a62:	781b      	ldrb	r3, [r3, #0]
10002a64:	1c1a      	adds	r2, r3, #0
10002a66:	230f      	movs	r3, #15
10002a68:	4013      	ands	r3, r2
10002a6a:	3b08      	subs	r3, #8
10002a6c:	0899      	lsrs	r1, r3, #2
10002a6e:	4a16      	ldr	r2, [pc, #88]	; (10002ac8 <__NVIC_SetPriority+0xd0>)
10002a70:	1dfb      	adds	r3, r7, #7
10002a72:	781b      	ldrb	r3, [r3, #0]
10002a74:	1c18      	adds	r0, r3, #0
10002a76:	230f      	movs	r3, #15
10002a78:	4003      	ands	r3, r0
10002a7a:	3b08      	subs	r3, #8
10002a7c:	089b      	lsrs	r3, r3, #2
10002a7e:	3306      	adds	r3, #6
10002a80:	009b      	lsls	r3, r3, #2
10002a82:	18d3      	adds	r3, r2, r3
10002a84:	685b      	ldr	r3, [r3, #4]
10002a86:	1dfa      	adds	r2, r7, #7
10002a88:	7812      	ldrb	r2, [r2, #0]
10002a8a:	1c10      	adds	r0, r2, #0
10002a8c:	2203      	movs	r2, #3
10002a8e:	4002      	ands	r2, r0
10002a90:	00d2      	lsls	r2, r2, #3
10002a92:	1c10      	adds	r0, r2, #0
10002a94:	22ff      	movs	r2, #255	; 0xff
10002a96:	4082      	lsls	r2, r0
10002a98:	43d2      	mvns	r2, r2
10002a9a:	401a      	ands	r2, r3
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
10002a9c:	683b      	ldr	r3, [r7, #0]
10002a9e:	019b      	lsls	r3, r3, #6
10002aa0:	20ff      	movs	r0, #255	; 0xff
10002aa2:	4003      	ands	r3, r0
10002aa4:	1df8      	adds	r0, r7, #7
10002aa6:	7800      	ldrb	r0, [r0, #0]
10002aa8:	1c05      	adds	r5, r0, #0
10002aaa:	2003      	movs	r0, #3
10002aac:	4028      	ands	r0, r5
10002aae:	00c0      	lsls	r0, r0, #3
10002ab0:	4083      	lsls	r3, r0
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
10002ab2:	431a      	orrs	r2, r3
10002ab4:	1d8b      	adds	r3, r1, #6
10002ab6:	009b      	lsls	r3, r3, #2
10002ab8:	18e3      	adds	r3, r4, r3
10002aba:	605a      	str	r2, [r3, #4]
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
}
10002abc:	46bd      	mov	sp, r7
10002abe:	b002      	add	sp, #8
10002ac0:	bdb0      	pop	{r4, r5, r7, pc}
10002ac2:	46c0      	nop			; (mov r8, r8)
10002ac4:	e000e100 	.word	0xe000e100
10002ac8:	e000ed00 	.word	0xe000ed00

10002acc <INTERRUPT_Enable>:
 *    return 0;
 *  }
 * @endcode<BR> </p>
 */
__STATIC_INLINE void INTERRUPT_Enable(const INTERRUPT_t *const handler)
{
10002acc:	b580      	push	{r7, lr}
10002ace:	b082      	sub	sp, #8
10002ad0:	af00      	add	r7, sp, #0
10002ad2:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("Handler NULL", (handler != NULL));
  NVIC_EnableIRQ(handler->node);
10002ad4:	687b      	ldr	r3, [r7, #4]
10002ad6:	781b      	ldrb	r3, [r3, #0]
10002ad8:	b25b      	sxtb	r3, r3
10002ada:	1c18      	adds	r0, r3, #0
10002adc:	f7ff ff72 	bl	100029c4 <__NVIC_EnableIRQ>
}
10002ae0:	46bd      	mov	sp, r7
10002ae2:	b002      	add	sp, #8
10002ae4:	bd80      	pop	{r7, pc}
10002ae6:	46c0      	nop			; (mov r8, r8)

10002ae8 <INTERRUPT_Init>:

/*
 * API to initialize the INTERRUPT APP
 */
INTERRUPT_STATUS_t INTERRUPT_Init(const INTERRUPT_t *const handler)
{
10002ae8:	b580      	push	{r7, lr}
10002aea:	b082      	sub	sp, #8
10002aec:	af00      	add	r7, sp, #0
10002aee:	6078      	str	r0, [r7, #4]
    INTERRUPT_Enable(handler);
  }
#endif

#if(UC_FAMILY == XMC1)
  NVIC_SetPriority(handler->node, handler->priority);
10002af0:	687b      	ldr	r3, [r7, #4]
10002af2:	781a      	ldrb	r2, [r3, #0]
10002af4:	687b      	ldr	r3, [r7, #4]
10002af6:	785b      	ldrb	r3, [r3, #1]
10002af8:	1c19      	adds	r1, r3, #0
10002afa:	b253      	sxtb	r3, r2
10002afc:	1c18      	adds	r0, r3, #0
10002afe:	f7ff ff7b 	bl	100029f8 <__NVIC_SetPriority>
#if (UC_SERIES == XMC14)
  XMC_SCU_SetInterruptControl((uint8_t)handler->node, (XMC_SCU_IRQCTRL_t)((handler->node << 8) | handler->irqctrl));
#endif

  /* Enable the interrupt if enable_at_init is enabled */
  if (handler->enable_at_init == true)
10002b02:	687b      	ldr	r3, [r7, #4]
10002b04:	789b      	ldrb	r3, [r3, #2]
10002b06:	2b00      	cmp	r3, #0
10002b08:	d003      	beq.n	10002b12 <INTERRUPT_Init+0x2a>
  {
    INTERRUPT_Enable(handler);
10002b0a:	687b      	ldr	r3, [r7, #4]
10002b0c:	1c18      	adds	r0, r3, #0
10002b0e:	f7ff ffdd 	bl	10002acc <INTERRUPT_Enable>
  }
#endif

  return (INTERRUPT_STATUS_SUCCESS);
10002b12:	2300      	movs	r3, #0
}
10002b14:	1c18      	adds	r0, r3, #0
10002b16:	46bd      	mov	sp, r7
10002b18:	b002      	add	sp, #8
10002b1a:	bd80      	pop	{r7, pc}

10002b1c <XMC_CCU4_StartPrescaler>:
 * \par<b>Related APIs:</b><br>
 * XMC_CCU4_Init()<BR> XMC_CCU4_EnableClock()<BR> XMC_CCU4_DisableClock()<BR> XMC_CCU4_StartPrescaler()<BR>
 * XMC_CCU4_StopPrescaler().
 */
__STATIC_INLINE void XMC_CCU4_StartPrescaler(XMC_CCU4_MODULE_t *const module)
{
10002b1c:	b580      	push	{r7, lr}
10002b1e:	b082      	sub	sp, #8
10002b20:	af00      	add	r7, sp, #0
10002b22:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_CCU4_StartPrescaler:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));
  module->GIDLC = (uint32_t) CCU4_GIDLC_SPRB_Msk;
10002b24:	687b      	ldr	r3, [r7, #4]
10002b26:	2280      	movs	r2, #128	; 0x80
10002b28:	0052      	lsls	r2, r2, #1
10002b2a:	60da      	str	r2, [r3, #12]
}
10002b2c:	46bd      	mov	sp, r7
10002b2e:	b002      	add	sp, #8
10002b30:	bd80      	pop	{r7, pc}
10002b32:	46c0      	nop			; (mov r8, r8)

10002b34 <GLOBAL_CCU4_Init>:
  return version;
}

/* Initializes the slice with the generated configuration */
GLOBAL_CCU4_STATUS_t GLOBAL_CCU4_Init(GLOBAL_CCU4_t* handle)
{
10002b34:	b580      	push	{r7, lr}
10002b36:	b082      	sub	sp, #8
10002b38:	af00      	add	r7, sp, #0
10002b3a:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("GLOBAL_CCU4_Init:NULL handler", (NULL != handle));

  if (false == handle->is_initialized)
10002b3c:	687b      	ldr	r3, [r7, #4]
10002b3e:	7b5b      	ldrb	r3, [r3, #13]
10002b40:	2201      	movs	r2, #1
10002b42:	4053      	eors	r3, r2
10002b44:	b2db      	uxtb	r3, r3
10002b46:	2b00      	cmp	r3, #0
10002b48:	d00f      	beq.n	10002b6a <GLOBAL_CCU4_Init+0x36>
  {
    /* Enable CCU4 module */
    XMC_CCU4_Init(handle->module_ptr,handle->mcs_action);
10002b4a:	687b      	ldr	r3, [r7, #4]
10002b4c:	689a      	ldr	r2, [r3, #8]
10002b4e:	687b      	ldr	r3, [r7, #4]
10002b50:	7b1b      	ldrb	r3, [r3, #12]
10002b52:	1c10      	adds	r0, r2, #0
10002b54:	1c19      	adds	r1, r3, #0
10002b56:	f7fe fce3 	bl	10001520 <XMC_CCU4_Init>
    /* Start the prescaler */
    XMC_CCU4_StartPrescaler(handle->module_ptr);
10002b5a:	687b      	ldr	r3, [r7, #4]
10002b5c:	689b      	ldr	r3, [r3, #8]
10002b5e:	1c18      	adds	r0, r3, #0
10002b60:	f7ff ffdc 	bl	10002b1c <XMC_CCU4_StartPrescaler>
    /* Restricts multiple initializations */
    handle->is_initialized = true;
10002b64:	687b      	ldr	r3, [r7, #4]
10002b66:	2201      	movs	r2, #1
10002b68:	735a      	strb	r2, [r3, #13]
  }

  return (GLOBAL_CCU4_STATUS_SUCCESS);
10002b6a:	2300      	movs	r3, #0
}
10002b6c:	1c18      	adds	r0, r3, #0
10002b6e:	46bd      	mov	sp, r7
10002b70:	b002      	add	sp, #8
10002b72:	bd80      	pop	{r7, pc}

10002b74 <pxPortInitialiseStack>:
 * See header file for description.
 */
StackType_t * pxPortInitialiseStack( StackType_t * pxTopOfStack,
                                     TaskFunction_t pxCode,
                                     void * pvParameters )
{
10002b74:	b580      	push	{r7, lr}
10002b76:	b084      	sub	sp, #16
10002b78:	af00      	add	r7, sp, #0
10002b7a:	60f8      	str	r0, [r7, #12]
10002b7c:	60b9      	str	r1, [r7, #8]
10002b7e:	607a      	str	r2, [r7, #4]
    /* Simulate the stack frame as it would be created by a context switch
     * interrupt. */
    pxTopOfStack--;                                          /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
10002b80:	68fb      	ldr	r3, [r7, #12]
10002b82:	3b04      	subs	r3, #4
10002b84:	60fb      	str	r3, [r7, #12]
    *pxTopOfStack = portINITIAL_XPSR;                        /* xPSR */
10002b86:	68fb      	ldr	r3, [r7, #12]
10002b88:	2280      	movs	r2, #128	; 0x80
10002b8a:	0452      	lsls	r2, r2, #17
10002b8c:	601a      	str	r2, [r3, #0]
    pxTopOfStack--;
10002b8e:	68fb      	ldr	r3, [r7, #12]
10002b90:	3b04      	subs	r3, #4
10002b92:	60fb      	str	r3, [r7, #12]
    *pxTopOfStack = ( StackType_t ) pxCode;                  /* PC */
10002b94:	68ba      	ldr	r2, [r7, #8]
10002b96:	68fb      	ldr	r3, [r7, #12]
10002b98:	601a      	str	r2, [r3, #0]
    pxTopOfStack--;
10002b9a:	68fb      	ldr	r3, [r7, #12]
10002b9c:	3b04      	subs	r3, #4
10002b9e:	60fb      	str	r3, [r7, #12]
    *pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS; /* LR */
10002ba0:	4a08      	ldr	r2, [pc, #32]	; (10002bc4 <pxPortInitialiseStack+0x50>)
10002ba2:	68fb      	ldr	r3, [r7, #12]
10002ba4:	601a      	str	r2, [r3, #0]
    pxTopOfStack -= 5;                                       /* R12, R3, R2 and R1. */
10002ba6:	68fb      	ldr	r3, [r7, #12]
10002ba8:	3b14      	subs	r3, #20
10002baa:	60fb      	str	r3, [r7, #12]
    *pxTopOfStack = ( StackType_t ) pvParameters;            /* R0 */
10002bac:	687a      	ldr	r2, [r7, #4]
10002bae:	68fb      	ldr	r3, [r7, #12]
10002bb0:	601a      	str	r2, [r3, #0]
    pxTopOfStack -= 8;                                       /* R11..R4. */
10002bb2:	68fb      	ldr	r3, [r7, #12]
10002bb4:	3b20      	subs	r3, #32
10002bb6:	60fb      	str	r3, [r7, #12]

    return pxTopOfStack;
10002bb8:	68fb      	ldr	r3, [r7, #12]
}
10002bba:	1c18      	adds	r0, r3, #0
10002bbc:	46bd      	mov	sp, r7
10002bbe:	b004      	add	sp, #16
10002bc0:	bd80      	pop	{r7, pc}
10002bc2:	46c0      	nop			; (mov r8, r8)
10002bc4:	10002bc9 	.word	0x10002bc9

10002bc8 <prvTaskExitError>:
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
10002bc8:	b580      	push	{r7, lr}
10002bca:	b082      	sub	sp, #8
10002bcc:	af00      	add	r7, sp, #0
    volatile uint32_t ulDummy = 0UL;
10002bce:	2300      	movs	r3, #0
10002bd0:	607b      	str	r3, [r7, #4]
     * its caller as there is nothing to return to.  If a task wants to exit it
     * should instead call vTaskDelete( NULL ).
     *
     * Artificially force an assert() to be triggered if configASSERT() is
     * defined, then stop here so application writers can catch the error. */
    configASSERT( uxCriticalNesting == ~0UL );
10002bd2:	4b07      	ldr	r3, [pc, #28]	; (10002bf0 <prvTaskExitError+0x28>)
10002bd4:	681b      	ldr	r3, [r3, #0]
10002bd6:	3301      	adds	r3, #1
10002bd8:	d001      	beq.n	10002bde <prvTaskExitError+0x16>
10002bda:	b672      	cpsid	i
10002bdc:	e7fe      	b.n	10002bdc <prvTaskExitError+0x14>
    portDISABLE_INTERRUPTS();
10002bde:	b672      	cpsid	i

    while( ulDummy == 0 )
10002be0:	46c0      	nop			; (mov r8, r8)
10002be2:	687b      	ldr	r3, [r7, #4]
10002be4:	2b00      	cmp	r3, #0
10002be6:	d0fc      	beq.n	10002be2 <prvTaskExitError+0x1a>
         * about code appearing after this function is called - making ulDummy
         * volatile makes the compiler think the function could return and
         * therefore not output an 'unreachable code' warning for code that appears
         * after it. */
    }
}
10002be8:	46bd      	mov	sp, r7
10002bea:	b002      	add	sp, #8
10002bec:	bd80      	pop	{r7, pc}
10002bee:	46c0      	nop			; (mov r8, r8)
10002bf0:	200005f4 	.word	0x200005f4

10002bf4 <SVC_Handler>:
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
10002bf4:	b580      	push	{r7, lr}
10002bf6:	af00      	add	r7, sp, #0
    /* This function is no longer used, but retained for backward
     * compatibility. */
}
10002bf8:	46bd      	mov	sp, r7
10002bfa:	bd80      	pop	{r7, pc}
10002bfc:	0000      	movs	r0, r0
	...

10002c00 <vPortStartFirstTask>:
void vPortStartFirstTask( void )
{
    /* The MSP stack is not reset as, unlike on M3/4 parts, there is no vector
     * table offset register that can be used to locate the initial stack value.
     * Not all M0 parts have the application vector table at address 0. */
    __asm volatile (
10002c00:	4a0b      	ldr	r2, [pc, #44]	; (10002c30 <pxCurrentTCBConst2>)
10002c02:	6813      	ldr	r3, [r2, #0]
10002c04:	6818      	ldr	r0, [r3, #0]
10002c06:	3020      	adds	r0, #32
10002c08:	f380 8809 	msr	PSP, r0
10002c0c:	2002      	movs	r0, #2
10002c0e:	f380 8814 	msr	CONTROL, r0
10002c12:	f3bf 8f6f 	isb	sy
10002c16:	bc3f      	pop	{r0, r1, r2, r3, r4, r5}
10002c18:	46ae      	mov	lr, r5
10002c1a:	bc08      	pop	{r3}
10002c1c:	bc04      	pop	{r2}
10002c1e:	b662      	cpsie	i
10002c20:	4718      	bx	r3
10002c22:	46c0      	nop			; (mov r8, r8)
10002c24:	46c0      	nop			; (mov r8, r8)
10002c26:	46c0      	nop			; (mov r8, r8)
10002c28:	46c0      	nop			; (mov r8, r8)
10002c2a:	46c0      	nop			; (mov r8, r8)
10002c2c:	46c0      	nop			; (mov r8, r8)
10002c2e:	46c0      	nop			; (mov r8, r8)

10002c30 <pxCurrentTCBConst2>:
10002c30:	200006d8 	.word	0x200006d8
10002c34:	46c0      	nop			; (mov r8, r8)
10002c36:	46c0      	nop			; (mov r8, r8)
10002c38:	46c0      	nop			; (mov r8, r8)
10002c3a:	46c0      	nop			; (mov r8, r8)
10002c3c:	46c0      	nop			; (mov r8, r8)
10002c3e:	46c0      	nop			; (mov r8, r8)

10002c40 <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
10002c40:	b580      	push	{r7, lr}
10002c42:	af00      	add	r7, sp, #0
    /* Make PendSV, CallSV and SysTick the same priority as the kernel. */
    portNVIC_SHPR3_REG |= portNVIC_PENDSV_PRI;
10002c44:	4b0e      	ldr	r3, [pc, #56]	; (10002c80 <xPortStartScheduler+0x40>)
10002c46:	4a0e      	ldr	r2, [pc, #56]	; (10002c80 <xPortStartScheduler+0x40>)
10002c48:	6812      	ldr	r2, [r2, #0]
10002c4a:	21ff      	movs	r1, #255	; 0xff
10002c4c:	0409      	lsls	r1, r1, #16
10002c4e:	430a      	orrs	r2, r1
10002c50:	601a      	str	r2, [r3, #0]
    portNVIC_SHPR3_REG |= portNVIC_SYSTICK_PRI;
10002c52:	4b0b      	ldr	r3, [pc, #44]	; (10002c80 <xPortStartScheduler+0x40>)
10002c54:	4a0a      	ldr	r2, [pc, #40]	; (10002c80 <xPortStartScheduler+0x40>)
10002c56:	6812      	ldr	r2, [r2, #0]
10002c58:	21ff      	movs	r1, #255	; 0xff
10002c5a:	0609      	lsls	r1, r1, #24
10002c5c:	430a      	orrs	r2, r1
10002c5e:	601a      	str	r2, [r3, #0]

    /* Start the timer that generates the tick ISR.  Interrupts are disabled
     * here already. */
    vPortSetupTimerInterrupt();
10002c60:	f000 f896 	bl	10002d90 <vPortSetupTimerInterrupt>

    /* Initialise the critical nesting count ready for the first task. */
    uxCriticalNesting = 0;
10002c64:	4b07      	ldr	r3, [pc, #28]	; (10002c84 <xPortStartScheduler+0x44>)
10002c66:	2200      	movs	r2, #0
10002c68:	601a      	str	r2, [r3, #0]

    /* Start the first task. */
    vPortStartFirstTask();
10002c6a:	f7ff ffc9 	bl	10002c00 <vPortStartFirstTask>
     * exit error function to prevent compiler warnings about a static function
     * not being called in the case that the application writer overrides this
     * functionality by defining configTASK_RETURN_ADDRESS.  Call
     * vTaskSwitchContext() so link time optimisation does not remove the
     * symbol. */
    vTaskSwitchContext();
10002c6e:	f001 f967 	bl	10003f40 <vTaskSwitchContext>
    prvTaskExitError();
10002c72:	f7ff ffa9 	bl	10002bc8 <prvTaskExitError>

    /* Should not get here! */
    return 0;
10002c76:	2300      	movs	r3, #0
}
10002c78:	1c18      	adds	r0, r3, #0
10002c7a:	46bd      	mov	sp, r7
10002c7c:	bd80      	pop	{r7, pc}
10002c7e:	46c0      	nop			; (mov r8, r8)
10002c80:	e000ed20 	.word	0xe000ed20
10002c84:	200005f4 	.word	0x200005f4

10002c88 <vPortYield>:
    configASSERT( uxCriticalNesting == 1000UL );
}
/*-----------------------------------------------------------*/

void vPortYield( void )
{
10002c88:	b580      	push	{r7, lr}
10002c8a:	af00      	add	r7, sp, #0
    /* Set a PendSV to request a context switch. */
    portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
10002c8c:	4b04      	ldr	r3, [pc, #16]	; (10002ca0 <vPortYield+0x18>)
10002c8e:	2280      	movs	r2, #128	; 0x80
10002c90:	0552      	lsls	r2, r2, #21
10002c92:	601a      	str	r2, [r3, #0]

    /* Barriers are normally not required but do ensure the code is completely
     * within the specified behaviour for the architecture. */
    __asm volatile ( "dsb" ::: "memory" );
10002c94:	f3bf 8f4f 	dsb	sy
    __asm volatile ( "isb" );
10002c98:	f3bf 8f6f 	isb	sy
}
10002c9c:	46bd      	mov	sp, r7
10002c9e:	bd80      	pop	{r7, pc}
10002ca0:	e000ed04 	.word	0xe000ed04

10002ca4 <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
10002ca4:	b580      	push	{r7, lr}
10002ca6:	af00      	add	r7, sp, #0
    portDISABLE_INTERRUPTS();
10002ca8:	b672      	cpsid	i
    uxCriticalNesting++;
10002caa:	4b05      	ldr	r3, [pc, #20]	; (10002cc0 <vPortEnterCritical+0x1c>)
10002cac:	681b      	ldr	r3, [r3, #0]
10002cae:	1c5a      	adds	r2, r3, #1
10002cb0:	4b03      	ldr	r3, [pc, #12]	; (10002cc0 <vPortEnterCritical+0x1c>)
10002cb2:	601a      	str	r2, [r3, #0]
    __asm volatile ( "dsb" ::: "memory" );
10002cb4:	f3bf 8f4f 	dsb	sy
    __asm volatile ( "isb" );
10002cb8:	f3bf 8f6f 	isb	sy
}
10002cbc:	46bd      	mov	sp, r7
10002cbe:	bd80      	pop	{r7, pc}
10002cc0:	200005f4 	.word	0x200005f4

10002cc4 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
10002cc4:	b580      	push	{r7, lr}
10002cc6:	af00      	add	r7, sp, #0
    configASSERT( uxCriticalNesting );
10002cc8:	4b08      	ldr	r3, [pc, #32]	; (10002cec <vPortExitCritical+0x28>)
10002cca:	681b      	ldr	r3, [r3, #0]
10002ccc:	2b00      	cmp	r3, #0
10002cce:	d101      	bne.n	10002cd4 <vPortExitCritical+0x10>
10002cd0:	b672      	cpsid	i
10002cd2:	e7fe      	b.n	10002cd2 <vPortExitCritical+0xe>
    uxCriticalNesting--;
10002cd4:	4b05      	ldr	r3, [pc, #20]	; (10002cec <vPortExitCritical+0x28>)
10002cd6:	681b      	ldr	r3, [r3, #0]
10002cd8:	1e5a      	subs	r2, r3, #1
10002cda:	4b04      	ldr	r3, [pc, #16]	; (10002cec <vPortExitCritical+0x28>)
10002cdc:	601a      	str	r2, [r3, #0]

    if( uxCriticalNesting == 0 )
10002cde:	4b03      	ldr	r3, [pc, #12]	; (10002cec <vPortExitCritical+0x28>)
10002ce0:	681b      	ldr	r3, [r3, #0]
10002ce2:	2b00      	cmp	r3, #0
10002ce4:	d100      	bne.n	10002ce8 <vPortExitCritical+0x24>
    {
        portENABLE_INTERRUPTS();
10002ce6:	b662      	cpsie	i
    }
}
10002ce8:	46bd      	mov	sp, r7
10002cea:	bd80      	pop	{r7, pc}
10002cec:	200005f4 	.word	0x200005f4

10002cf0 <ulSetInterruptMaskFromISR>:
/*-----------------------------------------------------------*/

uint32_t ulSetInterruptMaskFromISR( void )
{
    __asm volatile (
10002cf0:	f3ef 8010 	mrs	r0, PRIMASK
10002cf4:	b672      	cpsid	i
10002cf6:	4770      	bx	lr
        " mrs r0, PRIMASK	\n"
        " cpsid i			\n"
        " bx lr				  "
        ::: "memory"
        );
}
10002cf8:	1c18      	adds	r0, r3, #0
10002cfa:	46c0      	nop			; (mov r8, r8)

10002cfc <vClearInterruptMaskFromISR>:
/*-----------------------------------------------------------*/

void vClearInterruptMaskFromISR( __attribute__( ( unused ) ) uint32_t ulMask )
{
    __asm volatile (
10002cfc:	f380 8810 	msr	PRIMASK, r0
10002d00:	4770      	bx	lr
10002d02:	46c0      	nop			; (mov r8, r8)
	...

10002d10 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
    /* This is a naked function. */

    __asm volatile
10002d10:	f3ef 8009 	mrs	r0, PSP
10002d14:	4b0e      	ldr	r3, [pc, #56]	; (10002d50 <pxCurrentTCBConst>)
10002d16:	681a      	ldr	r2, [r3, #0]
10002d18:	3820      	subs	r0, #32
10002d1a:	6010      	str	r0, [r2, #0]
10002d1c:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
10002d1e:	4644      	mov	r4, r8
10002d20:	464d      	mov	r5, r9
10002d22:	4656      	mov	r6, sl
10002d24:	465f      	mov	r7, fp
10002d26:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
10002d28:	b508      	push	{r3, lr}
10002d2a:	b672      	cpsid	i
10002d2c:	f001 f908 	bl	10003f40 <vTaskSwitchContext>
10002d30:	b662      	cpsie	i
10002d32:	bc0c      	pop	{r2, r3}
10002d34:	6811      	ldr	r1, [r2, #0]
10002d36:	6808      	ldr	r0, [r1, #0]
10002d38:	3010      	adds	r0, #16
10002d3a:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
10002d3c:	46a0      	mov	r8, r4
10002d3e:	46a9      	mov	r9, r5
10002d40:	46b2      	mov	sl, r6
10002d42:	46bb      	mov	fp, r7
10002d44:	f380 8809 	msr	PSP, r0
10002d48:	3820      	subs	r0, #32
10002d4a:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
10002d4c:	4718      	bx	r3
10002d4e:	46c0      	nop			; (mov r8, r8)

10002d50 <pxCurrentTCBConst>:
10002d50:	200006d8 	.word	0x200006d8
10002d54:	46c0      	nop			; (mov r8, r8)
10002d56:	46c0      	nop			; (mov r8, r8)
10002d58:	46c0      	nop			; (mov r8, r8)
10002d5a:	46c0      	nop			; (mov r8, r8)
10002d5c:	46c0      	nop			; (mov r8, r8)
10002d5e:	46c0      	nop			; (mov r8, r8)

10002d60 <SysTick_Handler>:
    );
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
10002d60:	b580      	push	{r7, lr}
10002d62:	b082      	sub	sp, #8
10002d64:	af00      	add	r7, sp, #0
    uint32_t ulPreviousMask;

    ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
10002d66:	f7ff ffc3 	bl	10002cf0 <ulSetInterruptMaskFromISR>
10002d6a:	1c03      	adds	r3, r0, #0
10002d6c:	607b      	str	r3, [r7, #4]
    {
        /* Increment the RTOS tick. */
        if( xTaskIncrementTick() != pdFALSE )
10002d6e:	f001 f837 	bl	10003de0 <xTaskIncrementTick>
10002d72:	1e03      	subs	r3, r0, #0
10002d74:	d003      	beq.n	10002d7e <SysTick_Handler+0x1e>
        {
            /* Pend a context switch. */
            portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
10002d76:	4b05      	ldr	r3, [pc, #20]	; (10002d8c <SysTick_Handler+0x2c>)
10002d78:	2280      	movs	r2, #128	; 0x80
10002d7a:	0552      	lsls	r2, r2, #21
10002d7c:	601a      	str	r2, [r3, #0]
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
10002d7e:	687b      	ldr	r3, [r7, #4]
10002d80:	1c18      	adds	r0, r3, #0
10002d82:	f7ff ffbb 	bl	10002cfc <vClearInterruptMaskFromISR>
}
10002d86:	46bd      	mov	sp, r7
10002d88:	b002      	add	sp, #8
10002d8a:	bd80      	pop	{r7, pc}
10002d8c:	e000ed04 	.word	0xe000ed04

10002d90 <vPortSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
__attribute__( ( weak ) ) void vPortSetupTimerInterrupt( void )
{
10002d90:	b598      	push	{r3, r4, r7, lr}
10002d92:	af00      	add	r7, sp, #0
            ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR;
        }
    #endif /* configUSE_TICKLESS_IDLE */

    /* Stop and reset the SysTick. */
    portNVIC_SYSTICK_CTRL_REG = 0UL;
10002d94:	4b0a      	ldr	r3, [pc, #40]	; (10002dc0 <vPortSetupTimerInterrupt+0x30>)
10002d96:	2200      	movs	r2, #0
10002d98:	601a      	str	r2, [r3, #0]
    portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
10002d9a:	4b0a      	ldr	r3, [pc, #40]	; (10002dc4 <vPortSetupTimerInterrupt+0x34>)
10002d9c:	2200      	movs	r2, #0
10002d9e:	601a      	str	r2, [r3, #0]

    /* Configure SysTick to interrupt at the requested rate. */
    portNVIC_SYSTICK_LOAD_REG = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
10002da0:	4c09      	ldr	r4, [pc, #36]	; (10002dc8 <vPortSetupTimerInterrupt+0x38>)
10002da2:	4b0a      	ldr	r3, [pc, #40]	; (10002dcc <vPortSetupTimerInterrupt+0x3c>)
10002da4:	681b      	ldr	r3, [r3, #0]
10002da6:	1c18      	adds	r0, r3, #0
10002da8:	23fa      	movs	r3, #250	; 0xfa
10002daa:	0099      	lsls	r1, r3, #2
10002dac:	f002 fa34 	bl	10005218 <__aeabi_uidiv>
10002db0:	1c03      	adds	r3, r0, #0
10002db2:	3b01      	subs	r3, #1
10002db4:	6023      	str	r3, [r4, #0]
    portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT;
10002db6:	4b02      	ldr	r3, [pc, #8]	; (10002dc0 <vPortSetupTimerInterrupt+0x30>)
10002db8:	2207      	movs	r2, #7
10002dba:	601a      	str	r2, [r3, #0]
}
10002dbc:	46bd      	mov	sp, r7
10002dbe:	bd98      	pop	{r3, r4, r7, pc}
10002dc0:	e000e010 	.word	0xe000e010
10002dc4:	e000e018 	.word	0xe000e018
10002dc8:	e000e014 	.word	0xe000e014
10002dcc:	20003ffc 	.word	0x20003ffc

10002dd0 <pvPortMalloc>:
#endif

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
10002dd0:	b580      	push	{r7, lr}
10002dd2:	b084      	sub	sp, #16
10002dd4:	af00      	add	r7, sp, #0
10002dd6:	6078      	str	r0, [r7, #4]
    void * pvReturn;

    vTaskSuspendAll();
10002dd8:	f000 ff5c 	bl	10003c94 <vTaskSuspendAll>
    {
        pvReturn = malloc( xWantedSize );
10002ddc:	687b      	ldr	r3, [r7, #4]
10002dde:	1c18      	adds	r0, r3, #0
10002de0:	f002 fbc0 	bl	10005564 <malloc>
10002de4:	1c03      	adds	r3, r0, #0
10002de6:	60fb      	str	r3, [r7, #12]
        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
10002de8:	f000 ff60 	bl	10003cac <xTaskResumeAll>
                vApplicationMallocFailedHook();
            }
        }
    #endif

    return pvReturn;
10002dec:	68fb      	ldr	r3, [r7, #12]
}
10002dee:	1c18      	adds	r0, r3, #0
10002df0:	46bd      	mov	sp, r7
10002df2:	b004      	add	sp, #16
10002df4:	bd80      	pop	{r7, pc}
10002df6:	46c0      	nop			; (mov r8, r8)

10002df8 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
10002df8:	b580      	push	{r7, lr}
10002dfa:	b082      	sub	sp, #8
10002dfc:	af00      	add	r7, sp, #0
10002dfe:	6078      	str	r0, [r7, #4]
    if( pv )
10002e00:	687b      	ldr	r3, [r7, #4]
10002e02:	2b00      	cmp	r3, #0
10002e04:	d007      	beq.n	10002e16 <vPortFree+0x1e>
    {
        vTaskSuspendAll();
10002e06:	f000 ff45 	bl	10003c94 <vTaskSuspendAll>
        {
            free( pv );
10002e0a:	687b      	ldr	r3, [r7, #4]
10002e0c:	1c18      	adds	r0, r3, #0
10002e0e:	f002 fbb3 	bl	10005578 <free>
            traceFREE( pv, 0 );
        }
        ( void ) xTaskResumeAll();
10002e12:	f000 ff4b 	bl	10003cac <xTaskResumeAll>
    }
}
10002e16:	46bd      	mov	sp, r7
10002e18:	b002      	add	sp, #8
10002e1a:	bd80      	pop	{r7, pc}

10002e1c <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
10002e1c:	b580      	push	{r7, lr}
10002e1e:	b082      	sub	sp, #8
10002e20:	af00      	add	r7, sp, #0
10002e22:	6078      	str	r0, [r7, #4]
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
10002e24:	687b      	ldr	r3, [r7, #4]
10002e26:	3308      	adds	r3, #8
10002e28:	1c1a      	adds	r2, r3, #0
10002e2a:	687b      	ldr	r3, [r7, #4]
10002e2c:	605a      	str	r2, [r3, #4]

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
10002e2e:	687b      	ldr	r3, [r7, #4]
10002e30:	2201      	movs	r2, #1
10002e32:	4252      	negs	r2, r2
10002e34:	609a      	str	r2, [r3, #8]

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
10002e36:	687b      	ldr	r3, [r7, #4]
10002e38:	3308      	adds	r3, #8
10002e3a:	1c1a      	adds	r2, r3, #0
10002e3c:	687b      	ldr	r3, [r7, #4]
10002e3e:	60da      	str	r2, [r3, #12]
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
10002e40:	687b      	ldr	r3, [r7, #4]
10002e42:	3308      	adds	r3, #8
10002e44:	1c1a      	adds	r2, r3, #0
10002e46:	687b      	ldr	r3, [r7, #4]
10002e48:	611a      	str	r2, [r3, #16]

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
10002e4a:	687b      	ldr	r3, [r7, #4]
10002e4c:	2200      	movs	r2, #0
10002e4e:	601a      	str	r2, [r3, #0]

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
10002e50:	46bd      	mov	sp, r7
10002e52:	b002      	add	sp, #8
10002e54:	bd80      	pop	{r7, pc}
10002e56:	46c0      	nop			; (mov r8, r8)

10002e58 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
10002e58:	b580      	push	{r7, lr}
10002e5a:	b082      	sub	sp, #8
10002e5c:	af00      	add	r7, sp, #0
10002e5e:	6078      	str	r0, [r7, #4]
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
10002e60:	687b      	ldr	r3, [r7, #4]
10002e62:	2200      	movs	r2, #0
10002e64:	611a      	str	r2, [r3, #16]

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
10002e66:	46bd      	mov	sp, r7
10002e68:	b002      	add	sp, #8
10002e6a:	bd80      	pop	{r7, pc}

10002e6c <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
10002e6c:	b580      	push	{r7, lr}
10002e6e:	b084      	sub	sp, #16
10002e70:	af00      	add	r7, sp, #0
10002e72:	6078      	str	r0, [r7, #4]
10002e74:	6039      	str	r1, [r7, #0]
    ListItem_t * const pxIndex = pxList->pxIndex;
10002e76:	687b      	ldr	r3, [r7, #4]
10002e78:	685b      	ldr	r3, [r3, #4]
10002e7a:	60fb      	str	r3, [r7, #12]
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
10002e7c:	683b      	ldr	r3, [r7, #0]
10002e7e:	68fa      	ldr	r2, [r7, #12]
10002e80:	605a      	str	r2, [r3, #4]
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
10002e82:	68fb      	ldr	r3, [r7, #12]
10002e84:	689a      	ldr	r2, [r3, #8]
10002e86:	683b      	ldr	r3, [r7, #0]
10002e88:	609a      	str	r2, [r3, #8]

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
10002e8a:	68fb      	ldr	r3, [r7, #12]
10002e8c:	689b      	ldr	r3, [r3, #8]
10002e8e:	683a      	ldr	r2, [r7, #0]
10002e90:	605a      	str	r2, [r3, #4]
    pxIndex->pxPrevious = pxNewListItem;
10002e92:	68fb      	ldr	r3, [r7, #12]
10002e94:	683a      	ldr	r2, [r7, #0]
10002e96:	609a      	str	r2, [r3, #8]

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
10002e98:	683b      	ldr	r3, [r7, #0]
10002e9a:	687a      	ldr	r2, [r7, #4]
10002e9c:	611a      	str	r2, [r3, #16]

    ( pxList->uxNumberOfItems )++;
10002e9e:	687b      	ldr	r3, [r7, #4]
10002ea0:	681b      	ldr	r3, [r3, #0]
10002ea2:	1c5a      	adds	r2, r3, #1
10002ea4:	687b      	ldr	r3, [r7, #4]
10002ea6:	601a      	str	r2, [r3, #0]
}
10002ea8:	46bd      	mov	sp, r7
10002eaa:	b004      	add	sp, #16
10002eac:	bd80      	pop	{r7, pc}
10002eae:	46c0      	nop			; (mov r8, r8)

10002eb0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
10002eb0:	b580      	push	{r7, lr}
10002eb2:	b084      	sub	sp, #16
10002eb4:	af00      	add	r7, sp, #0
10002eb6:	6078      	str	r0, [r7, #4]
10002eb8:	6039      	str	r1, [r7, #0]
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
10002eba:	683b      	ldr	r3, [r7, #0]
10002ebc:	681b      	ldr	r3, [r3, #0]
10002ebe:	60bb      	str	r3, [r7, #8]
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
10002ec0:	68bb      	ldr	r3, [r7, #8]
10002ec2:	3301      	adds	r3, #1
10002ec4:	d103      	bne.n	10002ece <vListInsert+0x1e>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
10002ec6:	687b      	ldr	r3, [r7, #4]
10002ec8:	691b      	ldr	r3, [r3, #16]
10002eca:	60fb      	str	r3, [r7, #12]
10002ecc:	e00c      	b.n	10002ee8 <vListInsert+0x38>
        *   4) Using a queue or semaphore before it has been initialised or
        *      before the scheduler has been started (are interrupts firing
        *      before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
10002ece:	687b      	ldr	r3, [r7, #4]
10002ed0:	3308      	adds	r3, #8
10002ed2:	60fb      	str	r3, [r7, #12]
10002ed4:	e002      	b.n	10002edc <vListInsert+0x2c>
10002ed6:	68fb      	ldr	r3, [r7, #12]
10002ed8:	685b      	ldr	r3, [r3, #4]
10002eda:	60fb      	str	r3, [r7, #12]
10002edc:	68fb      	ldr	r3, [r7, #12]
10002ede:	685b      	ldr	r3, [r3, #4]
10002ee0:	681a      	ldr	r2, [r3, #0]
10002ee2:	68bb      	ldr	r3, [r7, #8]
10002ee4:	429a      	cmp	r2, r3
10002ee6:	d9f6      	bls.n	10002ed6 <vListInsert+0x26>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
10002ee8:	68fb      	ldr	r3, [r7, #12]
10002eea:	685a      	ldr	r2, [r3, #4]
10002eec:	683b      	ldr	r3, [r7, #0]
10002eee:	605a      	str	r2, [r3, #4]
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
10002ef0:	683b      	ldr	r3, [r7, #0]
10002ef2:	685b      	ldr	r3, [r3, #4]
10002ef4:	683a      	ldr	r2, [r7, #0]
10002ef6:	609a      	str	r2, [r3, #8]
    pxNewListItem->pxPrevious = pxIterator;
10002ef8:	683b      	ldr	r3, [r7, #0]
10002efa:	68fa      	ldr	r2, [r7, #12]
10002efc:	609a      	str	r2, [r3, #8]
    pxIterator->pxNext = pxNewListItem;
10002efe:	68fb      	ldr	r3, [r7, #12]
10002f00:	683a      	ldr	r2, [r7, #0]
10002f02:	605a      	str	r2, [r3, #4]

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
10002f04:	683b      	ldr	r3, [r7, #0]
10002f06:	687a      	ldr	r2, [r7, #4]
10002f08:	611a      	str	r2, [r3, #16]

    ( pxList->uxNumberOfItems )++;
10002f0a:	687b      	ldr	r3, [r7, #4]
10002f0c:	681b      	ldr	r3, [r3, #0]
10002f0e:	1c5a      	adds	r2, r3, #1
10002f10:	687b      	ldr	r3, [r7, #4]
10002f12:	601a      	str	r2, [r3, #0]
}
10002f14:	46bd      	mov	sp, r7
10002f16:	b004      	add	sp, #16
10002f18:	bd80      	pop	{r7, pc}
10002f1a:	46c0      	nop			; (mov r8, r8)

10002f1c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
10002f1c:	b580      	push	{r7, lr}
10002f1e:	b084      	sub	sp, #16
10002f20:	af00      	add	r7, sp, #0
10002f22:	6078      	str	r0, [r7, #4]
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
10002f24:	687b      	ldr	r3, [r7, #4]
10002f26:	691b      	ldr	r3, [r3, #16]
10002f28:	60fb      	str	r3, [r7, #12]

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
10002f2a:	687b      	ldr	r3, [r7, #4]
10002f2c:	685b      	ldr	r3, [r3, #4]
10002f2e:	687a      	ldr	r2, [r7, #4]
10002f30:	6892      	ldr	r2, [r2, #8]
10002f32:	609a      	str	r2, [r3, #8]
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
10002f34:	687b      	ldr	r3, [r7, #4]
10002f36:	689b      	ldr	r3, [r3, #8]
10002f38:	687a      	ldr	r2, [r7, #4]
10002f3a:	6852      	ldr	r2, [r2, #4]
10002f3c:	605a      	str	r2, [r3, #4]

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
10002f3e:	68fb      	ldr	r3, [r7, #12]
10002f40:	685a      	ldr	r2, [r3, #4]
10002f42:	687b      	ldr	r3, [r7, #4]
10002f44:	429a      	cmp	r2, r3
10002f46:	d103      	bne.n	10002f50 <uxListRemove+0x34>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
10002f48:	687b      	ldr	r3, [r7, #4]
10002f4a:	689a      	ldr	r2, [r3, #8]
10002f4c:	68fb      	ldr	r3, [r7, #12]
10002f4e:	605a      	str	r2, [r3, #4]
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
10002f50:	687b      	ldr	r3, [r7, #4]
10002f52:	2200      	movs	r2, #0
10002f54:	611a      	str	r2, [r3, #16]
    ( pxList->uxNumberOfItems )--;
10002f56:	68fb      	ldr	r3, [r7, #12]
10002f58:	681b      	ldr	r3, [r3, #0]
10002f5a:	1e5a      	subs	r2, r3, #1
10002f5c:	68fb      	ldr	r3, [r7, #12]
10002f5e:	601a      	str	r2, [r3, #0]

    return pxList->uxNumberOfItems;
10002f60:	68fb      	ldr	r3, [r7, #12]
10002f62:	681b      	ldr	r3, [r3, #0]
}
10002f64:	1c18      	adds	r0, r3, #0
10002f66:	46bd      	mov	sp, r7
10002f68:	b004      	add	sp, #16
10002f6a:	bd80      	pop	{r7, pc}

10002f6c <xQueueGenericReset>:
    taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
10002f6c:	b580      	push	{r7, lr}
10002f6e:	b084      	sub	sp, #16
10002f70:	af00      	add	r7, sp, #0
10002f72:	6078      	str	r0, [r7, #4]
10002f74:	6039      	str	r1, [r7, #0]
    Queue_t * const pxQueue = xQueue;
10002f76:	687b      	ldr	r3, [r7, #4]
10002f78:	60fb      	str	r3, [r7, #12]

    configASSERT( pxQueue );
10002f7a:	68fb      	ldr	r3, [r7, #12]
10002f7c:	2b00      	cmp	r3, #0
10002f7e:	d101      	bne.n	10002f84 <xQueueGenericReset+0x18>
10002f80:	b672      	cpsid	i
10002f82:	e7fe      	b.n	10002f82 <xQueueGenericReset+0x16>

    taskENTER_CRITICAL();
10002f84:	f7ff fe8e 	bl	10002ca4 <vPortEnterCritical>
    {
        pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
10002f88:	68fb      	ldr	r3, [r7, #12]
10002f8a:	681a      	ldr	r2, [r3, #0]
10002f8c:	68fb      	ldr	r3, [r7, #12]
10002f8e:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
10002f90:	68fb      	ldr	r3, [r7, #12]
10002f92:	6c1b      	ldr	r3, [r3, #64]	; 0x40
10002f94:	434b      	muls	r3, r1
10002f96:	18d2      	adds	r2, r2, r3
10002f98:	68fb      	ldr	r3, [r7, #12]
10002f9a:	609a      	str	r2, [r3, #8]
        pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
10002f9c:	68fb      	ldr	r3, [r7, #12]
10002f9e:	2200      	movs	r2, #0
10002fa0:	639a      	str	r2, [r3, #56]	; 0x38
        pxQueue->pcWriteTo = pxQueue->pcHead;
10002fa2:	68fb      	ldr	r3, [r7, #12]
10002fa4:	681a      	ldr	r2, [r3, #0]
10002fa6:	68fb      	ldr	r3, [r7, #12]
10002fa8:	605a      	str	r2, [r3, #4]
        pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
10002faa:	68fb      	ldr	r3, [r7, #12]
10002fac:	681a      	ldr	r2, [r3, #0]
10002fae:	68fb      	ldr	r3, [r7, #12]
10002fb0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
10002fb2:	1e59      	subs	r1, r3, #1
10002fb4:	68fb      	ldr	r3, [r7, #12]
10002fb6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
10002fb8:	434b      	muls	r3, r1
10002fba:	18d2      	adds	r2, r2, r3
10002fbc:	68fb      	ldr	r3, [r7, #12]
10002fbe:	60da      	str	r2, [r3, #12]
        pxQueue->cRxLock = queueUNLOCKED;
10002fc0:	68fb      	ldr	r3, [r7, #12]
10002fc2:	2244      	movs	r2, #68	; 0x44
10002fc4:	21ff      	movs	r1, #255	; 0xff
10002fc6:	5499      	strb	r1, [r3, r2]
        pxQueue->cTxLock = queueUNLOCKED;
10002fc8:	68fb      	ldr	r3, [r7, #12]
10002fca:	2245      	movs	r2, #69	; 0x45
10002fcc:	21ff      	movs	r1, #255	; 0xff
10002fce:	5499      	strb	r1, [r3, r2]

        if( xNewQueue == pdFALSE )
10002fd0:	683b      	ldr	r3, [r7, #0]
10002fd2:	2b00      	cmp	r3, #0
10002fd4:	d10d      	bne.n	10002ff2 <xQueueGenericReset+0x86>
            /* If there are tasks blocked waiting to read from the queue, then
             * the tasks will remain blocked as after this function exits the queue
             * will still be empty.  If there are tasks blocked waiting to write to
             * the queue, then one should be unblocked as after this function exits
             * it will be possible to write to it. */
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
10002fd6:	68fb      	ldr	r3, [r7, #12]
10002fd8:	691b      	ldr	r3, [r3, #16]
10002fda:	2b00      	cmp	r3, #0
10002fdc:	d013      	beq.n	10003006 <xQueueGenericReset+0x9a>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
10002fde:	68fb      	ldr	r3, [r7, #12]
10002fe0:	3310      	adds	r3, #16
10002fe2:	1c18      	adds	r0, r3, #0
10002fe4:	f001 f83c 	bl	10004060 <xTaskRemoveFromEventList>
10002fe8:	1e03      	subs	r3, r0, #0
10002fea:	d00c      	beq.n	10003006 <xQueueGenericReset+0x9a>
                {
                    queueYIELD_IF_USING_PREEMPTION();
10002fec:	f7ff fe4c 	bl	10002c88 <vPortYield>
10002ff0:	e009      	b.n	10003006 <xQueueGenericReset+0x9a>
            }
        }
        else
        {
            /* Ensure the event queues start in the correct state. */
            vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
10002ff2:	68fb      	ldr	r3, [r7, #12]
10002ff4:	3310      	adds	r3, #16
10002ff6:	1c18      	adds	r0, r3, #0
10002ff8:	f7ff ff10 	bl	10002e1c <vListInitialise>
            vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
10002ffc:	68fb      	ldr	r3, [r7, #12]
10002ffe:	3324      	adds	r3, #36	; 0x24
10003000:	1c18      	adds	r0, r3, #0
10003002:	f7ff ff0b 	bl	10002e1c <vListInitialise>
        }
    }
    taskEXIT_CRITICAL();
10003006:	f7ff fe5d 	bl	10002cc4 <vPortExitCritical>

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return pdPASS;
1000300a:	2301      	movs	r3, #1
}
1000300c:	1c18      	adds	r0, r3, #0
1000300e:	46bd      	mov	sp, r7
10003010:	b004      	add	sp, #16
10003012:	bd80      	pop	{r7, pc}

10003014 <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
10003014:	b590      	push	{r4, r7, lr}
10003016:	b08b      	sub	sp, #44	; 0x2c
10003018:	af02      	add	r7, sp, #8
1000301a:	60f8      	str	r0, [r7, #12]
1000301c:	60b9      	str	r1, [r7, #8]
1000301e:	1dfb      	adds	r3, r7, #7
10003020:	701a      	strb	r2, [r3, #0]
        Queue_t * pxNewQueue;
        size_t xQueueSizeInBytes;
        uint8_t * pucQueueStorage;

        configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
10003022:	68fb      	ldr	r3, [r7, #12]
10003024:	2b00      	cmp	r3, #0
10003026:	d101      	bne.n	1000302c <xQueueGenericCreate+0x18>
10003028:	b672      	cpsid	i
1000302a:	e7fe      	b.n	1000302a <xQueueGenericCreate+0x16>

        /* Allocate enough space to hold the maximum number of items that
         * can be in the queue at any time.  It is valid for uxItemSize to be
         * zero in the case the queue is used as a semaphore. */
        xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
1000302c:	68fb      	ldr	r3, [r7, #12]
1000302e:	68ba      	ldr	r2, [r7, #8]
10003030:	4353      	muls	r3, r2
10003032:	61fb      	str	r3, [r7, #28]

        /* Check for multiplication overflow. */
        configASSERT( ( uxItemSize == 0 ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) ) );
10003034:	68bb      	ldr	r3, [r7, #8]
10003036:	2b00      	cmp	r3, #0
10003038:	d008      	beq.n	1000304c <xQueueGenericCreate+0x38>
1000303a:	69f8      	ldr	r0, [r7, #28]
1000303c:	68b9      	ldr	r1, [r7, #8]
1000303e:	f002 f8eb 	bl	10005218 <__aeabi_uidiv>
10003042:	1c03      	adds	r3, r0, #0
10003044:	1e1a      	subs	r2, r3, #0
10003046:	68fb      	ldr	r3, [r7, #12]
10003048:	429a      	cmp	r2, r3
1000304a:	d101      	bne.n	10003050 <xQueueGenericCreate+0x3c>
1000304c:	2301      	movs	r3, #1
1000304e:	e000      	b.n	10003052 <xQueueGenericCreate+0x3e>
10003050:	2300      	movs	r3, #0
10003052:	2b00      	cmp	r3, #0
10003054:	d101      	bne.n	1000305a <xQueueGenericCreate+0x46>
10003056:	b672      	cpsid	i
10003058:	e7fe      	b.n	10003058 <xQueueGenericCreate+0x44>

        /* Check for addition overflow. */
        configASSERT( ( sizeof( Queue_t ) + xQueueSizeInBytes ) >  xQueueSizeInBytes );
1000305a:	69fb      	ldr	r3, [r7, #28]
1000305c:	3354      	adds	r3, #84	; 0x54
1000305e:	1e1a      	subs	r2, r3, #0
10003060:	69fb      	ldr	r3, [r7, #28]
10003062:	429a      	cmp	r2, r3
10003064:	d801      	bhi.n	1000306a <xQueueGenericCreate+0x56>
10003066:	b672      	cpsid	i
10003068:	e7fe      	b.n	10003068 <xQueueGenericCreate+0x54>
         * alignment requirements of the Queue_t structure - which in this case
         * is an int8_t *.  Therefore, whenever the stack alignment requirements
         * are greater than or equal to the pointer to char requirements the cast
         * is safe.  In other cases alignment requirements are not strict (one or
         * two bytes). */
        pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
1000306a:	69fb      	ldr	r3, [r7, #28]
1000306c:	3354      	adds	r3, #84	; 0x54
1000306e:	1c18      	adds	r0, r3, #0
10003070:	f7ff feae 	bl	10002dd0 <pvPortMalloc>
10003074:	1c03      	adds	r3, r0, #0
10003076:	61bb      	str	r3, [r7, #24]

        if( pxNewQueue != NULL )
10003078:	69bb      	ldr	r3, [r7, #24]
1000307a:	2b00      	cmp	r3, #0
1000307c:	d00e      	beq.n	1000309c <xQueueGenericCreate+0x88>
        {
            /* Jump past the queue structure to find the location of the queue
             * storage area. */
            pucQueueStorage = ( uint8_t * ) pxNewQueue;
1000307e:	69bb      	ldr	r3, [r7, #24]
10003080:	617b      	str	r3, [r7, #20]
            pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
10003082:	697b      	ldr	r3, [r7, #20]
10003084:	3354      	adds	r3, #84	; 0x54
10003086:	617b      	str	r3, [r7, #20]
                     * deleted. */
                    pxNewQueue->ucStaticallyAllocated = pdFALSE;
                }
            #endif /* configSUPPORT_STATIC_ALLOCATION */

            prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
10003088:	68f8      	ldr	r0, [r7, #12]
1000308a:	68b9      	ldr	r1, [r7, #8]
1000308c:	697a      	ldr	r2, [r7, #20]
1000308e:	1dfb      	adds	r3, r7, #7
10003090:	781c      	ldrb	r4, [r3, #0]
10003092:	69bb      	ldr	r3, [r7, #24]
10003094:	9300      	str	r3, [sp, #0]
10003096:	1c23      	adds	r3, r4, #0
10003098:	f000 f806 	bl	100030a8 <prvInitialiseNewQueue>
        {
            traceQUEUE_CREATE_FAILED( ucQueueType );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
1000309c:	69bb      	ldr	r3, [r7, #24]
    }
1000309e:	1c18      	adds	r0, r3, #0
100030a0:	46bd      	mov	sp, r7
100030a2:	b009      	add	sp, #36	; 0x24
100030a4:	bd90      	pop	{r4, r7, pc}
100030a6:	46c0      	nop			; (mov r8, r8)

100030a8 <prvInitialiseNewQueue>:
static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
                                   const UBaseType_t uxItemSize,
                                   uint8_t * pucQueueStorage,
                                   const uint8_t ucQueueType,
                                   Queue_t * pxNewQueue )
{
100030a8:	b580      	push	{r7, lr}
100030aa:	b084      	sub	sp, #16
100030ac:	af00      	add	r7, sp, #0
100030ae:	60f8      	str	r0, [r7, #12]
100030b0:	60b9      	str	r1, [r7, #8]
100030b2:	607a      	str	r2, [r7, #4]
100030b4:	1c1a      	adds	r2, r3, #0
100030b6:	1cfb      	adds	r3, r7, #3
100030b8:	701a      	strb	r2, [r3, #0]
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
100030ba:	68bb      	ldr	r3, [r7, #8]
100030bc:	2b00      	cmp	r3, #0
100030be:	d103      	bne.n	100030c8 <prvInitialiseNewQueue+0x20>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
100030c0:	69bb      	ldr	r3, [r7, #24]
100030c2:	69ba      	ldr	r2, [r7, #24]
100030c4:	601a      	str	r2, [r3, #0]
100030c6:	e002      	b.n	100030ce <prvInitialiseNewQueue+0x26>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
100030c8:	69bb      	ldr	r3, [r7, #24]
100030ca:	687a      	ldr	r2, [r7, #4]
100030cc:	601a      	str	r2, [r3, #0]
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
100030ce:	69bb      	ldr	r3, [r7, #24]
100030d0:	68fa      	ldr	r2, [r7, #12]
100030d2:	63da      	str	r2, [r3, #60]	; 0x3c
    pxNewQueue->uxItemSize = uxItemSize;
100030d4:	69bb      	ldr	r3, [r7, #24]
100030d6:	68ba      	ldr	r2, [r7, #8]
100030d8:	641a      	str	r2, [r3, #64]	; 0x40
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
100030da:	69bb      	ldr	r3, [r7, #24]
100030dc:	1c18      	adds	r0, r3, #0
100030de:	2101      	movs	r1, #1
100030e0:	f7ff ff44 	bl	10002f6c <xQueueGenericReset>

    #if ( configUSE_TRACE_FACILITY == 1 )
        {
            pxNewQueue->ucQueueType = ucQueueType;
100030e4:	69bb      	ldr	r3, [r7, #24]
100030e6:	1cfa      	adds	r2, r7, #3
100030e8:	2150      	movs	r1, #80	; 0x50
100030ea:	7812      	ldrb	r2, [r2, #0]
100030ec:	545a      	strb	r2, [r3, r1]
        }
    #endif /* configUSE_TRACE_FACILITY */

    #if ( configUSE_QUEUE_SETS == 1 )
        {
            pxNewQueue->pxQueueSetContainer = NULL;
100030ee:	69bb      	ldr	r3, [r7, #24]
100030f0:	2200      	movs	r2, #0
100030f2:	649a      	str	r2, [r3, #72]	; 0x48
        }
    #endif /* configUSE_QUEUE_SETS */

    traceQUEUE_CREATE( pxNewQueue );
}
100030f4:	46bd      	mov	sp, r7
100030f6:	b004      	add	sp, #16
100030f8:	bd80      	pop	{r7, pc}
100030fa:	46c0      	nop			; (mov r8, r8)

100030fc <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
100030fc:	b580      	push	{r7, lr}
100030fe:	b08a      	sub	sp, #40	; 0x28
10003100:	af00      	add	r7, sp, #0
10003102:	60f8      	str	r0, [r7, #12]
10003104:	60b9      	str	r1, [r7, #8]
10003106:	607a      	str	r2, [r7, #4]
10003108:	603b      	str	r3, [r7, #0]
    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
1000310a:	2300      	movs	r3, #0
1000310c:	627b      	str	r3, [r7, #36]	; 0x24
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
1000310e:	68fb      	ldr	r3, [r7, #12]
10003110:	623b      	str	r3, [r7, #32]

    configASSERT( pxQueue );
10003112:	6a3b      	ldr	r3, [r7, #32]
10003114:	2b00      	cmp	r3, #0
10003116:	d101      	bne.n	1000311c <xQueueGenericSend+0x20>
10003118:	b672      	cpsid	i
1000311a:	e7fe      	b.n	1000311a <xQueueGenericSend+0x1e>
    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1000311c:	68bb      	ldr	r3, [r7, #8]
1000311e:	2b00      	cmp	r3, #0
10003120:	d103      	bne.n	1000312a <xQueueGenericSend+0x2e>
10003122:	6a3b      	ldr	r3, [r7, #32]
10003124:	6c1b      	ldr	r3, [r3, #64]	; 0x40
10003126:	2b00      	cmp	r3, #0
10003128:	d101      	bne.n	1000312e <xQueueGenericSend+0x32>
1000312a:	2301      	movs	r3, #1
1000312c:	e000      	b.n	10003130 <xQueueGenericSend+0x34>
1000312e:	2300      	movs	r3, #0
10003130:	2b00      	cmp	r3, #0
10003132:	d101      	bne.n	10003138 <xQueueGenericSend+0x3c>
10003134:	b672      	cpsid	i
10003136:	e7fe      	b.n	10003136 <xQueueGenericSend+0x3a>
    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
10003138:	683b      	ldr	r3, [r7, #0]
1000313a:	2b02      	cmp	r3, #2
1000313c:	d103      	bne.n	10003146 <xQueueGenericSend+0x4a>
1000313e:	6a3b      	ldr	r3, [r7, #32]
10003140:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
10003142:	2b01      	cmp	r3, #1
10003144:	d101      	bne.n	1000314a <xQueueGenericSend+0x4e>
10003146:	2301      	movs	r3, #1
10003148:	e000      	b.n	1000314c <xQueueGenericSend+0x50>
1000314a:	2300      	movs	r3, #0
1000314c:	2b00      	cmp	r3, #0
1000314e:	d101      	bne.n	10003154 <xQueueGenericSend+0x58>
10003150:	b672      	cpsid	i
10003152:	e7fe      	b.n	10003152 <xQueueGenericSend+0x56>
    #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
10003154:	f001 f90a 	bl	1000436c <xTaskGetSchedulerState>
10003158:	1e03      	subs	r3, r0, #0
1000315a:	d102      	bne.n	10003162 <xQueueGenericSend+0x66>
1000315c:	687b      	ldr	r3, [r7, #4]
1000315e:	2b00      	cmp	r3, #0
10003160:	d101      	bne.n	10003166 <xQueueGenericSend+0x6a>
10003162:	2301      	movs	r3, #1
10003164:	e000      	b.n	10003168 <xQueueGenericSend+0x6c>
10003166:	2300      	movs	r3, #0
10003168:	2b00      	cmp	r3, #0
1000316a:	d101      	bne.n	10003170 <xQueueGenericSend+0x74>
1000316c:	b672      	cpsid	i
1000316e:	e7fe      	b.n	1000316e <xQueueGenericSend+0x72>
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
10003170:	f7ff fd98 	bl	10002ca4 <vPortEnterCritical>
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
10003174:	6a3b      	ldr	r3, [r7, #32]
10003176:	6b9a      	ldr	r2, [r3, #56]	; 0x38
10003178:	6a3b      	ldr	r3, [r7, #32]
1000317a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
1000317c:	429a      	cmp	r2, r3
1000317e:	d302      	bcc.n	10003186 <xQueueGenericSend+0x8a>
10003180:	683b      	ldr	r3, [r7, #0]
10003182:	2b02      	cmp	r3, #2
10003184:	d138      	bne.n	100031f8 <xQueueGenericSend+0xfc>
            {
                traceQUEUE_SEND( pxQueue );

                #if ( configUSE_QUEUE_SETS == 1 )
                    {
                        const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
10003186:	6a3b      	ldr	r3, [r7, #32]
10003188:	6b9b      	ldr	r3, [r3, #56]	; 0x38
1000318a:	61fb      	str	r3, [r7, #28]

                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
1000318c:	6a39      	ldr	r1, [r7, #32]
1000318e:	68ba      	ldr	r2, [r7, #8]
10003190:	683b      	ldr	r3, [r7, #0]
10003192:	1c08      	adds	r0, r1, #0
10003194:	1c11      	adds	r1, r2, #0
10003196:	1c1a      	adds	r2, r3, #0
10003198:	f000 f9e6 	bl	10003568 <prvCopyDataToQueue>
1000319c:	1c03      	adds	r3, r0, #0
1000319e:	61bb      	str	r3, [r7, #24]

                        if( pxQueue->pxQueueSetContainer != NULL )
100031a0:	6a3b      	ldr	r3, [r7, #32]
100031a2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
100031a4:	2b00      	cmp	r3, #0
100031a6:	d010      	beq.n	100031ca <xQueueGenericSend+0xce>
                        {
                            if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 ) )
100031a8:	683b      	ldr	r3, [r7, #0]
100031aa:	2b02      	cmp	r3, #2
100031ac:	d104      	bne.n	100031b8 <xQueueGenericSend+0xbc>
100031ae:	69fb      	ldr	r3, [r7, #28]
100031b0:	2b00      	cmp	r3, #0
100031b2:	d001      	beq.n	100031b8 <xQueueGenericSend+0xbc>
100031b4:	46c0      	nop			; (mov r8, r8)
100031b6:	e01b      	b.n	100031f0 <xQueueGenericSend+0xf4>
                                /* Do not notify the queue set as an existing item
                                 * was overwritten in the queue so the number of items
                                 * in the queue has not changed. */
                                mtCOVERAGE_TEST_MARKER();
                            }
                            else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
100031b8:	6a3b      	ldr	r3, [r7, #32]
100031ba:	1c18      	adds	r0, r3, #0
100031bc:	f000 fb64 	bl	10003888 <prvNotifyQueueSetContainer>
100031c0:	1e03      	subs	r3, r0, #0
100031c2:	d015      	beq.n	100031f0 <xQueueGenericSend+0xf4>
                            {
                                /* The queue is a member of a queue set, and posting
                                 * to the queue set caused a higher priority task to
                                 * unblock. A context switch is required. */
                                queueYIELD_IF_USING_PREEMPTION();
100031c4:	f7ff fd60 	bl	10002c88 <vPortYield>
100031c8:	e012      	b.n	100031f0 <xQueueGenericSend+0xf4>
                        }
                        else
                        {
                            /* If there was a task waiting for data to arrive on the
                             * queue then unblock it now. */
                            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
100031ca:	6a3b      	ldr	r3, [r7, #32]
100031cc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
100031ce:	2b00      	cmp	r3, #0
100031d0:	d009      	beq.n	100031e6 <xQueueGenericSend+0xea>
                            {
                                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
100031d2:	6a3b      	ldr	r3, [r7, #32]
100031d4:	3324      	adds	r3, #36	; 0x24
100031d6:	1c18      	adds	r0, r3, #0
100031d8:	f000 ff42 	bl	10004060 <xTaskRemoveFromEventList>
100031dc:	1e03      	subs	r3, r0, #0
100031de:	d007      	beq.n	100031f0 <xQueueGenericSend+0xf4>
                                {
                                    /* The unblocked task has a priority higher than
                                     * our own so yield immediately.  Yes it is ok to
                                     * do this from within the critical section - the
                                     * kernel takes care of that. */
                                    queueYIELD_IF_USING_PREEMPTION();
100031e0:	f7ff fd52 	bl	10002c88 <vPortYield>
100031e4:	e004      	b.n	100031f0 <xQueueGenericSend+0xf4>
                                else
                                {
                                    mtCOVERAGE_TEST_MARKER();
                                }
                            }
                            else if( xYieldRequired != pdFALSE )
100031e6:	69bb      	ldr	r3, [r7, #24]
100031e8:	2b00      	cmp	r3, #0
100031ea:	d001      	beq.n	100031f0 <xQueueGenericSend+0xf4>
                            {
                                /* This path is a special case that will only get
                                 * executed if the task was holding multiple mutexes
                                 * and the mutexes were given back in an order that is
                                 * different to that in which they were taken. */
                                queueYIELD_IF_USING_PREEMPTION();
100031ec:	f7ff fd4c 	bl	10002c88 <vPortYield>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
100031f0:	f7ff fd68 	bl	10002cc4 <vPortExitCritical>
                return pdPASS;
100031f4:	2301      	movs	r3, #1
100031f6:	e060      	b.n	100032ba <xQueueGenericSend+0x1be>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
100031f8:	687b      	ldr	r3, [r7, #4]
100031fa:	2b00      	cmp	r3, #0
100031fc:	d103      	bne.n	10003206 <xQueueGenericSend+0x10a>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
100031fe:	f7ff fd61 	bl	10002cc4 <vPortExitCritical>

                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
10003202:	2300      	movs	r3, #0
10003204:	e059      	b.n	100032ba <xQueueGenericSend+0x1be>
                }
                else if( xEntryTimeSet == pdFALSE )
10003206:	6a7b      	ldr	r3, [r7, #36]	; 0x24
10003208:	2b00      	cmp	r3, #0
1000320a:	d106      	bne.n	1000321a <xQueueGenericSend+0x11e>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
1000320c:	2310      	movs	r3, #16
1000320e:	18fb      	adds	r3, r7, r3
10003210:	1c18      	adds	r0, r3, #0
10003212:	f000 ff81 	bl	10004118 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
10003216:	2301      	movs	r3, #1
10003218:	627b      	str	r3, [r7, #36]	; 0x24
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
1000321a:	f7ff fd53 	bl	10002cc4 <vPortExitCritical>

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
1000321e:	f000 fd39 	bl	10003c94 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
10003222:	f7ff fd3f 	bl	10002ca4 <vPortEnterCritical>
10003226:	6a3b      	ldr	r3, [r7, #32]
10003228:	2244      	movs	r2, #68	; 0x44
1000322a:	5c9b      	ldrb	r3, [r3, r2]
1000322c:	b2db      	uxtb	r3, r3
1000322e:	b25b      	sxtb	r3, r3
10003230:	3301      	adds	r3, #1
10003232:	d103      	bne.n	1000323c <xQueueGenericSend+0x140>
10003234:	6a3b      	ldr	r3, [r7, #32]
10003236:	2244      	movs	r2, #68	; 0x44
10003238:	2100      	movs	r1, #0
1000323a:	5499      	strb	r1, [r3, r2]
1000323c:	6a3b      	ldr	r3, [r7, #32]
1000323e:	2245      	movs	r2, #69	; 0x45
10003240:	5c9b      	ldrb	r3, [r3, r2]
10003242:	b2db      	uxtb	r3, r3
10003244:	b25b      	sxtb	r3, r3
10003246:	3301      	adds	r3, #1
10003248:	d103      	bne.n	10003252 <xQueueGenericSend+0x156>
1000324a:	6a3b      	ldr	r3, [r7, #32]
1000324c:	2245      	movs	r2, #69	; 0x45
1000324e:	2100      	movs	r1, #0
10003250:	5499      	strb	r1, [r3, r2]
10003252:	f7ff fd37 	bl	10002cc4 <vPortExitCritical>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
10003256:	2310      	movs	r3, #16
10003258:	18fa      	adds	r2, r7, r3
1000325a:	1d3b      	adds	r3, r7, #4
1000325c:	1c10      	adds	r0, r2, #0
1000325e:	1c19      	adds	r1, r3, #0
10003260:	f000 ff6e 	bl	10004140 <xTaskCheckForTimeOut>
10003264:	1e03      	subs	r3, r0, #0
10003266:	d11f      	bne.n	100032a8 <xQueueGenericSend+0x1ac>
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
10003268:	6a3b      	ldr	r3, [r7, #32]
1000326a:	1c18      	adds	r0, r3, #0
1000326c:	f000 fa96 	bl	1000379c <prvIsQueueFull>
10003270:	1e03      	subs	r3, r0, #0
10003272:	d012      	beq.n	1000329a <xQueueGenericSend+0x19e>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
10003274:	6a3b      	ldr	r3, [r7, #32]
10003276:	3310      	adds	r3, #16
10003278:	1c1a      	adds	r2, r3, #0
1000327a:	687b      	ldr	r3, [r7, #4]
1000327c:	1c10      	adds	r0, r2, #0
1000327e:	1c19      	adds	r1, r3, #0
10003280:	f000 feae 	bl	10003fe0 <vTaskPlaceOnEventList>
                /* Unlocking the queue means queue events can effect the
                 * event list.  It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready last instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
10003284:	6a3b      	ldr	r3, [r7, #32]
10003286:	1c18      	adds	r0, r3, #0
10003288:	f000 fa06 	bl	10003698 <prvUnlockQueue>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in a ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
1000328c:	f000 fd0e 	bl	10003cac <xTaskResumeAll>
10003290:	1e03      	subs	r3, r0, #0
10003292:	d111      	bne.n	100032b8 <xQueueGenericSend+0x1bc>
                {
                    portYIELD_WITHIN_API();
10003294:	f7ff fcf8 	bl	10002c88 <vPortYield>
10003298:	e00e      	b.n	100032b8 <xQueueGenericSend+0x1bc>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
1000329a:	6a3b      	ldr	r3, [r7, #32]
1000329c:	1c18      	adds	r0, r3, #0
1000329e:	f000 f9fb 	bl	10003698 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
100032a2:	f000 fd03 	bl	10003cac <xTaskResumeAll>
100032a6:	e763      	b.n	10003170 <xQueueGenericSend+0x74>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
100032a8:	6a3b      	ldr	r3, [r7, #32]
100032aa:	1c18      	adds	r0, r3, #0
100032ac:	f000 f9f4 	bl	10003698 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
100032b0:	f000 fcfc 	bl	10003cac <xTaskResumeAll>

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
100032b4:	2300      	movs	r3, #0
100032b6:	e000      	b.n	100032ba <xQueueGenericSend+0x1be>
        }
    } /*lint -restore */
100032b8:	e75a      	b.n	10003170 <xQueueGenericSend+0x74>
}
100032ba:	1c18      	adds	r0, r3, #0
100032bc:	46bd      	mov	sp, r7
100032be:	b00a      	add	sp, #40	; 0x28
100032c0:	bd80      	pop	{r7, pc}
100032c2:	46c0      	nop			; (mov r8, r8)

100032c4 <xQueueGenericSendFromISR>:

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
100032c4:	b580      	push	{r7, lr}
100032c6:	b08a      	sub	sp, #40	; 0x28
100032c8:	af00      	add	r7, sp, #0
100032ca:	60f8      	str	r0, [r7, #12]
100032cc:	60b9      	str	r1, [r7, #8]
100032ce:	607a      	str	r2, [r7, #4]
100032d0:	603b      	str	r3, [r7, #0]
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
100032d2:	68fb      	ldr	r3, [r7, #12]
100032d4:	623b      	str	r3, [r7, #32]

    configASSERT( pxQueue );
100032d6:	6a3b      	ldr	r3, [r7, #32]
100032d8:	2b00      	cmp	r3, #0
100032da:	d101      	bne.n	100032e0 <xQueueGenericSendFromISR+0x1c>
100032dc:	b672      	cpsid	i
100032de:	e7fe      	b.n	100032de <xQueueGenericSendFromISR+0x1a>
    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
100032e0:	68bb      	ldr	r3, [r7, #8]
100032e2:	2b00      	cmp	r3, #0
100032e4:	d103      	bne.n	100032ee <xQueueGenericSendFromISR+0x2a>
100032e6:	6a3b      	ldr	r3, [r7, #32]
100032e8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
100032ea:	2b00      	cmp	r3, #0
100032ec:	d101      	bne.n	100032f2 <xQueueGenericSendFromISR+0x2e>
100032ee:	2301      	movs	r3, #1
100032f0:	e000      	b.n	100032f4 <xQueueGenericSendFromISR+0x30>
100032f2:	2300      	movs	r3, #0
100032f4:	2b00      	cmp	r3, #0
100032f6:	d101      	bne.n	100032fc <xQueueGenericSendFromISR+0x38>
100032f8:	b672      	cpsid	i
100032fa:	e7fe      	b.n	100032fa <xQueueGenericSendFromISR+0x36>
    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
100032fc:	683b      	ldr	r3, [r7, #0]
100032fe:	2b02      	cmp	r3, #2
10003300:	d103      	bne.n	1000330a <xQueueGenericSendFromISR+0x46>
10003302:	6a3b      	ldr	r3, [r7, #32]
10003304:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
10003306:	2b01      	cmp	r3, #1
10003308:	d101      	bne.n	1000330e <xQueueGenericSendFromISR+0x4a>
1000330a:	2301      	movs	r3, #1
1000330c:	e000      	b.n	10003310 <xQueueGenericSendFromISR+0x4c>
1000330e:	2300      	movs	r3, #0
10003310:	2b00      	cmp	r3, #0
10003312:	d101      	bne.n	10003318 <xQueueGenericSendFromISR+0x54>
10003314:	b672      	cpsid	i
10003316:	e7fe      	b.n	10003316 <xQueueGenericSendFromISR+0x52>
    /* Similar to xQueueGenericSend, except without blocking if there is no room
     * in the queue.  Also don't directly wake a task that was blocked on a queue
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
10003318:	f7ff fcea 	bl	10002cf0 <ulSetInterruptMaskFromISR>
1000331c:	1c03      	adds	r3, r0, #0
1000331e:	61fb      	str	r3, [r7, #28]
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
10003320:	6a3b      	ldr	r3, [r7, #32]
10003322:	6b9a      	ldr	r2, [r3, #56]	; 0x38
10003324:	6a3b      	ldr	r3, [r7, #32]
10003326:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
10003328:	429a      	cmp	r2, r3
1000332a:	d302      	bcc.n	10003332 <xQueueGenericSendFromISR+0x6e>
1000332c:	683b      	ldr	r3, [r7, #0]
1000332e:	2b02      	cmp	r3, #2
10003330:	d155      	bne.n	100033de <xQueueGenericSendFromISR+0x11a>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
10003332:	231b      	movs	r3, #27
10003334:	18fb      	adds	r3, r7, r3
10003336:	6a3a      	ldr	r2, [r7, #32]
10003338:	2145      	movs	r1, #69	; 0x45
1000333a:	5c52      	ldrb	r2, [r2, r1]
1000333c:	701a      	strb	r2, [r3, #0]
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
1000333e:	6a3b      	ldr	r3, [r7, #32]
10003340:	6b9b      	ldr	r3, [r3, #56]	; 0x38
10003342:	617b      	str	r3, [r7, #20]
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
10003344:	6a39      	ldr	r1, [r7, #32]
10003346:	68ba      	ldr	r2, [r7, #8]
10003348:	683b      	ldr	r3, [r7, #0]
1000334a:	1c08      	adds	r0, r1, #0
1000334c:	1c11      	adds	r1, r2, #0
1000334e:	1c1a      	adds	r2, r3, #0
10003350:	f000 f90a 	bl	10003568 <prvCopyDataToQueue>

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
10003354:	231b      	movs	r3, #27
10003356:	18fb      	adds	r3, r7, r3
10003358:	781b      	ldrb	r3, [r3, #0]
1000335a:	b25b      	sxtb	r3, r3
1000335c:	3301      	adds	r3, #1
1000335e:	d12a      	bne.n	100033b6 <xQueueGenericSendFromISR+0xf2>
            {
                #if ( configUSE_QUEUE_SETS == 1 )
                    {
                        if( pxQueue->pxQueueSetContainer != NULL )
10003360:	6a3b      	ldr	r3, [r7, #32]
10003362:	6c9b      	ldr	r3, [r3, #72]	; 0x48
10003364:	2b00      	cmp	r3, #0
10003366:	d014      	beq.n	10003392 <xQueueGenericSendFromISR+0xce>
                        {
                            if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 ) )
10003368:	683b      	ldr	r3, [r7, #0]
1000336a:	2b02      	cmp	r3, #2
1000336c:	d104      	bne.n	10003378 <xQueueGenericSendFromISR+0xb4>
1000336e:	697b      	ldr	r3, [r7, #20]
10003370:	2b00      	cmp	r3, #0
10003372:	d001      	beq.n	10003378 <xQueueGenericSendFromISR+0xb4>
10003374:	46c0      	nop			; (mov r8, r8)
10003376:	e02f      	b.n	100033d8 <xQueueGenericSendFromISR+0x114>
                                /* Do not notify the queue set as an existing item
                                 * was overwritten in the queue so the number of items
                                 * in the queue has not changed. */
                                mtCOVERAGE_TEST_MARKER();
                            }
                            else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
10003378:	6a3b      	ldr	r3, [r7, #32]
1000337a:	1c18      	adds	r0, r3, #0
1000337c:	f000 fa84 	bl	10003888 <prvNotifyQueueSetContainer>
10003380:	1e03      	subs	r3, r0, #0
10003382:	d029      	beq.n	100033d8 <xQueueGenericSendFromISR+0x114>
                            {
                                /* The queue is a member of a queue set, and posting
                                 * to the queue set caused a higher priority task to
                                 * unblock.  A context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
10003384:	687b      	ldr	r3, [r7, #4]
10003386:	2b00      	cmp	r3, #0
10003388:	d026      	beq.n	100033d8 <xQueueGenericSendFromISR+0x114>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
1000338a:	687b      	ldr	r3, [r7, #4]
1000338c:	2201      	movs	r2, #1
1000338e:	601a      	str	r2, [r3, #0]
10003390:	e022      	b.n	100033d8 <xQueueGenericSendFromISR+0x114>
                                mtCOVERAGE_TEST_MARKER();
                            }
                        }
                        else
                        {
                            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
10003392:	6a3b      	ldr	r3, [r7, #32]
10003394:	6a5b      	ldr	r3, [r3, #36]	; 0x24
10003396:	2b00      	cmp	r3, #0
10003398:	d01e      	beq.n	100033d8 <xQueueGenericSendFromISR+0x114>
                            {
                                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1000339a:	6a3b      	ldr	r3, [r7, #32]
1000339c:	3324      	adds	r3, #36	; 0x24
1000339e:	1c18      	adds	r0, r3, #0
100033a0:	f000 fe5e 	bl	10004060 <xTaskRemoveFromEventList>
100033a4:	1e03      	subs	r3, r0, #0
100033a6:	d017      	beq.n	100033d8 <xQueueGenericSendFromISR+0x114>
                                {
                                    /* The task waiting has a higher priority so
                                     *  record that a context switch is required. */
                                    if( pxHigherPriorityTaskWoken != NULL )
100033a8:	687b      	ldr	r3, [r7, #4]
100033aa:	2b00      	cmp	r3, #0
100033ac:	d014      	beq.n	100033d8 <xQueueGenericSendFromISR+0x114>
                                    {
                                        *pxHigherPriorityTaskWoken = pdTRUE;
100033ae:	687b      	ldr	r3, [r7, #4]
100033b0:	2201      	movs	r2, #1
100033b2:	601a      	str	r2, [r3, #0]
100033b4:	e010      	b.n	100033d8 <xQueueGenericSendFromISR+0x114>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );
100033b6:	231b      	movs	r3, #27
100033b8:	18fb      	adds	r3, r7, r3
100033ba:	781b      	ldrb	r3, [r3, #0]
100033bc:	b25b      	sxtb	r3, r3
100033be:	2b7f      	cmp	r3, #127	; 0x7f
100033c0:	d101      	bne.n	100033c6 <xQueueGenericSendFromISR+0x102>
100033c2:	b672      	cpsid	i
100033c4:	e7fe      	b.n	100033c4 <xQueueGenericSendFromISR+0x100>

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
100033c6:	231b      	movs	r3, #27
100033c8:	18fb      	adds	r3, r7, r3
100033ca:	781b      	ldrb	r3, [r3, #0]
100033cc:	3301      	adds	r3, #1
100033ce:	b2db      	uxtb	r3, r3
100033d0:	b2d9      	uxtb	r1, r3
100033d2:	6a3b      	ldr	r3, [r7, #32]
100033d4:	2245      	movs	r2, #69	; 0x45
100033d6:	5499      	strb	r1, [r3, r2]
            }

            xReturn = pdPASS;
100033d8:	2301      	movs	r3, #1
100033da:	627b      	str	r3, [r7, #36]	; 0x24
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
        {
100033dc:	e001      	b.n	100033e2 <xQueueGenericSendFromISR+0x11e>
            xReturn = pdPASS;
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
100033de:	2300      	movs	r3, #0
100033e0:	627b      	str	r3, [r7, #36]	; 0x24
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
100033e2:	69fb      	ldr	r3, [r7, #28]
100033e4:	1c18      	adds	r0, r3, #0
100033e6:	f7ff fc89 	bl	10002cfc <vClearInterruptMaskFromISR>

    return xReturn;
100033ea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
100033ec:	1c18      	adds	r0, r3, #0
100033ee:	46bd      	mov	sp, r7
100033f0:	b00a      	add	sp, #40	; 0x28
100033f2:	bd80      	pop	{r7, pc}

100033f4 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
100033f4:	b580      	push	{r7, lr}
100033f6:	b08a      	sub	sp, #40	; 0x28
100033f8:	af00      	add	r7, sp, #0
100033fa:	60f8      	str	r0, [r7, #12]
100033fc:	60b9      	str	r1, [r7, #8]
100033fe:	607a      	str	r2, [r7, #4]
    BaseType_t xEntryTimeSet = pdFALSE;
10003400:	2300      	movs	r3, #0
10003402:	627b      	str	r3, [r7, #36]	; 0x24
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
10003404:	68fb      	ldr	r3, [r7, #12]
10003406:	623b      	str	r3, [r7, #32]

    /* Check the pointer is not NULL. */
    configASSERT( ( pxQueue ) );
10003408:	6a3b      	ldr	r3, [r7, #32]
1000340a:	2b00      	cmp	r3, #0
1000340c:	d101      	bne.n	10003412 <xQueueReceive+0x1e>
1000340e:	b672      	cpsid	i
10003410:	e7fe      	b.n	10003410 <xQueueReceive+0x1c>

    /* The buffer into which data is received can only be NULL if the data size
     * is zero (so no data is copied into the buffer). */
    configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
10003412:	68bb      	ldr	r3, [r7, #8]
10003414:	2b00      	cmp	r3, #0
10003416:	d103      	bne.n	10003420 <xQueueReceive+0x2c>
10003418:	6a3b      	ldr	r3, [r7, #32]
1000341a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
1000341c:	2b00      	cmp	r3, #0
1000341e:	d101      	bne.n	10003424 <xQueueReceive+0x30>
10003420:	2301      	movs	r3, #1
10003422:	e000      	b.n	10003426 <xQueueReceive+0x32>
10003424:	2300      	movs	r3, #0
10003426:	2b00      	cmp	r3, #0
10003428:	d101      	bne.n	1000342e <xQueueReceive+0x3a>
1000342a:	b672      	cpsid	i
1000342c:	e7fe      	b.n	1000342c <xQueueReceive+0x38>

    /* Cannot block if the scheduler is suspended. */
    #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
1000342e:	f000 ff9d 	bl	1000436c <xTaskGetSchedulerState>
10003432:	1e03      	subs	r3, r0, #0
10003434:	d102      	bne.n	1000343c <xQueueReceive+0x48>
10003436:	687b      	ldr	r3, [r7, #4]
10003438:	2b00      	cmp	r3, #0
1000343a:	d101      	bne.n	10003440 <xQueueReceive+0x4c>
1000343c:	2301      	movs	r3, #1
1000343e:	e000      	b.n	10003442 <xQueueReceive+0x4e>
10003440:	2300      	movs	r3, #0
10003442:	2b00      	cmp	r3, #0
10003444:	d101      	bne.n	1000344a <xQueueReceive+0x56>
10003446:	b672      	cpsid	i
10003448:	e7fe      	b.n	10003448 <xQueueReceive+0x54>
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
1000344a:	f7ff fc2b 	bl	10002ca4 <vPortEnterCritical>
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
1000344e:	6a3b      	ldr	r3, [r7, #32]
10003450:	6b9b      	ldr	r3, [r3, #56]	; 0x38
10003452:	61fb      	str	r3, [r7, #28]

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
10003454:	69fb      	ldr	r3, [r7, #28]
10003456:	2b00      	cmp	r3, #0
10003458:	d01a      	beq.n	10003490 <xQueueReceive+0x9c>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
1000345a:	6a3a      	ldr	r2, [r7, #32]
1000345c:	68bb      	ldr	r3, [r7, #8]
1000345e:	1c10      	adds	r0, r2, #0
10003460:	1c19      	adds	r1, r3, #0
10003462:	f000 f8f1 	bl	10003648 <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
10003466:	69fb      	ldr	r3, [r7, #28]
10003468:	1e5a      	subs	r2, r3, #1
1000346a:	6a3b      	ldr	r3, [r7, #32]
1000346c:	639a      	str	r2, [r3, #56]	; 0x38

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1000346e:	6a3b      	ldr	r3, [r7, #32]
10003470:	691b      	ldr	r3, [r3, #16]
10003472:	2b00      	cmp	r3, #0
10003474:	d008      	beq.n	10003488 <xQueueReceive+0x94>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
10003476:	6a3b      	ldr	r3, [r7, #32]
10003478:	3310      	adds	r3, #16
1000347a:	1c18      	adds	r0, r3, #0
1000347c:	f000 fdf0 	bl	10004060 <xTaskRemoveFromEventList>
10003480:	1e03      	subs	r3, r0, #0
10003482:	d001      	beq.n	10003488 <xQueueReceive+0x94>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
10003484:	f7ff fc00 	bl	10002c88 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
10003488:	f7ff fc1c 	bl	10002cc4 <vPortExitCritical>
                return pdPASS;
1000348c:	2301      	movs	r3, #1
1000348e:	e066      	b.n	1000355e <xQueueReceive+0x16a>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
10003490:	687b      	ldr	r3, [r7, #4]
10003492:	2b00      	cmp	r3, #0
10003494:	d103      	bne.n	1000349e <xQueueReceive+0xaa>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
10003496:	f7ff fc15 	bl	10002cc4 <vPortExitCritical>
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
1000349a:	2300      	movs	r3, #0
1000349c:	e05f      	b.n	1000355e <xQueueReceive+0x16a>
                }
                else if( xEntryTimeSet == pdFALSE )
1000349e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
100034a0:	2b00      	cmp	r3, #0
100034a2:	d106      	bne.n	100034b2 <xQueueReceive+0xbe>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
100034a4:	2314      	movs	r3, #20
100034a6:	18fb      	adds	r3, r7, r3
100034a8:	1c18      	adds	r0, r3, #0
100034aa:	f000 fe35 	bl	10004118 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
100034ae:	2301      	movs	r3, #1
100034b0:	627b      	str	r3, [r7, #36]	; 0x24
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
100034b2:	f7ff fc07 	bl	10002cc4 <vPortExitCritical>

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
100034b6:	f000 fbed 	bl	10003c94 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
100034ba:	f7ff fbf3 	bl	10002ca4 <vPortEnterCritical>
100034be:	6a3b      	ldr	r3, [r7, #32]
100034c0:	2244      	movs	r2, #68	; 0x44
100034c2:	5c9b      	ldrb	r3, [r3, r2]
100034c4:	b2db      	uxtb	r3, r3
100034c6:	b25b      	sxtb	r3, r3
100034c8:	3301      	adds	r3, #1
100034ca:	d103      	bne.n	100034d4 <xQueueReceive+0xe0>
100034cc:	6a3b      	ldr	r3, [r7, #32]
100034ce:	2244      	movs	r2, #68	; 0x44
100034d0:	2100      	movs	r1, #0
100034d2:	5499      	strb	r1, [r3, r2]
100034d4:	6a3b      	ldr	r3, [r7, #32]
100034d6:	2245      	movs	r2, #69	; 0x45
100034d8:	5c9b      	ldrb	r3, [r3, r2]
100034da:	b2db      	uxtb	r3, r3
100034dc:	b25b      	sxtb	r3, r3
100034de:	3301      	adds	r3, #1
100034e0:	d103      	bne.n	100034ea <xQueueReceive+0xf6>
100034e2:	6a3b      	ldr	r3, [r7, #32]
100034e4:	2245      	movs	r2, #69	; 0x45
100034e6:	2100      	movs	r1, #0
100034e8:	5499      	strb	r1, [r3, r2]
100034ea:	f7ff fbeb 	bl	10002cc4 <vPortExitCritical>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
100034ee:	2314      	movs	r3, #20
100034f0:	18fa      	adds	r2, r7, r3
100034f2:	1d3b      	adds	r3, r7, #4
100034f4:	1c10      	adds	r0, r2, #0
100034f6:	1c19      	adds	r1, r3, #0
100034f8:	f000 fe22 	bl	10004140 <xTaskCheckForTimeOut>
100034fc:	1e03      	subs	r3, r0, #0
100034fe:	d11f      	bne.n	10003540 <xQueueReceive+0x14c>
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
10003500:	6a3b      	ldr	r3, [r7, #32]
10003502:	1c18      	adds	r0, r3, #0
10003504:	f000 f934 	bl	10003770 <prvIsQueueEmpty>
10003508:	1e03      	subs	r3, r0, #0
1000350a:	d012      	beq.n	10003532 <xQueueReceive+0x13e>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1000350c:	6a3b      	ldr	r3, [r7, #32]
1000350e:	3324      	adds	r3, #36	; 0x24
10003510:	1c1a      	adds	r2, r3, #0
10003512:	687b      	ldr	r3, [r7, #4]
10003514:	1c10      	adds	r0, r2, #0
10003516:	1c19      	adds	r1, r3, #0
10003518:	f000 fd62 	bl	10003fe0 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
1000351c:	6a3b      	ldr	r3, [r7, #32]
1000351e:	1c18      	adds	r0, r3, #0
10003520:	f000 f8ba 	bl	10003698 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
10003524:	f000 fbc2 	bl	10003cac <xTaskResumeAll>
10003528:	1e03      	subs	r3, r0, #0
1000352a:	d117      	bne.n	1000355c <xQueueReceive+0x168>
                {
                    portYIELD_WITHIN_API();
1000352c:	f7ff fbac 	bl	10002c88 <vPortYield>
10003530:	e014      	b.n	1000355c <xQueueReceive+0x168>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
10003532:	6a3b      	ldr	r3, [r7, #32]
10003534:	1c18      	adds	r0, r3, #0
10003536:	f000 f8af 	bl	10003698 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
1000353a:	f000 fbb7 	bl	10003cac <xTaskResumeAll>
1000353e:	e784      	b.n	1000344a <xQueueReceive+0x56>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
10003540:	6a3b      	ldr	r3, [r7, #32]
10003542:	1c18      	adds	r0, r3, #0
10003544:	f000 f8a8 	bl	10003698 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
10003548:	f000 fbb0 	bl	10003cac <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1000354c:	6a3b      	ldr	r3, [r7, #32]
1000354e:	1c18      	adds	r0, r3, #0
10003550:	f000 f90e 	bl	10003770 <prvIsQueueEmpty>
10003554:	1e03      	subs	r3, r0, #0
10003556:	d001      	beq.n	1000355c <xQueueReceive+0x168>
            {
                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
10003558:	2300      	movs	r3, #0
1000355a:	e000      	b.n	1000355e <xQueueReceive+0x16a>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
1000355c:	e775      	b.n	1000344a <xQueueReceive+0x56>
}
1000355e:	1c18      	adds	r0, r3, #0
10003560:	46bd      	mov	sp, r7
10003562:	b00a      	add	sp, #40	; 0x28
10003564:	bd80      	pop	{r7, pc}
10003566:	46c0      	nop			; (mov r8, r8)

10003568 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
10003568:	b580      	push	{r7, lr}
1000356a:	b086      	sub	sp, #24
1000356c:	af00      	add	r7, sp, #0
1000356e:	60f8      	str	r0, [r7, #12]
10003570:	60b9      	str	r1, [r7, #8]
10003572:	607a      	str	r2, [r7, #4]
    BaseType_t xReturn = pdFALSE;
10003574:	2300      	movs	r3, #0
10003576:	617b      	str	r3, [r7, #20]
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
10003578:	68fb      	ldr	r3, [r7, #12]
1000357a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
1000357c:	613b      	str	r3, [r7, #16]

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
1000357e:	68fb      	ldr	r3, [r7, #12]
10003580:	6c1b      	ldr	r3, [r3, #64]	; 0x40
10003582:	2b00      	cmp	r3, #0
10003584:	d10e      	bne.n	100035a4 <prvCopyDataToQueue+0x3c>
    {
        #if ( configUSE_MUTEXES == 1 )
            {
                if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
10003586:	68fb      	ldr	r3, [r7, #12]
10003588:	681b      	ldr	r3, [r3, #0]
1000358a:	2b00      	cmp	r3, #0
1000358c:	d152      	bne.n	10003634 <prvCopyDataToQueue+0xcc>
                {
                    /* The mutex is no longer being held. */
                    xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
1000358e:	68fb      	ldr	r3, [r7, #12]
10003590:	689b      	ldr	r3, [r3, #8]
10003592:	1c18      	adds	r0, r3, #0
10003594:	f000 ff06 	bl	100043a4 <xTaskPriorityDisinherit>
10003598:	1c03      	adds	r3, r0, #0
1000359a:	617b      	str	r3, [r7, #20]
                    pxQueue->u.xSemaphore.xMutexHolder = NULL;
1000359c:	68fb      	ldr	r3, [r7, #12]
1000359e:	2200      	movs	r2, #0
100035a0:	609a      	str	r2, [r3, #8]
100035a2:	e047      	b.n	10003634 <prvCopyDataToQueue+0xcc>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
100035a4:	687b      	ldr	r3, [r7, #4]
100035a6:	2b00      	cmp	r3, #0
100035a8:	d11b      	bne.n	100035e2 <prvCopyDataToQueue+0x7a>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
100035aa:	68fb      	ldr	r3, [r7, #12]
100035ac:	6859      	ldr	r1, [r3, #4]
100035ae:	68fb      	ldr	r3, [r7, #12]
100035b0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
100035b2:	68ba      	ldr	r2, [r7, #8]
100035b4:	1c08      	adds	r0, r1, #0
100035b6:	1c11      	adds	r1, r2, #0
100035b8:	1c1a      	adds	r2, r3, #0
100035ba:	f001 ffe7 	bl	1000558c <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
100035be:	68fb      	ldr	r3, [r7, #12]
100035c0:	685a      	ldr	r2, [r3, #4]
100035c2:	68fb      	ldr	r3, [r7, #12]
100035c4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
100035c6:	18d2      	adds	r2, r2, r3
100035c8:	68fb      	ldr	r3, [r7, #12]
100035ca:	605a      	str	r2, [r3, #4]

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
100035cc:	68fb      	ldr	r3, [r7, #12]
100035ce:	685a      	ldr	r2, [r3, #4]
100035d0:	68fb      	ldr	r3, [r7, #12]
100035d2:	689b      	ldr	r3, [r3, #8]
100035d4:	429a      	cmp	r2, r3
100035d6:	d32d      	bcc.n	10003634 <prvCopyDataToQueue+0xcc>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
100035d8:	68fb      	ldr	r3, [r7, #12]
100035da:	681a      	ldr	r2, [r3, #0]
100035dc:	68fb      	ldr	r3, [r7, #12]
100035de:	605a      	str	r2, [r3, #4]
100035e0:	e028      	b.n	10003634 <prvCopyDataToQueue+0xcc>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
100035e2:	68fb      	ldr	r3, [r7, #12]
100035e4:	68d9      	ldr	r1, [r3, #12]
100035e6:	68fb      	ldr	r3, [r7, #12]
100035e8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
100035ea:	68ba      	ldr	r2, [r7, #8]
100035ec:	1c08      	adds	r0, r1, #0
100035ee:	1c11      	adds	r1, r2, #0
100035f0:	1c1a      	adds	r2, r3, #0
100035f2:	f001 ffcb 	bl	1000558c <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
100035f6:	68fb      	ldr	r3, [r7, #12]
100035f8:	68da      	ldr	r2, [r3, #12]
100035fa:	68fb      	ldr	r3, [r7, #12]
100035fc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
100035fe:	425b      	negs	r3, r3
10003600:	18d2      	adds	r2, r2, r3
10003602:	68fb      	ldr	r3, [r7, #12]
10003604:	60da      	str	r2, [r3, #12]

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
10003606:	68fb      	ldr	r3, [r7, #12]
10003608:	68da      	ldr	r2, [r3, #12]
1000360a:	68fb      	ldr	r3, [r7, #12]
1000360c:	681b      	ldr	r3, [r3, #0]
1000360e:	429a      	cmp	r2, r3
10003610:	d207      	bcs.n	10003622 <prvCopyDataToQueue+0xba>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
10003612:	68fb      	ldr	r3, [r7, #12]
10003614:	689a      	ldr	r2, [r3, #8]
10003616:	68fb      	ldr	r3, [r7, #12]
10003618:	6c1b      	ldr	r3, [r3, #64]	; 0x40
1000361a:	425b      	negs	r3, r3
1000361c:	18d2      	adds	r2, r2, r3
1000361e:	68fb      	ldr	r3, [r7, #12]
10003620:	60da      	str	r2, [r3, #12]
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
10003622:	687b      	ldr	r3, [r7, #4]
10003624:	2b02      	cmp	r3, #2
10003626:	d105      	bne.n	10003634 <prvCopyDataToQueue+0xcc>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
10003628:	693b      	ldr	r3, [r7, #16]
1000362a:	2b00      	cmp	r3, #0
1000362c:	d002      	beq.n	10003634 <prvCopyDataToQueue+0xcc>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
1000362e:	693b      	ldr	r3, [r7, #16]
10003630:	3b01      	subs	r3, #1
10003632:	613b      	str	r3, [r7, #16]
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
10003634:	693b      	ldr	r3, [r7, #16]
10003636:	1c5a      	adds	r2, r3, #1
10003638:	68fb      	ldr	r3, [r7, #12]
1000363a:	639a      	str	r2, [r3, #56]	; 0x38

    return xReturn;
1000363c:	697b      	ldr	r3, [r7, #20]
}
1000363e:	1c18      	adds	r0, r3, #0
10003640:	46bd      	mov	sp, r7
10003642:	b006      	add	sp, #24
10003644:	bd80      	pop	{r7, pc}
10003646:	46c0      	nop			; (mov r8, r8)

10003648 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
10003648:	b580      	push	{r7, lr}
1000364a:	b082      	sub	sp, #8
1000364c:	af00      	add	r7, sp, #0
1000364e:	6078      	str	r0, [r7, #4]
10003650:	6039      	str	r1, [r7, #0]
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
10003652:	687b      	ldr	r3, [r7, #4]
10003654:	6c1b      	ldr	r3, [r3, #64]	; 0x40
10003656:	2b00      	cmp	r3, #0
10003658:	d01a      	beq.n	10003690 <prvCopyDataFromQueue+0x48>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
1000365a:	687b      	ldr	r3, [r7, #4]
1000365c:	68da      	ldr	r2, [r3, #12]
1000365e:	687b      	ldr	r3, [r7, #4]
10003660:	6c1b      	ldr	r3, [r3, #64]	; 0x40
10003662:	18d2      	adds	r2, r2, r3
10003664:	687b      	ldr	r3, [r7, #4]
10003666:	60da      	str	r2, [r3, #12]

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
10003668:	687b      	ldr	r3, [r7, #4]
1000366a:	68da      	ldr	r2, [r3, #12]
1000366c:	687b      	ldr	r3, [r7, #4]
1000366e:	689b      	ldr	r3, [r3, #8]
10003670:	429a      	cmp	r2, r3
10003672:	d303      	bcc.n	1000367c <prvCopyDataFromQueue+0x34>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
10003674:	687b      	ldr	r3, [r7, #4]
10003676:	681a      	ldr	r2, [r3, #0]
10003678:	687b      	ldr	r3, [r7, #4]
1000367a:	60da      	str	r2, [r3, #12]
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
1000367c:	687b      	ldr	r3, [r7, #4]
1000367e:	68da      	ldr	r2, [r3, #12]
10003680:	687b      	ldr	r3, [r7, #4]
10003682:	6c1b      	ldr	r3, [r3, #64]	; 0x40
10003684:	6839      	ldr	r1, [r7, #0]
10003686:	1c08      	adds	r0, r1, #0
10003688:	1c11      	adds	r1, r2, #0
1000368a:	1c1a      	adds	r2, r3, #0
1000368c:	f001 ff7e 	bl	1000558c <memcpy>
    }
}
10003690:	46bd      	mov	sp, r7
10003692:	b002      	add	sp, #8
10003694:	bd80      	pop	{r7, pc}
10003696:	46c0      	nop			; (mov r8, r8)

10003698 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
10003698:	b580      	push	{r7, lr}
1000369a:	b084      	sub	sp, #16
1000369c:	af00      	add	r7, sp, #0
1000369e:	6078      	str	r0, [r7, #4]

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
100036a0:	f7ff fb00 	bl	10002ca4 <vPortEnterCritical>
    {
        int8_t cTxLock = pxQueue->cTxLock;
100036a4:	230f      	movs	r3, #15
100036a6:	18fb      	adds	r3, r7, r3
100036a8:	687a      	ldr	r2, [r7, #4]
100036aa:	2145      	movs	r1, #69	; 0x45
100036ac:	5c52      	ldrb	r2, [r2, r1]
100036ae:	701a      	strb	r2, [r3, #0]

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
100036b0:	e023      	b.n	100036fa <prvUnlockQueue+0x62>
        {
            /* Data was posted while the queue was locked.  Are any tasks
             * blocked waiting for data to become available? */
            #if ( configUSE_QUEUE_SETS == 1 )
                {
                    if( pxQueue->pxQueueSetContainer != NULL )
100036b2:	687b      	ldr	r3, [r7, #4]
100036b4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
100036b6:	2b00      	cmp	r3, #0
100036b8:	d008      	beq.n	100036cc <prvUnlockQueue+0x34>
                    {
                        if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
100036ba:	687b      	ldr	r3, [r7, #4]
100036bc:	1c18      	adds	r0, r3, #0
100036be:	f000 f8e3 	bl	10003888 <prvNotifyQueueSetContainer>
100036c2:	1e03      	subs	r3, r0, #0
100036c4:	d011      	beq.n	100036ea <prvUnlockQueue+0x52>
                        {
                            /* The queue is a member of a queue set, and posting to
                             * the queue set caused a higher priority task to unblock.
                             * A context switch is required. */
                            vTaskMissedYield();
100036c6:	f000 fd9f 	bl	10004208 <vTaskMissedYield>
100036ca:	e00e      	b.n	100036ea <prvUnlockQueue+0x52>
                    else
                    {
                        /* Tasks that are removed from the event list will get
                         * added to the pending ready list as the scheduler is still
                         * suspended. */
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
100036cc:	687b      	ldr	r3, [r7, #4]
100036ce:	6a5b      	ldr	r3, [r3, #36]	; 0x24
100036d0:	2b00      	cmp	r3, #0
100036d2:	d009      	beq.n	100036e8 <prvUnlockQueue+0x50>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
100036d4:	687b      	ldr	r3, [r7, #4]
100036d6:	3324      	adds	r3, #36	; 0x24
100036d8:	1c18      	adds	r0, r3, #0
100036da:	f000 fcc1 	bl	10004060 <xTaskRemoveFromEventList>
100036de:	1e03      	subs	r3, r0, #0
100036e0:	d003      	beq.n	100036ea <prvUnlockQueue+0x52>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                vTaskMissedYield();
100036e2:	f000 fd91 	bl	10004208 <vTaskMissedYield>
100036e6:	e000      	b.n	100036ea <prvUnlockQueue+0x52>
                                mtCOVERAGE_TEST_MARKER();
                            }
                        }
                        else
                        {
                            break;
100036e8:	e00d      	b.n	10003706 <prvUnlockQueue+0x6e>
                        break;
                    }
                }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
100036ea:	230f      	movs	r3, #15
100036ec:	18fb      	adds	r3, r7, r3
100036ee:	781b      	ldrb	r3, [r3, #0]
100036f0:	3b01      	subs	r3, #1
100036f2:	b2da      	uxtb	r2, r3
100036f4:	230f      	movs	r3, #15
100036f6:	18fb      	adds	r3, r7, r3
100036f8:	701a      	strb	r2, [r3, #0]
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
100036fa:	230f      	movs	r3, #15
100036fc:	18fb      	adds	r3, r7, r3
100036fe:	781b      	ldrb	r3, [r3, #0]
10003700:	b25b      	sxtb	r3, r3
10003702:	2b00      	cmp	r3, #0
10003704:	dcd5      	bgt.n	100036b2 <prvUnlockQueue+0x1a>
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
10003706:	687b      	ldr	r3, [r7, #4]
10003708:	2245      	movs	r2, #69	; 0x45
1000370a:	21ff      	movs	r1, #255	; 0xff
1000370c:	5499      	strb	r1, [r3, r2]
    }
    taskEXIT_CRITICAL();
1000370e:	f7ff fad9 	bl	10002cc4 <vPortExitCritical>

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
10003712:	f7ff fac7 	bl	10002ca4 <vPortEnterCritical>
    {
        int8_t cRxLock = pxQueue->cRxLock;
10003716:	230e      	movs	r3, #14
10003718:	18fb      	adds	r3, r7, r3
1000371a:	687a      	ldr	r2, [r7, #4]
1000371c:	2144      	movs	r1, #68	; 0x44
1000371e:	5c52      	ldrb	r2, [r2, r1]
10003720:	701a      	strb	r2, [r3, #0]

        while( cRxLock > queueLOCKED_UNMODIFIED )
10003722:	e016      	b.n	10003752 <prvUnlockQueue+0xba>
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
10003724:	687b      	ldr	r3, [r7, #4]
10003726:	691b      	ldr	r3, [r3, #16]
10003728:	2b00      	cmp	r3, #0
1000372a:	d011      	beq.n	10003750 <prvUnlockQueue+0xb8>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1000372c:	687b      	ldr	r3, [r7, #4]
1000372e:	3310      	adds	r3, #16
10003730:	1c18      	adds	r0, r3, #0
10003732:	f000 fc95 	bl	10004060 <xTaskRemoveFromEventList>
10003736:	1e03      	subs	r3, r0, #0
10003738:	d001      	beq.n	1000373e <prvUnlockQueue+0xa6>
                {
                    vTaskMissedYield();
1000373a:	f000 fd65 	bl	10004208 <vTaskMissedYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
1000373e:	230e      	movs	r3, #14
10003740:	18fb      	adds	r3, r7, r3
10003742:	781b      	ldrb	r3, [r3, #0]
10003744:	3b01      	subs	r3, #1
10003746:	b2da      	uxtb	r2, r3
10003748:	230e      	movs	r3, #14
1000374a:	18fb      	adds	r3, r7, r3
1000374c:	701a      	strb	r2, [r3, #0]
1000374e:	e000      	b.n	10003752 <prvUnlockQueue+0xba>
            }
            else
            {
                break;
10003750:	e005      	b.n	1000375e <prvUnlockQueue+0xc6>
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
10003752:	230e      	movs	r3, #14
10003754:	18fb      	adds	r3, r7, r3
10003756:	781b      	ldrb	r3, [r3, #0]
10003758:	b25b      	sxtb	r3, r3
1000375a:	2b00      	cmp	r3, #0
1000375c:	dce2      	bgt.n	10003724 <prvUnlockQueue+0x8c>
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
1000375e:	687b      	ldr	r3, [r7, #4]
10003760:	2244      	movs	r2, #68	; 0x44
10003762:	21ff      	movs	r1, #255	; 0xff
10003764:	5499      	strb	r1, [r3, r2]
    }
    taskEXIT_CRITICAL();
10003766:	f7ff faad 	bl	10002cc4 <vPortExitCritical>
}
1000376a:	46bd      	mov	sp, r7
1000376c:	b004      	add	sp, #16
1000376e:	bd80      	pop	{r7, pc}

10003770 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
10003770:	b580      	push	{r7, lr}
10003772:	b084      	sub	sp, #16
10003774:	af00      	add	r7, sp, #0
10003776:	6078      	str	r0, [r7, #4]
    BaseType_t xReturn;

    taskENTER_CRITICAL();
10003778:	f7ff fa94 	bl	10002ca4 <vPortEnterCritical>
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
1000377c:	687b      	ldr	r3, [r7, #4]
1000377e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
10003780:	2b00      	cmp	r3, #0
10003782:	d102      	bne.n	1000378a <prvIsQueueEmpty+0x1a>
        {
            xReturn = pdTRUE;
10003784:	2301      	movs	r3, #1
10003786:	60fb      	str	r3, [r7, #12]
10003788:	e001      	b.n	1000378e <prvIsQueueEmpty+0x1e>
        }
        else
        {
            xReturn = pdFALSE;
1000378a:	2300      	movs	r3, #0
1000378c:	60fb      	str	r3, [r7, #12]
        }
    }
    taskEXIT_CRITICAL();
1000378e:	f7ff fa99 	bl	10002cc4 <vPortExitCritical>

    return xReturn;
10003792:	68fb      	ldr	r3, [r7, #12]
}
10003794:	1c18      	adds	r0, r3, #0
10003796:	46bd      	mov	sp, r7
10003798:	b004      	add	sp, #16
1000379a:	bd80      	pop	{r7, pc}

1000379c <prvIsQueueFull>:
    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
1000379c:	b580      	push	{r7, lr}
1000379e:	b084      	sub	sp, #16
100037a0:	af00      	add	r7, sp, #0
100037a2:	6078      	str	r0, [r7, #4]
    BaseType_t xReturn;

    taskENTER_CRITICAL();
100037a4:	f7ff fa7e 	bl	10002ca4 <vPortEnterCritical>
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
100037a8:	687b      	ldr	r3, [r7, #4]
100037aa:	6b9a      	ldr	r2, [r3, #56]	; 0x38
100037ac:	687b      	ldr	r3, [r7, #4]
100037ae:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
100037b0:	429a      	cmp	r2, r3
100037b2:	d102      	bne.n	100037ba <prvIsQueueFull+0x1e>
        {
            xReturn = pdTRUE;
100037b4:	2301      	movs	r3, #1
100037b6:	60fb      	str	r3, [r7, #12]
100037b8:	e001      	b.n	100037be <prvIsQueueFull+0x22>
        }
        else
        {
            xReturn = pdFALSE;
100037ba:	2300      	movs	r3, #0
100037bc:	60fb      	str	r3, [r7, #12]
        }
    }
    taskEXIT_CRITICAL();
100037be:	f7ff fa81 	bl	10002cc4 <vPortExitCritical>

    return xReturn;
100037c2:	68fb      	ldr	r3, [r7, #12]
}
100037c4:	1c18      	adds	r0, r3, #0
100037c6:	46bd      	mov	sp, r7
100037c8:	b004      	add	sp, #16
100037ca:	bd80      	pop	{r7, pc}

100037cc <vQueueAddToRegistry>:

#if ( configQUEUE_REGISTRY_SIZE > 0 )

    void vQueueAddToRegistry( QueueHandle_t xQueue,
                              const char * pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    {
100037cc:	b580      	push	{r7, lr}
100037ce:	b084      	sub	sp, #16
100037d0:	af00      	add	r7, sp, #0
100037d2:	6078      	str	r0, [r7, #4]
100037d4:	6039      	str	r1, [r7, #0]
        UBaseType_t ux;

        /* See if there is an empty space in the registry.  A NULL name denotes
         * a free slot. */
        for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
100037d6:	2300      	movs	r3, #0
100037d8:	60fb      	str	r3, [r7, #12]
100037da:	e014      	b.n	10003806 <vQueueAddToRegistry+0x3a>
        {
            if( xQueueRegistry[ ux ].pcQueueName == NULL )
100037dc:	4b0d      	ldr	r3, [pc, #52]	; (10003814 <vQueueAddToRegistry+0x48>)
100037de:	68fa      	ldr	r2, [r7, #12]
100037e0:	00d2      	lsls	r2, r2, #3
100037e2:	58d3      	ldr	r3, [r2, r3]
100037e4:	2b00      	cmp	r3, #0
100037e6:	d10b      	bne.n	10003800 <vQueueAddToRegistry+0x34>
            {
                /* Store the information on this queue. */
                xQueueRegistry[ ux ].pcQueueName = pcQueueName;
100037e8:	4b0a      	ldr	r3, [pc, #40]	; (10003814 <vQueueAddToRegistry+0x48>)
100037ea:	68fa      	ldr	r2, [r7, #12]
100037ec:	00d2      	lsls	r2, r2, #3
100037ee:	6839      	ldr	r1, [r7, #0]
100037f0:	50d1      	str	r1, [r2, r3]
                xQueueRegistry[ ux ].xHandle = xQueue;
100037f2:	4a08      	ldr	r2, [pc, #32]	; (10003814 <vQueueAddToRegistry+0x48>)
100037f4:	68fb      	ldr	r3, [r7, #12]
100037f6:	00db      	lsls	r3, r3, #3
100037f8:	18d3      	adds	r3, r2, r3
100037fa:	687a      	ldr	r2, [r7, #4]
100037fc:	605a      	str	r2, [r3, #4]

                traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
                break;
100037fe:	e005      	b.n	1000380c <vQueueAddToRegistry+0x40>
    {
        UBaseType_t ux;

        /* See if there is an empty space in the registry.  A NULL name denotes
         * a free slot. */
        for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
10003800:	68fb      	ldr	r3, [r7, #12]
10003802:	3301      	adds	r3, #1
10003804:	60fb      	str	r3, [r7, #12]
10003806:	68fb      	ldr	r3, [r7, #12]
10003808:	2b07      	cmp	r3, #7
1000380a:	d9e7      	bls.n	100037dc <vQueueAddToRegistry+0x10>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
1000380c:	46bd      	mov	sp, r7
1000380e:	b004      	add	sp, #16
10003810:	bd80      	pop	{r7, pc}
10003812:	46c0      	nop			; (mov r8, r8)
10003814:	200008d4 	.word	0x200008d4

10003818 <vQueueWaitForMessageRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
10003818:	b580      	push	{r7, lr}
1000381a:	b086      	sub	sp, #24
1000381c:	af00      	add	r7, sp, #0
1000381e:	60f8      	str	r0, [r7, #12]
10003820:	60b9      	str	r1, [r7, #8]
10003822:	607a      	str	r2, [r7, #4]
        Queue_t * const pxQueue = xQueue;
10003824:	68fb      	ldr	r3, [r7, #12]
10003826:	617b      	str	r3, [r7, #20]
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
10003828:	f7ff fa3c 	bl	10002ca4 <vPortEnterCritical>
1000382c:	697b      	ldr	r3, [r7, #20]
1000382e:	2244      	movs	r2, #68	; 0x44
10003830:	5c9b      	ldrb	r3, [r3, r2]
10003832:	b2db      	uxtb	r3, r3
10003834:	b25b      	sxtb	r3, r3
10003836:	3301      	adds	r3, #1
10003838:	d103      	bne.n	10003842 <vQueueWaitForMessageRestricted+0x2a>
1000383a:	697b      	ldr	r3, [r7, #20]
1000383c:	2244      	movs	r2, #68	; 0x44
1000383e:	2100      	movs	r1, #0
10003840:	5499      	strb	r1, [r3, r2]
10003842:	697b      	ldr	r3, [r7, #20]
10003844:	2245      	movs	r2, #69	; 0x45
10003846:	5c9b      	ldrb	r3, [r3, r2]
10003848:	b2db      	uxtb	r3, r3
1000384a:	b25b      	sxtb	r3, r3
1000384c:	3301      	adds	r3, #1
1000384e:	d103      	bne.n	10003858 <vQueueWaitForMessageRestricted+0x40>
10003850:	697b      	ldr	r3, [r7, #20]
10003852:	2245      	movs	r2, #69	; 0x45
10003854:	2100      	movs	r1, #0
10003856:	5499      	strb	r1, [r3, r2]
10003858:	f7ff fa34 	bl	10002cc4 <vPortExitCritical>

        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
1000385c:	697b      	ldr	r3, [r7, #20]
1000385e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
10003860:	2b00      	cmp	r3, #0
10003862:	d109      	bne.n	10003878 <vQueueWaitForMessageRestricted+0x60>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
10003864:	697b      	ldr	r3, [r7, #20]
10003866:	3324      	adds	r3, #36	; 0x24
10003868:	1c19      	adds	r1, r3, #0
1000386a:	68ba      	ldr	r2, [r7, #8]
1000386c:	687b      	ldr	r3, [r7, #4]
1000386e:	1c08      	adds	r0, r1, #0
10003870:	1c11      	adds	r1, r2, #0
10003872:	1c1a      	adds	r2, r3, #0
10003874:	f000 fbd0 	bl	10004018 <vTaskPlaceOnEventListRestricted>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
10003878:	697b      	ldr	r3, [r7, #20]
1000387a:	1c18      	adds	r0, r3, #0
1000387c:	f7ff ff0c 	bl	10003698 <prvUnlockQueue>
    }
10003880:	46bd      	mov	sp, r7
10003882:	b006      	add	sp, #24
10003884:	bd80      	pop	{r7, pc}
10003886:	46c0      	nop			; (mov r8, r8)

10003888 <prvNotifyQueueSetContainer>:
/*-----------------------------------------------------------*/

#if ( configUSE_QUEUE_SETS == 1 )

    static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue )
    {
10003888:	b580      	push	{r7, lr}
1000388a:	b086      	sub	sp, #24
1000388c:	af00      	add	r7, sp, #0
1000388e:	6078      	str	r0, [r7, #4]
        Queue_t * pxQueueSetContainer = pxQueue->pxQueueSetContainer;
10003890:	687b      	ldr	r3, [r7, #4]
10003892:	6c9b      	ldr	r3, [r3, #72]	; 0x48
10003894:	613b      	str	r3, [r7, #16]
        BaseType_t xReturn = pdFALSE;
10003896:	2300      	movs	r3, #0
10003898:	617b      	str	r3, [r7, #20]

        /* This function must be called form a critical section. */

        configASSERT( pxQueueSetContainer );
1000389a:	693b      	ldr	r3, [r7, #16]
1000389c:	2b00      	cmp	r3, #0
1000389e:	d101      	bne.n	100038a4 <prvNotifyQueueSetContainer+0x1c>
100038a0:	b672      	cpsid	i
100038a2:	e7fe      	b.n	100038a2 <prvNotifyQueueSetContainer+0x1a>
        configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
100038a4:	693b      	ldr	r3, [r7, #16]
100038a6:	6b9a      	ldr	r2, [r3, #56]	; 0x38
100038a8:	693b      	ldr	r3, [r7, #16]
100038aa:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
100038ac:	429a      	cmp	r2, r3
100038ae:	d301      	bcc.n	100038b4 <prvNotifyQueueSetContainer+0x2c>
100038b0:	b672      	cpsid	i
100038b2:	e7fe      	b.n	100038b2 <prvNotifyQueueSetContainer+0x2a>

        if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
100038b4:	693b      	ldr	r3, [r7, #16]
100038b6:	6b9a      	ldr	r2, [r3, #56]	; 0x38
100038b8:	693b      	ldr	r3, [r7, #16]
100038ba:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
100038bc:	429a      	cmp	r2, r3
100038be:	d234      	bcs.n	1000392a <prvNotifyQueueSetContainer+0xa2>
        {
            const int8_t cTxLock = pxQueueSetContainer->cTxLock;
100038c0:	230f      	movs	r3, #15
100038c2:	18fb      	adds	r3, r7, r3
100038c4:	693a      	ldr	r2, [r7, #16]
100038c6:	2145      	movs	r1, #69	; 0x45
100038c8:	5c52      	ldrb	r2, [r2, r1]
100038ca:	701a      	strb	r2, [r3, #0]

            traceQUEUE_SET_SEND( pxQueueSetContainer );

            /* The data copied is the handle of the queue that contains data. */
            xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, queueSEND_TO_BACK );
100038cc:	693a      	ldr	r2, [r7, #16]
100038ce:	1d3b      	adds	r3, r7, #4
100038d0:	1c10      	adds	r0, r2, #0
100038d2:	1c19      	adds	r1, r3, #0
100038d4:	2200      	movs	r2, #0
100038d6:	f7ff fe47 	bl	10003568 <prvCopyDataToQueue>
100038da:	1c03      	adds	r3, r0, #0
100038dc:	617b      	str	r3, [r7, #20]

            if( cTxLock == queueUNLOCKED )
100038de:	230f      	movs	r3, #15
100038e0:	18fb      	adds	r3, r7, r3
100038e2:	781b      	ldrb	r3, [r3, #0]
100038e4:	b25b      	sxtb	r3, r3
100038e6:	3301      	adds	r3, #1
100038e8:	d10d      	bne.n	10003906 <prvNotifyQueueSetContainer+0x7e>
            {
                if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
100038ea:	693b      	ldr	r3, [r7, #16]
100038ec:	6a5b      	ldr	r3, [r3, #36]	; 0x24
100038ee:	2b00      	cmp	r3, #0
100038f0:	d01b      	beq.n	1000392a <prvNotifyQueueSetContainer+0xa2>
                {
                    if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
100038f2:	693b      	ldr	r3, [r7, #16]
100038f4:	3324      	adds	r3, #36	; 0x24
100038f6:	1c18      	adds	r0, r3, #0
100038f8:	f000 fbb2 	bl	10004060 <xTaskRemoveFromEventList>
100038fc:	1e03      	subs	r3, r0, #0
100038fe:	d014      	beq.n	1000392a <prvNotifyQueueSetContainer+0xa2>
                    {
                        /* The task waiting has a higher priority. */
                        xReturn = pdTRUE;
10003900:	2301      	movs	r3, #1
10003902:	617b      	str	r3, [r7, #20]
10003904:	e011      	b.n	1000392a <prvNotifyQueueSetContainer+0xa2>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                configASSERT( cTxLock != queueINT8_MAX );
10003906:	230f      	movs	r3, #15
10003908:	18fb      	adds	r3, r7, r3
1000390a:	781b      	ldrb	r3, [r3, #0]
1000390c:	b25b      	sxtb	r3, r3
1000390e:	2b7f      	cmp	r3, #127	; 0x7f
10003910:	d101      	bne.n	10003916 <prvNotifyQueueSetContainer+0x8e>
10003912:	b672      	cpsid	i
10003914:	e7fe      	b.n	10003914 <prvNotifyQueueSetContainer+0x8c>

                pxQueueSetContainer->cTxLock = ( int8_t ) ( cTxLock + 1 );
10003916:	230f      	movs	r3, #15
10003918:	18fb      	adds	r3, r7, r3
1000391a:	781b      	ldrb	r3, [r3, #0]
1000391c:	3301      	adds	r3, #1
1000391e:	b2db      	uxtb	r3, r3
10003920:	b2d9      	uxtb	r1, r3
10003922:	693b      	ldr	r3, [r7, #16]
10003924:	2245      	movs	r2, #69	; 0x45
10003926:	5499      	strb	r1, [r3, r2]
10003928:	e7ff      	b.n	1000392a <prvNotifyQueueSetContainer+0xa2>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
1000392a:	697b      	ldr	r3, [r7, #20]
    }
1000392c:	1c18      	adds	r0, r3, #0
1000392e:	46bd      	mov	sp, r7
10003930:	b006      	add	sp, #24
10003932:	bd80      	pop	{r7, pc}

10003934 <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
10003934:	b590      	push	{r4, r7, lr}
10003936:	b08d      	sub	sp, #52	; 0x34
10003938:	af04      	add	r7, sp, #16
1000393a:	60f8      	str	r0, [r7, #12]
1000393c:	60b9      	str	r1, [r7, #8]
1000393e:	603b      	str	r3, [r7, #0]
10003940:	1dbb      	adds	r3, r7, #6
10003942:	801a      	strh	r2, [r3, #0]
        #else /* portSTACK_GROWTH */
            {
                StackType_t * pxStack;

                /* Allocate space for the stack used by the task being created. */
                pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
10003944:	1dbb      	adds	r3, r7, #6
10003946:	881b      	ldrh	r3, [r3, #0]
10003948:	009b      	lsls	r3, r3, #2
1000394a:	1c18      	adds	r0, r3, #0
1000394c:	f7ff fa40 	bl	10002dd0 <pvPortMalloc>
10003950:	1c03      	adds	r3, r0, #0
10003952:	617b      	str	r3, [r7, #20]

                if( pxStack != NULL )
10003954:	697b      	ldr	r3, [r7, #20]
10003956:	2b00      	cmp	r3, #0
10003958:	d010      	beq.n	1000397c <xTaskCreate+0x48>
                {
                    /* Allocate space for the TCB. */
                    pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
1000395a:	2070      	movs	r0, #112	; 0x70
1000395c:	f7ff fa38 	bl	10002dd0 <pvPortMalloc>
10003960:	1c03      	adds	r3, r0, #0
10003962:	61fb      	str	r3, [r7, #28]

                    if( pxNewTCB != NULL )
10003964:	69fb      	ldr	r3, [r7, #28]
10003966:	2b00      	cmp	r3, #0
10003968:	d003      	beq.n	10003972 <xTaskCreate+0x3e>
                    {
                        /* Store the stack location in the TCB. */
                        pxNewTCB->pxStack = pxStack;
1000396a:	69fb      	ldr	r3, [r7, #28]
1000396c:	697a      	ldr	r2, [r7, #20]
1000396e:	631a      	str	r2, [r3, #48]	; 0x30
10003970:	e006      	b.n	10003980 <xTaskCreate+0x4c>
                    }
                    else
                    {
                        /* The stack cannot be used as the TCB was not created.  Free
                         * it again. */
                        vPortFree( pxStack );
10003972:	697b      	ldr	r3, [r7, #20]
10003974:	1c18      	adds	r0, r3, #0
10003976:	f7ff fa3f 	bl	10002df8 <vPortFree>
1000397a:	e001      	b.n	10003980 <xTaskCreate+0x4c>
                    }
                }
                else
                {
                    pxNewTCB = NULL;
1000397c:	2300      	movs	r3, #0
1000397e:	61fb      	str	r3, [r7, #28]
                }
            }
        #endif /* portSTACK_GROWTH */

        if( pxNewTCB != NULL )
10003980:	69fb      	ldr	r3, [r7, #28]
10003982:	2b00      	cmp	r3, #0
10003984:	d016      	beq.n	100039b4 <xTaskCreate+0x80>
                     * task was created dynamically in case it is later deleted. */
                    pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
                }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

            prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
10003986:	1dbb      	adds	r3, r7, #6
10003988:	881a      	ldrh	r2, [r3, #0]
1000398a:	68f8      	ldr	r0, [r7, #12]
1000398c:	68b9      	ldr	r1, [r7, #8]
1000398e:	683c      	ldr	r4, [r7, #0]
10003990:	6b3b      	ldr	r3, [r7, #48]	; 0x30
10003992:	9300      	str	r3, [sp, #0]
10003994:	6b7b      	ldr	r3, [r7, #52]	; 0x34
10003996:	9301      	str	r3, [sp, #4]
10003998:	69fb      	ldr	r3, [r7, #28]
1000399a:	9302      	str	r3, [sp, #8]
1000399c:	2300      	movs	r3, #0
1000399e:	9303      	str	r3, [sp, #12]
100039a0:	1c23      	adds	r3, r4, #0
100039a2:	f000 f80f 	bl	100039c4 <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB );
100039a6:	69fb      	ldr	r3, [r7, #28]
100039a8:	1c18      	adds	r0, r3, #0
100039aa:	f000 f8a7 	bl	10003afc <prvAddNewTaskToReadyList>
            xReturn = pdPASS;
100039ae:	2301      	movs	r3, #1
100039b0:	61bb      	str	r3, [r7, #24]
100039b2:	e002      	b.n	100039ba <xTaskCreate+0x86>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
100039b4:	2301      	movs	r3, #1
100039b6:	425b      	negs	r3, r3
100039b8:	61bb      	str	r3, [r7, #24]
        }

        return xReturn;
100039ba:	69bb      	ldr	r3, [r7, #24]
    }
100039bc:	1c18      	adds	r0, r3, #0
100039be:	46bd      	mov	sp, r7
100039c0:	b009      	add	sp, #36	; 0x24
100039c2:	bd90      	pop	{r4, r7, pc}

100039c4 <prvInitialiseNewTask>:
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask,
                                  TCB_t * pxNewTCB,
                                  const MemoryRegion_t * const xRegions )
{
100039c4:	b580      	push	{r7, lr}
100039c6:	b086      	sub	sp, #24
100039c8:	af00      	add	r7, sp, #0
100039ca:	60f8      	str	r0, [r7, #12]
100039cc:	60b9      	str	r1, [r7, #8]
100039ce:	607a      	str	r2, [r7, #4]
100039d0:	603b      	str	r3, [r7, #0]

    /* Avoid dependency on memset() if it is not required. */
    #if ( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
        {
            /* Fill the stack with a known value to assist debugging. */
            ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
100039d2:	6abb      	ldr	r3, [r7, #40]	; 0x28
100039d4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
100039d6:	687b      	ldr	r3, [r7, #4]
100039d8:	009b      	lsls	r3, r3, #2
100039da:	1c10      	adds	r0, r2, #0
100039dc:	21a5      	movs	r1, #165	; 0xa5
100039de:	1c1a      	adds	r2, r3, #0
100039e0:	f001 fddd 	bl	1000559e <memset>
     * grows from high memory to low (as per the 80x86) or vice versa.
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
        {
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
100039e4:	6abb      	ldr	r3, [r7, #40]	; 0x28
100039e6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
100039e8:	687b      	ldr	r3, [r7, #4]
100039ea:	4943      	ldr	r1, [pc, #268]	; (10003af8 <prvInitialiseNewTask+0x134>)
100039ec:	468c      	mov	ip, r1
100039ee:	4463      	add	r3, ip
100039f0:	009b      	lsls	r3, r3, #2
100039f2:	18d3      	adds	r3, r2, r3
100039f4:	613b      	str	r3, [r7, #16]
            pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
100039f6:	693b      	ldr	r3, [r7, #16]
100039f8:	2207      	movs	r2, #7
100039fa:	4393      	bics	r3, r2
100039fc:	613b      	str	r3, [r7, #16]

            /* Check the alignment of the calculated top of stack is correct. */
            configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
100039fe:	693b      	ldr	r3, [r7, #16]
10003a00:	2207      	movs	r2, #7
10003a02:	4013      	ands	r3, r2
10003a04:	d001      	beq.n	10003a0a <prvInitialiseNewTask+0x46>
10003a06:	b672      	cpsid	i
10003a08:	e7fe      	b.n	10003a08 <prvInitialiseNewTask+0x44>
            pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
        }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
10003a0a:	68bb      	ldr	r3, [r7, #8]
10003a0c:	2b00      	cmp	r3, #0
10003a0e:	d01f      	beq.n	10003a50 <prvInitialiseNewTask+0x8c>
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
10003a10:	2300      	movs	r3, #0
10003a12:	617b      	str	r3, [r7, #20]
10003a14:	e014      	b.n	10003a40 <prvInitialiseNewTask+0x7c>
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
10003a16:	68ba      	ldr	r2, [r7, #8]
10003a18:	697b      	ldr	r3, [r7, #20]
10003a1a:	18d3      	adds	r3, r2, r3
10003a1c:	7818      	ldrb	r0, [r3, #0]
10003a1e:	6aba      	ldr	r2, [r7, #40]	; 0x28
10003a20:	2130      	movs	r1, #48	; 0x30
10003a22:	697b      	ldr	r3, [r7, #20]
10003a24:	18d3      	adds	r3, r2, r3
10003a26:	185b      	adds	r3, r3, r1
10003a28:	1c02      	adds	r2, r0, #0
10003a2a:	711a      	strb	r2, [r3, #4]

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
10003a2c:	68ba      	ldr	r2, [r7, #8]
10003a2e:	697b      	ldr	r3, [r7, #20]
10003a30:	18d3      	adds	r3, r2, r3
10003a32:	781b      	ldrb	r3, [r3, #0]
10003a34:	2b00      	cmp	r3, #0
10003a36:	d100      	bne.n	10003a3a <prvInitialiseNewTask+0x76>
            {
                break;
10003a38:	e005      	b.n	10003a46 <prvInitialiseNewTask+0x82>
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
10003a3a:	697b      	ldr	r3, [r7, #20]
10003a3c:	3301      	adds	r3, #1
10003a3e:	617b      	str	r3, [r7, #20]
10003a40:	697b      	ldr	r3, [r7, #20]
10003a42:	2b0f      	cmp	r3, #15
10003a44:	d9e7      	bls.n	10003a16 <prvInitialiseNewTask+0x52>
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
10003a46:	6abb      	ldr	r3, [r7, #40]	; 0x28
10003a48:	2243      	movs	r2, #67	; 0x43
10003a4a:	2100      	movs	r1, #0
10003a4c:	5499      	strb	r1, [r3, r2]
10003a4e:	e003      	b.n	10003a58 <prvInitialiseNewTask+0x94>
    }
    else
    {
        /* The task has not been given a name, so just ensure there is a NULL
         * terminator when it is read out. */
        pxNewTCB->pcTaskName[ 0 ] = 0x00;
10003a50:	6abb      	ldr	r3, [r7, #40]	; 0x28
10003a52:	2234      	movs	r2, #52	; 0x34
10003a54:	2100      	movs	r1, #0
10003a56:	5499      	strb	r1, [r3, r2]
    }

    /* This is used as an array index so must ensure it's not too large.  First
     * remove the privilege bit if one is present. */
    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
10003a58:	6a3b      	ldr	r3, [r7, #32]
10003a5a:	2b04      	cmp	r3, #4
10003a5c:	d901      	bls.n	10003a62 <prvInitialiseNewTask+0x9e>
    {
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
10003a5e:	2304      	movs	r3, #4
10003a60:	623b      	str	r3, [r7, #32]
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
10003a62:	6abb      	ldr	r3, [r7, #40]	; 0x28
10003a64:	6a3a      	ldr	r2, [r7, #32]
10003a66:	62da      	str	r2, [r3, #44]	; 0x2c
    #if ( configUSE_MUTEXES == 1 )
        {
            pxNewTCB->uxBasePriority = uxPriority;
10003a68:	6abb      	ldr	r3, [r7, #40]	; 0x28
10003a6a:	6a3a      	ldr	r2, [r7, #32]
10003a6c:	64da      	str	r2, [r3, #76]	; 0x4c
            pxNewTCB->uxMutexesHeld = 0;
10003a6e:	6abb      	ldr	r3, [r7, #40]	; 0x28
10003a70:	2200      	movs	r2, #0
10003a72:	651a      	str	r2, [r3, #80]	; 0x50
        }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
10003a74:	6abb      	ldr	r3, [r7, #40]	; 0x28
10003a76:	3304      	adds	r3, #4
10003a78:	1c18      	adds	r0, r3, #0
10003a7a:	f7ff f9ed 	bl	10002e58 <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
10003a7e:	6abb      	ldr	r3, [r7, #40]	; 0x28
10003a80:	3318      	adds	r3, #24
10003a82:	1c18      	adds	r0, r3, #0
10003a84:	f7ff f9e8 	bl	10002e58 <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
10003a88:	6abb      	ldr	r3, [r7, #40]	; 0x28
10003a8a:	6aba      	ldr	r2, [r7, #40]	; 0x28
10003a8c:	611a      	str	r2, [r3, #16]

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
10003a8e:	6a3b      	ldr	r3, [r7, #32]
10003a90:	2205      	movs	r2, #5
10003a92:	1ad2      	subs	r2, r2, r3
10003a94:	6abb      	ldr	r3, [r7, #40]	; 0x28
10003a96:	619a      	str	r2, [r3, #24]
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
10003a98:	6abb      	ldr	r3, [r7, #40]	; 0x28
10003a9a:	6aba      	ldr	r2, [r7, #40]	; 0x28
10003a9c:	625a      	str	r2, [r3, #36]	; 0x24
        }
    #endif

    #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
        {
            memset( ( void * ) &( pxNewTCB->pvThreadLocalStoragePointers[ 0 ] ), 0x00, sizeof( pxNewTCB->pvThreadLocalStoragePointers ) );
10003a9e:	6abb      	ldr	r3, [r7, #40]	; 0x28
10003aa0:	3354      	adds	r3, #84	; 0x54
10003aa2:	1c18      	adds	r0, r3, #0
10003aa4:	2100      	movs	r1, #0
10003aa6:	2214      	movs	r2, #20
10003aa8:	f001 fd79 	bl	1000559e <memset>
        }
    #endif

    #if ( configUSE_TASK_NOTIFICATIONS == 1 )
        {
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
10003aac:	6abb      	ldr	r3, [r7, #40]	; 0x28
10003aae:	3368      	adds	r3, #104	; 0x68
10003ab0:	1c18      	adds	r0, r3, #0
10003ab2:	2100      	movs	r1, #0
10003ab4:	2204      	movs	r2, #4
10003ab6:	f001 fd72 	bl	1000559e <memset>
            memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyState ) );
10003aba:	6abb      	ldr	r3, [r7, #40]	; 0x28
10003abc:	336c      	adds	r3, #108	; 0x6c
10003abe:	1c18      	adds	r0, r3, #0
10003ac0:	2100      	movs	r1, #0
10003ac2:	2201      	movs	r2, #1
10003ac4:	f001 fd6b 	bl	1000559e <memset>
        }
    #endif

    #if ( INCLUDE_xTaskAbortDelay == 1 )
        {
            pxNewTCB->ucDelayAborted = pdFALSE;
10003ac8:	6abb      	ldr	r3, [r7, #40]	; 0x28
10003aca:	226d      	movs	r2, #109	; 0x6d
10003acc:	2100      	movs	r1, #0
10003ace:	5499      	strb	r1, [r3, r2]
                        }
                    #endif /* portSTACK_GROWTH */
                }
            #else /* portHAS_STACK_OVERFLOW_CHECKING */
                {
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
10003ad0:	6939      	ldr	r1, [r7, #16]
10003ad2:	68fa      	ldr	r2, [r7, #12]
10003ad4:	683b      	ldr	r3, [r7, #0]
10003ad6:	1c08      	adds	r0, r1, #0
10003ad8:	1c11      	adds	r1, r2, #0
10003ada:	1c1a      	adds	r2, r3, #0
10003adc:	f7ff f84a 	bl	10002b74 <pxPortInitialiseStack>
10003ae0:	1c02      	adds	r2, r0, #0
10003ae2:	6abb      	ldr	r3, [r7, #40]	; 0x28
10003ae4:	601a      	str	r2, [r3, #0]
                }
            #endif /* portHAS_STACK_OVERFLOW_CHECKING */
        }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
10003ae6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
10003ae8:	2b00      	cmp	r3, #0
10003aea:	d002      	beq.n	10003af2 <prvInitialiseNewTask+0x12e>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
10003aec:	6a7b      	ldr	r3, [r7, #36]	; 0x24
10003aee:	6aba      	ldr	r2, [r7, #40]	; 0x28
10003af0:	601a      	str	r2, [r3, #0]
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
10003af2:	46bd      	mov	sp, r7
10003af4:	b006      	add	sp, #24
10003af6:	bd80      	pop	{r7, pc}
10003af8:	3fffffff 	.word	0x3fffffff

10003afc <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
10003afc:	b580      	push	{r7, lr}
10003afe:	b082      	sub	sp, #8
10003b00:	af00      	add	r7, sp, #0
10003b02:	6078      	str	r0, [r7, #4]
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
10003b04:	f7ff f8ce 	bl	10002ca4 <vPortEnterCritical>
    {
        uxCurrentNumberOfTasks++;
10003b08:	4b29      	ldr	r3, [pc, #164]	; (10003bb0 <prvAddNewTaskToReadyList+0xb4>)
10003b0a:	681b      	ldr	r3, [r3, #0]
10003b0c:	1c5a      	adds	r2, r3, #1
10003b0e:	4b28      	ldr	r3, [pc, #160]	; (10003bb0 <prvAddNewTaskToReadyList+0xb4>)
10003b10:	601a      	str	r2, [r3, #0]

        if( pxCurrentTCB == NULL )
10003b12:	4b28      	ldr	r3, [pc, #160]	; (10003bb4 <prvAddNewTaskToReadyList+0xb8>)
10003b14:	681b      	ldr	r3, [r3, #0]
10003b16:	2b00      	cmp	r3, #0
10003b18:	d109      	bne.n	10003b2e <prvAddNewTaskToReadyList+0x32>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
10003b1a:	4b26      	ldr	r3, [pc, #152]	; (10003bb4 <prvAddNewTaskToReadyList+0xb8>)
10003b1c:	687a      	ldr	r2, [r7, #4]
10003b1e:	601a      	str	r2, [r3, #0]

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
10003b20:	4b23      	ldr	r3, [pc, #140]	; (10003bb0 <prvAddNewTaskToReadyList+0xb4>)
10003b22:	681b      	ldr	r3, [r3, #0]
10003b24:	2b01      	cmp	r3, #1
10003b26:	d110      	bne.n	10003b4a <prvAddNewTaskToReadyList+0x4e>
            {
                /* This is the first task to be created so do the preliminary
                 * initialisation required.  We will not recover if this call
                 * fails, but we will report the failure. */
                prvInitialiseTaskLists();
10003b28:	f000 fb88 	bl	1000423c <prvInitialiseTaskLists>
10003b2c:	e00d      	b.n	10003b4a <prvAddNewTaskToReadyList+0x4e>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
10003b2e:	4b22      	ldr	r3, [pc, #136]	; (10003bb8 <prvAddNewTaskToReadyList+0xbc>)
10003b30:	681b      	ldr	r3, [r3, #0]
10003b32:	2b00      	cmp	r3, #0
10003b34:	d109      	bne.n	10003b4a <prvAddNewTaskToReadyList+0x4e>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
10003b36:	4b1f      	ldr	r3, [pc, #124]	; (10003bb4 <prvAddNewTaskToReadyList+0xb8>)
10003b38:	681b      	ldr	r3, [r3, #0]
10003b3a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10003b3c:	687b      	ldr	r3, [r7, #4]
10003b3e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
10003b40:	429a      	cmp	r2, r3
10003b42:	d802      	bhi.n	10003b4a <prvAddNewTaskToReadyList+0x4e>
                {
                    pxCurrentTCB = pxNewTCB;
10003b44:	4b1b      	ldr	r3, [pc, #108]	; (10003bb4 <prvAddNewTaskToReadyList+0xb8>)
10003b46:	687a      	ldr	r2, [r7, #4]
10003b48:	601a      	str	r2, [r3, #0]
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
10003b4a:	4b1c      	ldr	r3, [pc, #112]	; (10003bbc <prvAddNewTaskToReadyList+0xc0>)
10003b4c:	681b      	ldr	r3, [r3, #0]
10003b4e:	1c5a      	adds	r2, r3, #1
10003b50:	4b1a      	ldr	r3, [pc, #104]	; (10003bbc <prvAddNewTaskToReadyList+0xc0>)
10003b52:	601a      	str	r2, [r3, #0]

        #if ( configUSE_TRACE_FACILITY == 1 )
            {
                /* Add a counter into the TCB for tracing only. */
                pxNewTCB->uxTCBNumber = uxTaskNumber;
10003b54:	4b19      	ldr	r3, [pc, #100]	; (10003bbc <prvAddNewTaskToReadyList+0xc0>)
10003b56:	681a      	ldr	r2, [r3, #0]
10003b58:	687b      	ldr	r3, [r7, #4]
10003b5a:	645a      	str	r2, [r3, #68]	; 0x44
            }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
10003b5c:	687b      	ldr	r3, [r7, #4]
10003b5e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10003b60:	4b17      	ldr	r3, [pc, #92]	; (10003bc0 <prvAddNewTaskToReadyList+0xc4>)
10003b62:	681b      	ldr	r3, [r3, #0]
10003b64:	429a      	cmp	r2, r3
10003b66:	d903      	bls.n	10003b70 <prvAddNewTaskToReadyList+0x74>
10003b68:	687b      	ldr	r3, [r7, #4]
10003b6a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10003b6c:	4b14      	ldr	r3, [pc, #80]	; (10003bc0 <prvAddNewTaskToReadyList+0xc4>)
10003b6e:	601a      	str	r2, [r3, #0]
10003b70:	687b      	ldr	r3, [r7, #4]
10003b72:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10003b74:	1c13      	adds	r3, r2, #0
10003b76:	009b      	lsls	r3, r3, #2
10003b78:	189b      	adds	r3, r3, r2
10003b7a:	009b      	lsls	r3, r3, #2
10003b7c:	4a11      	ldr	r2, [pc, #68]	; (10003bc4 <prvAddNewTaskToReadyList+0xc8>)
10003b7e:	189a      	adds	r2, r3, r2
10003b80:	687b      	ldr	r3, [r7, #4]
10003b82:	3304      	adds	r3, #4
10003b84:	1c10      	adds	r0, r2, #0
10003b86:	1c19      	adds	r1, r3, #0
10003b88:	f7ff f970 	bl	10002e6c <vListInsertEnd>

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
10003b8c:	f7ff f89a 	bl	10002cc4 <vPortExitCritical>

    if( xSchedulerRunning != pdFALSE )
10003b90:	4b09      	ldr	r3, [pc, #36]	; (10003bb8 <prvAddNewTaskToReadyList+0xbc>)
10003b92:	681b      	ldr	r3, [r3, #0]
10003b94:	2b00      	cmp	r3, #0
10003b96:	d008      	beq.n	10003baa <prvAddNewTaskToReadyList+0xae>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
10003b98:	4b06      	ldr	r3, [pc, #24]	; (10003bb4 <prvAddNewTaskToReadyList+0xb8>)
10003b9a:	681b      	ldr	r3, [r3, #0]
10003b9c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10003b9e:	687b      	ldr	r3, [r7, #4]
10003ba0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
10003ba2:	429a      	cmp	r2, r3
10003ba4:	d201      	bcs.n	10003baa <prvAddNewTaskToReadyList+0xae>
        {
            taskYIELD_IF_USING_PREEMPTION();
10003ba6:	f7ff f86f 	bl	10002c88 <vPortYield>
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
10003baa:	46bd      	mov	sp, r7
10003bac:	b002      	add	sp, #8
10003bae:	bd80      	pop	{r7, pc}
10003bb0:	200007b0 	.word	0x200007b0
10003bb4:	200006d8 	.word	0x200006d8
10003bb8:	200007bc 	.word	0x200007bc
10003bbc:	200007cc 	.word	0x200007cc
10003bc0:	200007b8 	.word	0x200007b8
10003bc4:	200006dc 	.word	0x200006dc

10003bc8 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
10003bc8:	b580      	push	{r7, lr}
10003bca:	b084      	sub	sp, #16
10003bcc:	af00      	add	r7, sp, #0
10003bce:	6078      	str	r0, [r7, #4]
        BaseType_t xAlreadyYielded = pdFALSE;
10003bd0:	2300      	movs	r3, #0
10003bd2:	60fb      	str	r3, [r7, #12]

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
10003bd4:	687b      	ldr	r3, [r7, #4]
10003bd6:	2b00      	cmp	r3, #0
10003bd8:	d010      	beq.n	10003bfc <vTaskDelay+0x34>
        {
            configASSERT( uxSchedulerSuspended == 0 );
10003bda:	4b0c      	ldr	r3, [pc, #48]	; (10003c0c <vTaskDelay+0x44>)
10003bdc:	681b      	ldr	r3, [r3, #0]
10003bde:	2b00      	cmp	r3, #0
10003be0:	d001      	beq.n	10003be6 <vTaskDelay+0x1e>
10003be2:	b672      	cpsid	i
10003be4:	e7fe      	b.n	10003be4 <vTaskDelay+0x1c>
            vTaskSuspendAll();
10003be6:	f000 f855 	bl	10003c94 <vTaskSuspendAll>
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
10003bea:	687b      	ldr	r3, [r7, #4]
10003bec:	1c18      	adds	r0, r3, #0
10003bee:	2100      	movs	r1, #0
10003bf0:	f000 fc34 	bl	1000445c <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
10003bf4:	f000 f85a 	bl	10003cac <xTaskResumeAll>
10003bf8:	1c03      	adds	r3, r0, #0
10003bfa:	60fb      	str	r3, [r7, #12]
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
10003bfc:	68fb      	ldr	r3, [r7, #12]
10003bfe:	2b00      	cmp	r3, #0
10003c00:	d101      	bne.n	10003c06 <vTaskDelay+0x3e>
        {
            portYIELD_WITHIN_API();
10003c02:	f7ff f841 	bl	10002c88 <vPortYield>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
10003c06:	46bd      	mov	sp, r7
10003c08:	b004      	add	sp, #16
10003c0a:	bd80      	pop	{r7, pc}
10003c0c:	200007d8 	.word	0x200007d8

10003c10 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
10003c10:	b580      	push	{r7, lr}
10003c12:	b084      	sub	sp, #16
10003c14:	af02      	add	r7, sp, #8
            }
        }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
        {
            /* The Idle task is being created using dynamically allocated RAM. */
            xReturn = xTaskCreate( prvIdleTask,
10003c16:	4918      	ldr	r1, [pc, #96]	; (10003c78 <vTaskStartScheduler+0x68>)
10003c18:	4a18      	ldr	r2, [pc, #96]	; (10003c7c <vTaskStartScheduler+0x6c>)
10003c1a:	2300      	movs	r3, #0
10003c1c:	9300      	str	r3, [sp, #0]
10003c1e:	4b18      	ldr	r3, [pc, #96]	; (10003c80 <vTaskStartScheduler+0x70>)
10003c20:	9301      	str	r3, [sp, #4]
10003c22:	1c08      	adds	r0, r1, #0
10003c24:	1c11      	adds	r1, r2, #0
10003c26:	223c      	movs	r2, #60	; 0x3c
10003c28:	2300      	movs	r3, #0
10003c2a:	f7ff fe83 	bl	10003934 <xTaskCreate>
10003c2e:	1c03      	adds	r3, r0, #0
10003c30:	607b      	str	r3, [r7, #4]
        }
    #endif /* configSUPPORT_STATIC_ALLOCATION */

    #if ( configUSE_TIMERS == 1 )
        {
            if( xReturn == pdPASS )
10003c32:	687b      	ldr	r3, [r7, #4]
10003c34:	2b01      	cmp	r3, #1
10003c36:	d103      	bne.n	10003c40 <vTaskStartScheduler+0x30>
            {
                xReturn = xTimerCreateTimerTask();
10003c38:	f000 fc68 	bl	1000450c <xTimerCreateTimerTask>
10003c3c:	1c03      	adds	r3, r0, #0
10003c3e:	607b      	str	r3, [r7, #4]
                mtCOVERAGE_TEST_MARKER();
            }
        }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
10003c40:	687b      	ldr	r3, [r7, #4]
10003c42:	2b01      	cmp	r3, #1
10003c44:	d10d      	bne.n	10003c62 <vTaskStartScheduler+0x52>
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
10003c46:	b672      	cpsid	i
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */

        xNextTaskUnblockTime = portMAX_DELAY;
10003c48:	4b0e      	ldr	r3, [pc, #56]	; (10003c84 <vTaskStartScheduler+0x74>)
10003c4a:	2201      	movs	r2, #1
10003c4c:	4252      	negs	r2, r2
10003c4e:	601a      	str	r2, [r3, #0]
        xSchedulerRunning = pdTRUE;
10003c50:	4b0d      	ldr	r3, [pc, #52]	; (10003c88 <vTaskStartScheduler+0x78>)
10003c52:	2201      	movs	r2, #1
10003c54:	601a      	str	r2, [r3, #0]
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
10003c56:	4b0d      	ldr	r3, [pc, #52]	; (10003c8c <vTaskStartScheduler+0x7c>)
10003c58:	2200      	movs	r2, #0
10003c5a:	601a      	str	r2, [r3, #0]

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        if( xPortStartScheduler() != pdFALSE )
10003c5c:	f7fe fff0 	bl	10002c40 <xPortStartScheduler>
10003c60:	e004      	b.n	10003c6c <vTaskStartScheduler+0x5c>
    else
    {
        /* This line will only be reached if the kernel could not be started,
         * because there was not enough FreeRTOS heap to create the idle task
         * or the timer task. */
        configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
10003c62:	687b      	ldr	r3, [r7, #4]
10003c64:	3301      	adds	r3, #1
10003c66:	d101      	bne.n	10003c6c <vTaskStartScheduler+0x5c>
10003c68:	b672      	cpsid	i
10003c6a:	e7fe      	b.n	10003c6a <vTaskStartScheduler+0x5a>
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
10003c6c:	4b08      	ldr	r3, [pc, #32]	; (10003c90 <vTaskStartScheduler+0x80>)
10003c6e:	681b      	ldr	r3, [r3, #0]
}
10003c70:	46bd      	mov	sp, r7
10003c72:	b002      	add	sp, #8
10003c74:	bd80      	pop	{r7, pc}
10003c76:	46c0      	nop			; (mov r8, r8)
10003c78:	1000421d 	.word	0x1000421d
10003c7c:	1000a1ac 	.word	0x1000a1ac
10003c80:	200007d4 	.word	0x200007d4
10003c84:	200007d0 	.word	0x200007d0
10003c88:	200007bc 	.word	0x200007bc
10003c8c:	200007b4 	.word	0x200007b4
10003c90:	200005f8 	.word	0x200005f8

10003c94 <vTaskSuspendAll>:
    vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
10003c94:	b580      	push	{r7, lr}
10003c96:	af00      	add	r7, sp, #0
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
10003c98:	4b03      	ldr	r3, [pc, #12]	; (10003ca8 <vTaskSuspendAll+0x14>)
10003c9a:	681b      	ldr	r3, [r3, #0]
10003c9c:	1c5a      	adds	r2, r3, #1
10003c9e:	4b02      	ldr	r3, [pc, #8]	; (10003ca8 <vTaskSuspendAll+0x14>)
10003ca0:	601a      	str	r2, [r3, #0]

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
10003ca2:	46bd      	mov	sp, r7
10003ca4:	bd80      	pop	{r7, pc}
10003ca6:	46c0      	nop			; (mov r8, r8)
10003ca8:	200007d8 	.word	0x200007d8

10003cac <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
10003cac:	b580      	push	{r7, lr}
10003cae:	b084      	sub	sp, #16
10003cb0:	af00      	add	r7, sp, #0
    TCB_t * pxTCB = NULL;
10003cb2:	2300      	movs	r3, #0
10003cb4:	60fb      	str	r3, [r7, #12]
    BaseType_t xAlreadyYielded = pdFALSE;
10003cb6:	2300      	movs	r3, #0
10003cb8:	60bb      	str	r3, [r7, #8]

    /* If uxSchedulerSuspended is zero then this function does not match a
     * previous call to vTaskSuspendAll(). */
    configASSERT( uxSchedulerSuspended );
10003cba:	4b3a      	ldr	r3, [pc, #232]	; (10003da4 <xTaskResumeAll+0xf8>)
10003cbc:	681b      	ldr	r3, [r3, #0]
10003cbe:	2b00      	cmp	r3, #0
10003cc0:	d101      	bne.n	10003cc6 <xTaskResumeAll+0x1a>
10003cc2:	b672      	cpsid	i
10003cc4:	e7fe      	b.n	10003cc4 <xTaskResumeAll+0x18>
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
10003cc6:	f7fe ffed 	bl	10002ca4 <vPortEnterCritical>
    {
        --uxSchedulerSuspended;
10003cca:	4b36      	ldr	r3, [pc, #216]	; (10003da4 <xTaskResumeAll+0xf8>)
10003ccc:	681b      	ldr	r3, [r3, #0]
10003cce:	1e5a      	subs	r2, r3, #1
10003cd0:	4b34      	ldr	r3, [pc, #208]	; (10003da4 <xTaskResumeAll+0xf8>)
10003cd2:	601a      	str	r2, [r3, #0]

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
10003cd4:	4b33      	ldr	r3, [pc, #204]	; (10003da4 <xTaskResumeAll+0xf8>)
10003cd6:	681b      	ldr	r3, [r3, #0]
10003cd8:	2b00      	cmp	r3, #0
10003cda:	d15b      	bne.n	10003d94 <xTaskResumeAll+0xe8>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
10003cdc:	4b32      	ldr	r3, [pc, #200]	; (10003da8 <xTaskResumeAll+0xfc>)
10003cde:	681b      	ldr	r3, [r3, #0]
10003ce0:	2b00      	cmp	r3, #0
10003ce2:	d057      	beq.n	10003d94 <xTaskResumeAll+0xe8>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
10003ce4:	e02f      	b.n	10003d46 <xTaskResumeAll+0x9a>
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
10003ce6:	4b31      	ldr	r3, [pc, #196]	; (10003dac <xTaskResumeAll+0x100>)
10003ce8:	68db      	ldr	r3, [r3, #12]
10003cea:	68db      	ldr	r3, [r3, #12]
10003cec:	60fb      	str	r3, [r7, #12]
                    ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
10003cee:	68fb      	ldr	r3, [r7, #12]
10003cf0:	3318      	adds	r3, #24
10003cf2:	1c18      	adds	r0, r3, #0
10003cf4:	f7ff f912 	bl	10002f1c <uxListRemove>
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
10003cf8:	68fb      	ldr	r3, [r7, #12]
10003cfa:	3304      	adds	r3, #4
10003cfc:	1c18      	adds	r0, r3, #0
10003cfe:	f7ff f90d 	bl	10002f1c <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
10003d02:	68fb      	ldr	r3, [r7, #12]
10003d04:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10003d06:	4b2a      	ldr	r3, [pc, #168]	; (10003db0 <xTaskResumeAll+0x104>)
10003d08:	681b      	ldr	r3, [r3, #0]
10003d0a:	429a      	cmp	r2, r3
10003d0c:	d903      	bls.n	10003d16 <xTaskResumeAll+0x6a>
10003d0e:	68fb      	ldr	r3, [r7, #12]
10003d10:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10003d12:	4b27      	ldr	r3, [pc, #156]	; (10003db0 <xTaskResumeAll+0x104>)
10003d14:	601a      	str	r2, [r3, #0]
10003d16:	68fb      	ldr	r3, [r7, #12]
10003d18:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10003d1a:	1c13      	adds	r3, r2, #0
10003d1c:	009b      	lsls	r3, r3, #2
10003d1e:	189b      	adds	r3, r3, r2
10003d20:	009b      	lsls	r3, r3, #2
10003d22:	4a24      	ldr	r2, [pc, #144]	; (10003db4 <xTaskResumeAll+0x108>)
10003d24:	189a      	adds	r2, r3, r2
10003d26:	68fb      	ldr	r3, [r7, #12]
10003d28:	3304      	adds	r3, #4
10003d2a:	1c10      	adds	r0, r2, #0
10003d2c:	1c19      	adds	r1, r3, #0
10003d2e:	f7ff f89d 	bl	10002e6c <vListInsertEnd>

                    /* If the moved task has a priority higher than the current
                     * task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
10003d32:	68fb      	ldr	r3, [r7, #12]
10003d34:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10003d36:	4b20      	ldr	r3, [pc, #128]	; (10003db8 <xTaskResumeAll+0x10c>)
10003d38:	681b      	ldr	r3, [r3, #0]
10003d3a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
10003d3c:	429a      	cmp	r2, r3
10003d3e:	d302      	bcc.n	10003d46 <xTaskResumeAll+0x9a>
                    {
                        xYieldPending = pdTRUE;
10003d40:	4b1e      	ldr	r3, [pc, #120]	; (10003dbc <xTaskResumeAll+0x110>)
10003d42:	2201      	movs	r2, #1
10003d44:	601a      	str	r2, [r3, #0]
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
10003d46:	4b19      	ldr	r3, [pc, #100]	; (10003dac <xTaskResumeAll+0x100>)
10003d48:	681b      	ldr	r3, [r3, #0]
10003d4a:	2b00      	cmp	r3, #0
10003d4c:	d1cb      	bne.n	10003ce6 <xTaskResumeAll+0x3a>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
10003d4e:	68fb      	ldr	r3, [r7, #12]
10003d50:	2b00      	cmp	r3, #0
10003d52:	d001      	beq.n	10003d58 <xTaskResumeAll+0xac>
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
10003d54:	f000 faf2 	bl	1000433c <prvResetNextTaskUnblockTime>
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
10003d58:	4b19      	ldr	r3, [pc, #100]	; (10003dc0 <xTaskResumeAll+0x114>)
10003d5a:	681b      	ldr	r3, [r3, #0]
10003d5c:	607b      	str	r3, [r7, #4]

                    if( xPendedCounts > ( TickType_t ) 0U )
10003d5e:	687b      	ldr	r3, [r7, #4]
10003d60:	2b00      	cmp	r3, #0
10003d62:	d00f      	beq.n	10003d84 <xTaskResumeAll+0xd8>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
10003d64:	f000 f83c 	bl	10003de0 <xTaskIncrementTick>
10003d68:	1e03      	subs	r3, r0, #0
10003d6a:	d002      	beq.n	10003d72 <xTaskResumeAll+0xc6>
                            {
                                xYieldPending = pdTRUE;
10003d6c:	4b13      	ldr	r3, [pc, #76]	; (10003dbc <xTaskResumeAll+0x110>)
10003d6e:	2201      	movs	r2, #1
10003d70:	601a      	str	r2, [r3, #0]
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
10003d72:	687b      	ldr	r3, [r7, #4]
10003d74:	3b01      	subs	r3, #1
10003d76:	607b      	str	r3, [r7, #4]
                        } while( xPendedCounts > ( TickType_t ) 0U );
10003d78:	687b      	ldr	r3, [r7, #4]
10003d7a:	2b00      	cmp	r3, #0
10003d7c:	d1f2      	bne.n	10003d64 <xTaskResumeAll+0xb8>

                        xPendedTicks = 0;
10003d7e:	4b10      	ldr	r3, [pc, #64]	; (10003dc0 <xTaskResumeAll+0x114>)
10003d80:	2200      	movs	r2, #0
10003d82:	601a      	str	r2, [r3, #0]
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
10003d84:	4b0d      	ldr	r3, [pc, #52]	; (10003dbc <xTaskResumeAll+0x110>)
10003d86:	681b      	ldr	r3, [r3, #0]
10003d88:	2b00      	cmp	r3, #0
10003d8a:	d003      	beq.n	10003d94 <xTaskResumeAll+0xe8>
                {
                    #if ( configUSE_PREEMPTION != 0 )
                        {
                            xAlreadyYielded = pdTRUE;
10003d8c:	2301      	movs	r3, #1
10003d8e:	60bb      	str	r3, [r7, #8]
                        }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
10003d90:	f7fe ff7a 	bl	10002c88 <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
10003d94:	f7fe ff96 	bl	10002cc4 <vPortExitCritical>

    return xAlreadyYielded;
10003d98:	68bb      	ldr	r3, [r7, #8]
}
10003d9a:	1c18      	adds	r0, r3, #0
10003d9c:	46bd      	mov	sp, r7
10003d9e:	b004      	add	sp, #16
10003da0:	bd80      	pop	{r7, pc}
10003da2:	46c0      	nop			; (mov r8, r8)
10003da4:	200007d8 	.word	0x200007d8
10003da8:	200007b0 	.word	0x200007b0
10003dac:	20000770 	.word	0x20000770
10003db0:	200007b8 	.word	0x200007b8
10003db4:	200006dc 	.word	0x200006dc
10003db8:	200006d8 	.word	0x200006d8
10003dbc:	200007c4 	.word	0x200007c4
10003dc0:	200007c0 	.word	0x200007c0

10003dc4 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
10003dc4:	b580      	push	{r7, lr}
10003dc6:	b082      	sub	sp, #8
10003dc8:	af00      	add	r7, sp, #0
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    {
        xTicks = xTickCount;
10003dca:	4b04      	ldr	r3, [pc, #16]	; (10003ddc <xTaskGetTickCount+0x18>)
10003dcc:	681b      	ldr	r3, [r3, #0]
10003dce:	607b      	str	r3, [r7, #4]
    }
    portTICK_TYPE_EXIT_CRITICAL();

    return xTicks;
10003dd0:	687b      	ldr	r3, [r7, #4]
}
10003dd2:	1c18      	adds	r0, r3, #0
10003dd4:	46bd      	mov	sp, r7
10003dd6:	b002      	add	sp, #8
10003dd8:	bd80      	pop	{r7, pc}
10003dda:	46c0      	nop			; (mov r8, r8)
10003ddc:	200007b4 	.word	0x200007b4

10003de0 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
10003de0:	b580      	push	{r7, lr}
10003de2:	b086      	sub	sp, #24
10003de4:	af00      	add	r7, sp, #0
    TCB_t * pxTCB;
    TickType_t xItemValue;
    BaseType_t xSwitchRequired = pdFALSE;
10003de6:	2300      	movs	r3, #0
10003de8:	617b      	str	r3, [r7, #20]
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
10003dea:	4b4a      	ldr	r3, [pc, #296]	; (10003f14 <xTaskIncrementTick+0x134>)
10003dec:	681b      	ldr	r3, [r3, #0]
10003dee:	2b00      	cmp	r3, #0
10003df0:	d000      	beq.n	10003df4 <xTaskIncrementTick+0x14>
10003df2:	e084      	b.n	10003efe <xTaskIncrementTick+0x11e>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
10003df4:	4b48      	ldr	r3, [pc, #288]	; (10003f18 <xTaskIncrementTick+0x138>)
10003df6:	681b      	ldr	r3, [r3, #0]
10003df8:	3301      	adds	r3, #1
10003dfa:	613b      	str	r3, [r7, #16]

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
10003dfc:	4b46      	ldr	r3, [pc, #280]	; (10003f18 <xTaskIncrementTick+0x138>)
10003dfe:	693a      	ldr	r2, [r7, #16]
10003e00:	601a      	str	r2, [r3, #0]

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
10003e02:	693b      	ldr	r3, [r7, #16]
10003e04:	2b00      	cmp	r3, #0
10003e06:	d117      	bne.n	10003e38 <xTaskIncrementTick+0x58>
        {
            taskSWITCH_DELAYED_LISTS();
10003e08:	4b44      	ldr	r3, [pc, #272]	; (10003f1c <xTaskIncrementTick+0x13c>)
10003e0a:	681b      	ldr	r3, [r3, #0]
10003e0c:	681b      	ldr	r3, [r3, #0]
10003e0e:	2b00      	cmp	r3, #0
10003e10:	d001      	beq.n	10003e16 <xTaskIncrementTick+0x36>
10003e12:	b672      	cpsid	i
10003e14:	e7fe      	b.n	10003e14 <xTaskIncrementTick+0x34>
10003e16:	4b41      	ldr	r3, [pc, #260]	; (10003f1c <xTaskIncrementTick+0x13c>)
10003e18:	681b      	ldr	r3, [r3, #0]
10003e1a:	60fb      	str	r3, [r7, #12]
10003e1c:	4b40      	ldr	r3, [pc, #256]	; (10003f20 <xTaskIncrementTick+0x140>)
10003e1e:	681a      	ldr	r2, [r3, #0]
10003e20:	4b3e      	ldr	r3, [pc, #248]	; (10003f1c <xTaskIncrementTick+0x13c>)
10003e22:	601a      	str	r2, [r3, #0]
10003e24:	4b3e      	ldr	r3, [pc, #248]	; (10003f20 <xTaskIncrementTick+0x140>)
10003e26:	68fa      	ldr	r2, [r7, #12]
10003e28:	601a      	str	r2, [r3, #0]
10003e2a:	4b3e      	ldr	r3, [pc, #248]	; (10003f24 <xTaskIncrementTick+0x144>)
10003e2c:	681b      	ldr	r3, [r3, #0]
10003e2e:	1c5a      	adds	r2, r3, #1
10003e30:	4b3c      	ldr	r3, [pc, #240]	; (10003f24 <xTaskIncrementTick+0x144>)
10003e32:	601a      	str	r2, [r3, #0]
10003e34:	f000 fa82 	bl	1000433c <prvResetNextTaskUnblockTime>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
10003e38:	4b3b      	ldr	r3, [pc, #236]	; (10003f28 <xTaskIncrementTick+0x148>)
10003e3a:	681b      	ldr	r3, [r3, #0]
10003e3c:	693a      	ldr	r2, [r7, #16]
10003e3e:	429a      	cmp	r2, r3
10003e40:	d349      	bcc.n	10003ed6 <xTaskIncrementTick+0xf6>
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
10003e42:	4b36      	ldr	r3, [pc, #216]	; (10003f1c <xTaskIncrementTick+0x13c>)
10003e44:	681b      	ldr	r3, [r3, #0]
10003e46:	681b      	ldr	r3, [r3, #0]
10003e48:	2b00      	cmp	r3, #0
10003e4a:	d104      	bne.n	10003e56 <xTaskIncrementTick+0x76>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
10003e4c:	4b36      	ldr	r3, [pc, #216]	; (10003f28 <xTaskIncrementTick+0x148>)
10003e4e:	2201      	movs	r2, #1
10003e50:	4252      	negs	r2, r2
10003e52:	601a      	str	r2, [r3, #0]
                    break;
10003e54:	e03f      	b.n	10003ed6 <xTaskIncrementTick+0xf6>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
10003e56:	4b31      	ldr	r3, [pc, #196]	; (10003f1c <xTaskIncrementTick+0x13c>)
10003e58:	681b      	ldr	r3, [r3, #0]
10003e5a:	68db      	ldr	r3, [r3, #12]
10003e5c:	68db      	ldr	r3, [r3, #12]
10003e5e:	60bb      	str	r3, [r7, #8]
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
10003e60:	68bb      	ldr	r3, [r7, #8]
10003e62:	685b      	ldr	r3, [r3, #4]
10003e64:	607b      	str	r3, [r7, #4]

                    if( xConstTickCount < xItemValue )
10003e66:	693a      	ldr	r2, [r7, #16]
10003e68:	687b      	ldr	r3, [r7, #4]
10003e6a:	429a      	cmp	r2, r3
10003e6c:	d203      	bcs.n	10003e76 <xTaskIncrementTick+0x96>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
10003e6e:	4b2e      	ldr	r3, [pc, #184]	; (10003f28 <xTaskIncrementTick+0x148>)
10003e70:	687a      	ldr	r2, [r7, #4]
10003e72:	601a      	str	r2, [r3, #0]
                        break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
10003e74:	e02f      	b.n	10003ed6 <xTaskIncrementTick+0xf6>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
10003e76:	68bb      	ldr	r3, [r7, #8]
10003e78:	3304      	adds	r3, #4
10003e7a:	1c18      	adds	r0, r3, #0
10003e7c:	f7ff f84e 	bl	10002f1c <uxListRemove>

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
10003e80:	68bb      	ldr	r3, [r7, #8]
10003e82:	6a9b      	ldr	r3, [r3, #40]	; 0x28
10003e84:	2b00      	cmp	r3, #0
10003e86:	d004      	beq.n	10003e92 <xTaskIncrementTick+0xb2>
                    {
                        ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
10003e88:	68bb      	ldr	r3, [r7, #8]
10003e8a:	3318      	adds	r3, #24
10003e8c:	1c18      	adds	r0, r3, #0
10003e8e:	f7ff f845 	bl	10002f1c <uxListRemove>
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
10003e92:	68bb      	ldr	r3, [r7, #8]
10003e94:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10003e96:	4b25      	ldr	r3, [pc, #148]	; (10003f2c <xTaskIncrementTick+0x14c>)
10003e98:	681b      	ldr	r3, [r3, #0]
10003e9a:	429a      	cmp	r2, r3
10003e9c:	d903      	bls.n	10003ea6 <xTaskIncrementTick+0xc6>
10003e9e:	68bb      	ldr	r3, [r7, #8]
10003ea0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10003ea2:	4b22      	ldr	r3, [pc, #136]	; (10003f2c <xTaskIncrementTick+0x14c>)
10003ea4:	601a      	str	r2, [r3, #0]
10003ea6:	68bb      	ldr	r3, [r7, #8]
10003ea8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10003eaa:	1c13      	adds	r3, r2, #0
10003eac:	009b      	lsls	r3, r3, #2
10003eae:	189b      	adds	r3, r3, r2
10003eb0:	009b      	lsls	r3, r3, #2
10003eb2:	4a1f      	ldr	r2, [pc, #124]	; (10003f30 <xTaskIncrementTick+0x150>)
10003eb4:	189a      	adds	r2, r3, r2
10003eb6:	68bb      	ldr	r3, [r7, #8]
10003eb8:	3304      	adds	r3, #4
10003eba:	1c10      	adds	r0, r2, #0
10003ebc:	1c19      	adds	r1, r3, #0
10003ebe:	f7fe ffd5 	bl	10002e6c <vListInsertEnd>
                        {
                            /* Preemption is on, but a context switch should
                             * only be performed if the unblocked task has a
                             * priority that is equal to or higher than the
                             * currently executing task. */
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
10003ec2:	68bb      	ldr	r3, [r7, #8]
10003ec4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10003ec6:	4b1b      	ldr	r3, [pc, #108]	; (10003f34 <xTaskIncrementTick+0x154>)
10003ec8:	681b      	ldr	r3, [r3, #0]
10003eca:	6adb      	ldr	r3, [r3, #44]	; 0x2c
10003ecc:	429a      	cmp	r2, r3
10003ece:	d301      	bcc.n	10003ed4 <xTaskIncrementTick+0xf4>
                            {
                                xSwitchRequired = pdTRUE;
10003ed0:	2301      	movs	r3, #1
10003ed2:	617b      	str	r3, [r7, #20]
                                mtCOVERAGE_TEST_MARKER();
                            }
                        }
                    #endif /* configUSE_PREEMPTION */
                }
            }
10003ed4:	e7b5      	b.n	10003e42 <xTaskIncrementTick+0x62>
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
            {
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
10003ed6:	4b17      	ldr	r3, [pc, #92]	; (10003f34 <xTaskIncrementTick+0x154>)
10003ed8:	681b      	ldr	r3, [r3, #0]
10003eda:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10003edc:	4914      	ldr	r1, [pc, #80]	; (10003f30 <xTaskIncrementTick+0x150>)
10003ede:	1c13      	adds	r3, r2, #0
10003ee0:	009b      	lsls	r3, r3, #2
10003ee2:	189b      	adds	r3, r3, r2
10003ee4:	009b      	lsls	r3, r3, #2
10003ee6:	585b      	ldr	r3, [r3, r1]
10003ee8:	2b01      	cmp	r3, #1
10003eea:	d901      	bls.n	10003ef0 <xTaskIncrementTick+0x110>
                {
                    xSwitchRequired = pdTRUE;
10003eec:	2301      	movs	r3, #1
10003eee:	617b      	str	r3, [r7, #20]
            }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
            {
                if( xYieldPending != pdFALSE )
10003ef0:	4b11      	ldr	r3, [pc, #68]	; (10003f38 <xTaskIncrementTick+0x158>)
10003ef2:	681b      	ldr	r3, [r3, #0]
10003ef4:	2b00      	cmp	r3, #0
10003ef6:	d001      	beq.n	10003efc <xTaskIncrementTick+0x11c>
                {
                    xSwitchRequired = pdTRUE;
10003ef8:	2301      	movs	r3, #1
10003efa:	617b      	str	r3, [r7, #20]
10003efc:	e004      	b.n	10003f08 <xTaskIncrementTick+0x128>
            }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
10003efe:	4b0f      	ldr	r3, [pc, #60]	; (10003f3c <xTaskIncrementTick+0x15c>)
10003f00:	681b      	ldr	r3, [r3, #0]
10003f02:	1c5a      	adds	r2, r3, #1
10003f04:	4b0d      	ldr	r3, [pc, #52]	; (10003f3c <xTaskIncrementTick+0x15c>)
10003f06:	601a      	str	r2, [r3, #0]
                vApplicationTickHook();
            }
        #endif
    }

    return xSwitchRequired;
10003f08:	697b      	ldr	r3, [r7, #20]
}
10003f0a:	1c18      	adds	r0, r3, #0
10003f0c:	46bd      	mov	sp, r7
10003f0e:	b006      	add	sp, #24
10003f10:	bd80      	pop	{r7, pc}
10003f12:	46c0      	nop			; (mov r8, r8)
10003f14:	200007d8 	.word	0x200007d8
10003f18:	200007b4 	.word	0x200007b4
10003f1c:	20000768 	.word	0x20000768
10003f20:	2000076c 	.word	0x2000076c
10003f24:	200007c8 	.word	0x200007c8
10003f28:	200007d0 	.word	0x200007d0
10003f2c:	200007b8 	.word	0x200007b8
10003f30:	200006dc 	.word	0x200006dc
10003f34:	200006d8 	.word	0x200006d8
10003f38:	200007c4 	.word	0x200007c4
10003f3c:	200007c0 	.word	0x200007c0

10003f40 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
10003f40:	b580      	push	{r7, lr}
10003f42:	b082      	sub	sp, #8
10003f44:	af00      	add	r7, sp, #0
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
10003f46:	4b21      	ldr	r3, [pc, #132]	; (10003fcc <vTaskSwitchContext+0x8c>)
10003f48:	681b      	ldr	r3, [r3, #0]
10003f4a:	2b00      	cmp	r3, #0
10003f4c:	d003      	beq.n	10003f56 <vTaskSwitchContext+0x16>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
10003f4e:	4b20      	ldr	r3, [pc, #128]	; (10003fd0 <vTaskSwitchContext+0x90>)
10003f50:	2201      	movs	r2, #1
10003f52:	601a      	str	r2, [r3, #0]
10003f54:	e037      	b.n	10003fc6 <vTaskSwitchContext+0x86>
    }
    else
    {
        xYieldPending = pdFALSE;
10003f56:	4b1e      	ldr	r3, [pc, #120]	; (10003fd0 <vTaskSwitchContext+0x90>)
10003f58:	2200      	movs	r2, #0
10003f5a:	601a      	str	r2, [r3, #0]
            }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
10003f5c:	4b1d      	ldr	r3, [pc, #116]	; (10003fd4 <vTaskSwitchContext+0x94>)
10003f5e:	681b      	ldr	r3, [r3, #0]
10003f60:	607b      	str	r3, [r7, #4]
10003f62:	e007      	b.n	10003f74 <vTaskSwitchContext+0x34>
10003f64:	687b      	ldr	r3, [r7, #4]
10003f66:	2b00      	cmp	r3, #0
10003f68:	d101      	bne.n	10003f6e <vTaskSwitchContext+0x2e>
10003f6a:	b672      	cpsid	i
10003f6c:	e7fe      	b.n	10003f6c <vTaskSwitchContext+0x2c>
10003f6e:	687b      	ldr	r3, [r7, #4]
10003f70:	3b01      	subs	r3, #1
10003f72:	607b      	str	r3, [r7, #4]
10003f74:	4918      	ldr	r1, [pc, #96]	; (10003fd8 <vTaskSwitchContext+0x98>)
10003f76:	687a      	ldr	r2, [r7, #4]
10003f78:	1c13      	adds	r3, r2, #0
10003f7a:	009b      	lsls	r3, r3, #2
10003f7c:	189b      	adds	r3, r3, r2
10003f7e:	009b      	lsls	r3, r3, #2
10003f80:	585b      	ldr	r3, [r3, r1]
10003f82:	2b00      	cmp	r3, #0
10003f84:	d0ee      	beq.n	10003f64 <vTaskSwitchContext+0x24>
10003f86:	687a      	ldr	r2, [r7, #4]
10003f88:	1c13      	adds	r3, r2, #0
10003f8a:	009b      	lsls	r3, r3, #2
10003f8c:	189b      	adds	r3, r3, r2
10003f8e:	009b      	lsls	r3, r3, #2
10003f90:	4a11      	ldr	r2, [pc, #68]	; (10003fd8 <vTaskSwitchContext+0x98>)
10003f92:	189b      	adds	r3, r3, r2
10003f94:	603b      	str	r3, [r7, #0]
10003f96:	683b      	ldr	r3, [r7, #0]
10003f98:	685b      	ldr	r3, [r3, #4]
10003f9a:	685a      	ldr	r2, [r3, #4]
10003f9c:	683b      	ldr	r3, [r7, #0]
10003f9e:	605a      	str	r2, [r3, #4]
10003fa0:	683b      	ldr	r3, [r7, #0]
10003fa2:	685a      	ldr	r2, [r3, #4]
10003fa4:	683b      	ldr	r3, [r7, #0]
10003fa6:	3308      	adds	r3, #8
10003fa8:	429a      	cmp	r2, r3
10003faa:	d104      	bne.n	10003fb6 <vTaskSwitchContext+0x76>
10003fac:	683b      	ldr	r3, [r7, #0]
10003fae:	685b      	ldr	r3, [r3, #4]
10003fb0:	685a      	ldr	r2, [r3, #4]
10003fb2:	683b      	ldr	r3, [r7, #0]
10003fb4:	605a      	str	r2, [r3, #4]
10003fb6:	683b      	ldr	r3, [r7, #0]
10003fb8:	685b      	ldr	r3, [r3, #4]
10003fba:	68da      	ldr	r2, [r3, #12]
10003fbc:	4b07      	ldr	r3, [pc, #28]	; (10003fdc <vTaskSwitchContext+0x9c>)
10003fbe:	601a      	str	r2, [r3, #0]
10003fc0:	4b04      	ldr	r3, [pc, #16]	; (10003fd4 <vTaskSwitchContext+0x94>)
10003fc2:	687a      	ldr	r2, [r7, #4]
10003fc4:	601a      	str	r2, [r3, #0]
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */
    }
}
10003fc6:	46bd      	mov	sp, r7
10003fc8:	b002      	add	sp, #8
10003fca:	bd80      	pop	{r7, pc}
10003fcc:	200007d8 	.word	0x200007d8
10003fd0:	200007c4 	.word	0x200007c4
10003fd4:	200007b8 	.word	0x200007b8
10003fd8:	200006dc 	.word	0x200006dc
10003fdc:	200006d8 	.word	0x200006d8

10003fe0 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
10003fe0:	b580      	push	{r7, lr}
10003fe2:	b082      	sub	sp, #8
10003fe4:	af00      	add	r7, sp, #0
10003fe6:	6078      	str	r0, [r7, #4]
10003fe8:	6039      	str	r1, [r7, #0]
    configASSERT( pxEventList );
10003fea:	687b      	ldr	r3, [r7, #4]
10003fec:	2b00      	cmp	r3, #0
10003fee:	d101      	bne.n	10003ff4 <vTaskPlaceOnEventList+0x14>
10003ff0:	b672      	cpsid	i
10003ff2:	e7fe      	b.n	10003ff2 <vTaskPlaceOnEventList+0x12>

    /* Place the event list item of the TCB in the appropriate event list.
     * This is placed in the list in priority order so the highest priority task
     * is the first to be woken by the event.  The queue that contains the event
     * list is locked, preventing simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
10003ff4:	4b07      	ldr	r3, [pc, #28]	; (10004014 <vTaskPlaceOnEventList+0x34>)
10003ff6:	681b      	ldr	r3, [r3, #0]
10003ff8:	3318      	adds	r3, #24
10003ffa:	687a      	ldr	r2, [r7, #4]
10003ffc:	1c10      	adds	r0, r2, #0
10003ffe:	1c19      	adds	r1, r3, #0
10004000:	f7fe ff56 	bl	10002eb0 <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
10004004:	683b      	ldr	r3, [r7, #0]
10004006:	1c18      	adds	r0, r3, #0
10004008:	2101      	movs	r1, #1
1000400a:	f000 fa27 	bl	1000445c <prvAddCurrentTaskToDelayedList>
}
1000400e:	46bd      	mov	sp, r7
10004010:	b002      	add	sp, #8
10004012:	bd80      	pop	{r7, pc}
10004014:	200006d8 	.word	0x200006d8

10004018 <vTaskPlaceOnEventListRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vTaskPlaceOnEventListRestricted( List_t * const pxEventList,
                                          TickType_t xTicksToWait,
                                          const BaseType_t xWaitIndefinitely )
    {
10004018:	b580      	push	{r7, lr}
1000401a:	b084      	sub	sp, #16
1000401c:	af00      	add	r7, sp, #0
1000401e:	60f8      	str	r0, [r7, #12]
10004020:	60b9      	str	r1, [r7, #8]
10004022:	607a      	str	r2, [r7, #4]
        configASSERT( pxEventList );
10004024:	68fb      	ldr	r3, [r7, #12]
10004026:	2b00      	cmp	r3, #0
10004028:	d101      	bne.n	1000402e <vTaskPlaceOnEventListRestricted+0x16>
1000402a:	b672      	cpsid	i
1000402c:	e7fe      	b.n	1000402c <vTaskPlaceOnEventListRestricted+0x14>

        /* Place the event list item of the TCB in the appropriate event list.
         * In this case it is assume that this is the only task that is going to
         * be waiting on this event list, so the faster vListInsertEnd() function
         * can be used in place of vListInsert. */
        vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
1000402e:	4b0b      	ldr	r3, [pc, #44]	; (1000405c <vTaskPlaceOnEventListRestricted+0x44>)
10004030:	681b      	ldr	r3, [r3, #0]
10004032:	3318      	adds	r3, #24
10004034:	68fa      	ldr	r2, [r7, #12]
10004036:	1c10      	adds	r0, r2, #0
10004038:	1c19      	adds	r1, r3, #0
1000403a:	f7fe ff17 	bl	10002e6c <vListInsertEnd>

        /* If the task should block indefinitely then set the block time to a
         * value that will be recognised as an indefinite delay inside the
         * prvAddCurrentTaskToDelayedList() function. */
        if( xWaitIndefinitely != pdFALSE )
1000403e:	687b      	ldr	r3, [r7, #4]
10004040:	2b00      	cmp	r3, #0
10004042:	d002      	beq.n	1000404a <vTaskPlaceOnEventListRestricted+0x32>
        {
            xTicksToWait = portMAX_DELAY;
10004044:	2301      	movs	r3, #1
10004046:	425b      	negs	r3, r3
10004048:	60bb      	str	r3, [r7, #8]
        }

        traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
        prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
1000404a:	68ba      	ldr	r2, [r7, #8]
1000404c:	687b      	ldr	r3, [r7, #4]
1000404e:	1c10      	adds	r0, r2, #0
10004050:	1c19      	adds	r1, r3, #0
10004052:	f000 fa03 	bl	1000445c <prvAddCurrentTaskToDelayedList>
    }
10004056:	46bd      	mov	sp, r7
10004058:	b004      	add	sp, #16
1000405a:	bd80      	pop	{r7, pc}
1000405c:	200006d8 	.word	0x200006d8

10004060 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
10004060:	b580      	push	{r7, lr}
10004062:	b084      	sub	sp, #16
10004064:	af00      	add	r7, sp, #0
10004066:	6078      	str	r0, [r7, #4]
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
10004068:	687b      	ldr	r3, [r7, #4]
1000406a:	68db      	ldr	r3, [r3, #12]
1000406c:	68db      	ldr	r3, [r3, #12]
1000406e:	60bb      	str	r3, [r7, #8]
    configASSERT( pxUnblockedTCB );
10004070:	68bb      	ldr	r3, [r7, #8]
10004072:	2b00      	cmp	r3, #0
10004074:	d101      	bne.n	1000407a <xTaskRemoveFromEventList+0x1a>
10004076:	b672      	cpsid	i
10004078:	e7fe      	b.n	10004078 <xTaskRemoveFromEventList+0x18>
    ( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
1000407a:	68bb      	ldr	r3, [r7, #8]
1000407c:	3318      	adds	r3, #24
1000407e:	1c18      	adds	r0, r3, #0
10004080:	f7fe ff4c 	bl	10002f1c <uxListRemove>

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
10004084:	4b1e      	ldr	r3, [pc, #120]	; (10004100 <xTaskRemoveFromEventList+0xa0>)
10004086:	681b      	ldr	r3, [r3, #0]
10004088:	2b00      	cmp	r3, #0
1000408a:	d11d      	bne.n	100040c8 <xTaskRemoveFromEventList+0x68>
    {
        ( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
1000408c:	68bb      	ldr	r3, [r7, #8]
1000408e:	3304      	adds	r3, #4
10004090:	1c18      	adds	r0, r3, #0
10004092:	f7fe ff43 	bl	10002f1c <uxListRemove>
        prvAddTaskToReadyList( pxUnblockedTCB );
10004096:	68bb      	ldr	r3, [r7, #8]
10004098:	6ada      	ldr	r2, [r3, #44]	; 0x2c
1000409a:	4b1a      	ldr	r3, [pc, #104]	; (10004104 <xTaskRemoveFromEventList+0xa4>)
1000409c:	681b      	ldr	r3, [r3, #0]
1000409e:	429a      	cmp	r2, r3
100040a0:	d903      	bls.n	100040aa <xTaskRemoveFromEventList+0x4a>
100040a2:	68bb      	ldr	r3, [r7, #8]
100040a4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
100040a6:	4b17      	ldr	r3, [pc, #92]	; (10004104 <xTaskRemoveFromEventList+0xa4>)
100040a8:	601a      	str	r2, [r3, #0]
100040aa:	68bb      	ldr	r3, [r7, #8]
100040ac:	6ada      	ldr	r2, [r3, #44]	; 0x2c
100040ae:	1c13      	adds	r3, r2, #0
100040b0:	009b      	lsls	r3, r3, #2
100040b2:	189b      	adds	r3, r3, r2
100040b4:	009b      	lsls	r3, r3, #2
100040b6:	4a14      	ldr	r2, [pc, #80]	; (10004108 <xTaskRemoveFromEventList+0xa8>)
100040b8:	189a      	adds	r2, r3, r2
100040ba:	68bb      	ldr	r3, [r7, #8]
100040bc:	3304      	adds	r3, #4
100040be:	1c10      	adds	r0, r2, #0
100040c0:	1c19      	adds	r1, r3, #0
100040c2:	f7fe fed3 	bl	10002e6c <vListInsertEnd>
100040c6:	e006      	b.n	100040d6 <xTaskRemoveFromEventList+0x76>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
100040c8:	68bb      	ldr	r3, [r7, #8]
100040ca:	3318      	adds	r3, #24
100040cc:	4a0f      	ldr	r2, [pc, #60]	; (1000410c <xTaskRemoveFromEventList+0xac>)
100040ce:	1c10      	adds	r0, r2, #0
100040d0:	1c19      	adds	r1, r3, #0
100040d2:	f7fe fecb 	bl	10002e6c <vListInsertEnd>
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
100040d6:	68bb      	ldr	r3, [r7, #8]
100040d8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
100040da:	4b0d      	ldr	r3, [pc, #52]	; (10004110 <xTaskRemoveFromEventList+0xb0>)
100040dc:	681b      	ldr	r3, [r3, #0]
100040de:	6adb      	ldr	r3, [r3, #44]	; 0x2c
100040e0:	429a      	cmp	r2, r3
100040e2:	d905      	bls.n	100040f0 <xTaskRemoveFromEventList+0x90>
    {
        /* Return true if the task removed from the event list has a higher
         * priority than the calling task.  This allows the calling task to know if
         * it should force a context switch now. */
        xReturn = pdTRUE;
100040e4:	2301      	movs	r3, #1
100040e6:	60fb      	str	r3, [r7, #12]

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
100040e8:	4b0a      	ldr	r3, [pc, #40]	; (10004114 <xTaskRemoveFromEventList+0xb4>)
100040ea:	2201      	movs	r2, #1
100040ec:	601a      	str	r2, [r3, #0]
100040ee:	e001      	b.n	100040f4 <xTaskRemoveFromEventList+0x94>
    }
    else
    {
        xReturn = pdFALSE;
100040f0:	2300      	movs	r3, #0
100040f2:	60fb      	str	r3, [r7, #12]
    }

    return xReturn;
100040f4:	68fb      	ldr	r3, [r7, #12]
}
100040f6:	1c18      	adds	r0, r3, #0
100040f8:	46bd      	mov	sp, r7
100040fa:	b004      	add	sp, #16
100040fc:	bd80      	pop	{r7, pc}
100040fe:	46c0      	nop			; (mov r8, r8)
10004100:	200007d8 	.word	0x200007d8
10004104:	200007b8 	.word	0x200007b8
10004108:	200006dc 	.word	0x200006dc
1000410c:	20000770 	.word	0x20000770
10004110:	200006d8 	.word	0x200006d8
10004114:	200007c4 	.word	0x200007c4

10004118 <vTaskInternalSetTimeOutState>:
    taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
10004118:	b580      	push	{r7, lr}
1000411a:	b082      	sub	sp, #8
1000411c:	af00      	add	r7, sp, #0
1000411e:	6078      	str	r0, [r7, #4]
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
10004120:	4b05      	ldr	r3, [pc, #20]	; (10004138 <vTaskInternalSetTimeOutState+0x20>)
10004122:	681a      	ldr	r2, [r3, #0]
10004124:	687b      	ldr	r3, [r7, #4]
10004126:	601a      	str	r2, [r3, #0]
    pxTimeOut->xTimeOnEntering = xTickCount;
10004128:	4b04      	ldr	r3, [pc, #16]	; (1000413c <vTaskInternalSetTimeOutState+0x24>)
1000412a:	681a      	ldr	r2, [r3, #0]
1000412c:	687b      	ldr	r3, [r7, #4]
1000412e:	605a      	str	r2, [r3, #4]
}
10004130:	46bd      	mov	sp, r7
10004132:	b002      	add	sp, #8
10004134:	bd80      	pop	{r7, pc}
10004136:	46c0      	nop			; (mov r8, r8)
10004138:	200007c8 	.word	0x200007c8
1000413c:	200007b4 	.word	0x200007b4

10004140 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
10004140:	b580      	push	{r7, lr}
10004142:	b086      	sub	sp, #24
10004144:	af00      	add	r7, sp, #0
10004146:	6078      	str	r0, [r7, #4]
10004148:	6039      	str	r1, [r7, #0]
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
1000414a:	687b      	ldr	r3, [r7, #4]
1000414c:	2b00      	cmp	r3, #0
1000414e:	d101      	bne.n	10004154 <xTaskCheckForTimeOut+0x14>
10004150:	b672      	cpsid	i
10004152:	e7fe      	b.n	10004152 <xTaskCheckForTimeOut+0x12>
    configASSERT( pxTicksToWait );
10004154:	683b      	ldr	r3, [r7, #0]
10004156:	2b00      	cmp	r3, #0
10004158:	d101      	bne.n	1000415e <xTaskCheckForTimeOut+0x1e>
1000415a:	b672      	cpsid	i
1000415c:	e7fe      	b.n	1000415c <xTaskCheckForTimeOut+0x1c>

    taskENTER_CRITICAL();
1000415e:	f7fe fda1 	bl	10002ca4 <vPortEnterCritical>
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
10004162:	4b26      	ldr	r3, [pc, #152]	; (100041fc <xTaskCheckForTimeOut+0xbc>)
10004164:	681b      	ldr	r3, [r3, #0]
10004166:	613b      	str	r3, [r7, #16]
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
10004168:	687b      	ldr	r3, [r7, #4]
1000416a:	685b      	ldr	r3, [r3, #4]
1000416c:	693a      	ldr	r2, [r7, #16]
1000416e:	1ad3      	subs	r3, r2, r3
10004170:	60fb      	str	r3, [r7, #12]

        #if ( INCLUDE_xTaskAbortDelay == 1 )
            if( pxCurrentTCB->ucDelayAborted != ( uint8_t ) pdFALSE )
10004172:	4b23      	ldr	r3, [pc, #140]	; (10004200 <xTaskCheckForTimeOut+0xc0>)
10004174:	681b      	ldr	r3, [r3, #0]
10004176:	226d      	movs	r2, #109	; 0x6d
10004178:	5c9b      	ldrb	r3, [r3, r2]
1000417a:	2b00      	cmp	r3, #0
1000417c:	d007      	beq.n	1000418e <xTaskCheckForTimeOut+0x4e>
            {
                /* The delay was aborted, which is not the same as a time out,
                 * but has the same result. */
                pxCurrentTCB->ucDelayAborted = pdFALSE;
1000417e:	4b20      	ldr	r3, [pc, #128]	; (10004200 <xTaskCheckForTimeOut+0xc0>)
10004180:	681b      	ldr	r3, [r3, #0]
10004182:	226d      	movs	r2, #109	; 0x6d
10004184:	2100      	movs	r1, #0
10004186:	5499      	strb	r1, [r3, r2]
                xReturn = pdTRUE;
10004188:	2301      	movs	r3, #1
1000418a:	617b      	str	r3, [r7, #20]
1000418c:	e02e      	b.n	100041ec <xTaskCheckForTimeOut+0xac>
            }
            else
        #endif

        #if ( INCLUDE_vTaskSuspend == 1 )
            if( *pxTicksToWait == portMAX_DELAY )
1000418e:	683b      	ldr	r3, [r7, #0]
10004190:	681b      	ldr	r3, [r3, #0]
10004192:	3301      	adds	r3, #1
10004194:	d102      	bne.n	1000419c <xTaskCheckForTimeOut+0x5c>
            {
                /* If INCLUDE_vTaskSuspend is set to 1 and the block time
                 * specified is the maximum block time then the task should block
                 * indefinitely, and therefore never time out. */
                xReturn = pdFALSE;
10004196:	2300      	movs	r3, #0
10004198:	617b      	str	r3, [r7, #20]
1000419a:	e027      	b.n	100041ec <xTaskCheckForTimeOut+0xac>
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
1000419c:	687b      	ldr	r3, [r7, #4]
1000419e:	681a      	ldr	r2, [r3, #0]
100041a0:	4b18      	ldr	r3, [pc, #96]	; (10004204 <xTaskCheckForTimeOut+0xc4>)
100041a2:	681b      	ldr	r3, [r3, #0]
100041a4:	429a      	cmp	r2, r3
100041a6:	d00a      	beq.n	100041be <xTaskCheckForTimeOut+0x7e>
100041a8:	687b      	ldr	r3, [r7, #4]
100041aa:	685a      	ldr	r2, [r3, #4]
100041ac:	693b      	ldr	r3, [r7, #16]
100041ae:	429a      	cmp	r2, r3
100041b0:	d805      	bhi.n	100041be <xTaskCheckForTimeOut+0x7e>
            /* The tick count is greater than the time at which
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
100041b2:	2301      	movs	r3, #1
100041b4:	617b      	str	r3, [r7, #20]
            *pxTicksToWait = ( TickType_t ) 0;
100041b6:	683b      	ldr	r3, [r7, #0]
100041b8:	2200      	movs	r2, #0
100041ba:	601a      	str	r2, [r3, #0]
100041bc:	e016      	b.n	100041ec <xTaskCheckForTimeOut+0xac>
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
100041be:	683b      	ldr	r3, [r7, #0]
100041c0:	681a      	ldr	r2, [r3, #0]
100041c2:	68fb      	ldr	r3, [r7, #12]
100041c4:	429a      	cmp	r2, r3
100041c6:	d90c      	bls.n	100041e2 <xTaskCheckForTimeOut+0xa2>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
100041c8:	683b      	ldr	r3, [r7, #0]
100041ca:	681a      	ldr	r2, [r3, #0]
100041cc:	68fb      	ldr	r3, [r7, #12]
100041ce:	1ad2      	subs	r2, r2, r3
100041d0:	683b      	ldr	r3, [r7, #0]
100041d2:	601a      	str	r2, [r3, #0]
            vTaskInternalSetTimeOutState( pxTimeOut );
100041d4:	687b      	ldr	r3, [r7, #4]
100041d6:	1c18      	adds	r0, r3, #0
100041d8:	f7ff ff9e 	bl	10004118 <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
100041dc:	2300      	movs	r3, #0
100041de:	617b      	str	r3, [r7, #20]
100041e0:	e004      	b.n	100041ec <xTaskCheckForTimeOut+0xac>
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
100041e2:	683b      	ldr	r3, [r7, #0]
100041e4:	2200      	movs	r2, #0
100041e6:	601a      	str	r2, [r3, #0]
            xReturn = pdTRUE;
100041e8:	2301      	movs	r3, #1
100041ea:	617b      	str	r3, [r7, #20]
        }
    }
    taskEXIT_CRITICAL();
100041ec:	f7fe fd6a 	bl	10002cc4 <vPortExitCritical>

    return xReturn;
100041f0:	697b      	ldr	r3, [r7, #20]
}
100041f2:	1c18      	adds	r0, r3, #0
100041f4:	46bd      	mov	sp, r7
100041f6:	b006      	add	sp, #24
100041f8:	bd80      	pop	{r7, pc}
100041fa:	46c0      	nop			; (mov r8, r8)
100041fc:	200007b4 	.word	0x200007b4
10004200:	200006d8 	.word	0x200006d8
10004204:	200007c8 	.word	0x200007c8

10004208 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
10004208:	b580      	push	{r7, lr}
1000420a:	af00      	add	r7, sp, #0
    xYieldPending = pdTRUE;
1000420c:	4b02      	ldr	r3, [pc, #8]	; (10004218 <vTaskMissedYield+0x10>)
1000420e:	2201      	movs	r2, #1
10004210:	601a      	str	r2, [r3, #0]
}
10004212:	46bd      	mov	sp, r7
10004214:	bd80      	pop	{r7, pc}
10004216:	46c0      	nop			; (mov r8, r8)
10004218:	200007c4 	.word	0x200007c4

1000421c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
1000421c:	b580      	push	{r7, lr}
1000421e:	b082      	sub	sp, #8
10004220:	af00      	add	r7, sp, #0
10004222:	6078      	str	r0, [r7, #4]

    for( ; ; )
    {
        /* See if any tasks have deleted themselves - if so then the idle task
         * is responsible for freeing the deleted task's TCB and stack. */
        prvCheckTasksWaitingTermination();
10004224:	f000 f84e 	bl	100042c4 <prvCheckTasksWaitingTermination>
                 *
                 * A critical region is not required here as we are just reading from
                 * the list, and an occasional incorrect value will not matter.  If
                 * the ready list at the idle priority contains more than one task
                 * then a task other than the idle task is ready to execute. */
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
10004228:	4b03      	ldr	r3, [pc, #12]	; (10004238 <prvIdleTask+0x1c>)
1000422a:	681b      	ldr	r3, [r3, #0]
1000422c:	2b01      	cmp	r3, #1
1000422e:	d901      	bls.n	10004234 <prvIdleTask+0x18>
                {
                    taskYIELD();
10004230:	f7fe fd2a 	bl	10002c88 <vPortYield>
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configUSE_TICKLESS_IDLE */
    }
10004234:	e7f6      	b.n	10004224 <prvIdleTask+0x8>
10004236:	46c0      	nop			; (mov r8, r8)
10004238:	200006dc 	.word	0x200006dc

1000423c <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
1000423c:	b580      	push	{r7, lr}
1000423e:	b082      	sub	sp, #8
10004240:	af00      	add	r7, sp, #0
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
10004242:	2300      	movs	r3, #0
10004244:	607b      	str	r3, [r7, #4]
10004246:	e00c      	b.n	10004262 <prvInitialiseTaskLists+0x26>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
10004248:	687a      	ldr	r2, [r7, #4]
1000424a:	1c13      	adds	r3, r2, #0
1000424c:	009b      	lsls	r3, r3, #2
1000424e:	189b      	adds	r3, r3, r2
10004250:	009b      	lsls	r3, r3, #2
10004252:	4a14      	ldr	r2, [pc, #80]	; (100042a4 <prvInitialiseTaskLists+0x68>)
10004254:	189b      	adds	r3, r3, r2
10004256:	1c18      	adds	r0, r3, #0
10004258:	f7fe fde0 	bl	10002e1c <vListInitialise>

static void prvInitialiseTaskLists( void )
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
1000425c:	687b      	ldr	r3, [r7, #4]
1000425e:	3301      	adds	r3, #1
10004260:	607b      	str	r3, [r7, #4]
10004262:	687b      	ldr	r3, [r7, #4]
10004264:	2b04      	cmp	r3, #4
10004266:	d9ef      	bls.n	10004248 <prvInitialiseTaskLists+0xc>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    }

    vListInitialise( &xDelayedTaskList1 );
10004268:	4b0f      	ldr	r3, [pc, #60]	; (100042a8 <prvInitialiseTaskLists+0x6c>)
1000426a:	1c18      	adds	r0, r3, #0
1000426c:	f7fe fdd6 	bl	10002e1c <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
10004270:	4b0e      	ldr	r3, [pc, #56]	; (100042ac <prvInitialiseTaskLists+0x70>)
10004272:	1c18      	adds	r0, r3, #0
10004274:	f7fe fdd2 	bl	10002e1c <vListInitialise>
    vListInitialise( &xPendingReadyList );
10004278:	4b0d      	ldr	r3, [pc, #52]	; (100042b0 <prvInitialiseTaskLists+0x74>)
1000427a:	1c18      	adds	r0, r3, #0
1000427c:	f7fe fdce 	bl	10002e1c <vListInitialise>

    #if ( INCLUDE_vTaskDelete == 1 )
        {
            vListInitialise( &xTasksWaitingTermination );
10004280:	4b0c      	ldr	r3, [pc, #48]	; (100042b4 <prvInitialiseTaskLists+0x78>)
10004282:	1c18      	adds	r0, r3, #0
10004284:	f7fe fdca 	bl	10002e1c <vListInitialise>
        }
    #endif /* INCLUDE_vTaskDelete */

    #if ( INCLUDE_vTaskSuspend == 1 )
        {
            vListInitialise( &xSuspendedTaskList );
10004288:	4b0b      	ldr	r3, [pc, #44]	; (100042b8 <prvInitialiseTaskLists+0x7c>)
1000428a:	1c18      	adds	r0, r3, #0
1000428c:	f7fe fdc6 	bl	10002e1c <vListInitialise>
        }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
10004290:	4b0a      	ldr	r3, [pc, #40]	; (100042bc <prvInitialiseTaskLists+0x80>)
10004292:	4a05      	ldr	r2, [pc, #20]	; (100042a8 <prvInitialiseTaskLists+0x6c>)
10004294:	601a      	str	r2, [r3, #0]
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
10004296:	4b0a      	ldr	r3, [pc, #40]	; (100042c0 <prvInitialiseTaskLists+0x84>)
10004298:	4a04      	ldr	r2, [pc, #16]	; (100042ac <prvInitialiseTaskLists+0x70>)
1000429a:	601a      	str	r2, [r3, #0]
}
1000429c:	46bd      	mov	sp, r7
1000429e:	b002      	add	sp, #8
100042a0:	bd80      	pop	{r7, pc}
100042a2:	46c0      	nop			; (mov r8, r8)
100042a4:	200006dc 	.word	0x200006dc
100042a8:	20000740 	.word	0x20000740
100042ac:	20000754 	.word	0x20000754
100042b0:	20000770 	.word	0x20000770
100042b4:	20000784 	.word	0x20000784
100042b8:	2000079c 	.word	0x2000079c
100042bc:	20000768 	.word	0x20000768
100042c0:	2000076c 	.word	0x2000076c

100042c4 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
100042c4:	b580      	push	{r7, lr}
100042c6:	b082      	sub	sp, #8
100042c8:	af00      	add	r7, sp, #0
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
100042ca:	e01a      	b.n	10004302 <prvCheckTasksWaitingTermination+0x3e>
            {
                taskENTER_CRITICAL();
100042cc:	f7fe fcea 	bl	10002ca4 <vPortEnterCritical>
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
100042d0:	4b0f      	ldr	r3, [pc, #60]	; (10004310 <prvCheckTasksWaitingTermination+0x4c>)
100042d2:	68db      	ldr	r3, [r3, #12]
100042d4:	68db      	ldr	r3, [r3, #12]
100042d6:	607b      	str	r3, [r7, #4]
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
100042d8:	687b      	ldr	r3, [r7, #4]
100042da:	3304      	adds	r3, #4
100042dc:	1c18      	adds	r0, r3, #0
100042de:	f7fe fe1d 	bl	10002f1c <uxListRemove>
                    --uxCurrentNumberOfTasks;
100042e2:	4b0c      	ldr	r3, [pc, #48]	; (10004314 <prvCheckTasksWaitingTermination+0x50>)
100042e4:	681b      	ldr	r3, [r3, #0]
100042e6:	1e5a      	subs	r2, r3, #1
100042e8:	4b0a      	ldr	r3, [pc, #40]	; (10004314 <prvCheckTasksWaitingTermination+0x50>)
100042ea:	601a      	str	r2, [r3, #0]
                    --uxDeletedTasksWaitingCleanUp;
100042ec:	4b0a      	ldr	r3, [pc, #40]	; (10004318 <prvCheckTasksWaitingTermination+0x54>)
100042ee:	681b      	ldr	r3, [r3, #0]
100042f0:	1e5a      	subs	r2, r3, #1
100042f2:	4b09      	ldr	r3, [pc, #36]	; (10004318 <prvCheckTasksWaitingTermination+0x54>)
100042f4:	601a      	str	r2, [r3, #0]
                }
                taskEXIT_CRITICAL();
100042f6:	f7fe fce5 	bl	10002cc4 <vPortExitCritical>

                prvDeleteTCB( pxTCB );
100042fa:	687b      	ldr	r3, [r7, #4]
100042fc:	1c18      	adds	r0, r3, #0
100042fe:	f000 f80d 	bl	1000431c <prvDeleteTCB>
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
10004302:	4b05      	ldr	r3, [pc, #20]	; (10004318 <prvCheckTasksWaitingTermination+0x54>)
10004304:	681b      	ldr	r3, [r3, #0]
10004306:	2b00      	cmp	r3, #0
10004308:	d1e0      	bne.n	100042cc <prvCheckTasksWaitingTermination+0x8>

                prvDeleteTCB( pxTCB );
            }
        }
    #endif /* INCLUDE_vTaskDelete */
}
1000430a:	46bd      	mov	sp, r7
1000430c:	b002      	add	sp, #8
1000430e:	bd80      	pop	{r7, pc}
10004310:	20000784 	.word	0x20000784
10004314:	200007b0 	.word	0x200007b0
10004318:	20000798 	.word	0x20000798

1000431c <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    static void prvDeleteTCB( TCB_t * pxTCB )
    {
1000431c:	b580      	push	{r7, lr}
1000431e:	b082      	sub	sp, #8
10004320:	af00      	add	r7, sp, #0
10004322:	6078      	str	r0, [r7, #4]

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
            {
                /* The task can only have been allocated dynamically - free both
                 * the stack and TCB. */
                vPortFree( pxTCB->pxStack );
10004324:	687b      	ldr	r3, [r7, #4]
10004326:	6b1b      	ldr	r3, [r3, #48]	; 0x30
10004328:	1c18      	adds	r0, r3, #0
1000432a:	f7fe fd65 	bl	10002df8 <vPortFree>
                vPortFree( pxTCB );
1000432e:	687b      	ldr	r3, [r7, #4]
10004330:	1c18      	adds	r0, r3, #0
10004332:	f7fe fd61 	bl	10002df8 <vPortFree>
                    configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
10004336:	46bd      	mov	sp, r7
10004338:	b002      	add	sp, #8
1000433a:	bd80      	pop	{r7, pc}

1000433c <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
1000433c:	b580      	push	{r7, lr}
1000433e:	af00      	add	r7, sp, #0
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
10004340:	4b08      	ldr	r3, [pc, #32]	; (10004364 <prvResetNextTaskUnblockTime+0x28>)
10004342:	681b      	ldr	r3, [r3, #0]
10004344:	681b      	ldr	r3, [r3, #0]
10004346:	2b00      	cmp	r3, #0
10004348:	d104      	bne.n	10004354 <prvResetNextTaskUnblockTime+0x18>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
1000434a:	4b07      	ldr	r3, [pc, #28]	; (10004368 <prvResetNextTaskUnblockTime+0x2c>)
1000434c:	2201      	movs	r2, #1
1000434e:	4252      	negs	r2, r2
10004350:	601a      	str	r2, [r3, #0]
10004352:	e005      	b.n	10004360 <prvResetNextTaskUnblockTime+0x24>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
10004354:	4b03      	ldr	r3, [pc, #12]	; (10004364 <prvResetNextTaskUnblockTime+0x28>)
10004356:	681b      	ldr	r3, [r3, #0]
10004358:	68db      	ldr	r3, [r3, #12]
1000435a:	681a      	ldr	r2, [r3, #0]
1000435c:	4b02      	ldr	r3, [pc, #8]	; (10004368 <prvResetNextTaskUnblockTime+0x2c>)
1000435e:	601a      	str	r2, [r3, #0]
    }
}
10004360:	46bd      	mov	sp, r7
10004362:	bd80      	pop	{r7, pc}
10004364:	20000768 	.word	0x20000768
10004368:	200007d0 	.word	0x200007d0

1000436c <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

    BaseType_t xTaskGetSchedulerState( void )
    {
1000436c:	b580      	push	{r7, lr}
1000436e:	b082      	sub	sp, #8
10004370:	af00      	add	r7, sp, #0
        BaseType_t xReturn;

        if( xSchedulerRunning == pdFALSE )
10004372:	4b0a      	ldr	r3, [pc, #40]	; (1000439c <xTaskGetSchedulerState+0x30>)
10004374:	681b      	ldr	r3, [r3, #0]
10004376:	2b00      	cmp	r3, #0
10004378:	d102      	bne.n	10004380 <xTaskGetSchedulerState+0x14>
        {
            xReturn = taskSCHEDULER_NOT_STARTED;
1000437a:	2301      	movs	r3, #1
1000437c:	607b      	str	r3, [r7, #4]
1000437e:	e008      	b.n	10004392 <xTaskGetSchedulerState+0x26>
        }
        else
        {
            if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
10004380:	4b07      	ldr	r3, [pc, #28]	; (100043a0 <xTaskGetSchedulerState+0x34>)
10004382:	681b      	ldr	r3, [r3, #0]
10004384:	2b00      	cmp	r3, #0
10004386:	d102      	bne.n	1000438e <xTaskGetSchedulerState+0x22>
            {
                xReturn = taskSCHEDULER_RUNNING;
10004388:	2302      	movs	r3, #2
1000438a:	607b      	str	r3, [r7, #4]
1000438c:	e001      	b.n	10004392 <xTaskGetSchedulerState+0x26>
            }
            else
            {
                xReturn = taskSCHEDULER_SUSPENDED;
1000438e:	2300      	movs	r3, #0
10004390:	607b      	str	r3, [r7, #4]
            }
        }

        return xReturn;
10004392:	687b      	ldr	r3, [r7, #4]
    }
10004394:	1c18      	adds	r0, r3, #0
10004396:	46bd      	mov	sp, r7
10004398:	b002      	add	sp, #8
1000439a:	bd80      	pop	{r7, pc}
1000439c:	200007bc 	.word	0x200007bc
100043a0:	200007d8 	.word	0x200007d8

100043a4 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
100043a4:	b580      	push	{r7, lr}
100043a6:	b084      	sub	sp, #16
100043a8:	af00      	add	r7, sp, #0
100043aa:	6078      	str	r0, [r7, #4]
        TCB_t * const pxTCB = pxMutexHolder;
100043ac:	687b      	ldr	r3, [r7, #4]
100043ae:	60bb      	str	r3, [r7, #8]
        BaseType_t xReturn = pdFALSE;
100043b0:	2300      	movs	r3, #0
100043b2:	60fb      	str	r3, [r7, #12]

        if( pxMutexHolder != NULL )
100043b4:	687b      	ldr	r3, [r7, #4]
100043b6:	2b00      	cmp	r3, #0
100043b8:	d044      	beq.n	10004444 <xTaskPriorityDisinherit+0xa0>
        {
            /* A task can only have an inherited priority if it holds the mutex.
             * If the mutex is held by a task then it cannot be given from an
             * interrupt, and if a mutex is given by the holding task then it must
             * be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
100043ba:	4b25      	ldr	r3, [pc, #148]	; (10004450 <xTaskPriorityDisinherit+0xac>)
100043bc:	681b      	ldr	r3, [r3, #0]
100043be:	68ba      	ldr	r2, [r7, #8]
100043c0:	429a      	cmp	r2, r3
100043c2:	d001      	beq.n	100043c8 <xTaskPriorityDisinherit+0x24>
100043c4:	b672      	cpsid	i
100043c6:	e7fe      	b.n	100043c6 <xTaskPriorityDisinherit+0x22>
            configASSERT( pxTCB->uxMutexesHeld );
100043c8:	68bb      	ldr	r3, [r7, #8]
100043ca:	6d1b      	ldr	r3, [r3, #80]	; 0x50
100043cc:	2b00      	cmp	r3, #0
100043ce:	d101      	bne.n	100043d4 <xTaskPriorityDisinherit+0x30>
100043d0:	b672      	cpsid	i
100043d2:	e7fe      	b.n	100043d2 <xTaskPriorityDisinherit+0x2e>
            ( pxTCB->uxMutexesHeld )--;
100043d4:	68bb      	ldr	r3, [r7, #8]
100043d6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
100043d8:	1e5a      	subs	r2, r3, #1
100043da:	68bb      	ldr	r3, [r7, #8]
100043dc:	651a      	str	r2, [r3, #80]	; 0x50

            /* Has the holder of the mutex inherited the priority of another
             * task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
100043de:	68bb      	ldr	r3, [r7, #8]
100043e0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
100043e2:	68bb      	ldr	r3, [r7, #8]
100043e4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
100043e6:	429a      	cmp	r2, r3
100043e8:	d02c      	beq.n	10004444 <xTaskPriorityDisinherit+0xa0>
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
100043ea:	68bb      	ldr	r3, [r7, #8]
100043ec:	6d1b      	ldr	r3, [r3, #80]	; 0x50
100043ee:	2b00      	cmp	r3, #0
100043f0:	d128      	bne.n	10004444 <xTaskPriorityDisinherit+0xa0>
                    /* A task can only have an inherited priority if it holds
                     * the mutex.  If the mutex is held by a task then it cannot be
                     * given from an interrupt, and if a mutex is given by the
                     * holding task then it must be the running state task.  Remove
                     * the holding task from the ready list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
100043f2:	68bb      	ldr	r3, [r7, #8]
100043f4:	3304      	adds	r3, #4
100043f6:	1c18      	adds	r0, r3, #0
100043f8:	f7fe fd90 	bl	10002f1c <uxListRemove>
                    }

                    /* Disinherit the priority before adding the task into the
                     * new  ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
100043fc:	68bb      	ldr	r3, [r7, #8]
100043fe:	6cda      	ldr	r2, [r3, #76]	; 0x4c
10004400:	68bb      	ldr	r3, [r7, #8]
10004402:	62da      	str	r2, [r3, #44]	; 0x2c

                    /* Reset the event list item value.  It cannot be in use for
                     * any other purpose if this task is running, and it must be
                     * running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
10004404:	68bb      	ldr	r3, [r7, #8]
10004406:	6adb      	ldr	r3, [r3, #44]	; 0x2c
10004408:	2205      	movs	r2, #5
1000440a:	1ad2      	subs	r2, r2, r3
1000440c:	68bb      	ldr	r3, [r7, #8]
1000440e:	619a      	str	r2, [r3, #24]
                    prvAddTaskToReadyList( pxTCB );
10004410:	68bb      	ldr	r3, [r7, #8]
10004412:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10004414:	4b0f      	ldr	r3, [pc, #60]	; (10004454 <xTaskPriorityDisinherit+0xb0>)
10004416:	681b      	ldr	r3, [r3, #0]
10004418:	429a      	cmp	r2, r3
1000441a:	d903      	bls.n	10004424 <xTaskPriorityDisinherit+0x80>
1000441c:	68bb      	ldr	r3, [r7, #8]
1000441e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10004420:	4b0c      	ldr	r3, [pc, #48]	; (10004454 <xTaskPriorityDisinherit+0xb0>)
10004422:	601a      	str	r2, [r3, #0]
10004424:	68bb      	ldr	r3, [r7, #8]
10004426:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10004428:	1c13      	adds	r3, r2, #0
1000442a:	009b      	lsls	r3, r3, #2
1000442c:	189b      	adds	r3, r3, r2
1000442e:	009b      	lsls	r3, r3, #2
10004430:	4a09      	ldr	r2, [pc, #36]	; (10004458 <xTaskPriorityDisinherit+0xb4>)
10004432:	189a      	adds	r2, r3, r2
10004434:	68bb      	ldr	r3, [r7, #8]
10004436:	3304      	adds	r3, #4
10004438:	1c10      	adds	r0, r2, #0
1000443a:	1c19      	adds	r1, r3, #0
1000443c:	f7fe fd16 	bl	10002e6c <vListInsertEnd>
                     * in an order different to that in which they were taken.
                     * If a context switch did not occur when the first mutex was
                     * returned, even if a task was waiting on it, then a context
                     * switch should occur when the last mutex is returned whether
                     * a task is waiting on it or not. */
                    xReturn = pdTRUE;
10004440:	2301      	movs	r3, #1
10004442:	60fb      	str	r3, [r7, #12]
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
10004444:	68fb      	ldr	r3, [r7, #12]
    }
10004446:	1c18      	adds	r0, r3, #0
10004448:	46bd      	mov	sp, r7
1000444a:	b004      	add	sp, #16
1000444c:	bd80      	pop	{r7, pc}
1000444e:	46c0      	nop			; (mov r8, r8)
10004450:	200006d8 	.word	0x200006d8
10004454:	200007b8 	.word	0x200007b8
10004458:	200006dc 	.word	0x200006dc

1000445c <prvAddCurrentTaskToDelayedList>:
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
1000445c:	b580      	push	{r7, lr}
1000445e:	b084      	sub	sp, #16
10004460:	af00      	add	r7, sp, #0
10004462:	6078      	str	r0, [r7, #4]
10004464:	6039      	str	r1, [r7, #0]
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
10004466:	4b23      	ldr	r3, [pc, #140]	; (100044f4 <prvAddCurrentTaskToDelayedList+0x98>)
10004468:	681b      	ldr	r3, [r3, #0]
1000446a:	60fb      	str	r3, [r7, #12]
    #if ( INCLUDE_xTaskAbortDelay == 1 )
        {
            /* About to enter a delayed list, so ensure the ucDelayAborted flag is
             * reset to pdFALSE so it can be detected as having been set to pdTRUE
             * when the task leaves the Blocked state. */
            pxCurrentTCB->ucDelayAborted = pdFALSE;
1000446c:	4b22      	ldr	r3, [pc, #136]	; (100044f8 <prvAddCurrentTaskToDelayedList+0x9c>)
1000446e:	681b      	ldr	r3, [r3, #0]
10004470:	226d      	movs	r2, #109	; 0x6d
10004472:	2100      	movs	r1, #0
10004474:	5499      	strb	r1, [r3, r2]
        }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
10004476:	4b20      	ldr	r3, [pc, #128]	; (100044f8 <prvAddCurrentTaskToDelayedList+0x9c>)
10004478:	681b      	ldr	r3, [r3, #0]
1000447a:	3304      	adds	r3, #4
1000447c:	1c18      	adds	r0, r3, #0
1000447e:	f7fe fd4d 	bl	10002f1c <uxListRemove>
        mtCOVERAGE_TEST_MARKER();
    }

    #if ( INCLUDE_vTaskSuspend == 1 )
        {
            if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
10004482:	687b      	ldr	r3, [r7, #4]
10004484:	3301      	adds	r3, #1
10004486:	d10b      	bne.n	100044a0 <prvAddCurrentTaskToDelayedList+0x44>
10004488:	683b      	ldr	r3, [r7, #0]
1000448a:	2b00      	cmp	r3, #0
1000448c:	d008      	beq.n	100044a0 <prvAddCurrentTaskToDelayedList+0x44>
            {
                /* Add the task to the suspended task list instead of a delayed task
                 * list to ensure it is not woken by a timing event.  It will block
                 * indefinitely. */
                vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
1000448e:	4b1a      	ldr	r3, [pc, #104]	; (100044f8 <prvAddCurrentTaskToDelayedList+0x9c>)
10004490:	681b      	ldr	r3, [r3, #0]
10004492:	3304      	adds	r3, #4
10004494:	4a19      	ldr	r2, [pc, #100]	; (100044fc <prvAddCurrentTaskToDelayedList+0xa0>)
10004496:	1c10      	adds	r0, r2, #0
10004498:	1c19      	adds	r1, r3, #0
1000449a:	f7fe fce7 	bl	10002e6c <vListInsertEnd>
1000449e:	e026      	b.n	100044ee <prvAddCurrentTaskToDelayedList+0x92>
            else
            {
                /* Calculate the time at which the task should be woken if the event
                 * does not occur.  This may overflow but this doesn't matter, the
                 * kernel will manage it correctly. */
                xTimeToWake = xConstTickCount + xTicksToWait;
100044a0:	68fa      	ldr	r2, [r7, #12]
100044a2:	687b      	ldr	r3, [r7, #4]
100044a4:	18d3      	adds	r3, r2, r3
100044a6:	60bb      	str	r3, [r7, #8]

                /* The list item will be inserted in wake time order. */
                listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
100044a8:	4b13      	ldr	r3, [pc, #76]	; (100044f8 <prvAddCurrentTaskToDelayedList+0x9c>)
100044aa:	681b      	ldr	r3, [r3, #0]
100044ac:	68ba      	ldr	r2, [r7, #8]
100044ae:	605a      	str	r2, [r3, #4]

                if( xTimeToWake < xConstTickCount )
100044b0:	68ba      	ldr	r2, [r7, #8]
100044b2:	68fb      	ldr	r3, [r7, #12]
100044b4:	429a      	cmp	r2, r3
100044b6:	d209      	bcs.n	100044cc <prvAddCurrentTaskToDelayedList+0x70>
                {
                    /* Wake time has overflowed.  Place this item in the overflow
                     * list. */
                    vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
100044b8:	4b11      	ldr	r3, [pc, #68]	; (10004500 <prvAddCurrentTaskToDelayedList+0xa4>)
100044ba:	681a      	ldr	r2, [r3, #0]
100044bc:	4b0e      	ldr	r3, [pc, #56]	; (100044f8 <prvAddCurrentTaskToDelayedList+0x9c>)
100044be:	681b      	ldr	r3, [r3, #0]
100044c0:	3304      	adds	r3, #4
100044c2:	1c10      	adds	r0, r2, #0
100044c4:	1c19      	adds	r1, r3, #0
100044c6:	f7fe fcf3 	bl	10002eb0 <vListInsert>
100044ca:	e010      	b.n	100044ee <prvAddCurrentTaskToDelayedList+0x92>
                }
                else
                {
                    /* The wake time has not overflowed, so the current block list
                     * is used. */
                    vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
100044cc:	4b0d      	ldr	r3, [pc, #52]	; (10004504 <prvAddCurrentTaskToDelayedList+0xa8>)
100044ce:	681a      	ldr	r2, [r3, #0]
100044d0:	4b09      	ldr	r3, [pc, #36]	; (100044f8 <prvAddCurrentTaskToDelayedList+0x9c>)
100044d2:	681b      	ldr	r3, [r3, #0]
100044d4:	3304      	adds	r3, #4
100044d6:	1c10      	adds	r0, r2, #0
100044d8:	1c19      	adds	r1, r3, #0
100044da:	f7fe fce9 	bl	10002eb0 <vListInsert>

                    /* If the task entering the blocked state was placed at the
                     * head of the list of blocked tasks then xNextTaskUnblockTime
                     * needs to be updated too. */
                    if( xTimeToWake < xNextTaskUnblockTime )
100044de:	4b0a      	ldr	r3, [pc, #40]	; (10004508 <prvAddCurrentTaskToDelayedList+0xac>)
100044e0:	681b      	ldr	r3, [r3, #0]
100044e2:	68ba      	ldr	r2, [r7, #8]
100044e4:	429a      	cmp	r2, r3
100044e6:	d202      	bcs.n	100044ee <prvAddCurrentTaskToDelayedList+0x92>
                    {
                        xNextTaskUnblockTime = xTimeToWake;
100044e8:	4b07      	ldr	r3, [pc, #28]	; (10004508 <prvAddCurrentTaskToDelayedList+0xac>)
100044ea:	68ba      	ldr	r2, [r7, #8]
100044ec:	601a      	str	r2, [r3, #0]

            /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
            ( void ) xCanBlockIndefinitely;
        }
    #endif /* INCLUDE_vTaskSuspend */
}
100044ee:	46bd      	mov	sp, r7
100044f0:	b004      	add	sp, #16
100044f2:	bd80      	pop	{r7, pc}
100044f4:	200007b4 	.word	0x200007b4
100044f8:	200006d8 	.word	0x200006d8
100044fc:	2000079c 	.word	0x2000079c
10004500:	2000076c 	.word	0x2000076c
10004504:	20000768 	.word	0x20000768
10004508:	200007d0 	.word	0x200007d0

1000450c <xTimerCreateTimerTask>:
                                       TimerCallbackFunction_t pxCallbackFunction,
                                       Timer_t * pxNewTimer ) PRIVILEGED_FUNCTION;
/*-----------------------------------------------------------*/

    BaseType_t xTimerCreateTimerTask( void )
    {
1000450c:	b580      	push	{r7, lr}
1000450e:	b084      	sub	sp, #16
10004510:	af02      	add	r7, sp, #8
        BaseType_t xReturn = pdFAIL;
10004512:	2300      	movs	r3, #0
10004514:	607b      	str	r3, [r7, #4]

        /* This function is called when the scheduler is started if
         * configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
         * timer service task has been created/initialised.  If timers have already
         * been created then the initialisation will already have been performed. */
        prvCheckForValidListAndQueue();
10004516:	f000 fac9 	bl	10004aac <prvCheckForValidListAndQueue>

        if( xTimerQueue != NULL )
1000451a:	4b0e      	ldr	r3, [pc, #56]	; (10004554 <xTimerCreateTimerTask+0x48>)
1000451c:	681b      	ldr	r3, [r3, #0]
1000451e:	2b00      	cmp	r3, #0
10004520:	d00d      	beq.n	1000453e <xTimerCreateTimerTask+0x32>
                        xReturn = pdPASS;
                    }
                }
            #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
                {
                    xReturn = xTaskCreate( prvTimerTask,
10004522:	490d      	ldr	r1, [pc, #52]	; (10004558 <xTimerCreateTimerTask+0x4c>)
10004524:	4a0d      	ldr	r2, [pc, #52]	; (1000455c <xTimerCreateTimerTask+0x50>)
10004526:	2302      	movs	r3, #2
10004528:	9300      	str	r3, [sp, #0]
1000452a:	4b0d      	ldr	r3, [pc, #52]	; (10004560 <xTimerCreateTimerTask+0x54>)
1000452c:	9301      	str	r3, [sp, #4]
1000452e:	1c08      	adds	r0, r1, #0
10004530:	1c11      	adds	r1, r2, #0
10004532:	2278      	movs	r2, #120	; 0x78
10004534:	2300      	movs	r3, #0
10004536:	f7ff f9fd 	bl	10003934 <xTaskCreate>
1000453a:	1c03      	adds	r3, r0, #0
1000453c:	607b      	str	r3, [r7, #4]
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        configASSERT( xReturn );
1000453e:	687b      	ldr	r3, [r7, #4]
10004540:	2b00      	cmp	r3, #0
10004542:	d101      	bne.n	10004548 <xTimerCreateTimerTask+0x3c>
10004544:	b672      	cpsid	i
10004546:	e7fe      	b.n	10004546 <xTimerCreateTimerTask+0x3a>
        return xReturn;
10004548:	687b      	ldr	r3, [r7, #4]
    }
1000454a:	1c18      	adds	r0, r3, #0
1000454c:	46bd      	mov	sp, r7
1000454e:	b002      	add	sp, #8
10004550:	bd80      	pop	{r7, pc}
10004552:	46c0      	nop			; (mov r8, r8)
10004554:	2000080c 	.word	0x2000080c
10004558:	10004699 	.word	0x10004699
1000455c:	1000a1c4 	.word	0x1000a1c4
10004560:	20000810 	.word	0x20000810

10004564 <xTimerGenericCommand>:
    BaseType_t xTimerGenericCommand( TimerHandle_t xTimer,
                                     const BaseType_t xCommandID,
                                     const TickType_t xOptionalValue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const TickType_t xTicksToWait )
    {
10004564:	b580      	push	{r7, lr}
10004566:	b08a      	sub	sp, #40	; 0x28
10004568:	af00      	add	r7, sp, #0
1000456a:	60f8      	str	r0, [r7, #12]
1000456c:	60b9      	str	r1, [r7, #8]
1000456e:	607a      	str	r2, [r7, #4]
10004570:	603b      	str	r3, [r7, #0]
        BaseType_t xReturn = pdFAIL;
10004572:	2300      	movs	r3, #0
10004574:	627b      	str	r3, [r7, #36]	; 0x24
        DaemonTaskMessage_t xMessage;

        configASSERT( xTimer );
10004576:	68fb      	ldr	r3, [r7, #12]
10004578:	2b00      	cmp	r3, #0
1000457a:	d101      	bne.n	10004580 <xTimerGenericCommand+0x1c>
1000457c:	b672      	cpsid	i
1000457e:	e7fe      	b.n	1000457e <xTimerGenericCommand+0x1a>

        /* Send a message to the timer service task to perform a particular action
         * on a particular timer definition. */
        if( xTimerQueue != NULL )
10004580:	4b22      	ldr	r3, [pc, #136]	; (1000460c <xTimerGenericCommand+0xa8>)
10004582:	681b      	ldr	r3, [r3, #0]
10004584:	2b00      	cmp	r3, #0
10004586:	d03b      	beq.n	10004600 <xTimerGenericCommand+0x9c>
        {
            /* Send a command to the timer service task to start the xTimer timer. */
            xMessage.xMessageID = xCommandID;
10004588:	2314      	movs	r3, #20
1000458a:	18fb      	adds	r3, r7, r3
1000458c:	68ba      	ldr	r2, [r7, #8]
1000458e:	601a      	str	r2, [r3, #0]
            xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
10004590:	2314      	movs	r3, #20
10004592:	18fb      	adds	r3, r7, r3
10004594:	687a      	ldr	r2, [r7, #4]
10004596:	605a      	str	r2, [r3, #4]
            xMessage.u.xTimerParameters.pxTimer = xTimer;
10004598:	2314      	movs	r3, #20
1000459a:	18fb      	adds	r3, r7, r3
1000459c:	68fa      	ldr	r2, [r7, #12]
1000459e:	609a      	str	r2, [r3, #8]

            if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
100045a0:	68bb      	ldr	r3, [r7, #8]
100045a2:	2b05      	cmp	r3, #5
100045a4:	dc1f      	bgt.n	100045e6 <xTimerGenericCommand+0x82>
            {
                if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
100045a6:	f7ff fee1 	bl	1000436c <xTaskGetSchedulerState>
100045aa:	1e03      	subs	r3, r0, #0
100045ac:	2b02      	cmp	r3, #2
100045ae:	d10d      	bne.n	100045cc <xTimerGenericCommand+0x68>
                {
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
100045b0:	4b16      	ldr	r3, [pc, #88]	; (1000460c <xTimerGenericCommand+0xa8>)
100045b2:	6819      	ldr	r1, [r3, #0]
100045b4:	2314      	movs	r3, #20
100045b6:	18fa      	adds	r2, r7, r3
100045b8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
100045ba:	1c08      	adds	r0, r1, #0
100045bc:	1c11      	adds	r1, r2, #0
100045be:	1c1a      	adds	r2, r3, #0
100045c0:	2300      	movs	r3, #0
100045c2:	f7fe fd9b 	bl	100030fc <xQueueGenericSend>
100045c6:	1c03      	adds	r3, r0, #0
100045c8:	627b      	str	r3, [r7, #36]	; 0x24
100045ca:	e019      	b.n	10004600 <xTimerGenericCommand+0x9c>
                }
                else
                {
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
100045cc:	4b0f      	ldr	r3, [pc, #60]	; (1000460c <xTimerGenericCommand+0xa8>)
100045ce:	681a      	ldr	r2, [r3, #0]
100045d0:	2314      	movs	r3, #20
100045d2:	18fb      	adds	r3, r7, r3
100045d4:	1c10      	adds	r0, r2, #0
100045d6:	1c19      	adds	r1, r3, #0
100045d8:	2200      	movs	r2, #0
100045da:	2300      	movs	r3, #0
100045dc:	f7fe fd8e 	bl	100030fc <xQueueGenericSend>
100045e0:	1c03      	adds	r3, r0, #0
100045e2:	627b      	str	r3, [r7, #36]	; 0x24
100045e4:	e00c      	b.n	10004600 <xTimerGenericCommand+0x9c>
                }
            }
            else
            {
                xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
100045e6:	4b09      	ldr	r3, [pc, #36]	; (1000460c <xTimerGenericCommand+0xa8>)
100045e8:	6819      	ldr	r1, [r3, #0]
100045ea:	2314      	movs	r3, #20
100045ec:	18fa      	adds	r2, r7, r3
100045ee:	683b      	ldr	r3, [r7, #0]
100045f0:	1c08      	adds	r0, r1, #0
100045f2:	1c11      	adds	r1, r2, #0
100045f4:	1c1a      	adds	r2, r3, #0
100045f6:	2300      	movs	r3, #0
100045f8:	f7fe fe64 	bl	100032c4 <xQueueGenericSendFromISR>
100045fc:	1c03      	adds	r3, r0, #0
100045fe:	627b      	str	r3, [r7, #36]	; 0x24
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
10004600:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    }
10004602:	1c18      	adds	r0, r3, #0
10004604:	46bd      	mov	sp, r7
10004606:	b00a      	add	sp, #40	; 0x28
10004608:	bd80      	pop	{r7, pc}
1000460a:	46c0      	nop			; (mov r8, r8)
1000460c:	2000080c 	.word	0x2000080c

10004610 <prvProcessExpiredTimer>:
    }
/*-----------------------------------------------------------*/

    static void prvProcessExpiredTimer( const TickType_t xNextExpireTime,
                                        const TickType_t xTimeNow )
    {
10004610:	b580      	push	{r7, lr}
10004612:	b086      	sub	sp, #24
10004614:	af02      	add	r7, sp, #8
10004616:	6078      	str	r0, [r7, #4]
10004618:	6039      	str	r1, [r7, #0]
        BaseType_t xResult;
        Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
1000461a:	4b1e      	ldr	r3, [pc, #120]	; (10004694 <prvProcessExpiredTimer+0x84>)
1000461c:	681b      	ldr	r3, [r3, #0]
1000461e:	68db      	ldr	r3, [r3, #12]
10004620:	68db      	ldr	r3, [r3, #12]
10004622:	60fb      	str	r3, [r7, #12]

        /* Remove the timer from the list of active timers.  A check has already
         * been performed to ensure the list is not empty. */

        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
10004624:	68fb      	ldr	r3, [r7, #12]
10004626:	3304      	adds	r3, #4
10004628:	1c18      	adds	r0, r3, #0
1000462a:	f7fe fc77 	bl	10002f1c <uxListRemove>
        traceTIMER_EXPIRED( pxTimer );

        /* If the timer is an auto-reload timer then calculate the next
         * expiry time and re-insert the timer in the list of active timers. */
        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
1000462e:	68fb      	ldr	r3, [r7, #12]
10004630:	2228      	movs	r2, #40	; 0x28
10004632:	5c9b      	ldrb	r3, [r3, r2]
10004634:	1c1a      	adds	r2, r3, #0
10004636:	2304      	movs	r3, #4
10004638:	4013      	ands	r3, r2
1000463a:	d01a      	beq.n	10004672 <prvProcessExpiredTimer+0x62>
        {
            /* The timer is inserted into a list using a time relative to anything
             * other than the current time.  It will therefore be inserted into the
             * correct list relative to the time this task thinks it is now. */
            if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
1000463c:	68fb      	ldr	r3, [r7, #12]
1000463e:	699a      	ldr	r2, [r3, #24]
10004640:	687b      	ldr	r3, [r7, #4]
10004642:	18d1      	adds	r1, r2, r3
10004644:	68f8      	ldr	r0, [r7, #12]
10004646:	683a      	ldr	r2, [r7, #0]
10004648:	687b      	ldr	r3, [r7, #4]
1000464a:	f000 f8c3 	bl	100047d4 <prvInsertTimerInActiveList>
1000464e:	1e03      	subs	r3, r0, #0
10004650:	d018      	beq.n	10004684 <prvProcessExpiredTimer+0x74>
            {
                /* The timer expired before it was added to the active timer
                 * list.  Reload it now.  */
                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
10004652:	68f9      	ldr	r1, [r7, #12]
10004654:	687a      	ldr	r2, [r7, #4]
10004656:	2300      	movs	r3, #0
10004658:	9300      	str	r3, [sp, #0]
1000465a:	1c08      	adds	r0, r1, #0
1000465c:	2100      	movs	r1, #0
1000465e:	2300      	movs	r3, #0
10004660:	f7ff ff80 	bl	10004564 <xTimerGenericCommand>
10004664:	1c03      	adds	r3, r0, #0
10004666:	60bb      	str	r3, [r7, #8]
                configASSERT( xResult );
10004668:	68bb      	ldr	r3, [r7, #8]
1000466a:	2b00      	cmp	r3, #0
1000466c:	d10a      	bne.n	10004684 <prvProcessExpiredTimer+0x74>
1000466e:	b672      	cpsid	i
10004670:	e7fe      	b.n	10004670 <prvProcessExpiredTimer+0x60>
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else
        {
            pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
10004672:	68fb      	ldr	r3, [r7, #12]
10004674:	2228      	movs	r2, #40	; 0x28
10004676:	5c9b      	ldrb	r3, [r3, r2]
10004678:	2201      	movs	r2, #1
1000467a:	4393      	bics	r3, r2
1000467c:	b2d9      	uxtb	r1, r3
1000467e:	68fb      	ldr	r3, [r7, #12]
10004680:	2228      	movs	r2, #40	; 0x28
10004682:	5499      	strb	r1, [r3, r2]
            mtCOVERAGE_TEST_MARKER();
        }

        /* Call the timer callback. */
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
10004684:	68fb      	ldr	r3, [r7, #12]
10004686:	6a1b      	ldr	r3, [r3, #32]
10004688:	68fa      	ldr	r2, [r7, #12]
1000468a:	1c10      	adds	r0, r2, #0
1000468c:	4798      	blx	r3
    }
1000468e:	46bd      	mov	sp, r7
10004690:	b004      	add	sp, #16
10004692:	bd80      	pop	{r7, pc}
10004694:	20000804 	.word	0x20000804

10004698 <prvTimerTask>:
/*-----------------------------------------------------------*/

    static portTASK_FUNCTION( prvTimerTask, pvParameters )
    {
10004698:	b580      	push	{r7, lr}
1000469a:	b084      	sub	sp, #16
1000469c:	af00      	add	r7, sp, #0
1000469e:	6078      	str	r0, [r7, #4]

        for( ; ; )
        {
            /* Query the timers list to see if it contains any timers, and if so,
             * obtain the time at which the next timer will expire. */
            xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
100046a0:	2308      	movs	r3, #8
100046a2:	18fb      	adds	r3, r7, r3
100046a4:	1c18      	adds	r0, r3, #0
100046a6:	f000 f853 	bl	10004750 <prvGetNextExpireTime>
100046aa:	1c03      	adds	r3, r0, #0
100046ac:	60fb      	str	r3, [r7, #12]

            /* If a timer has expired, process it.  Otherwise, block this task
             * until either a timer does expire, or a command is received. */
            prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
100046ae:	68bb      	ldr	r3, [r7, #8]
100046b0:	68fa      	ldr	r2, [r7, #12]
100046b2:	1c10      	adds	r0, r2, #0
100046b4:	1c19      	adds	r1, r3, #0
100046b6:	f000 f803 	bl	100046c0 <prvProcessTimerOrBlockTask>

            /* Empty the command queue. */
            prvProcessReceivedCommands();
100046ba:	f000 f8cd 	bl	10004858 <prvProcessReceivedCommands>
        }
100046be:	e7ef      	b.n	100046a0 <prvTimerTask+0x8>

100046c0 <prvProcessTimerOrBlockTask>:
    }
/*-----------------------------------------------------------*/

    static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime,
                                            BaseType_t xListWasEmpty )
    {
100046c0:	b580      	push	{r7, lr}
100046c2:	b084      	sub	sp, #16
100046c4:	af00      	add	r7, sp, #0
100046c6:	6078      	str	r0, [r7, #4]
100046c8:	6039      	str	r1, [r7, #0]
        TickType_t xTimeNow;
        BaseType_t xTimerListsWereSwitched;

        vTaskSuspendAll();
100046ca:	f7ff fae3 	bl	10003c94 <vTaskSuspendAll>
            /* Obtain the time now to make an assessment as to whether the timer
             * has expired or not.  If obtaining the time causes the lists to switch
             * then don't process this timer as any timers that remained in the list
             * when the lists were switched will have been processed within the
             * prvSampleTimeNow() function. */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
100046ce:	2308      	movs	r3, #8
100046d0:	18fb      	adds	r3, r7, r3
100046d2:	1c18      	adds	r0, r3, #0
100046d4:	f000 f85e 	bl	10004794 <prvSampleTimeNow>
100046d8:	1c03      	adds	r3, r0, #0
100046da:	60fb      	str	r3, [r7, #12]

            if( xTimerListsWereSwitched == pdFALSE )
100046dc:	68bb      	ldr	r3, [r7, #8]
100046de:	2b00      	cmp	r3, #0
100046e0:	d12d      	bne.n	1000473e <prvProcessTimerOrBlockTask+0x7e>
            {
                /* The tick count has not overflowed, has the timer expired? */
                if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
100046e2:	683b      	ldr	r3, [r7, #0]
100046e4:	2b00      	cmp	r3, #0
100046e6:	d10c      	bne.n	10004702 <prvProcessTimerOrBlockTask+0x42>
100046e8:	687a      	ldr	r2, [r7, #4]
100046ea:	68fb      	ldr	r3, [r7, #12]
100046ec:	429a      	cmp	r2, r3
100046ee:	d808      	bhi.n	10004702 <prvProcessTimerOrBlockTask+0x42>
                {
                    ( void ) xTaskResumeAll();
100046f0:	f7ff fadc 	bl	10003cac <xTaskResumeAll>
                    prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
100046f4:	687a      	ldr	r2, [r7, #4]
100046f6:	68fb      	ldr	r3, [r7, #12]
100046f8:	1c10      	adds	r0, r2, #0
100046fa:	1c19      	adds	r1, r3, #0
100046fc:	f7ff ff88 	bl	10004610 <prvProcessExpiredTimer>
10004700:	e01f      	b.n	10004742 <prvProcessTimerOrBlockTask+0x82>
                     * time has not been reached yet.  This task should therefore
                     * block to wait for the next expire time or a command to be
                     * received - whichever comes first.  The following line cannot
                     * be reached unless xNextExpireTime > xTimeNow, except in the
                     * case when the current timer list is empty. */
                    if( xListWasEmpty != pdFALSE )
10004702:	683b      	ldr	r3, [r7, #0]
10004704:	2b00      	cmp	r3, #0
10004706:	d008      	beq.n	1000471a <prvProcessTimerOrBlockTask+0x5a>
                    {
                        /* The current timer list is empty - is the overflow list
                         * also empty? */
                        xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
10004708:	4b0f      	ldr	r3, [pc, #60]	; (10004748 <prvProcessTimerOrBlockTask+0x88>)
1000470a:	681b      	ldr	r3, [r3, #0]
1000470c:	681b      	ldr	r3, [r3, #0]
1000470e:	2b00      	cmp	r3, #0
10004710:	d101      	bne.n	10004716 <prvProcessTimerOrBlockTask+0x56>
10004712:	2301      	movs	r3, #1
10004714:	e000      	b.n	10004718 <prvProcessTimerOrBlockTask+0x58>
10004716:	2300      	movs	r3, #0
10004718:	603b      	str	r3, [r7, #0]
                    }

                    vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
1000471a:	4b0c      	ldr	r3, [pc, #48]	; (1000474c <prvProcessTimerOrBlockTask+0x8c>)
1000471c:	6819      	ldr	r1, [r3, #0]
1000471e:	687a      	ldr	r2, [r7, #4]
10004720:	68fb      	ldr	r3, [r7, #12]
10004722:	1ad2      	subs	r2, r2, r3
10004724:	683b      	ldr	r3, [r7, #0]
10004726:	1c08      	adds	r0, r1, #0
10004728:	1c11      	adds	r1, r2, #0
1000472a:	1c1a      	adds	r2, r3, #0
1000472c:	f7ff f874 	bl	10003818 <vQueueWaitForMessageRestricted>

                    if( xTaskResumeAll() == pdFALSE )
10004730:	f7ff fabc 	bl	10003cac <xTaskResumeAll>
10004734:	1e03      	subs	r3, r0, #0
10004736:	d104      	bne.n	10004742 <prvProcessTimerOrBlockTask+0x82>
                    {
                        /* Yield to wait for either a command to arrive, or the
                         * block time to expire.  If a command arrived between the
                         * critical section being exited and this yield then the yield
                         * will not cause the task to block. */
                        portYIELD_WITHIN_API();
10004738:	f7fe faa6 	bl	10002c88 <vPortYield>
1000473c:	e001      	b.n	10004742 <prvProcessTimerOrBlockTask+0x82>
                    }
                }
            }
            else
            {
                ( void ) xTaskResumeAll();
1000473e:	f7ff fab5 	bl	10003cac <xTaskResumeAll>
            }
        }
    }
10004742:	46bd      	mov	sp, r7
10004744:	b004      	add	sp, #16
10004746:	bd80      	pop	{r7, pc}
10004748:	20000808 	.word	0x20000808
1000474c:	2000080c 	.word	0x2000080c

10004750 <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

    static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
    {
10004750:	b580      	push	{r7, lr}
10004752:	b084      	sub	sp, #16
10004754:	af00      	add	r7, sp, #0
10004756:	6078      	str	r0, [r7, #4]
         * the timer with the nearest expiry time will expire.  If there are no
         * active timers then just set the next expire time to 0.  That will cause
         * this task to unblock when the tick count overflows, at which point the
         * timer lists will be switched and the next expiry time can be
         * re-assessed.  */
        *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
10004758:	4b0d      	ldr	r3, [pc, #52]	; (10004790 <prvGetNextExpireTime+0x40>)
1000475a:	681b      	ldr	r3, [r3, #0]
1000475c:	681b      	ldr	r3, [r3, #0]
1000475e:	2b00      	cmp	r3, #0
10004760:	d101      	bne.n	10004766 <prvGetNextExpireTime+0x16>
10004762:	2201      	movs	r2, #1
10004764:	e000      	b.n	10004768 <prvGetNextExpireTime+0x18>
10004766:	2200      	movs	r2, #0
10004768:	687b      	ldr	r3, [r7, #4]
1000476a:	601a      	str	r2, [r3, #0]

        if( *pxListWasEmpty == pdFALSE )
1000476c:	687b      	ldr	r3, [r7, #4]
1000476e:	681b      	ldr	r3, [r3, #0]
10004770:	2b00      	cmp	r3, #0
10004772:	d105      	bne.n	10004780 <prvGetNextExpireTime+0x30>
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
10004774:	4b06      	ldr	r3, [pc, #24]	; (10004790 <prvGetNextExpireTime+0x40>)
10004776:	681b      	ldr	r3, [r3, #0]
10004778:	68db      	ldr	r3, [r3, #12]
1000477a:	681b      	ldr	r3, [r3, #0]
1000477c:	60fb      	str	r3, [r7, #12]
1000477e:	e001      	b.n	10004784 <prvGetNextExpireTime+0x34>
        }
        else
        {
            /* Ensure the task unblocks when the tick count rolls over. */
            xNextExpireTime = ( TickType_t ) 0U;
10004780:	2300      	movs	r3, #0
10004782:	60fb      	str	r3, [r7, #12]
        }

        return xNextExpireTime;
10004784:	68fb      	ldr	r3, [r7, #12]
    }
10004786:	1c18      	adds	r0, r3, #0
10004788:	46bd      	mov	sp, r7
1000478a:	b004      	add	sp, #16
1000478c:	bd80      	pop	{r7, pc}
1000478e:	46c0      	nop			; (mov r8, r8)
10004790:	20000804 	.word	0x20000804

10004794 <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

    static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
    {
10004794:	b580      	push	{r7, lr}
10004796:	b084      	sub	sp, #16
10004798:	af00      	add	r7, sp, #0
1000479a:	6078      	str	r0, [r7, #4]
        TickType_t xTimeNow;
        PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

        xTimeNow = xTaskGetTickCount();
1000479c:	f7ff fb12 	bl	10003dc4 <xTaskGetTickCount>
100047a0:	1c03      	adds	r3, r0, #0
100047a2:	60fb      	str	r3, [r7, #12]

        if( xTimeNow < xLastTime )
100047a4:	4b0a      	ldr	r3, [pc, #40]	; (100047d0 <prvSampleTimeNow+0x3c>)
100047a6:	681b      	ldr	r3, [r3, #0]
100047a8:	68fa      	ldr	r2, [r7, #12]
100047aa:	429a      	cmp	r2, r3
100047ac:	d205      	bcs.n	100047ba <prvSampleTimeNow+0x26>
        {
            prvSwitchTimerLists();
100047ae:	f000 f91f 	bl	100049f0 <prvSwitchTimerLists>
            *pxTimerListsWereSwitched = pdTRUE;
100047b2:	687b      	ldr	r3, [r7, #4]
100047b4:	2201      	movs	r2, #1
100047b6:	601a      	str	r2, [r3, #0]
100047b8:	e002      	b.n	100047c0 <prvSampleTimeNow+0x2c>
        }
        else
        {
            *pxTimerListsWereSwitched = pdFALSE;
100047ba:	687b      	ldr	r3, [r7, #4]
100047bc:	2200      	movs	r2, #0
100047be:	601a      	str	r2, [r3, #0]
        }

        xLastTime = xTimeNow;
100047c0:	4b03      	ldr	r3, [pc, #12]	; (100047d0 <prvSampleTimeNow+0x3c>)
100047c2:	68fa      	ldr	r2, [r7, #12]
100047c4:	601a      	str	r2, [r3, #0]

        return xTimeNow;
100047c6:	68fb      	ldr	r3, [r7, #12]
    }
100047c8:	1c18      	adds	r0, r3, #0
100047ca:	46bd      	mov	sp, r7
100047cc:	b004      	add	sp, #16
100047ce:	bd80      	pop	{r7, pc}
100047d0:	20000814 	.word	0x20000814

100047d4 <prvInsertTimerInActiveList>:

    static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer,
                                                  const TickType_t xNextExpiryTime,
                                                  const TickType_t xTimeNow,
                                                  const TickType_t xCommandTime )
    {
100047d4:	b580      	push	{r7, lr}
100047d6:	b086      	sub	sp, #24
100047d8:	af00      	add	r7, sp, #0
100047da:	60f8      	str	r0, [r7, #12]
100047dc:	60b9      	str	r1, [r7, #8]
100047de:	607a      	str	r2, [r7, #4]
100047e0:	603b      	str	r3, [r7, #0]
        BaseType_t xProcessTimerNow = pdFALSE;
100047e2:	2300      	movs	r3, #0
100047e4:	617b      	str	r3, [r7, #20]

        listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
100047e6:	68fb      	ldr	r3, [r7, #12]
100047e8:	68ba      	ldr	r2, [r7, #8]
100047ea:	605a      	str	r2, [r3, #4]
        listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
100047ec:	68fb      	ldr	r3, [r7, #12]
100047ee:	68fa      	ldr	r2, [r7, #12]
100047f0:	611a      	str	r2, [r3, #16]

        if( xNextExpiryTime <= xTimeNow )
100047f2:	68ba      	ldr	r2, [r7, #8]
100047f4:	687b      	ldr	r3, [r7, #4]
100047f6:	429a      	cmp	r2, r3
100047f8:	d812      	bhi.n	10004820 <prvInsertTimerInActiveList+0x4c>
        {
            /* Has the expiry time elapsed between the command to start/reset a
             * timer was issued, and the time the command was processed? */
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
100047fa:	687a      	ldr	r2, [r7, #4]
100047fc:	683b      	ldr	r3, [r7, #0]
100047fe:	1ad2      	subs	r2, r2, r3
10004800:	68fb      	ldr	r3, [r7, #12]
10004802:	699b      	ldr	r3, [r3, #24]
10004804:	429a      	cmp	r2, r3
10004806:	d302      	bcc.n	1000480e <prvInsertTimerInActiveList+0x3a>
            {
                /* The time between a command being issued and the command being
                 * processed actually exceeds the timers period.  */
                xProcessTimerNow = pdTRUE;
10004808:	2301      	movs	r3, #1
1000480a:	617b      	str	r3, [r7, #20]
1000480c:	e01b      	b.n	10004846 <prvInsertTimerInActiveList+0x72>
            }
            else
            {
                vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
1000480e:	4b10      	ldr	r3, [pc, #64]	; (10004850 <prvInsertTimerInActiveList+0x7c>)
10004810:	681a      	ldr	r2, [r3, #0]
10004812:	68fb      	ldr	r3, [r7, #12]
10004814:	3304      	adds	r3, #4
10004816:	1c10      	adds	r0, r2, #0
10004818:	1c19      	adds	r1, r3, #0
1000481a:	f7fe fb49 	bl	10002eb0 <vListInsert>
1000481e:	e012      	b.n	10004846 <prvInsertTimerInActiveList+0x72>
            }
        }
        else
        {
            if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
10004820:	687a      	ldr	r2, [r7, #4]
10004822:	683b      	ldr	r3, [r7, #0]
10004824:	429a      	cmp	r2, r3
10004826:	d206      	bcs.n	10004836 <prvInsertTimerInActiveList+0x62>
10004828:	68ba      	ldr	r2, [r7, #8]
1000482a:	683b      	ldr	r3, [r7, #0]
1000482c:	429a      	cmp	r2, r3
1000482e:	d302      	bcc.n	10004836 <prvInsertTimerInActiveList+0x62>
            {
                /* If, since the command was issued, the tick count has overflowed
                 * but the expiry time has not, then the timer must have already passed
                 * its expiry time and should be processed immediately. */
                xProcessTimerNow = pdTRUE;
10004830:	2301      	movs	r3, #1
10004832:	617b      	str	r3, [r7, #20]
10004834:	e007      	b.n	10004846 <prvInsertTimerInActiveList+0x72>
            }
            else
            {
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
10004836:	4b07      	ldr	r3, [pc, #28]	; (10004854 <prvInsertTimerInActiveList+0x80>)
10004838:	681a      	ldr	r2, [r3, #0]
1000483a:	68fb      	ldr	r3, [r7, #12]
1000483c:	3304      	adds	r3, #4
1000483e:	1c10      	adds	r0, r2, #0
10004840:	1c19      	adds	r1, r3, #0
10004842:	f7fe fb35 	bl	10002eb0 <vListInsert>
            }
        }

        return xProcessTimerNow;
10004846:	697b      	ldr	r3, [r7, #20]
    }
10004848:	1c18      	adds	r0, r3, #0
1000484a:	46bd      	mov	sp, r7
1000484c:	b006      	add	sp, #24
1000484e:	bd80      	pop	{r7, pc}
10004850:	20000808 	.word	0x20000808
10004854:	20000804 	.word	0x20000804

10004858 <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

    static void prvProcessReceivedCommands( void )
    {
10004858:	b580      	push	{r7, lr}
1000485a:	b08c      	sub	sp, #48	; 0x30
1000485c:	af02      	add	r7, sp, #8
        DaemonTaskMessage_t xMessage;
        Timer_t * pxTimer;
        BaseType_t xTimerListsWereSwitched, xResult;
        TickType_t xTimeNow;

        while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
1000485e:	e0b3      	b.n	100049c8 <prvProcessReceivedCommands+0x170>
        {
            #if ( INCLUDE_xTimerPendFunctionCall == 1 )
                {
                    /* Negative commands are pended function calls rather than timer
                     * commands. */
                    if( xMessage.xMessageID < ( BaseType_t ) 0 )
10004860:	2308      	movs	r3, #8
10004862:	18fb      	adds	r3, r7, r3
10004864:	681b      	ldr	r3, [r3, #0]
10004866:	2b00      	cmp	r3, #0
10004868:	da11      	bge.n	1000488e <prvProcessReceivedCommands+0x36>
                    {
                        const CallbackParameters_t * const pxCallback = &( xMessage.u.xCallbackParameters );
1000486a:	2308      	movs	r3, #8
1000486c:	18fb      	adds	r3, r7, r3
1000486e:	3304      	adds	r3, #4
10004870:	627b      	str	r3, [r7, #36]	; 0x24

                        /* The timer uses the xCallbackParameters member to request a
                         * callback be executed.  Check the callback is not NULL. */
                        configASSERT( pxCallback );
10004872:	6a7b      	ldr	r3, [r7, #36]	; 0x24
10004874:	2b00      	cmp	r3, #0
10004876:	d101      	bne.n	1000487c <prvProcessReceivedCommands+0x24>
10004878:	b672      	cpsid	i
1000487a:	e7fe      	b.n	1000487a <prvProcessReceivedCommands+0x22>

                        /* Call the function. */
                        pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
1000487c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
1000487e:	681a      	ldr	r2, [r3, #0]
10004880:	6a7b      	ldr	r3, [r7, #36]	; 0x24
10004882:	6859      	ldr	r1, [r3, #4]
10004884:	6a7b      	ldr	r3, [r7, #36]	; 0x24
10004886:	689b      	ldr	r3, [r3, #8]
10004888:	1c08      	adds	r0, r1, #0
1000488a:	1c19      	adds	r1, r3, #0
1000488c:	4790      	blx	r2
                }
            #endif /* INCLUDE_xTimerPendFunctionCall */

            /* Commands that are positive are timer commands rather than pended
             * function calls. */
            if( xMessage.xMessageID >= ( BaseType_t ) 0 )
1000488e:	2308      	movs	r3, #8
10004890:	18fb      	adds	r3, r7, r3
10004892:	681b      	ldr	r3, [r3, #0]
10004894:	2b00      	cmp	r3, #0
10004896:	da00      	bge.n	1000489a <prvProcessReceivedCommands+0x42>
10004898:	e096      	b.n	100049c8 <prvProcessReceivedCommands+0x170>
            {
                /* The messages uses the xTimerParameters member to work on a
                 * software timer. */
                pxTimer = xMessage.u.xTimerParameters.pxTimer;
1000489a:	2308      	movs	r3, #8
1000489c:	18fb      	adds	r3, r7, r3
1000489e:	689b      	ldr	r3, [r3, #8]
100048a0:	623b      	str	r3, [r7, #32]

                if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
100048a2:	6a3b      	ldr	r3, [r7, #32]
100048a4:	695b      	ldr	r3, [r3, #20]
100048a6:	2b00      	cmp	r3, #0
100048a8:	d004      	beq.n	100048b4 <prvProcessReceivedCommands+0x5c>
                {
                    /* The timer is in a list, remove it. */
                    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
100048aa:	6a3b      	ldr	r3, [r7, #32]
100048ac:	3304      	adds	r3, #4
100048ae:	1c18      	adds	r0, r3, #0
100048b0:	f7fe fb34 	bl	10002f1c <uxListRemove>
                 *  it must be present in the function call.  prvSampleTimeNow() must be
                 *  called after the message is received from xTimerQueue so there is no
                 *  possibility of a higher priority task adding a message to the message
                 *  queue with a time that is ahead of the timer daemon task (because it
                 *  pre-empted the timer daemon task after the xTimeNow value was set). */
                xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
100048b4:	1d3b      	adds	r3, r7, #4
100048b6:	1c18      	adds	r0, r3, #0
100048b8:	f7ff ff6c 	bl	10004794 <prvSampleTimeNow>
100048bc:	1c03      	adds	r3, r0, #0
100048be:	61fb      	str	r3, [r7, #28]

                switch( xMessage.xMessageID )
100048c0:	2308      	movs	r3, #8
100048c2:	18fb      	adds	r3, r7, r3
100048c4:	681b      	ldr	r3, [r3, #0]
100048c6:	2b09      	cmp	r3, #9
100048c8:	d900      	bls.n	100048cc <prvProcessReceivedCommands+0x74>
100048ca:	e07c      	b.n	100049c6 <prvProcessReceivedCommands+0x16e>
100048cc:	009a      	lsls	r2, r3, #2
100048ce:	4b46      	ldr	r3, [pc, #280]	; (100049e8 <prvProcessReceivedCommands+0x190>)
100048d0:	18d3      	adds	r3, r2, r3
100048d2:	681b      	ldr	r3, [r3, #0]
100048d4:	469f      	mov	pc, r3
                    case tmrCOMMAND_START_FROM_ISR:
                    case tmrCOMMAND_RESET:
                    case tmrCOMMAND_RESET_FROM_ISR:
                    case tmrCOMMAND_START_DONT_TRACE:
                        /* Start or restart a timer. */
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
100048d6:	6a3b      	ldr	r3, [r7, #32]
100048d8:	2228      	movs	r2, #40	; 0x28
100048da:	5c9b      	ldrb	r3, [r3, r2]
100048dc:	2201      	movs	r2, #1
100048de:	4313      	orrs	r3, r2
100048e0:	b2d9      	uxtb	r1, r3
100048e2:	6a3b      	ldr	r3, [r7, #32]
100048e4:	2228      	movs	r2, #40	; 0x28
100048e6:	5499      	strb	r1, [r3, r2]

                        if( prvInsertTimerInActiveList( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
100048e8:	2308      	movs	r3, #8
100048ea:	18fb      	adds	r3, r7, r3
100048ec:	685a      	ldr	r2, [r3, #4]
100048ee:	6a3b      	ldr	r3, [r7, #32]
100048f0:	699b      	ldr	r3, [r3, #24]
100048f2:	18d1      	adds	r1, r2, r3
100048f4:	2308      	movs	r3, #8
100048f6:	18fb      	adds	r3, r7, r3
100048f8:	685b      	ldr	r3, [r3, #4]
100048fa:	6a38      	ldr	r0, [r7, #32]
100048fc:	69fa      	ldr	r2, [r7, #28]
100048fe:	f7ff ff69 	bl	100047d4 <prvInsertTimerInActiveList>
10004902:	1e03      	subs	r3, r0, #0
10004904:	d020      	beq.n	10004948 <prvProcessReceivedCommands+0xf0>
                        {
                            /* The timer expired before it was added to the active
                             * timer list.  Process it now. */
                            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
10004906:	6a3b      	ldr	r3, [r7, #32]
10004908:	6a1b      	ldr	r3, [r3, #32]
1000490a:	6a3a      	ldr	r2, [r7, #32]
1000490c:	1c10      	adds	r0, r2, #0
1000490e:	4798      	blx	r3
                            traceTIMER_EXPIRED( pxTimer );

                            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
10004910:	6a3b      	ldr	r3, [r7, #32]
10004912:	2228      	movs	r2, #40	; 0x28
10004914:	5c9b      	ldrb	r3, [r3, r2]
10004916:	1c1a      	adds	r2, r3, #0
10004918:	2304      	movs	r3, #4
1000491a:	4013      	ands	r3, r2
1000491c:	d014      	beq.n	10004948 <prvProcessReceivedCommands+0xf0>
                            {
                                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
1000491e:	2308      	movs	r3, #8
10004920:	18fb      	adds	r3, r7, r3
10004922:	685a      	ldr	r2, [r3, #4]
10004924:	6a3b      	ldr	r3, [r7, #32]
10004926:	699b      	ldr	r3, [r3, #24]
10004928:	18d2      	adds	r2, r2, r3
1000492a:	6a39      	ldr	r1, [r7, #32]
1000492c:	2300      	movs	r3, #0
1000492e:	9300      	str	r3, [sp, #0]
10004930:	1c08      	adds	r0, r1, #0
10004932:	2100      	movs	r1, #0
10004934:	2300      	movs	r3, #0
10004936:	f7ff fe15 	bl	10004564 <xTimerGenericCommand>
1000493a:	1c03      	adds	r3, r0, #0
1000493c:	61bb      	str	r3, [r7, #24]
                                configASSERT( xResult );
1000493e:	69bb      	ldr	r3, [r7, #24]
10004940:	2b00      	cmp	r3, #0
10004942:	d101      	bne.n	10004948 <prvProcessReceivedCommands+0xf0>
10004944:	b672      	cpsid	i
10004946:	e7fe      	b.n	10004946 <prvProcessReceivedCommands+0xee>
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }

                        break;
10004948:	e03e      	b.n	100049c8 <prvProcessReceivedCommands+0x170>

                    case tmrCOMMAND_STOP:
                    case tmrCOMMAND_STOP_FROM_ISR:
                        /* The timer has already been removed from the active list. */
                        pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
1000494a:	6a3b      	ldr	r3, [r7, #32]
1000494c:	2228      	movs	r2, #40	; 0x28
1000494e:	5c9b      	ldrb	r3, [r3, r2]
10004950:	2201      	movs	r2, #1
10004952:	4393      	bics	r3, r2
10004954:	b2d9      	uxtb	r1, r3
10004956:	6a3b      	ldr	r3, [r7, #32]
10004958:	2228      	movs	r2, #40	; 0x28
1000495a:	5499      	strb	r1, [r3, r2]
                        break;
1000495c:	e034      	b.n	100049c8 <prvProcessReceivedCommands+0x170>

                    case tmrCOMMAND_CHANGE_PERIOD:
                    case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR:
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
1000495e:	6a3b      	ldr	r3, [r7, #32]
10004960:	2228      	movs	r2, #40	; 0x28
10004962:	5c9b      	ldrb	r3, [r3, r2]
10004964:	2201      	movs	r2, #1
10004966:	4313      	orrs	r3, r2
10004968:	b2d9      	uxtb	r1, r3
1000496a:	6a3b      	ldr	r3, [r7, #32]
1000496c:	2228      	movs	r2, #40	; 0x28
1000496e:	5499      	strb	r1, [r3, r2]
                        pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
10004970:	2308      	movs	r3, #8
10004972:	18fb      	adds	r3, r7, r3
10004974:	685a      	ldr	r2, [r3, #4]
10004976:	6a3b      	ldr	r3, [r7, #32]
10004978:	619a      	str	r2, [r3, #24]
                        configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
1000497a:	6a3b      	ldr	r3, [r7, #32]
1000497c:	699b      	ldr	r3, [r3, #24]
1000497e:	2b00      	cmp	r3, #0
10004980:	d101      	bne.n	10004986 <prvProcessReceivedCommands+0x12e>
10004982:	b672      	cpsid	i
10004984:	e7fe      	b.n	10004984 <prvProcessReceivedCommands+0x12c>
                         * be longer or shorter than the old one.  The command time is
                         * therefore set to the current time, and as the period cannot
                         * be zero the next expiry time can only be in the future,
                         * meaning (unlike for the xTimerStart() case above) there is
                         * no fail case that needs to be handled here. */
                        ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
10004986:	6a3b      	ldr	r3, [r7, #32]
10004988:	699a      	ldr	r2, [r3, #24]
1000498a:	69fb      	ldr	r3, [r7, #28]
1000498c:	18d1      	adds	r1, r2, r3
1000498e:	6a38      	ldr	r0, [r7, #32]
10004990:	69fa      	ldr	r2, [r7, #28]
10004992:	69fb      	ldr	r3, [r7, #28]
10004994:	f7ff ff1e 	bl	100047d4 <prvInsertTimerInActiveList>
                        break;
10004998:	e016      	b.n	100049c8 <prvProcessReceivedCommands+0x170>
                        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
                            {
                                /* The timer has already been removed from the active list,
                                 * just free up the memory if the memory was dynamically
                                 * allocated. */
                                if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
1000499a:	6a3b      	ldr	r3, [r7, #32]
1000499c:	2228      	movs	r2, #40	; 0x28
1000499e:	5c9b      	ldrb	r3, [r3, r2]
100049a0:	1c1a      	adds	r2, r3, #0
100049a2:	2302      	movs	r3, #2
100049a4:	4013      	ands	r3, r2
100049a6:	d104      	bne.n	100049b2 <prvProcessReceivedCommands+0x15a>
                                {
                                    vPortFree( pxTimer );
100049a8:	6a3b      	ldr	r3, [r7, #32]
100049aa:	1c18      	adds	r0, r3, #0
100049ac:	f7fe fa24 	bl	10002df8 <vPortFree>
100049b0:	e008      	b.n	100049c4 <prvProcessReceivedCommands+0x16c>
                                }
                                else
                                {
                                    pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
100049b2:	6a3b      	ldr	r3, [r7, #32]
100049b4:	2228      	movs	r2, #40	; 0x28
100049b6:	5c9b      	ldrb	r3, [r3, r2]
100049b8:	2201      	movs	r2, #1
100049ba:	4393      	bics	r3, r2
100049bc:	b2d9      	uxtb	r1, r3
100049be:	6a3b      	ldr	r3, [r7, #32]
100049c0:	2228      	movs	r2, #40	; 0x28
100049c2:	5499      	strb	r1, [r3, r2]
                                 * no need to free the memory - just mark the timer as
                                 * "not active". */
                                pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
                            }
                        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
                        break;
100049c4:	e000      	b.n	100049c8 <prvProcessReceivedCommands+0x170>

                    default:
                        /* Don't expect to get here. */
                        break;
100049c6:	46c0      	nop			; (mov r8, r8)
        DaemonTaskMessage_t xMessage;
        Timer_t * pxTimer;
        BaseType_t xTimerListsWereSwitched, xResult;
        TickType_t xTimeNow;

        while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
100049c8:	4b08      	ldr	r3, [pc, #32]	; (100049ec <prvProcessReceivedCommands+0x194>)
100049ca:	681a      	ldr	r2, [r3, #0]
100049cc:	2308      	movs	r3, #8
100049ce:	18fb      	adds	r3, r7, r3
100049d0:	1c10      	adds	r0, r2, #0
100049d2:	1c19      	adds	r1, r3, #0
100049d4:	2200      	movs	r2, #0
100049d6:	f7fe fd0d 	bl	100033f4 <xQueueReceive>
100049da:	1e03      	subs	r3, r0, #0
100049dc:	d000      	beq.n	100049e0 <prvProcessReceivedCommands+0x188>
100049de:	e73f      	b.n	10004860 <prvProcessReceivedCommands+0x8>
                        /* Don't expect to get here. */
                        break;
                }
            }
        }
    }
100049e0:	46bd      	mov	sp, r7
100049e2:	b00a      	add	sp, #40	; 0x28
100049e4:	bd80      	pop	{r7, pc}
100049e6:	46c0      	nop			; (mov r8, r8)
100049e8:	1000a1d4 	.word	0x1000a1d4
100049ec:	2000080c 	.word	0x2000080c

100049f0 <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

    static void prvSwitchTimerLists( void )
    {
100049f0:	b580      	push	{r7, lr}
100049f2:	b088      	sub	sp, #32
100049f4:	af02      	add	r7, sp, #8

        /* The tick count has overflowed.  The timer lists must be switched.
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
100049f6:	e042      	b.n	10004a7e <prvSwitchTimerLists+0x8e>
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
100049f8:	4b2a      	ldr	r3, [pc, #168]	; (10004aa4 <prvSwitchTimerLists+0xb4>)
100049fa:	681b      	ldr	r3, [r3, #0]
100049fc:	68db      	ldr	r3, [r3, #12]
100049fe:	681b      	ldr	r3, [r3, #0]
10004a00:	617b      	str	r3, [r7, #20]

            /* Remove the timer from the list. */
            pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
10004a02:	4b28      	ldr	r3, [pc, #160]	; (10004aa4 <prvSwitchTimerLists+0xb4>)
10004a04:	681b      	ldr	r3, [r3, #0]
10004a06:	68db      	ldr	r3, [r3, #12]
10004a08:	68db      	ldr	r3, [r3, #12]
10004a0a:	613b      	str	r3, [r7, #16]
            ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
10004a0c:	693b      	ldr	r3, [r7, #16]
10004a0e:	3304      	adds	r3, #4
10004a10:	1c18      	adds	r0, r3, #0
10004a12:	f7fe fa83 	bl	10002f1c <uxListRemove>
            traceTIMER_EXPIRED( pxTimer );

            /* Execute its callback, then send a command to restart the timer if
             * it is an auto-reload timer.  It cannot be restarted here as the lists
             * have not yet been switched. */
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
10004a16:	693b      	ldr	r3, [r7, #16]
10004a18:	6a1b      	ldr	r3, [r3, #32]
10004a1a:	693a      	ldr	r2, [r7, #16]
10004a1c:	1c10      	adds	r0, r2, #0
10004a1e:	4798      	blx	r3

            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
10004a20:	693b      	ldr	r3, [r7, #16]
10004a22:	2228      	movs	r2, #40	; 0x28
10004a24:	5c9b      	ldrb	r3, [r3, r2]
10004a26:	1c1a      	adds	r2, r3, #0
10004a28:	2304      	movs	r3, #4
10004a2a:	4013      	ands	r3, r2
10004a2c:	d027      	beq.n	10004a7e <prvSwitchTimerLists+0x8e>
                 * the timer going into the same timer list then it has already expired
                 * and the timer should be re-inserted into the current list so it is
                 * processed again within this loop.  Otherwise a command should be sent
                 * to restart the timer to ensure it is only inserted into a list after
                 * the lists have been swapped. */
                xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
10004a2e:	693b      	ldr	r3, [r7, #16]
10004a30:	699a      	ldr	r2, [r3, #24]
10004a32:	697b      	ldr	r3, [r7, #20]
10004a34:	18d3      	adds	r3, r2, r3
10004a36:	60fb      	str	r3, [r7, #12]

                if( xReloadTime > xNextExpireTime )
10004a38:	68fa      	ldr	r2, [r7, #12]
10004a3a:	697b      	ldr	r3, [r7, #20]
10004a3c:	429a      	cmp	r2, r3
10004a3e:	d90e      	bls.n	10004a5e <prvSwitchTimerLists+0x6e>
                {
                    listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
10004a40:	693b      	ldr	r3, [r7, #16]
10004a42:	68fa      	ldr	r2, [r7, #12]
10004a44:	605a      	str	r2, [r3, #4]
                    listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
10004a46:	693b      	ldr	r3, [r7, #16]
10004a48:	693a      	ldr	r2, [r7, #16]
10004a4a:	611a      	str	r2, [r3, #16]
                    vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
10004a4c:	4b15      	ldr	r3, [pc, #84]	; (10004aa4 <prvSwitchTimerLists+0xb4>)
10004a4e:	681a      	ldr	r2, [r3, #0]
10004a50:	693b      	ldr	r3, [r7, #16]
10004a52:	3304      	adds	r3, #4
10004a54:	1c10      	adds	r0, r2, #0
10004a56:	1c19      	adds	r1, r3, #0
10004a58:	f7fe fa2a 	bl	10002eb0 <vListInsert>
10004a5c:	e00f      	b.n	10004a7e <prvSwitchTimerLists+0x8e>
                }
                else
                {
                    xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
10004a5e:	6939      	ldr	r1, [r7, #16]
10004a60:	697a      	ldr	r2, [r7, #20]
10004a62:	2300      	movs	r3, #0
10004a64:	9300      	str	r3, [sp, #0]
10004a66:	1c08      	adds	r0, r1, #0
10004a68:	2100      	movs	r1, #0
10004a6a:	2300      	movs	r3, #0
10004a6c:	f7ff fd7a 	bl	10004564 <xTimerGenericCommand>
10004a70:	1c03      	adds	r3, r0, #0
10004a72:	60bb      	str	r3, [r7, #8]
                    configASSERT( xResult );
10004a74:	68bb      	ldr	r3, [r7, #8]
10004a76:	2b00      	cmp	r3, #0
10004a78:	d101      	bne.n	10004a7e <prvSwitchTimerLists+0x8e>
10004a7a:	b672      	cpsid	i
10004a7c:	e7fe      	b.n	10004a7c <prvSwitchTimerLists+0x8c>

        /* The tick count has overflowed.  The timer lists must be switched.
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
10004a7e:	4b09      	ldr	r3, [pc, #36]	; (10004aa4 <prvSwitchTimerLists+0xb4>)
10004a80:	681b      	ldr	r3, [r3, #0]
10004a82:	681b      	ldr	r3, [r3, #0]
10004a84:	2b00      	cmp	r3, #0
10004a86:	d1b7      	bne.n	100049f8 <prvSwitchTimerLists+0x8>
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        pxTemp = pxCurrentTimerList;
10004a88:	4b06      	ldr	r3, [pc, #24]	; (10004aa4 <prvSwitchTimerLists+0xb4>)
10004a8a:	681b      	ldr	r3, [r3, #0]
10004a8c:	607b      	str	r3, [r7, #4]
        pxCurrentTimerList = pxOverflowTimerList;
10004a8e:	4b06      	ldr	r3, [pc, #24]	; (10004aa8 <prvSwitchTimerLists+0xb8>)
10004a90:	681a      	ldr	r2, [r3, #0]
10004a92:	4b04      	ldr	r3, [pc, #16]	; (10004aa4 <prvSwitchTimerLists+0xb4>)
10004a94:	601a      	str	r2, [r3, #0]
        pxOverflowTimerList = pxTemp;
10004a96:	4b04      	ldr	r3, [pc, #16]	; (10004aa8 <prvSwitchTimerLists+0xb8>)
10004a98:	687a      	ldr	r2, [r7, #4]
10004a9a:	601a      	str	r2, [r3, #0]
    }
10004a9c:	46bd      	mov	sp, r7
10004a9e:	b006      	add	sp, #24
10004aa0:	bd80      	pop	{r7, pc}
10004aa2:	46c0      	nop			; (mov r8, r8)
10004aa4:	20000804 	.word	0x20000804
10004aa8:	20000808 	.word	0x20000808

10004aac <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

    static void prvCheckForValidListAndQueue( void )
    {
10004aac:	b580      	push	{r7, lr}
10004aae:	af00      	add	r7, sp, #0
        /* Check that the list from which active timers are referenced, and the
         * queue used to communicate with the timer service, have been
         * initialised. */
        taskENTER_CRITICAL();
10004ab0:	f7fe f8f8 	bl	10002ca4 <vPortEnterCritical>
        {
            if( xTimerQueue == NULL )
10004ab4:	4b14      	ldr	r3, [pc, #80]	; (10004b08 <prvCheckForValidListAndQueue+0x5c>)
10004ab6:	681b      	ldr	r3, [r3, #0]
10004ab8:	2b00      	cmp	r3, #0
10004aba:	d120      	bne.n	10004afe <prvCheckForValidListAndQueue+0x52>
            {
                vListInitialise( &xActiveTimerList1 );
10004abc:	4b13      	ldr	r3, [pc, #76]	; (10004b0c <prvCheckForValidListAndQueue+0x60>)
10004abe:	1c18      	adds	r0, r3, #0
10004ac0:	f7fe f9ac 	bl	10002e1c <vListInitialise>
                vListInitialise( &xActiveTimerList2 );
10004ac4:	4b12      	ldr	r3, [pc, #72]	; (10004b10 <prvCheckForValidListAndQueue+0x64>)
10004ac6:	1c18      	adds	r0, r3, #0
10004ac8:	f7fe f9a8 	bl	10002e1c <vListInitialise>
                pxCurrentTimerList = &xActiveTimerList1;
10004acc:	4b11      	ldr	r3, [pc, #68]	; (10004b14 <prvCheckForValidListAndQueue+0x68>)
10004ace:	4a0f      	ldr	r2, [pc, #60]	; (10004b0c <prvCheckForValidListAndQueue+0x60>)
10004ad0:	601a      	str	r2, [r3, #0]
                pxOverflowTimerList = &xActiveTimerList2;
10004ad2:	4b11      	ldr	r3, [pc, #68]	; (10004b18 <prvCheckForValidListAndQueue+0x6c>)
10004ad4:	4a0e      	ldr	r2, [pc, #56]	; (10004b10 <prvCheckForValidListAndQueue+0x64>)
10004ad6:	601a      	str	r2, [r3, #0]

                        xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
                    }
                #else
                    {
                        xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
10004ad8:	2005      	movs	r0, #5
10004ada:	2110      	movs	r1, #16
10004adc:	2200      	movs	r2, #0
10004ade:	f7fe fa99 	bl	10003014 <xQueueGenericCreate>
10004ae2:	1c02      	adds	r2, r0, #0
10004ae4:	4b08      	ldr	r3, [pc, #32]	; (10004b08 <prvCheckForValidListAndQueue+0x5c>)
10004ae6:	601a      	str	r2, [r3, #0]
                    }
                #endif /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */

                #if ( configQUEUE_REGISTRY_SIZE > 0 )
                    {
                        if( xTimerQueue != NULL )
10004ae8:	4b07      	ldr	r3, [pc, #28]	; (10004b08 <prvCheckForValidListAndQueue+0x5c>)
10004aea:	681b      	ldr	r3, [r3, #0]
10004aec:	2b00      	cmp	r3, #0
10004aee:	d006      	beq.n	10004afe <prvCheckForValidListAndQueue+0x52>
                        {
                            vQueueAddToRegistry( xTimerQueue, "TmrQ" );
10004af0:	4b05      	ldr	r3, [pc, #20]	; (10004b08 <prvCheckForValidListAndQueue+0x5c>)
10004af2:	681a      	ldr	r2, [r3, #0]
10004af4:	4b09      	ldr	r3, [pc, #36]	; (10004b1c <prvCheckForValidListAndQueue+0x70>)
10004af6:	1c10      	adds	r0, r2, #0
10004af8:	1c19      	adds	r1, r3, #0
10004afa:	f7fe fe67 	bl	100037cc <vQueueAddToRegistry>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
10004afe:	f7fe f8e1 	bl	10002cc4 <vPortExitCritical>
    }
10004b02:	46bd      	mov	sp, r7
10004b04:	bd80      	pop	{r7, pc}
10004b06:	46c0      	nop			; (mov r8, r8)
10004b08:	2000080c 	.word	0x2000080c
10004b0c:	200007dc 	.word	0x200007dc
10004b10:	200007f0 	.word	0x200007f0
10004b14:	20000804 	.word	0x20000804
10004b18:	20000808 	.word	0x20000808
10004b1c:	1000a1cc 	.word	0x1000a1cc

10004b20 <DIGITAL_IO_Init>:
* @param handler Pointer pointing to APP data structure.
* @return DIGITAL_IO_STATUS_t DIGITAL_IO APP status.
*/

DIGITAL_IO_STATUS_t DIGITAL_IO_Init(const DIGITAL_IO_t *const handler)
{
10004b20:	b580      	push	{r7, lr}
10004b22:	b082      	sub	sp, #8
10004b24:	af00      	add	r7, sp, #0
10004b26:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("DIGITAL_IO_Init: handler null pointer", handler != NULL);

  /* Initializes input / output characteristics */
  XMC_GPIO_Init(handler->gpio_port, handler->gpio_pin, &handler->gpio_config);
10004b28:	687b      	ldr	r3, [r7, #4]
10004b2a:	6819      	ldr	r1, [r3, #0]
10004b2c:	687b      	ldr	r3, [r7, #4]
10004b2e:	7b1a      	ldrb	r2, [r3, #12]
10004b30:	687b      	ldr	r3, [r7, #4]
10004b32:	3304      	adds	r3, #4
10004b34:	1c08      	adds	r0, r1, #0
10004b36:	1c11      	adds	r1, r2, #0
10004b38:	1c1a      	adds	r2, r3, #0
10004b3a:	f7fc fae7 	bl	1000110c <XMC_GPIO_Init>

  /*Configure hardware port control*/
  XMC_GPIO_SetHardwareControl(handler->gpio_port, handler->gpio_pin, handler->hwctrl);
10004b3e:	687b      	ldr	r3, [r7, #4]
10004b40:	6819      	ldr	r1, [r3, #0]
10004b42:	687b      	ldr	r3, [r7, #4]
10004b44:	7b1a      	ldrb	r2, [r3, #12]
10004b46:	687b      	ldr	r3, [r7, #4]
10004b48:	7b5b      	ldrb	r3, [r3, #13]
10004b4a:	1c08      	adds	r0, r1, #0
10004b4c:	1c11      	adds	r1, r2, #0
10004b4e:	1c1a      	adds	r2, r3, #0
10004b50:	f7fc fd92 	bl	10001678 <XMC_GPIO_SetHardwareControl>

  return (DIGITAL_IO_STATUS_OK);
10004b54:	2300      	movs	r3, #0
}
10004b56:	1c18      	adds	r0, r3, #0
10004b58:	46bd      	mov	sp, r7
10004b5a:	b002      	add	sp, #8
10004b5c:	bd80      	pop	{r7, pc}
10004b5e:	46c0      	nop			; (mov r8, r8)

10004b60 <SystemCoreSetup>:
{
  .initialized = false
};
 
void SystemCoreSetup(void)
{
10004b60:	b580      	push	{r7, lr}
10004b62:	af00      	add	r7, sp, #0
#if UC_SERIES == XMC14
  /* Enable Prefetch unit */
  SCU_GENERAL->PFUCR &= ~SCU_GENERAL_PFUCR_PFUBYP_Msk;
#endif
}
10004b64:	46bd      	mov	sp, r7
10004b66:	bd80      	pop	{r7, pc}

10004b68 <CLOCK_XMC1_Init>:

/*
 * API to initialize the CLOCK_XMC1 APP Interrupts
 */
CLOCK_XMC1_STATUS_t CLOCK_XMC1_Init(CLOCK_XMC1_t *handle)
{
10004b68:	b580      	push	{r7, lr}
10004b6a:	b084      	sub	sp, #16
10004b6c:	af00      	add	r7, sp, #0
10004b6e:	6078      	str	r0, [r7, #4]
  CLOCK_XMC1_STATUS_t status = CLOCK_XMC1_STATUS_SUCCESS;
10004b70:	230f      	movs	r3, #15
10004b72:	18fb      	adds	r3, r7, r3
10004b74:	2200      	movs	r2, #0
10004b76:	701a      	strb	r2, [r3, #0]
  CLOCK_XMC1_STATUS_t loci_event_status = CLOCK_XMC1_STATUS_SUCCESS;
10004b78:	230e      	movs	r3, #14
10004b7a:	18fb      	adds	r3, r7, r3
10004b7c:	2200      	movs	r2, #0
10004b7e:	701a      	strb	r2, [r3, #0]
  CLOCK_XMC1_STATUS_t stdbyclkfail_status = CLOCK_XMC1_STATUS_SUCCESS;
10004b80:	230d      	movs	r3, #13
10004b82:	18fb      	adds	r3, r7, r3
10004b84:	2200      	movs	r2, #0
10004b86:	701a      	strb	r2, [r3, #0]
  CLOCK_XMC1_STATUS_t loss_ext_clock_event_status = CLOCK_XMC1_STATUS_SUCCESS;
10004b88:	230c      	movs	r3, #12
10004b8a:	18fb      	adds	r3, r7, r3
10004b8c:	2200      	movs	r2, #0
10004b8e:	701a      	strb	r2, [r3, #0]
  CLOCK_XMC1_STATUS_t dco1_out_sync_status = CLOCK_XMC1_STATUS_SUCCESS;
10004b90:	230b      	movs	r3, #11
10004b92:	18fb      	adds	r3, r7, r3
10004b94:	2200      	movs	r2, #0
10004b96:	701a      	strb	r2, [r3, #0]

  XMC_ASSERT("CLOCK_XMC1_Init: CLOCK_XMC1 APP handle pointer uninitialized", (handle != NULL));

  if (handle->init_status == false)
10004b98:	687b      	ldr	r3, [r7, #4]
10004b9a:	781b      	ldrb	r3, [r3, #0]
10004b9c:	2201      	movs	r2, #1
10004b9e:	4053      	eors	r3, r2
10004ba0:	b2db      	uxtb	r3, r3
10004ba2:	2b00      	cmp	r3, #0
10004ba4:	d01b      	beq.n	10004bde <CLOCK_XMC1_Init+0x76>

#endif
    }

#endif
    status = (CLOCK_XMC1_STATUS_t)(((uint32_t)loci_event_status) | ((uint32_t)stdbyclkfail_status) |
10004ba6:	230e      	movs	r3, #14
10004ba8:	18fa      	adds	r2, r7, r3
10004baa:	230d      	movs	r3, #13
10004bac:	18fb      	adds	r3, r7, r3
10004bae:	7812      	ldrb	r2, [r2, #0]
10004bb0:	781b      	ldrb	r3, [r3, #0]
10004bb2:	4313      	orrs	r3, r2
10004bb4:	b2da      	uxtb	r2, r3
10004bb6:	230c      	movs	r3, #12
10004bb8:	18fb      	adds	r3, r7, r3
10004bba:	781b      	ldrb	r3, [r3, #0]
10004bbc:	4313      	orrs	r3, r2
10004bbe:	b2d9      	uxtb	r1, r3
10004bc0:	230f      	movs	r3, #15
10004bc2:	18fb      	adds	r3, r7, r3
10004bc4:	220b      	movs	r2, #11
10004bc6:	18ba      	adds	r2, r7, r2
10004bc8:	7812      	ldrb	r2, [r2, #0]
10004bca:	430a      	orrs	r2, r1
10004bcc:	701a      	strb	r2, [r3, #0]
    		                       ((uint32_t)loss_ext_clock_event_status) | ((uint32_t)dco1_out_sync_status));
    if (CLOCK_XMC1_STATUS_SUCCESS == status)
10004bce:	230f      	movs	r3, #15
10004bd0:	18fb      	adds	r3, r7, r3
10004bd2:	781b      	ldrb	r3, [r3, #0]
10004bd4:	2b00      	cmp	r3, #0
10004bd6:	d102      	bne.n	10004bde <CLOCK_XMC1_Init+0x76>
    {
      handle->init_status = true;
10004bd8:	687b      	ldr	r3, [r7, #4]
10004bda:	2201      	movs	r2, #1
10004bdc:	701a      	strb	r2, [r3, #0]
    }
  }
  return (status);
10004bde:	230f      	movs	r3, #15
10004be0:	18fb      	adds	r3, r7, r3
10004be2:	781b      	ldrb	r3, [r3, #0]
}
10004be4:	1c18      	adds	r0, r3, #0
10004be6:	46bd      	mov	sp, r7
10004be8:	b004      	add	sp, #16
10004bea:	bd80      	pop	{r7, pc}

10004bec <SystemCoreClockSetup>:

/**********************************************************************************************************************
* API IMPLEMENTATION
**********************************************************************************************************************/
void SystemCoreClockSetup(void)
{
10004bec:	b590      	push	{r4, r7, lr}
10004bee:	b085      	sub	sp, #20
10004bf0:	af00      	add	r7, sp, #0
/* LOCAL DATA STRUCTURES */
const XMC_SCU_CLOCK_CONFIG_t CLOCK_XMC1_0_CONFIG =
10004bf2:	1d3b      	adds	r3, r7, #4
10004bf4:	4a04      	ldr	r2, [pc, #16]	; (10004c08 <SystemCoreClockSetup+0x1c>)
10004bf6:	ca13      	ldmia	r2!, {r0, r1, r4}
10004bf8:	c313      	stmia	r3!, {r0, r1, r4}
  .idiv = 1U,  /**< 8 Bit integer divider */

};

  /* Configure FDIV, IDIV, PCLKSEL dividers*/
  XMC_SCU_CLOCK_Init(&CLOCK_XMC1_0_CONFIG);
10004bfa:	1d3b      	adds	r3, r7, #4
10004bfc:	1c18      	adds	r0, r3, #0
10004bfe:	f7fc fb5d 	bl	100012bc <XMC_SCU_CLOCK_Init>
}
10004c02:	46bd      	mov	sp, r7
10004c04:	b005      	add	sp, #20
10004c06:	bd90      	pop	{r4, r7, pc}
10004c08:	1000a23c 	.word	0x1000a23c

10004c0c <DAVE_Init>:
 * @param[in]  None
 *
 * @return  DAVE_STATUS_t <BR>
 ******************************************************************************/
__WEAK DAVE_STATUS_t DAVE_Init(void)
{
10004c0c:	b590      	push	{r4, r7, lr}
10004c0e:	b083      	sub	sp, #12
10004c10:	af00      	add	r7, sp, #0
  DAVE_STATUS_t init_status;
  
  init_status = DAVE_STATUS_SUCCESS;
10004c12:	1dfb      	adds	r3, r7, #7
10004c14:	2200      	movs	r2, #0
10004c16:	701a      	strb	r2, [r3, #0]
     /** @Initialization of APPs Init Functions */
     init_status = (DAVE_STATUS_t)CLOCK_XMC1_Init(&CLOCK_XMC1_0);
10004c18:	1dfc      	adds	r4, r7, #7
10004c1a:	4b42      	ldr	r3, [pc, #264]	; (10004d24 <DAVE_Init+0x118>)
10004c1c:	1c18      	adds	r0, r3, #0
10004c1e:	f7ff ffa3 	bl	10004b68 <CLOCK_XMC1_Init>
10004c22:	1c03      	adds	r3, r0, #0
10004c24:	7023      	strb	r3, [r4, #0]

  if (init_status == DAVE_STATUS_SUCCESS)
10004c26:	1dfb      	adds	r3, r7, #7
10004c28:	781b      	ldrb	r3, [r3, #0]
10004c2a:	2b00      	cmp	r3, #0
10004c2c:	d106      	bne.n	10004c3c <DAVE_Init+0x30>
  {
	 /**  Initialization of TIMER APP instance TIMER_ECHO_IN */
	 init_status = (DAVE_STATUS_t)TIMER_Init(&TIMER_ECHO_IN); 
10004c2e:	1dfc      	adds	r4, r7, #7
10004c30:	4b3d      	ldr	r3, [pc, #244]	; (10004d28 <DAVE_Init+0x11c>)
10004c32:	1c18      	adds	r0, r3, #0
10004c34:	f7fd fcca 	bl	100025cc <TIMER_Init>
10004c38:	1c03      	adds	r3, r0, #0
10004c3a:	7023      	strb	r3, [r4, #0]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
10004c3c:	1dfb      	adds	r3, r7, #7
10004c3e:	781b      	ldrb	r3, [r3, #0]
10004c40:	2b00      	cmp	r3, #0
10004c42:	d106      	bne.n	10004c52 <DAVE_Init+0x46>
  {
	 /**  Initialization of INTERRUPT APP instance INTERRUPT_ECHO_IN */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&INTERRUPT_ECHO_IN); 
10004c44:	1dfc      	adds	r4, r7, #7
10004c46:	4b39      	ldr	r3, [pc, #228]	; (10004d2c <DAVE_Init+0x120>)
10004c48:	1c18      	adds	r0, r3, #0
10004c4a:	f7fd ff4d 	bl	10002ae8 <INTERRUPT_Init>
10004c4e:	1c03      	adds	r3, r0, #0
10004c50:	7023      	strb	r3, [r4, #0]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
10004c52:	1dfb      	adds	r3, r7, #7
10004c54:	781b      	ldrb	r3, [r3, #0]
10004c56:	2b00      	cmp	r3, #0
10004c58:	d106      	bne.n	10004c68 <DAVE_Init+0x5c>
  {
	 /**  Initialization of DIGITAL_IO APP instance ECHO_OUT */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&ECHO_OUT); 
10004c5a:	1dfc      	adds	r4, r7, #7
10004c5c:	4b34      	ldr	r3, [pc, #208]	; (10004d30 <DAVE_Init+0x124>)
10004c5e:	1c18      	adds	r0, r3, #0
10004c60:	f7ff ff5e 	bl	10004b20 <DIGITAL_IO_Init>
10004c64:	1c03      	adds	r3, r0, #0
10004c66:	7023      	strb	r3, [r4, #0]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
10004c68:	1dfb      	adds	r3, r7, #7
10004c6a:	781b      	ldrb	r3, [r3, #0]
10004c6c:	2b00      	cmp	r3, #0
10004c6e:	d106      	bne.n	10004c7e <DAVE_Init+0x72>
  {
	 /**  Initialization of PWM APP instance TRIGGER_IN */
	 init_status = (DAVE_STATUS_t)PWM_Init(&TRIGGER_IN); 
10004c70:	1dfc      	adds	r4, r7, #7
10004c72:	4b30      	ldr	r3, [pc, #192]	; (10004d34 <DAVE_Init+0x128>)
10004c74:	1c18      	adds	r0, r3, #0
10004c76:	f7fd fe79 	bl	1000296c <PWM_Init>
10004c7a:	1c03      	adds	r3, r0, #0
10004c7c:	7023      	strb	r3, [r4, #0]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
10004c7e:	1dfb      	adds	r3, r7, #7
10004c80:	781b      	ldrb	r3, [r3, #0]
10004c82:	2b00      	cmp	r3, #0
10004c84:	d106      	bne.n	10004c94 <DAVE_Init+0x88>
  {
	 /**  Initialization of DIGITAL_IO APP instance ECHO_IN */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&ECHO_IN); 
10004c86:	1dfc      	adds	r4, r7, #7
10004c88:	4b2b      	ldr	r3, [pc, #172]	; (10004d38 <DAVE_Init+0x12c>)
10004c8a:	1c18      	adds	r0, r3, #0
10004c8c:	f7ff ff48 	bl	10004b20 <DIGITAL_IO_Init>
10004c90:	1c03      	adds	r3, r0, #0
10004c92:	7023      	strb	r3, [r4, #0]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
10004c94:	1dfb      	adds	r3, r7, #7
10004c96:	781b      	ldrb	r3, [r3, #0]
10004c98:	2b00      	cmp	r3, #0
10004c9a:	d106      	bne.n	10004caa <DAVE_Init+0x9e>
  {
	 /**  Initialization of UART APP instance UART_BLUETOOTH */
	 init_status = (DAVE_STATUS_t)UART_Init(&UART_BLUETOOTH); 
10004c9c:	1dfc      	adds	r4, r7, #7
10004c9e:	4b27      	ldr	r3, [pc, #156]	; (10004d3c <DAVE_Init+0x130>)
10004ca0:	1c18      	adds	r0, r3, #0
10004ca2:	f7fd f8f5 	bl	10001e90 <UART_Init>
10004ca6:	1c03      	adds	r3, r0, #0
10004ca8:	7023      	strb	r3, [r4, #0]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
10004caa:	1dfb      	adds	r3, r7, #7
10004cac:	781b      	ldrb	r3, [r3, #0]
10004cae:	2b00      	cmp	r3, #0
10004cb0:	d106      	bne.n	10004cc0 <DAVE_Init+0xb4>
  {
	 /**  Initialization of PWM APP instance TRIGGER_OUT */
	 init_status = (DAVE_STATUS_t)PWM_Init(&TRIGGER_OUT); 
10004cb2:	1dfc      	adds	r4, r7, #7
10004cb4:	4b22      	ldr	r3, [pc, #136]	; (10004d40 <DAVE_Init+0x134>)
10004cb6:	1c18      	adds	r0, r3, #0
10004cb8:	f7fd fe58 	bl	1000296c <PWM_Init>
10004cbc:	1c03      	adds	r3, r0, #0
10004cbe:	7023      	strb	r3, [r4, #0]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
10004cc0:	1dfb      	adds	r3, r7, #7
10004cc2:	781b      	ldrb	r3, [r3, #0]
10004cc4:	2b00      	cmp	r3, #0
10004cc6:	d106      	bne.n	10004cd6 <DAVE_Init+0xca>
  {
	 /**  Initialization of TIMER APP instance TIMER_ECHO_OUT */
	 init_status = (DAVE_STATUS_t)TIMER_Init(&TIMER_ECHO_OUT); 
10004cc8:	1dfc      	adds	r4, r7, #7
10004cca:	4b1e      	ldr	r3, [pc, #120]	; (10004d44 <DAVE_Init+0x138>)
10004ccc:	1c18      	adds	r0, r3, #0
10004cce:	f7fd fc7d 	bl	100025cc <TIMER_Init>
10004cd2:	1c03      	adds	r3, r0, #0
10004cd4:	7023      	strb	r3, [r4, #0]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
10004cd6:	1dfb      	adds	r3, r7, #7
10004cd8:	781b      	ldrb	r3, [r3, #0]
10004cda:	2b00      	cmp	r3, #0
10004cdc:	d106      	bne.n	10004cec <DAVE_Init+0xe0>
  {
	 /**  Initialization of INTERRUPT APP instance INTERRUPT_ECHO_OUT */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&INTERRUPT_ECHO_OUT); 
10004cde:	1dfc      	adds	r4, r7, #7
10004ce0:	4b19      	ldr	r3, [pc, #100]	; (10004d48 <DAVE_Init+0x13c>)
10004ce2:	1c18      	adds	r0, r3, #0
10004ce4:	f7fd ff00 	bl	10002ae8 <INTERRUPT_Init>
10004ce8:	1c03      	adds	r3, r0, #0
10004cea:	7023      	strb	r3, [r4, #0]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
10004cec:	1dfb      	adds	r3, r7, #7
10004cee:	781b      	ldrb	r3, [r3, #0]
10004cf0:	2b00      	cmp	r3, #0
10004cf2:	d106      	bne.n	10004d02 <DAVE_Init+0xf6>
  {
	 /**  Initialization of DIGITAL_IO APP instance GREEN_LED */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&GREEN_LED); 
10004cf4:	1dfc      	adds	r4, r7, #7
10004cf6:	4b15      	ldr	r3, [pc, #84]	; (10004d4c <DAVE_Init+0x140>)
10004cf8:	1c18      	adds	r0, r3, #0
10004cfa:	f7ff ff11 	bl	10004b20 <DIGITAL_IO_Init>
10004cfe:	1c03      	adds	r3, r0, #0
10004d00:	7023      	strb	r3, [r4, #0]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
10004d02:	1dfb      	adds	r3, r7, #7
10004d04:	781b      	ldrb	r3, [r3, #0]
10004d06:	2b00      	cmp	r3, #0
10004d08:	d106      	bne.n	10004d18 <DAVE_Init+0x10c>
  {
	 /**  Initialization of DIGITAL_IO APP instance RED_LED */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&RED_LED); 
10004d0a:	1dfc      	adds	r4, r7, #7
10004d0c:	4b10      	ldr	r3, [pc, #64]	; (10004d50 <DAVE_Init+0x144>)
10004d0e:	1c18      	adds	r0, r3, #0
10004d10:	f7ff ff06 	bl	10004b20 <DIGITAL_IO_Init>
10004d14:	1c03      	adds	r3, r0, #0
10004d16:	7023      	strb	r3, [r4, #0]
   }  
  return init_status;
10004d18:	1dfb      	adds	r3, r7, #7
10004d1a:	781b      	ldrb	r3, [r3, #0]
} /**  End of function DAVE_Init */
10004d1c:	1c18      	adds	r0, r3, #0
10004d1e:	46bd      	mov	sp, r7
10004d20:	b003      	add	sp, #12
10004d22:	bd90      	pop	{r4, r7, pc}
10004d24:	20000818 	.word	0x20000818
10004d28:	2000052c 	.word	0x2000052c
10004d2c:	1000a1a4 	.word	0x1000a1a4
10004d30:	1000a1fc 	.word	0x1000a1fc
10004d34:	2000057c 	.word	0x2000057c
10004d38:	1000a20c 	.word	0x1000a20c
10004d3c:	20000520 	.word	0x20000520
10004d40:	200005b0 	.word	0x200005b0
10004d44:	20000554 	.word	0x20000554
10004d48:	1000a1a8 	.word	0x1000a1a8
10004d4c:	1000a21c 	.word	0x1000a21c
10004d50:	1000a22c 	.word	0x1000a22c

10004d54 <XMC_GPIO_SetOutputHigh>:
 * Register Pn_OMR is virtual and does not contain any flip-flop. A read action delivers the value of 0.
 *
 */

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
10004d54:	b580      	push	{r7, lr}
10004d56:	b082      	sub	sp, #8
10004d58:	af00      	add	r7, sp, #0
10004d5a:	6078      	str	r0, [r7, #4]
10004d5c:	1c0a      	adds	r2, r1, #0
10004d5e:	1cfb      	adds	r3, r7, #3
10004d60:	701a      	strb	r2, [r3, #0]
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
10004d62:	1cfb      	adds	r3, r7, #3
10004d64:	781b      	ldrb	r3, [r3, #0]
10004d66:	2201      	movs	r2, #1
10004d68:	409a      	lsls	r2, r3
10004d6a:	687b      	ldr	r3, [r7, #4]
10004d6c:	605a      	str	r2, [r3, #4]
}
10004d6e:	46bd      	mov	sp, r7
10004d70:	b002      	add	sp, #8
10004d72:	bd80      	pop	{r7, pc}

10004d74 <XMC_GPIO_SetOutputLow>:
 * Register Pn_OMR is virtual and does not contain any flip-flop. A read action delivers the value of 0.\n
 *
 */

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
10004d74:	b580      	push	{r7, lr}
10004d76:	b082      	sub	sp, #8
10004d78:	af00      	add	r7, sp, #0
10004d7a:	6078      	str	r0, [r7, #4]
10004d7c:	1c0a      	adds	r2, r1, #0
10004d7e:	1cfb      	adds	r3, r7, #3
10004d80:	701a      	strb	r2, [r3, #0]
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
10004d82:	1cfb      	adds	r3, r7, #3
10004d84:	781b      	ldrb	r3, [r3, #0]
10004d86:	2280      	movs	r2, #128	; 0x80
10004d88:	0252      	lsls	r2, r2, #9
10004d8a:	409a      	lsls	r2, r3
10004d8c:	687b      	ldr	r3, [r7, #4]
10004d8e:	605a      	str	r2, [r3, #4]
}
10004d90:	46bd      	mov	sp, r7
10004d92:	b002      	add	sp, #8
10004d94:	bd80      	pop	{r7, pc}
10004d96:	46c0      	nop			; (mov r8, r8)

10004d98 <XMC_GPIO_GetInput>:
 * Prior to this api, user has to configure port pin to input mode using XMC_GPIO_SetMode().
 *
 */

__STATIC_INLINE uint32_t XMC_GPIO_GetInput(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
10004d98:	b580      	push	{r7, lr}
10004d9a:	b082      	sub	sp, #8
10004d9c:	af00      	add	r7, sp, #0
10004d9e:	6078      	str	r0, [r7, #4]
10004da0:	1c0a      	adds	r2, r1, #0
10004da2:	1cfb      	adds	r3, r7, #3
10004da4:	701a      	strb	r2, [r3, #0]
  XMC_ASSERT("XMC_GPIO_GetInput: Invalid port", XMC_GPIO_CHECK_PORT(port));

  return (((port->IN) >> pin) & 0x1U);
10004da6:	687b      	ldr	r3, [r7, #4]
10004da8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
10004daa:	1cfb      	adds	r3, r7, #3
10004dac:	781b      	ldrb	r3, [r3, #0]
10004dae:	40da      	lsrs	r2, r3
10004db0:	1c13      	adds	r3, r2, #0
10004db2:	2201      	movs	r2, #1
10004db4:	4013      	ands	r3, r2
}
10004db6:	1c18      	adds	r0, r3, #0
10004db8:	46bd      	mov	sp, r7
10004dba:	b002      	add	sp, #8
10004dbc:	bd80      	pop	{r7, pc}
10004dbe:	46c0      	nop			; (mov r8, r8)

10004dc0 <DIGITAL_IO_SetOutputHigh>:
* }
*  @endcode
*/

__STATIC_INLINE void DIGITAL_IO_SetOutputHigh(const DIGITAL_IO_t *const handler)
{
10004dc0:	b580      	push	{r7, lr}
10004dc2:	b082      	sub	sp, #8
10004dc4:	af00      	add	r7, sp, #0
10004dc6:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("DIGITAL_IO_SetOutputHigh: handler null pointer", handler != NULL);
  XMC_GPIO_SetOutputHigh(handler->gpio_port, handler->gpio_pin);
10004dc8:	687b      	ldr	r3, [r7, #4]
10004dca:	681a      	ldr	r2, [r3, #0]
10004dcc:	687b      	ldr	r3, [r7, #4]
10004dce:	7b1b      	ldrb	r3, [r3, #12]
10004dd0:	1c10      	adds	r0, r2, #0
10004dd2:	1c19      	adds	r1, r3, #0
10004dd4:	f7ff ffbe 	bl	10004d54 <XMC_GPIO_SetOutputHigh>
}
10004dd8:	46bd      	mov	sp, r7
10004dda:	b002      	add	sp, #8
10004ddc:	bd80      	pop	{r7, pc}
10004dde:	46c0      	nop			; (mov r8, r8)

10004de0 <DIGITAL_IO_SetOutputLow>:
* }
*  @endcode
*/

__STATIC_INLINE void DIGITAL_IO_SetOutputLow(const DIGITAL_IO_t *const handler)
{
10004de0:	b580      	push	{r7, lr}
10004de2:	b082      	sub	sp, #8
10004de4:	af00      	add	r7, sp, #0
10004de6:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("DIGITAL_IO_SetOutputLow: handler null pointer", handler != NULL);
  XMC_GPIO_SetOutputLow(handler->gpio_port,handler->gpio_pin);
10004de8:	687b      	ldr	r3, [r7, #4]
10004dea:	681a      	ldr	r2, [r3, #0]
10004dec:	687b      	ldr	r3, [r7, #4]
10004dee:	7b1b      	ldrb	r3, [r3, #12]
10004df0:	1c10      	adds	r0, r2, #0
10004df2:	1c19      	adds	r1, r3, #0
10004df4:	f7ff ffbe 	bl	10004d74 <XMC_GPIO_SetOutputLow>
}
10004df8:	46bd      	mov	sp, r7
10004dfa:	b002      	add	sp, #8
10004dfc:	bd80      	pop	{r7, pc}
10004dfe:	46c0      	nop			; (mov r8, r8)

10004e00 <DIGITAL_IO_GetInput>:
* }
*  @endcode
*/

__STATIC_INLINE uint32_t DIGITAL_IO_GetInput(const DIGITAL_IO_t *const handler)
{
10004e00:	b580      	push	{r7, lr}
10004e02:	b082      	sub	sp, #8
10004e04:	af00      	add	r7, sp, #0
10004e06:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("DIGITAL_IO_GetInput: handler null pointer", handler != NULL);
  return XMC_GPIO_GetInput(handler->gpio_port, handler->gpio_pin);
10004e08:	687b      	ldr	r3, [r7, #4]
10004e0a:	681a      	ldr	r2, [r3, #0]
10004e0c:	687b      	ldr	r3, [r7, #4]
10004e0e:	7b1b      	ldrb	r3, [r3, #12]
10004e10:	1c10      	adds	r0, r2, #0
10004e12:	1c19      	adds	r1, r3, #0
10004e14:	f7ff ffc0 	bl	10004d98 <XMC_GPIO_GetInput>
10004e18:	1c03      	adds	r3, r0, #0
}
10004e1a:	1c18      	adds	r0, r3, #0
10004e1c:	46bd      	mov	sp, r7
10004e1e:	b002      	add	sp, #8
10004e20:	bd80      	pop	{r7, pc}
10004e22:	46c0      	nop			; (mov r8, r8)

10004e24 <main>:

void ProcessingTask(void *pvParameters);
void CommunicationTask(void *pvParameters);

int main(void)
{
10004e24:	b590      	push	{r4, r7, lr}
10004e26:	b085      	sub	sp, #20
10004e28:	af02      	add	r7, sp, #8
  initialise_monitor_handles();
10004e2a:	f005 f801 	bl	10009e30 <initialise_monitor_handles>
  DAVE_STATUS_t status;

  status = DAVE_Init();
10004e2e:	1dfc      	adds	r4, r7, #7
10004e30:	f7ff feec 	bl	10004c0c <DAVE_Init>
10004e34:	1c03      	adds	r3, r0, #0
10004e36:	7023      	strb	r3, [r4, #0]

  if (status != DAVE_STATUS_SUCCESS)
10004e38:	1dfb      	adds	r3, r7, #7
10004e3a:	781b      	ldrb	r3, [r3, #0]
10004e3c:	2b00      	cmp	r3, #0
10004e3e:	d004      	beq.n	10004e4a <main+0x26>
  {
	  printf("DAVE APPs initialization failed\n");
10004e40:	4b1d      	ldr	r3, [pc, #116]	; (10004eb8 <main+0x94>)
10004e42:	1c18      	adds	r0, r3, #0
10004e44:	f001 f922 	bl	1000608c <puts>

	  while(1U);
10004e48:	e7fe      	b.n	10004e48 <main+0x24>
  }
  printf("Start\n");
10004e4a:	4b1c      	ldr	r3, [pc, #112]	; (10004ebc <main+0x98>)
10004e4c:	1c18      	adds	r0, r3, #0
10004e4e:	f001 f91d 	bl	1000608c <puts>
  TIMER_Start(&TIMER_ECHO_IN);
10004e52:	4b1b      	ldr	r3, [pc, #108]	; (10004ec0 <main+0x9c>)
10004e54:	1c18      	adds	r0, r3, #0
10004e56:	f7fd fbdd 	bl	10002614 <TIMER_Start>
  TIMER_Start(&TIMER_ECHO_OUT);
10004e5a:	4b1a      	ldr	r3, [pc, #104]	; (10004ec4 <main+0xa0>)
10004e5c:	1c18      	adds	r0, r3, #0
10004e5e:	f7fd fbd9 	bl	10002614 <TIMER_Start>

  xSemaphore = xSemaphoreCreateBinary();
10004e62:	2001      	movs	r0, #1
10004e64:	2100      	movs	r1, #0
10004e66:	2203      	movs	r2, #3
10004e68:	f7fe f8d4 	bl	10003014 <xQueueGenericCreate>
10004e6c:	1c02      	adds	r2, r0, #0
10004e6e:	4b16      	ldr	r3, [pc, #88]	; (10004ec8 <main+0xa4>)
10004e70:	601a      	str	r2, [r3, #0]
  xQueue = xQueueCreate(5, sizeof(uint8_t));
10004e72:	2005      	movs	r0, #5
10004e74:	2101      	movs	r1, #1
10004e76:	2200      	movs	r2, #0
10004e78:	f7fe f8cc 	bl	10003014 <xQueueGenericCreate>
10004e7c:	1c02      	adds	r2, r0, #0
10004e7e:	4b13      	ldr	r3, [pc, #76]	; (10004ecc <main+0xa8>)
10004e80:	601a      	str	r2, [r3, #0]

  xTaskCreate(ProcessingTask, "Processing Task", 200, NULL, 2, NULL);
10004e82:	4913      	ldr	r1, [pc, #76]	; (10004ed0 <main+0xac>)
10004e84:	4a13      	ldr	r2, [pc, #76]	; (10004ed4 <main+0xb0>)
10004e86:	2302      	movs	r3, #2
10004e88:	9300      	str	r3, [sp, #0]
10004e8a:	2300      	movs	r3, #0
10004e8c:	9301      	str	r3, [sp, #4]
10004e8e:	1c08      	adds	r0, r1, #0
10004e90:	1c11      	adds	r1, r2, #0
10004e92:	22c8      	movs	r2, #200	; 0xc8
10004e94:	2300      	movs	r3, #0
10004e96:	f7fe fd4d 	bl	10003934 <xTaskCreate>
  xTaskCreate(CommunicationTask, "Communication Task", 200, NULL, 1, NULL);
10004e9a:	490f      	ldr	r1, [pc, #60]	; (10004ed8 <main+0xb4>)
10004e9c:	4a0f      	ldr	r2, [pc, #60]	; (10004edc <main+0xb8>)
10004e9e:	2301      	movs	r3, #1
10004ea0:	9300      	str	r3, [sp, #0]
10004ea2:	2300      	movs	r3, #0
10004ea4:	9301      	str	r3, [sp, #4]
10004ea6:	1c08      	adds	r0, r1, #0
10004ea8:	1c11      	adds	r1, r2, #0
10004eaa:	22c8      	movs	r2, #200	; 0xc8
10004eac:	2300      	movs	r3, #0
10004eae:	f7fe fd41 	bl	10003934 <xTaskCreate>

  vTaskStartScheduler();
10004eb2:	f7fe fead 	bl	10003c10 <vTaskStartScheduler>

  while(1U);
10004eb6:	e7fe      	b.n	10004eb6 <main+0x92>
10004eb8:	1000a248 	.word	0x1000a248
10004ebc:	1000a268 	.word	0x1000a268
10004ec0:	2000052c 	.word	0x2000052c
10004ec4:	20000554 	.word	0x20000554
10004ec8:	20000914 	.word	0x20000914
10004ecc:	20000920 	.word	0x20000920
10004ed0:	10004ee1 	.word	0x10004ee1
10004ed4:	1000a270 	.word	0x1000a270
10004ed8:	10004f2d 	.word	0x10004f2d
10004edc:	1000a280 	.word	0x1000a280

10004ee0 <ProcessingTask>:
}

void ProcessingTask(void *pvParameters)
{
10004ee0:	b580      	push	{r7, lr}
10004ee2:	b084      	sub	sp, #16
10004ee4:	af00      	add	r7, sp, #0
10004ee6:	6078      	str	r0, [r7, #4]
    uint32_t start_time, end_time;
    task_timer_counter = 0;
10004ee8:	4b0e      	ldr	r3, [pc, #56]	; (10004f24 <ProcessingTask+0x44>)
10004eea:	2200      	movs	r2, #0
10004eec:	601a      	str	r2, [r3, #0]
	while (1)
	{
        start_time = task_timer_counter;
10004eee:	4b0d      	ldr	r3, [pc, #52]	; (10004f24 <ProcessingTask+0x44>)
10004ef0:	681b      	ldr	r3, [r3, #0]
10004ef2:	60fb      	str	r3, [r7, #12]
		check_entrance();
10004ef4:	f000 f886 	bl	10005004 <check_entrance>
		check_exit();
10004ef8:	f000 f8ea 	bl	100050d0 <check_exit>
		update_leds();
10004efc:	f000 f94e 	bl	1000519c <update_leds>

		end_time = task_timer_counter;
10004f00:	4b08      	ldr	r3, [pc, #32]	; (10004f24 <ProcessingTask+0x44>)
10004f02:	681b      	ldr	r3, [r3, #0]
10004f04:	60bb      	str	r3, [r7, #8]

        printf("ProcessingTask duration: %lu us\n", (end_time - start_time)*1000);
10004f06:	68ba      	ldr	r2, [r7, #8]
10004f08:	68fb      	ldr	r3, [r7, #12]
10004f0a:	1ad3      	subs	r3, r2, r3
10004f0c:	22fa      	movs	r2, #250	; 0xfa
10004f0e:	0092      	lsls	r2, r2, #2
10004f10:	4353      	muls	r3, r2
10004f12:	4a05      	ldr	r2, [pc, #20]	; (10004f28 <ProcessingTask+0x48>)
10004f14:	1c10      	adds	r0, r2, #0
10004f16:	1c19      	adds	r1, r3, #0
10004f18:	f001 f83c 	bl	10005f94 <iprintf>

		vTaskDelay(pdMS_TO_TICKS(100));
10004f1c:	2064      	movs	r0, #100	; 0x64
10004f1e:	f7fe fe53 	bl	10003bc8 <vTaskDelay>
	}
10004f22:	e7e4      	b.n	10004eee <ProcessingTask+0xe>
10004f24:	20000924 	.word	0x20000924
10004f28:	1000a294 	.word	0x1000a294

10004f2c <CommunicationTask>:
}

void CommunicationTask(void *pvParameters)
{
10004f2c:	b590      	push	{r4, r7, lr}
10004f2e:	b09d      	sub	sp, #116	; 0x74
10004f30:	af00      	add	r7, sp, #0
10004f32:	6078      	str	r0, [r7, #4]
    uint8_t occupied_spaces;
    char message[100];

    while (1)
    {
        if (xQueueReceive(xQueue, &occupied_spaces, portMAX_DELAY) == pdPASS)
10004f34:	4b2d      	ldr	r3, [pc, #180]	; (10004fec <CommunicationTask+0xc0>)
10004f36:	6819      	ldr	r1, [r3, #0]
10004f38:	236f      	movs	r3, #111	; 0x6f
10004f3a:	18fa      	adds	r2, r7, r3
10004f3c:	2301      	movs	r3, #1
10004f3e:	425b      	negs	r3, r3
10004f40:	1c08      	adds	r0, r1, #0
10004f42:	1c11      	adds	r1, r2, #0
10004f44:	1c1a      	adds	r2, r3, #0
10004f46:	f7fe fa55 	bl	100033f4 <xQueueReceive>
10004f4a:	1e03      	subs	r3, r0, #0
10004f4c:	2b01      	cmp	r3, #1
10004f4e:	d14c      	bne.n	10004fea <CommunicationTask+0xbe>
        {
        	printf("occupied_spaces = %lu\n", occupied_spaces);
10004f50:	236f      	movs	r3, #111	; 0x6f
10004f52:	18fb      	adds	r3, r7, r3
10004f54:	781b      	ldrb	r3, [r3, #0]
10004f56:	1c1a      	adds	r2, r3, #0
10004f58:	4b25      	ldr	r3, [pc, #148]	; (10004ff0 <CommunicationTask+0xc4>)
10004f5a:	1c18      	adds	r0, r3, #0
10004f5c:	1c11      	adds	r1, r2, #0
10004f5e:	f001 f819 	bl	10005f94 <iprintf>
            sprintf(message, "Free spaces: %d\n", (PARK_SPACES - occupied_spaces));
10004f62:	236f      	movs	r3, #111	; 0x6f
10004f64:	18fb      	adds	r3, r7, r3
10004f66:	781b      	ldrb	r3, [r3, #0]
10004f68:	1c1a      	adds	r2, r3, #0
10004f6a:	2305      	movs	r3, #5
10004f6c:	1a9b      	subs	r3, r3, r2
10004f6e:	2208      	movs	r2, #8
10004f70:	18b9      	adds	r1, r7, r2
10004f72:	4a20      	ldr	r2, [pc, #128]	; (10004ff4 <CommunicationTask+0xc8>)
10004f74:	1c08      	adds	r0, r1, #0
10004f76:	1c11      	adds	r1, r2, #0
10004f78:	1c1a      	adds	r2, r3, #0
10004f7a:	f001 f8cb 	bl	10006114 <siprintf>
            UART_Transmit(&UART_BLUETOOTH, (uint8_t *)message, strlen(message));
10004f7e:	2308      	movs	r3, #8
10004f80:	18fb      	adds	r3, r7, r3
10004f82:	1c18      	adds	r0, r3, #0
10004f84:	f001 f8e8 	bl	10006158 <strlen>
10004f88:	1c04      	adds	r4, r0, #0
10004f8a:	4a1b      	ldr	r2, [pc, #108]	; (10004ff8 <CommunicationTask+0xcc>)
10004f8c:	2308      	movs	r3, #8
10004f8e:	18fb      	adds	r3, r7, r3
10004f90:	1c10      	adds	r0, r2, #0
10004f92:	1c19      	adds	r1, r3, #0
10004f94:	1c22      	adds	r2, r4, #0
10004f96:	f7fc ff93 	bl	10001ec0 <UART_Transmit>
            if(occupied_spaces == PARK_SPACES)
10004f9a:	236f      	movs	r3, #111	; 0x6f
10004f9c:	18fb      	adds	r3, r7, r3
10004f9e:	781b      	ldrb	r3, [r3, #0]
10004fa0:	2b05      	cmp	r3, #5
10004fa2:	d122      	bne.n	10004fea <CommunicationTask+0xbe>
            {
            	sprintf(message, "Entrance blocked!\n");
10004fa4:	2308      	movs	r3, #8
10004fa6:	18fb      	adds	r3, r7, r3
10004fa8:	4a14      	ldr	r2, [pc, #80]	; (10004ffc <CommunicationTask+0xd0>)
10004faa:	ca13      	ldmia	r2!, {r0, r1, r4}
10004fac:	c313      	stmia	r3!, {r0, r1, r4}
10004fae:	6811      	ldr	r1, [r2, #0]
10004fb0:	6019      	str	r1, [r3, #0]
10004fb2:	8891      	ldrh	r1, [r2, #4]
10004fb4:	8099      	strh	r1, [r3, #4]
10004fb6:	7992      	ldrb	r2, [r2, #6]
10004fb8:	719a      	strb	r2, [r3, #6]
            	printf("Generated message: %s", message);
10004fba:	4a11      	ldr	r2, [pc, #68]	; (10005000 <CommunicationTask+0xd4>)
10004fbc:	2308      	movs	r3, #8
10004fbe:	18fb      	adds	r3, r7, r3
10004fc0:	1c10      	adds	r0, r2, #0
10004fc2:	1c19      	adds	r1, r3, #0
10004fc4:	f000 ffe6 	bl	10005f94 <iprintf>
            	vTaskDelay(pdMS_TO_TICKS(10));
10004fc8:	200a      	movs	r0, #10
10004fca:	f7fe fdfd 	bl	10003bc8 <vTaskDelay>
                UART_Transmit(&UART_BLUETOOTH, (uint8_t *)message, strlen(message));
10004fce:	2308      	movs	r3, #8
10004fd0:	18fb      	adds	r3, r7, r3
10004fd2:	1c18      	adds	r0, r3, #0
10004fd4:	f001 f8c0 	bl	10006158 <strlen>
10004fd8:	1c04      	adds	r4, r0, #0
10004fda:	4a07      	ldr	r2, [pc, #28]	; (10004ff8 <CommunicationTask+0xcc>)
10004fdc:	2308      	movs	r3, #8
10004fde:	18fb      	adds	r3, r7, r3
10004fe0:	1c10      	adds	r0, r2, #0
10004fe2:	1c19      	adds	r1, r3, #0
10004fe4:	1c22      	adds	r2, r4, #0
10004fe6:	f7fc ff6b 	bl	10001ec0 <UART_Transmit>
            }
        }
    }
10004fea:	e7a3      	b.n	10004f34 <CommunicationTask+0x8>
10004fec:	20000920 	.word	0x20000920
10004ff0:	1000a2b8 	.word	0x1000a2b8
10004ff4:	1000a2d0 	.word	0x1000a2d0
10004ff8:	20000520 	.word	0x20000520
10004ffc:	1000a2e4 	.word	0x1000a2e4
10005000:	1000a2f8 	.word	0x1000a2f8

10005004 <check_entrance>:
}

void check_entrance(void)
{
10005004:	b580      	push	{r7, lr}
10005006:	b082      	sub	sp, #8
10005008:	af00      	add	r7, sp, #0
	uint32_t pulse_start = 0, pulse_stop = 0;
1000500a:	2300      	movs	r3, #0
1000500c:	607b      	str	r3, [r7, #4]
1000500e:	2300      	movs	r3, #0
10005010:	603b      	str	r3, [r7, #0]
	echo_in_counter = 0;
10005012:	4b28      	ldr	r3, [pc, #160]	; (100050b4 <check_entrance+0xb0>)
10005014:	2200      	movs	r2, #0
10005016:	601a      	str	r2, [r3, #0]

	while (DIGITAL_IO_GetInput(&ECHO_IN) == 0);
10005018:	46c0      	nop			; (mov r8, r8)
1000501a:	4b27      	ldr	r3, [pc, #156]	; (100050b8 <check_entrance+0xb4>)
1000501c:	1c18      	adds	r0, r3, #0
1000501e:	f7ff feef 	bl	10004e00 <DIGITAL_IO_GetInput>
10005022:	1e03      	subs	r3, r0, #0
10005024:	d0f9      	beq.n	1000501a <check_entrance+0x16>
	pulse_start = echo_in_counter;
10005026:	4b23      	ldr	r3, [pc, #140]	; (100050b4 <check_entrance+0xb0>)
10005028:	681b      	ldr	r3, [r3, #0]
1000502a:	607b      	str	r3, [r7, #4]
	while (DIGITAL_IO_GetInput(&ECHO_IN) == 1 && (echo_in_counter - pulse_start) < 3);
1000502c:	46c0      	nop			; (mov r8, r8)
1000502e:	4b22      	ldr	r3, [pc, #136]	; (100050b8 <check_entrance+0xb4>)
10005030:	1c18      	adds	r0, r3, #0
10005032:	f7ff fee5 	bl	10004e00 <DIGITAL_IO_GetInput>
10005036:	1e03      	subs	r3, r0, #0
10005038:	2b01      	cmp	r3, #1
1000503a:	d105      	bne.n	10005048 <check_entrance+0x44>
1000503c:	4b1d      	ldr	r3, [pc, #116]	; (100050b4 <check_entrance+0xb0>)
1000503e:	681a      	ldr	r2, [r3, #0]
10005040:	687b      	ldr	r3, [r7, #4]
10005042:	1ad3      	subs	r3, r2, r3
10005044:	2b02      	cmp	r3, #2
10005046:	d9f2      	bls.n	1000502e <check_entrance+0x2a>
	pulse_stop = echo_in_counter;
10005048:	4b1a      	ldr	r3, [pc, #104]	; (100050b4 <check_entrance+0xb0>)
1000504a:	681b      	ldr	r3, [r3, #0]
1000504c:	603b      	str	r3, [r7, #0]

	printf("distance_in = %lu\n", pulse_stop - pulse_start);
1000504e:	683a      	ldr	r2, [r7, #0]
10005050:	687b      	ldr	r3, [r7, #4]
10005052:	1ad3      	subs	r3, r2, r3
10005054:	4a19      	ldr	r2, [pc, #100]	; (100050bc <check_entrance+0xb8>)
10005056:	1c10      	adds	r0, r2, #0
10005058:	1c19      	adds	r1, r3, #0
1000505a:	f000 ff9b 	bl	10005f94 <iprintf>
//	printf("distance_in = %lu\n", echo_in_counter);

	if ((pulse_stop - pulse_start) < 2 && last_distance_in >= 2)
1000505e:	683a      	ldr	r2, [r7, #0]
10005060:	687b      	ldr	r3, [r7, #4]
10005062:	1ad3      	subs	r3, r2, r3
10005064:	2b01      	cmp	r3, #1
10005066:	d81c      	bhi.n	100050a2 <check_entrance+0x9e>
10005068:	4b15      	ldr	r3, [pc, #84]	; (100050c0 <check_entrance+0xbc>)
1000506a:	681b      	ldr	r3, [r3, #0]
1000506c:	2b01      	cmp	r3, #1
1000506e:	d918      	bls.n	100050a2 <check_entrance+0x9e>
	{
		printf("\nCar In detected\n");
10005070:	4b14      	ldr	r3, [pc, #80]	; (100050c4 <check_entrance+0xc0>)
10005072:	1c18      	adds	r0, r3, #0
10005074:	f001 f80a 	bl	1000608c <puts>
        if (parked_cars < PARK_SPACES)
10005078:	4b13      	ldr	r3, [pc, #76]	; (100050c8 <check_entrance+0xc4>)
1000507a:	781b      	ldrb	r3, [r3, #0]
1000507c:	2b04      	cmp	r3, #4
1000507e:	d810      	bhi.n	100050a2 <check_entrance+0x9e>
        {
        	parked_cars++;
10005080:	4b11      	ldr	r3, [pc, #68]	; (100050c8 <check_entrance+0xc4>)
10005082:	781b      	ldrb	r3, [r3, #0]
10005084:	3301      	adds	r3, #1
10005086:	b2da      	uxtb	r2, r3
10005088:	4b0f      	ldr	r3, [pc, #60]	; (100050c8 <check_entrance+0xc4>)
1000508a:	701a      	strb	r2, [r3, #0]
			xQueueSend(xQueue, &parked_cars, portMAX_DELAY);
1000508c:	4b0f      	ldr	r3, [pc, #60]	; (100050cc <check_entrance+0xc8>)
1000508e:	6819      	ldr	r1, [r3, #0]
10005090:	4a0d      	ldr	r2, [pc, #52]	; (100050c8 <check_entrance+0xc4>)
10005092:	2301      	movs	r3, #1
10005094:	425b      	negs	r3, r3
10005096:	1c08      	adds	r0, r1, #0
10005098:	1c11      	adds	r1, r2, #0
1000509a:	1c1a      	adds	r2, r3, #0
1000509c:	2300      	movs	r3, #0
1000509e:	f7fe f82d 	bl	100030fc <xQueueGenericSend>
        }
	}

	last_distance_in = pulse_stop - pulse_start;
100050a2:	683a      	ldr	r2, [r7, #0]
100050a4:	687b      	ldr	r3, [r7, #4]
100050a6:	1ad2      	subs	r2, r2, r3
100050a8:	4b05      	ldr	r3, [pc, #20]	; (100050c0 <check_entrance+0xbc>)
100050aa:	601a      	str	r2, [r3, #0]
}
100050ac:	46bd      	mov	sp, r7
100050ae:	b002      	add	sp, #8
100050b0:	bd80      	pop	{r7, pc}
100050b2:	46c0      	nop			; (mov r8, r8)
100050b4:	2000091c 	.word	0x2000091c
100050b8:	1000a20c 	.word	0x1000a20c
100050bc:	1000a310 	.word	0x1000a310
100050c0:	200005fc 	.word	0x200005fc
100050c4:	1000a324 	.word	0x1000a324
100050c8:	2000081c 	.word	0x2000081c
100050cc:	20000920 	.word	0x20000920

100050d0 <check_exit>:

void check_exit(void)
{
100050d0:	b580      	push	{r7, lr}
100050d2:	b082      	sub	sp, #8
100050d4:	af00      	add	r7, sp, #0
	uint32_t pulse_start = 0, pulse_stop = 0;
100050d6:	2300      	movs	r3, #0
100050d8:	607b      	str	r3, [r7, #4]
100050da:	2300      	movs	r3, #0
100050dc:	603b      	str	r3, [r7, #0]
	echo_out_counter = 0;
100050de:	4b28      	ldr	r3, [pc, #160]	; (10005180 <check_exit+0xb0>)
100050e0:	2200      	movs	r2, #0
100050e2:	601a      	str	r2, [r3, #0]

	while (DIGITAL_IO_GetInput(&ECHO_OUT) == 0);
100050e4:	46c0      	nop			; (mov r8, r8)
100050e6:	4b27      	ldr	r3, [pc, #156]	; (10005184 <check_exit+0xb4>)
100050e8:	1c18      	adds	r0, r3, #0
100050ea:	f7ff fe89 	bl	10004e00 <DIGITAL_IO_GetInput>
100050ee:	1e03      	subs	r3, r0, #0
100050f0:	d0f9      	beq.n	100050e6 <check_exit+0x16>
	pulse_start = echo_out_counter;
100050f2:	4b23      	ldr	r3, [pc, #140]	; (10005180 <check_exit+0xb0>)
100050f4:	681b      	ldr	r3, [r3, #0]
100050f6:	607b      	str	r3, [r7, #4]
	while (DIGITAL_IO_GetInput(&ECHO_OUT) == 1 && (echo_out_counter - pulse_start) < 3);
100050f8:	46c0      	nop			; (mov r8, r8)
100050fa:	4b22      	ldr	r3, [pc, #136]	; (10005184 <check_exit+0xb4>)
100050fc:	1c18      	adds	r0, r3, #0
100050fe:	f7ff fe7f 	bl	10004e00 <DIGITAL_IO_GetInput>
10005102:	1e03      	subs	r3, r0, #0
10005104:	2b01      	cmp	r3, #1
10005106:	d105      	bne.n	10005114 <check_exit+0x44>
10005108:	4b1d      	ldr	r3, [pc, #116]	; (10005180 <check_exit+0xb0>)
1000510a:	681a      	ldr	r2, [r3, #0]
1000510c:	687b      	ldr	r3, [r7, #4]
1000510e:	1ad3      	subs	r3, r2, r3
10005110:	2b02      	cmp	r3, #2
10005112:	d9f2      	bls.n	100050fa <check_exit+0x2a>
	pulse_stop = echo_out_counter;
10005114:	4b1a      	ldr	r3, [pc, #104]	; (10005180 <check_exit+0xb0>)
10005116:	681b      	ldr	r3, [r3, #0]
10005118:	603b      	str	r3, [r7, #0]

	printf("distance_out = %lu\n", pulse_stop - pulse_start);
1000511a:	683a      	ldr	r2, [r7, #0]
1000511c:	687b      	ldr	r3, [r7, #4]
1000511e:	1ad3      	subs	r3, r2, r3
10005120:	4a19      	ldr	r2, [pc, #100]	; (10005188 <check_exit+0xb8>)
10005122:	1c10      	adds	r0, r2, #0
10005124:	1c19      	adds	r1, r3, #0
10005126:	f000 ff35 	bl	10005f94 <iprintf>
//	printf("distance_out = %lu\n", echo_out_counter);

	if ((pulse_stop - pulse_start) < 2 && last_distance_out >= 2)
1000512a:	683a      	ldr	r2, [r7, #0]
1000512c:	687b      	ldr	r3, [r7, #4]
1000512e:	1ad3      	subs	r3, r2, r3
10005130:	2b01      	cmp	r3, #1
10005132:	d81c      	bhi.n	1000516e <check_exit+0x9e>
10005134:	4b15      	ldr	r3, [pc, #84]	; (1000518c <check_exit+0xbc>)
10005136:	681b      	ldr	r3, [r3, #0]
10005138:	2b01      	cmp	r3, #1
1000513a:	d918      	bls.n	1000516e <check_exit+0x9e>
	{
		printf("\nCar Out detected\n");
1000513c:	4b14      	ldr	r3, [pc, #80]	; (10005190 <check_exit+0xc0>)
1000513e:	1c18      	adds	r0, r3, #0
10005140:	f000 ffa4 	bl	1000608c <puts>
		if (parked_cars > 0) {
10005144:	4b13      	ldr	r3, [pc, #76]	; (10005194 <check_exit+0xc4>)
10005146:	781b      	ldrb	r3, [r3, #0]
10005148:	2b00      	cmp	r3, #0
1000514a:	d010      	beq.n	1000516e <check_exit+0x9e>
			parked_cars--;
1000514c:	4b11      	ldr	r3, [pc, #68]	; (10005194 <check_exit+0xc4>)
1000514e:	781b      	ldrb	r3, [r3, #0]
10005150:	3b01      	subs	r3, #1
10005152:	b2da      	uxtb	r2, r3
10005154:	4b0f      	ldr	r3, [pc, #60]	; (10005194 <check_exit+0xc4>)
10005156:	701a      	strb	r2, [r3, #0]
            xQueueSend(xQueue, &parked_cars, portMAX_DELAY);
10005158:	4b0f      	ldr	r3, [pc, #60]	; (10005198 <check_exit+0xc8>)
1000515a:	6819      	ldr	r1, [r3, #0]
1000515c:	4a0d      	ldr	r2, [pc, #52]	; (10005194 <check_exit+0xc4>)
1000515e:	2301      	movs	r3, #1
10005160:	425b      	negs	r3, r3
10005162:	1c08      	adds	r0, r1, #0
10005164:	1c11      	adds	r1, r2, #0
10005166:	1c1a      	adds	r2, r3, #0
10005168:	2300      	movs	r3, #0
1000516a:	f7fd ffc7 	bl	100030fc <xQueueGenericSend>
		}
	}
	last_distance_out = pulse_stop - pulse_start;
1000516e:	683a      	ldr	r2, [r7, #0]
10005170:	687b      	ldr	r3, [r7, #4]
10005172:	1ad2      	subs	r2, r2, r3
10005174:	4b05      	ldr	r3, [pc, #20]	; (1000518c <check_exit+0xbc>)
10005176:	601a      	str	r2, [r3, #0]
}
10005178:	46bd      	mov	sp, r7
1000517a:	b002      	add	sp, #8
1000517c:	bd80      	pop	{r7, pc}
1000517e:	46c0      	nop			; (mov r8, r8)
10005180:	20000918 	.word	0x20000918
10005184:	1000a1fc 	.word	0x1000a1fc
10005188:	1000a338 	.word	0x1000a338
1000518c:	20000600 	.word	0x20000600
10005190:	1000a34c 	.word	0x1000a34c
10005194:	2000081c 	.word	0x2000081c
10005198:	20000920 	.word	0x20000920

1000519c <update_leds>:

void update_leds(void)
{
1000519c:	b580      	push	{r7, lr}
1000519e:	af00      	add	r7, sp, #0
	if(parked_cars == PARK_SPACES)
100051a0:	4b0b      	ldr	r3, [pc, #44]	; (100051d0 <update_leds+0x34>)
100051a2:	781b      	ldrb	r3, [r3, #0]
100051a4:	2b05      	cmp	r3, #5
100051a6:	d108      	bne.n	100051ba <update_leds+0x1e>
	{
		DIGITAL_IO_SetOutputHigh(&RED_LED);
100051a8:	4b0a      	ldr	r3, [pc, #40]	; (100051d4 <update_leds+0x38>)
100051aa:	1c18      	adds	r0, r3, #0
100051ac:	f7ff fe08 	bl	10004dc0 <DIGITAL_IO_SetOutputHigh>
		DIGITAL_IO_SetOutputLow(&GREEN_LED);
100051b0:	4b09      	ldr	r3, [pc, #36]	; (100051d8 <update_leds+0x3c>)
100051b2:	1c18      	adds	r0, r3, #0
100051b4:	f7ff fe14 	bl	10004de0 <DIGITAL_IO_SetOutputLow>
100051b8:	e007      	b.n	100051ca <update_leds+0x2e>
	}
	else
	{
		DIGITAL_IO_SetOutputHigh(&GREEN_LED);
100051ba:	4b07      	ldr	r3, [pc, #28]	; (100051d8 <update_leds+0x3c>)
100051bc:	1c18      	adds	r0, r3, #0
100051be:	f7ff fdff 	bl	10004dc0 <DIGITAL_IO_SetOutputHigh>
		DIGITAL_IO_SetOutputLow(&RED_LED);
100051c2:	4b04      	ldr	r3, [pc, #16]	; (100051d4 <update_leds+0x38>)
100051c4:	1c18      	adds	r0, r3, #0
100051c6:	f7ff fe0b 	bl	10004de0 <DIGITAL_IO_SetOutputLow>
	}
}
100051ca:	46bd      	mov	sp, r7
100051cc:	bd80      	pop	{r7, pc}
100051ce:	46c0      	nop			; (mov r8, r8)
100051d0:	2000081c 	.word	0x2000081c
100051d4:	1000a22c 	.word	0x1000a22c
100051d8:	1000a21c 	.word	0x1000a21c

100051dc <CCU40_2_IRQHandler>:

void EchoInPulse(void)
{
100051dc:	b580      	push	{r7, lr}
100051de:	af00      	add	r7, sp, #0
	echo_in_counter++;
100051e0:	4b05      	ldr	r3, [pc, #20]	; (100051f8 <CCU40_2_IRQHandler+0x1c>)
100051e2:	681b      	ldr	r3, [r3, #0]
100051e4:	1c5a      	adds	r2, r3, #1
100051e6:	4b04      	ldr	r3, [pc, #16]	; (100051f8 <CCU40_2_IRQHandler+0x1c>)
100051e8:	601a      	str	r2, [r3, #0]
	task_timer_counter++;
100051ea:	4b04      	ldr	r3, [pc, #16]	; (100051fc <CCU40_2_IRQHandler+0x20>)
100051ec:	681b      	ldr	r3, [r3, #0]
100051ee:	1c5a      	adds	r2, r3, #1
100051f0:	4b02      	ldr	r3, [pc, #8]	; (100051fc <CCU40_2_IRQHandler+0x20>)
100051f2:	601a      	str	r2, [r3, #0]
}
100051f4:	46bd      	mov	sp, r7
100051f6:	bd80      	pop	{r7, pc}
100051f8:	2000091c 	.word	0x2000091c
100051fc:	20000924 	.word	0x20000924

10005200 <CCU40_3_IRQHandler>:

void EchoOutPulse(void)
{
10005200:	b580      	push	{r7, lr}
10005202:	af00      	add	r7, sp, #0
	echo_out_counter++;
10005204:	4b03      	ldr	r3, [pc, #12]	; (10005214 <CCU40_3_IRQHandler+0x14>)
10005206:	681b      	ldr	r3, [r3, #0]
10005208:	1c5a      	adds	r2, r3, #1
1000520a:	4b02      	ldr	r3, [pc, #8]	; (10005214 <CCU40_3_IRQHandler+0x14>)
1000520c:	601a      	str	r2, [r3, #0]
}
1000520e:	46bd      	mov	sp, r7
10005210:	bd80      	pop	{r7, pc}
10005212:	46c0      	nop			; (mov r8, r8)
10005214:	20000918 	.word	0x20000918

10005218 <__aeabi_uidiv>:
10005218:	2200      	movs	r2, #0
1000521a:	0843      	lsrs	r3, r0, #1
1000521c:	428b      	cmp	r3, r1
1000521e:	d374      	bcc.n	1000530a <__aeabi_uidiv+0xf2>
10005220:	0903      	lsrs	r3, r0, #4
10005222:	428b      	cmp	r3, r1
10005224:	d35f      	bcc.n	100052e6 <__aeabi_uidiv+0xce>
10005226:	0a03      	lsrs	r3, r0, #8
10005228:	428b      	cmp	r3, r1
1000522a:	d344      	bcc.n	100052b6 <__aeabi_uidiv+0x9e>
1000522c:	0b03      	lsrs	r3, r0, #12
1000522e:	428b      	cmp	r3, r1
10005230:	d328      	bcc.n	10005284 <__aeabi_uidiv+0x6c>
10005232:	0c03      	lsrs	r3, r0, #16
10005234:	428b      	cmp	r3, r1
10005236:	d30d      	bcc.n	10005254 <__aeabi_uidiv+0x3c>
10005238:	22ff      	movs	r2, #255	; 0xff
1000523a:	0209      	lsls	r1, r1, #8
1000523c:	ba12      	rev	r2, r2
1000523e:	0c03      	lsrs	r3, r0, #16
10005240:	428b      	cmp	r3, r1
10005242:	d302      	bcc.n	1000524a <__aeabi_uidiv+0x32>
10005244:	1212      	asrs	r2, r2, #8
10005246:	0209      	lsls	r1, r1, #8
10005248:	d065      	beq.n	10005316 <__aeabi_uidiv+0xfe>
1000524a:	0b03      	lsrs	r3, r0, #12
1000524c:	428b      	cmp	r3, r1
1000524e:	d319      	bcc.n	10005284 <__aeabi_uidiv+0x6c>
10005250:	e000      	b.n	10005254 <__aeabi_uidiv+0x3c>
10005252:	0a09      	lsrs	r1, r1, #8
10005254:	0bc3      	lsrs	r3, r0, #15
10005256:	428b      	cmp	r3, r1
10005258:	d301      	bcc.n	1000525e <__aeabi_uidiv+0x46>
1000525a:	03cb      	lsls	r3, r1, #15
1000525c:	1ac0      	subs	r0, r0, r3
1000525e:	4152      	adcs	r2, r2
10005260:	0b83      	lsrs	r3, r0, #14
10005262:	428b      	cmp	r3, r1
10005264:	d301      	bcc.n	1000526a <__aeabi_uidiv+0x52>
10005266:	038b      	lsls	r3, r1, #14
10005268:	1ac0      	subs	r0, r0, r3
1000526a:	4152      	adcs	r2, r2
1000526c:	0b43      	lsrs	r3, r0, #13
1000526e:	428b      	cmp	r3, r1
10005270:	d301      	bcc.n	10005276 <__aeabi_uidiv+0x5e>
10005272:	034b      	lsls	r3, r1, #13
10005274:	1ac0      	subs	r0, r0, r3
10005276:	4152      	adcs	r2, r2
10005278:	0b03      	lsrs	r3, r0, #12
1000527a:	428b      	cmp	r3, r1
1000527c:	d301      	bcc.n	10005282 <__aeabi_uidiv+0x6a>
1000527e:	030b      	lsls	r3, r1, #12
10005280:	1ac0      	subs	r0, r0, r3
10005282:	4152      	adcs	r2, r2
10005284:	0ac3      	lsrs	r3, r0, #11
10005286:	428b      	cmp	r3, r1
10005288:	d301      	bcc.n	1000528e <__aeabi_uidiv+0x76>
1000528a:	02cb      	lsls	r3, r1, #11
1000528c:	1ac0      	subs	r0, r0, r3
1000528e:	4152      	adcs	r2, r2
10005290:	0a83      	lsrs	r3, r0, #10
10005292:	428b      	cmp	r3, r1
10005294:	d301      	bcc.n	1000529a <__aeabi_uidiv+0x82>
10005296:	028b      	lsls	r3, r1, #10
10005298:	1ac0      	subs	r0, r0, r3
1000529a:	4152      	adcs	r2, r2
1000529c:	0a43      	lsrs	r3, r0, #9
1000529e:	428b      	cmp	r3, r1
100052a0:	d301      	bcc.n	100052a6 <__aeabi_uidiv+0x8e>
100052a2:	024b      	lsls	r3, r1, #9
100052a4:	1ac0      	subs	r0, r0, r3
100052a6:	4152      	adcs	r2, r2
100052a8:	0a03      	lsrs	r3, r0, #8
100052aa:	428b      	cmp	r3, r1
100052ac:	d301      	bcc.n	100052b2 <__aeabi_uidiv+0x9a>
100052ae:	020b      	lsls	r3, r1, #8
100052b0:	1ac0      	subs	r0, r0, r3
100052b2:	4152      	adcs	r2, r2
100052b4:	d2cd      	bcs.n	10005252 <__aeabi_uidiv+0x3a>
100052b6:	09c3      	lsrs	r3, r0, #7
100052b8:	428b      	cmp	r3, r1
100052ba:	d301      	bcc.n	100052c0 <__aeabi_uidiv+0xa8>
100052bc:	01cb      	lsls	r3, r1, #7
100052be:	1ac0      	subs	r0, r0, r3
100052c0:	4152      	adcs	r2, r2
100052c2:	0983      	lsrs	r3, r0, #6
100052c4:	428b      	cmp	r3, r1
100052c6:	d301      	bcc.n	100052cc <__aeabi_uidiv+0xb4>
100052c8:	018b      	lsls	r3, r1, #6
100052ca:	1ac0      	subs	r0, r0, r3
100052cc:	4152      	adcs	r2, r2
100052ce:	0943      	lsrs	r3, r0, #5
100052d0:	428b      	cmp	r3, r1
100052d2:	d301      	bcc.n	100052d8 <__aeabi_uidiv+0xc0>
100052d4:	014b      	lsls	r3, r1, #5
100052d6:	1ac0      	subs	r0, r0, r3
100052d8:	4152      	adcs	r2, r2
100052da:	0903      	lsrs	r3, r0, #4
100052dc:	428b      	cmp	r3, r1
100052de:	d301      	bcc.n	100052e4 <__aeabi_uidiv+0xcc>
100052e0:	010b      	lsls	r3, r1, #4
100052e2:	1ac0      	subs	r0, r0, r3
100052e4:	4152      	adcs	r2, r2
100052e6:	08c3      	lsrs	r3, r0, #3
100052e8:	428b      	cmp	r3, r1
100052ea:	d301      	bcc.n	100052f0 <__aeabi_uidiv+0xd8>
100052ec:	00cb      	lsls	r3, r1, #3
100052ee:	1ac0      	subs	r0, r0, r3
100052f0:	4152      	adcs	r2, r2
100052f2:	0883      	lsrs	r3, r0, #2
100052f4:	428b      	cmp	r3, r1
100052f6:	d301      	bcc.n	100052fc <__aeabi_uidiv+0xe4>
100052f8:	008b      	lsls	r3, r1, #2
100052fa:	1ac0      	subs	r0, r0, r3
100052fc:	4152      	adcs	r2, r2
100052fe:	0843      	lsrs	r3, r0, #1
10005300:	428b      	cmp	r3, r1
10005302:	d301      	bcc.n	10005308 <__aeabi_uidiv+0xf0>
10005304:	004b      	lsls	r3, r1, #1
10005306:	1ac0      	subs	r0, r0, r3
10005308:	4152      	adcs	r2, r2
1000530a:	1a41      	subs	r1, r0, r1
1000530c:	d200      	bcs.n	10005310 <__aeabi_uidiv+0xf8>
1000530e:	4601      	mov	r1, r0
10005310:	4152      	adcs	r2, r2
10005312:	4610      	mov	r0, r2
10005314:	4770      	bx	lr
10005316:	e7ff      	b.n	10005318 <__aeabi_uidiv+0x100>
10005318:	b501      	push	{r0, lr}
1000531a:	2000      	movs	r0, #0
1000531c:	f000 f8fc 	bl	10005518 <__aeabi_idiv0>
10005320:	bd02      	pop	{r1, pc}
10005322:	46c0      	nop			; (mov r8, r8)

10005324 <__aeabi_uidivmod>:
10005324:	2900      	cmp	r1, #0
10005326:	d0f7      	beq.n	10005318 <__aeabi_uidiv+0x100>
10005328:	b503      	push	{r0, r1, lr}
1000532a:	f7ff ff75 	bl	10005218 <__aeabi_uidiv>
1000532e:	bc0e      	pop	{r1, r2, r3}
10005330:	4342      	muls	r2, r0
10005332:	1a89      	subs	r1, r1, r2
10005334:	4718      	bx	r3
10005336:	46c0      	nop			; (mov r8, r8)

10005338 <__aeabi_idiv>:
10005338:	4603      	mov	r3, r0
1000533a:	430b      	orrs	r3, r1
1000533c:	d47f      	bmi.n	1000543e <__aeabi_idiv+0x106>
1000533e:	2200      	movs	r2, #0
10005340:	0843      	lsrs	r3, r0, #1
10005342:	428b      	cmp	r3, r1
10005344:	d374      	bcc.n	10005430 <__aeabi_idiv+0xf8>
10005346:	0903      	lsrs	r3, r0, #4
10005348:	428b      	cmp	r3, r1
1000534a:	d35f      	bcc.n	1000540c <__aeabi_idiv+0xd4>
1000534c:	0a03      	lsrs	r3, r0, #8
1000534e:	428b      	cmp	r3, r1
10005350:	d344      	bcc.n	100053dc <__aeabi_idiv+0xa4>
10005352:	0b03      	lsrs	r3, r0, #12
10005354:	428b      	cmp	r3, r1
10005356:	d328      	bcc.n	100053aa <__aeabi_idiv+0x72>
10005358:	0c03      	lsrs	r3, r0, #16
1000535a:	428b      	cmp	r3, r1
1000535c:	d30d      	bcc.n	1000537a <__aeabi_idiv+0x42>
1000535e:	22ff      	movs	r2, #255	; 0xff
10005360:	0209      	lsls	r1, r1, #8
10005362:	ba12      	rev	r2, r2
10005364:	0c03      	lsrs	r3, r0, #16
10005366:	428b      	cmp	r3, r1
10005368:	d302      	bcc.n	10005370 <__aeabi_idiv+0x38>
1000536a:	1212      	asrs	r2, r2, #8
1000536c:	0209      	lsls	r1, r1, #8
1000536e:	d065      	beq.n	1000543c <__aeabi_idiv+0x104>
10005370:	0b03      	lsrs	r3, r0, #12
10005372:	428b      	cmp	r3, r1
10005374:	d319      	bcc.n	100053aa <__aeabi_idiv+0x72>
10005376:	e000      	b.n	1000537a <__aeabi_idiv+0x42>
10005378:	0a09      	lsrs	r1, r1, #8
1000537a:	0bc3      	lsrs	r3, r0, #15
1000537c:	428b      	cmp	r3, r1
1000537e:	d301      	bcc.n	10005384 <__aeabi_idiv+0x4c>
10005380:	03cb      	lsls	r3, r1, #15
10005382:	1ac0      	subs	r0, r0, r3
10005384:	4152      	adcs	r2, r2
10005386:	0b83      	lsrs	r3, r0, #14
10005388:	428b      	cmp	r3, r1
1000538a:	d301      	bcc.n	10005390 <__aeabi_idiv+0x58>
1000538c:	038b      	lsls	r3, r1, #14
1000538e:	1ac0      	subs	r0, r0, r3
10005390:	4152      	adcs	r2, r2
10005392:	0b43      	lsrs	r3, r0, #13
10005394:	428b      	cmp	r3, r1
10005396:	d301      	bcc.n	1000539c <__aeabi_idiv+0x64>
10005398:	034b      	lsls	r3, r1, #13
1000539a:	1ac0      	subs	r0, r0, r3
1000539c:	4152      	adcs	r2, r2
1000539e:	0b03      	lsrs	r3, r0, #12
100053a0:	428b      	cmp	r3, r1
100053a2:	d301      	bcc.n	100053a8 <__aeabi_idiv+0x70>
100053a4:	030b      	lsls	r3, r1, #12
100053a6:	1ac0      	subs	r0, r0, r3
100053a8:	4152      	adcs	r2, r2
100053aa:	0ac3      	lsrs	r3, r0, #11
100053ac:	428b      	cmp	r3, r1
100053ae:	d301      	bcc.n	100053b4 <__aeabi_idiv+0x7c>
100053b0:	02cb      	lsls	r3, r1, #11
100053b2:	1ac0      	subs	r0, r0, r3
100053b4:	4152      	adcs	r2, r2
100053b6:	0a83      	lsrs	r3, r0, #10
100053b8:	428b      	cmp	r3, r1
100053ba:	d301      	bcc.n	100053c0 <__aeabi_idiv+0x88>
100053bc:	028b      	lsls	r3, r1, #10
100053be:	1ac0      	subs	r0, r0, r3
100053c0:	4152      	adcs	r2, r2
100053c2:	0a43      	lsrs	r3, r0, #9
100053c4:	428b      	cmp	r3, r1
100053c6:	d301      	bcc.n	100053cc <__aeabi_idiv+0x94>
100053c8:	024b      	lsls	r3, r1, #9
100053ca:	1ac0      	subs	r0, r0, r3
100053cc:	4152      	adcs	r2, r2
100053ce:	0a03      	lsrs	r3, r0, #8
100053d0:	428b      	cmp	r3, r1
100053d2:	d301      	bcc.n	100053d8 <__aeabi_idiv+0xa0>
100053d4:	020b      	lsls	r3, r1, #8
100053d6:	1ac0      	subs	r0, r0, r3
100053d8:	4152      	adcs	r2, r2
100053da:	d2cd      	bcs.n	10005378 <__aeabi_idiv+0x40>
100053dc:	09c3      	lsrs	r3, r0, #7
100053de:	428b      	cmp	r3, r1
100053e0:	d301      	bcc.n	100053e6 <__aeabi_idiv+0xae>
100053e2:	01cb      	lsls	r3, r1, #7
100053e4:	1ac0      	subs	r0, r0, r3
100053e6:	4152      	adcs	r2, r2
100053e8:	0983      	lsrs	r3, r0, #6
100053ea:	428b      	cmp	r3, r1
100053ec:	d301      	bcc.n	100053f2 <__aeabi_idiv+0xba>
100053ee:	018b      	lsls	r3, r1, #6
100053f0:	1ac0      	subs	r0, r0, r3
100053f2:	4152      	adcs	r2, r2
100053f4:	0943      	lsrs	r3, r0, #5
100053f6:	428b      	cmp	r3, r1
100053f8:	d301      	bcc.n	100053fe <__aeabi_idiv+0xc6>
100053fa:	014b      	lsls	r3, r1, #5
100053fc:	1ac0      	subs	r0, r0, r3
100053fe:	4152      	adcs	r2, r2
10005400:	0903      	lsrs	r3, r0, #4
10005402:	428b      	cmp	r3, r1
10005404:	d301      	bcc.n	1000540a <__aeabi_idiv+0xd2>
10005406:	010b      	lsls	r3, r1, #4
10005408:	1ac0      	subs	r0, r0, r3
1000540a:	4152      	adcs	r2, r2
1000540c:	08c3      	lsrs	r3, r0, #3
1000540e:	428b      	cmp	r3, r1
10005410:	d301      	bcc.n	10005416 <__aeabi_idiv+0xde>
10005412:	00cb      	lsls	r3, r1, #3
10005414:	1ac0      	subs	r0, r0, r3
10005416:	4152      	adcs	r2, r2
10005418:	0883      	lsrs	r3, r0, #2
1000541a:	428b      	cmp	r3, r1
1000541c:	d301      	bcc.n	10005422 <__aeabi_idiv+0xea>
1000541e:	008b      	lsls	r3, r1, #2
10005420:	1ac0      	subs	r0, r0, r3
10005422:	4152      	adcs	r2, r2
10005424:	0843      	lsrs	r3, r0, #1
10005426:	428b      	cmp	r3, r1
10005428:	d301      	bcc.n	1000542e <__aeabi_idiv+0xf6>
1000542a:	004b      	lsls	r3, r1, #1
1000542c:	1ac0      	subs	r0, r0, r3
1000542e:	4152      	adcs	r2, r2
10005430:	1a41      	subs	r1, r0, r1
10005432:	d200      	bcs.n	10005436 <__aeabi_idiv+0xfe>
10005434:	4601      	mov	r1, r0
10005436:	4152      	adcs	r2, r2
10005438:	4610      	mov	r0, r2
1000543a:	4770      	bx	lr
1000543c:	e05d      	b.n	100054fa <__aeabi_idiv+0x1c2>
1000543e:	0fca      	lsrs	r2, r1, #31
10005440:	d000      	beq.n	10005444 <__aeabi_idiv+0x10c>
10005442:	4249      	negs	r1, r1
10005444:	1003      	asrs	r3, r0, #32
10005446:	d300      	bcc.n	1000544a <__aeabi_idiv+0x112>
10005448:	4240      	negs	r0, r0
1000544a:	4053      	eors	r3, r2
1000544c:	2200      	movs	r2, #0
1000544e:	469c      	mov	ip, r3
10005450:	0903      	lsrs	r3, r0, #4
10005452:	428b      	cmp	r3, r1
10005454:	d32d      	bcc.n	100054b2 <__aeabi_idiv+0x17a>
10005456:	0a03      	lsrs	r3, r0, #8
10005458:	428b      	cmp	r3, r1
1000545a:	d312      	bcc.n	10005482 <__aeabi_idiv+0x14a>
1000545c:	22fc      	movs	r2, #252	; 0xfc
1000545e:	0189      	lsls	r1, r1, #6
10005460:	ba12      	rev	r2, r2
10005462:	0a03      	lsrs	r3, r0, #8
10005464:	428b      	cmp	r3, r1
10005466:	d30c      	bcc.n	10005482 <__aeabi_idiv+0x14a>
10005468:	0189      	lsls	r1, r1, #6
1000546a:	1192      	asrs	r2, r2, #6
1000546c:	428b      	cmp	r3, r1
1000546e:	d308      	bcc.n	10005482 <__aeabi_idiv+0x14a>
10005470:	0189      	lsls	r1, r1, #6
10005472:	1192      	asrs	r2, r2, #6
10005474:	428b      	cmp	r3, r1
10005476:	d304      	bcc.n	10005482 <__aeabi_idiv+0x14a>
10005478:	0189      	lsls	r1, r1, #6
1000547a:	d03a      	beq.n	100054f2 <__aeabi_idiv+0x1ba>
1000547c:	1192      	asrs	r2, r2, #6
1000547e:	e000      	b.n	10005482 <__aeabi_idiv+0x14a>
10005480:	0989      	lsrs	r1, r1, #6
10005482:	09c3      	lsrs	r3, r0, #7
10005484:	428b      	cmp	r3, r1
10005486:	d301      	bcc.n	1000548c <__aeabi_idiv+0x154>
10005488:	01cb      	lsls	r3, r1, #7
1000548a:	1ac0      	subs	r0, r0, r3
1000548c:	4152      	adcs	r2, r2
1000548e:	0983      	lsrs	r3, r0, #6
10005490:	428b      	cmp	r3, r1
10005492:	d301      	bcc.n	10005498 <__aeabi_idiv+0x160>
10005494:	018b      	lsls	r3, r1, #6
10005496:	1ac0      	subs	r0, r0, r3
10005498:	4152      	adcs	r2, r2
1000549a:	0943      	lsrs	r3, r0, #5
1000549c:	428b      	cmp	r3, r1
1000549e:	d301      	bcc.n	100054a4 <__aeabi_idiv+0x16c>
100054a0:	014b      	lsls	r3, r1, #5
100054a2:	1ac0      	subs	r0, r0, r3
100054a4:	4152      	adcs	r2, r2
100054a6:	0903      	lsrs	r3, r0, #4
100054a8:	428b      	cmp	r3, r1
100054aa:	d301      	bcc.n	100054b0 <__aeabi_idiv+0x178>
100054ac:	010b      	lsls	r3, r1, #4
100054ae:	1ac0      	subs	r0, r0, r3
100054b0:	4152      	adcs	r2, r2
100054b2:	08c3      	lsrs	r3, r0, #3
100054b4:	428b      	cmp	r3, r1
100054b6:	d301      	bcc.n	100054bc <__aeabi_idiv+0x184>
100054b8:	00cb      	lsls	r3, r1, #3
100054ba:	1ac0      	subs	r0, r0, r3
100054bc:	4152      	adcs	r2, r2
100054be:	0883      	lsrs	r3, r0, #2
100054c0:	428b      	cmp	r3, r1
100054c2:	d301      	bcc.n	100054c8 <__aeabi_idiv+0x190>
100054c4:	008b      	lsls	r3, r1, #2
100054c6:	1ac0      	subs	r0, r0, r3
100054c8:	4152      	adcs	r2, r2
100054ca:	d2d9      	bcs.n	10005480 <__aeabi_idiv+0x148>
100054cc:	0843      	lsrs	r3, r0, #1
100054ce:	428b      	cmp	r3, r1
100054d0:	d301      	bcc.n	100054d6 <__aeabi_idiv+0x19e>
100054d2:	004b      	lsls	r3, r1, #1
100054d4:	1ac0      	subs	r0, r0, r3
100054d6:	4152      	adcs	r2, r2
100054d8:	1a41      	subs	r1, r0, r1
100054da:	d200      	bcs.n	100054de <__aeabi_idiv+0x1a6>
100054dc:	4601      	mov	r1, r0
100054de:	4663      	mov	r3, ip
100054e0:	4152      	adcs	r2, r2
100054e2:	105b      	asrs	r3, r3, #1
100054e4:	4610      	mov	r0, r2
100054e6:	d301      	bcc.n	100054ec <__aeabi_idiv+0x1b4>
100054e8:	4240      	negs	r0, r0
100054ea:	2b00      	cmp	r3, #0
100054ec:	d500      	bpl.n	100054f0 <__aeabi_idiv+0x1b8>
100054ee:	4249      	negs	r1, r1
100054f0:	4770      	bx	lr
100054f2:	4663      	mov	r3, ip
100054f4:	105b      	asrs	r3, r3, #1
100054f6:	d300      	bcc.n	100054fa <__aeabi_idiv+0x1c2>
100054f8:	4240      	negs	r0, r0
100054fa:	b501      	push	{r0, lr}
100054fc:	2000      	movs	r0, #0
100054fe:	f000 f80b 	bl	10005518 <__aeabi_idiv0>
10005502:	bd02      	pop	{r1, pc}

10005504 <__aeabi_idivmod>:
10005504:	2900      	cmp	r1, #0
10005506:	d0f8      	beq.n	100054fa <__aeabi_idiv+0x1c2>
10005508:	b503      	push	{r0, r1, lr}
1000550a:	f7ff ff15 	bl	10005338 <__aeabi_idiv>
1000550e:	bc0e      	pop	{r1, r2, r3}
10005510:	4342      	muls	r2, r0
10005512:	1a89      	subs	r1, r1, r2
10005514:	4718      	bx	r3
10005516:	46c0      	nop			; (mov r8, r8)

10005518 <__aeabi_idiv0>:
10005518:	4770      	bx	lr
1000551a:	46c0      	nop			; (mov r8, r8)

1000551c <__clzsi2>:
1000551c:	211c      	movs	r1, #28
1000551e:	2301      	movs	r3, #1
10005520:	041b      	lsls	r3, r3, #16
10005522:	4298      	cmp	r0, r3
10005524:	d301      	bcc.n	1000552a <__clzsi2+0xe>
10005526:	0c00      	lsrs	r0, r0, #16
10005528:	3910      	subs	r1, #16
1000552a:	0a1b      	lsrs	r3, r3, #8
1000552c:	4298      	cmp	r0, r3
1000552e:	d301      	bcc.n	10005534 <__clzsi2+0x18>
10005530:	0a00      	lsrs	r0, r0, #8
10005532:	3908      	subs	r1, #8
10005534:	091b      	lsrs	r3, r3, #4
10005536:	4298      	cmp	r0, r3
10005538:	d301      	bcc.n	1000553e <__clzsi2+0x22>
1000553a:	0900      	lsrs	r0, r0, #4
1000553c:	3904      	subs	r1, #4
1000553e:	a202      	add	r2, pc, #8	; (adr r2, 10005548 <__clzsi2+0x2c>)
10005540:	5c10      	ldrb	r0, [r2, r0]
10005542:	1840      	adds	r0, r0, r1
10005544:	4770      	bx	lr
10005546:	46c0      	nop			; (mov r8, r8)
10005548:	02020304 	.word	0x02020304
1000554c:	01010101 	.word	0x01010101
	...

10005558 <__errno>:
10005558:	4b01      	ldr	r3, [pc, #4]	; (10005560 <__errno+0x8>)
1000555a:	6818      	ldr	r0, [r3, #0]
1000555c:	4770      	bx	lr
1000555e:	46c0      	nop			; (mov r8, r8)
10005560:	20000664 	.word	0x20000664

10005564 <malloc>:
10005564:	b508      	push	{r3, lr}
10005566:	4b03      	ldr	r3, [pc, #12]	; (10005574 <malloc+0x10>)
10005568:	1c01      	adds	r1, r0, #0
1000556a:	6818      	ldr	r0, [r3, #0]
1000556c:	f000 f866 	bl	1000563c <_malloc_r>
10005570:	bd08      	pop	{r3, pc}
10005572:	46c0      	nop			; (mov r8, r8)
10005574:	20000664 	.word	0x20000664

10005578 <free>:
10005578:	b508      	push	{r3, lr}
1000557a:	4b03      	ldr	r3, [pc, #12]	; (10005588 <free+0x10>)
1000557c:	1c01      	adds	r1, r0, #0
1000557e:	6818      	ldr	r0, [r3, #0]
10005580:	f000 f816 	bl	100055b0 <_free_r>
10005584:	bd08      	pop	{r3, pc}
10005586:	46c0      	nop			; (mov r8, r8)
10005588:	20000664 	.word	0x20000664

1000558c <memcpy>:
1000558c:	2300      	movs	r3, #0
1000558e:	b510      	push	{r4, lr}
10005590:	4293      	cmp	r3, r2
10005592:	d003      	beq.n	1000559c <memcpy+0x10>
10005594:	5ccc      	ldrb	r4, [r1, r3]
10005596:	54c4      	strb	r4, [r0, r3]
10005598:	3301      	adds	r3, #1
1000559a:	e7f9      	b.n	10005590 <memcpy+0x4>
1000559c:	bd10      	pop	{r4, pc}

1000559e <memset>:
1000559e:	1c03      	adds	r3, r0, #0
100055a0:	1882      	adds	r2, r0, r2
100055a2:	4293      	cmp	r3, r2
100055a4:	d002      	beq.n	100055ac <memset+0xe>
100055a6:	7019      	strb	r1, [r3, #0]
100055a8:	3301      	adds	r3, #1
100055aa:	e7fa      	b.n	100055a2 <memset+0x4>
100055ac:	4770      	bx	lr
	...

100055b0 <_free_r>:
100055b0:	b530      	push	{r4, r5, lr}
100055b2:	2900      	cmp	r1, #0
100055b4:	d03e      	beq.n	10005634 <_free_r+0x84>
100055b6:	3904      	subs	r1, #4
100055b8:	680b      	ldr	r3, [r1, #0]
100055ba:	2b00      	cmp	r3, #0
100055bc:	da00      	bge.n	100055c0 <_free_r+0x10>
100055be:	18c9      	adds	r1, r1, r3
100055c0:	4a1d      	ldr	r2, [pc, #116]	; (10005638 <_free_r+0x88>)
100055c2:	6813      	ldr	r3, [r2, #0]
100055c4:	1c14      	adds	r4, r2, #0
100055c6:	2b00      	cmp	r3, #0
100055c8:	d102      	bne.n	100055d0 <_free_r+0x20>
100055ca:	604b      	str	r3, [r1, #4]
100055cc:	6011      	str	r1, [r2, #0]
100055ce:	e031      	b.n	10005634 <_free_r+0x84>
100055d0:	4299      	cmp	r1, r3
100055d2:	d20d      	bcs.n	100055f0 <_free_r+0x40>
100055d4:	6808      	ldr	r0, [r1, #0]
100055d6:	180a      	adds	r2, r1, r0
100055d8:	429a      	cmp	r2, r3
100055da:	d103      	bne.n	100055e4 <_free_r+0x34>
100055dc:	6813      	ldr	r3, [r2, #0]
100055de:	18c3      	adds	r3, r0, r3
100055e0:	600b      	str	r3, [r1, #0]
100055e2:	6853      	ldr	r3, [r2, #4]
100055e4:	604b      	str	r3, [r1, #4]
100055e6:	6021      	str	r1, [r4, #0]
100055e8:	e024      	b.n	10005634 <_free_r+0x84>
100055ea:	428a      	cmp	r2, r1
100055ec:	d803      	bhi.n	100055f6 <_free_r+0x46>
100055ee:	1c13      	adds	r3, r2, #0
100055f0:	685a      	ldr	r2, [r3, #4]
100055f2:	2a00      	cmp	r2, #0
100055f4:	d1f9      	bne.n	100055ea <_free_r+0x3a>
100055f6:	681d      	ldr	r5, [r3, #0]
100055f8:	195c      	adds	r4, r3, r5
100055fa:	428c      	cmp	r4, r1
100055fc:	d10b      	bne.n	10005616 <_free_r+0x66>
100055fe:	6809      	ldr	r1, [r1, #0]
10005600:	1869      	adds	r1, r5, r1
10005602:	1858      	adds	r0, r3, r1
10005604:	6019      	str	r1, [r3, #0]
10005606:	4290      	cmp	r0, r2
10005608:	d114      	bne.n	10005634 <_free_r+0x84>
1000560a:	6810      	ldr	r0, [r2, #0]
1000560c:	6852      	ldr	r2, [r2, #4]
1000560e:	1809      	adds	r1, r1, r0
10005610:	6019      	str	r1, [r3, #0]
10005612:	605a      	str	r2, [r3, #4]
10005614:	e00e      	b.n	10005634 <_free_r+0x84>
10005616:	428c      	cmp	r4, r1
10005618:	d902      	bls.n	10005620 <_free_r+0x70>
1000561a:	230c      	movs	r3, #12
1000561c:	6003      	str	r3, [r0, #0]
1000561e:	e009      	b.n	10005634 <_free_r+0x84>
10005620:	6808      	ldr	r0, [r1, #0]
10005622:	180c      	adds	r4, r1, r0
10005624:	4294      	cmp	r4, r2
10005626:	d103      	bne.n	10005630 <_free_r+0x80>
10005628:	6814      	ldr	r4, [r2, #0]
1000562a:	6852      	ldr	r2, [r2, #4]
1000562c:	1900      	adds	r0, r0, r4
1000562e:	6008      	str	r0, [r1, #0]
10005630:	604a      	str	r2, [r1, #4]
10005632:	6059      	str	r1, [r3, #4]
10005634:	bd30      	pop	{r4, r5, pc}
10005636:	46c0      	nop			; (mov r8, r8)
10005638:	20000824 	.word	0x20000824

1000563c <_malloc_r>:
1000563c:	2303      	movs	r3, #3
1000563e:	b570      	push	{r4, r5, r6, lr}
10005640:	1ccc      	adds	r4, r1, #3
10005642:	439c      	bics	r4, r3
10005644:	3408      	adds	r4, #8
10005646:	1c05      	adds	r5, r0, #0
10005648:	2c0c      	cmp	r4, #12
1000564a:	d201      	bcs.n	10005650 <_malloc_r+0x14>
1000564c:	240c      	movs	r4, #12
1000564e:	e005      	b.n	1000565c <_malloc_r+0x20>
10005650:	2c00      	cmp	r4, #0
10005652:	da03      	bge.n	1000565c <_malloc_r+0x20>
10005654:	230c      	movs	r3, #12
10005656:	2000      	movs	r0, #0
10005658:	602b      	str	r3, [r5, #0]
1000565a:	e042      	b.n	100056e2 <_malloc_r+0xa6>
1000565c:	428c      	cmp	r4, r1
1000565e:	d3f9      	bcc.n	10005654 <_malloc_r+0x18>
10005660:	4a20      	ldr	r2, [pc, #128]	; (100056e4 <_malloc_r+0xa8>)
10005662:	6813      	ldr	r3, [r2, #0]
10005664:	1c10      	adds	r0, r2, #0
10005666:	1c19      	adds	r1, r3, #0
10005668:	2900      	cmp	r1, #0
1000566a:	d013      	beq.n	10005694 <_malloc_r+0x58>
1000566c:	680a      	ldr	r2, [r1, #0]
1000566e:	1b12      	subs	r2, r2, r4
10005670:	d40d      	bmi.n	1000568e <_malloc_r+0x52>
10005672:	2a0b      	cmp	r2, #11
10005674:	d902      	bls.n	1000567c <_malloc_r+0x40>
10005676:	600a      	str	r2, [r1, #0]
10005678:	188b      	adds	r3, r1, r2
1000567a:	e01f      	b.n	100056bc <_malloc_r+0x80>
1000567c:	428b      	cmp	r3, r1
1000567e:	d102      	bne.n	10005686 <_malloc_r+0x4a>
10005680:	685a      	ldr	r2, [r3, #4]
10005682:	6002      	str	r2, [r0, #0]
10005684:	e01b      	b.n	100056be <_malloc_r+0x82>
10005686:	684a      	ldr	r2, [r1, #4]
10005688:	605a      	str	r2, [r3, #4]
1000568a:	1c0b      	adds	r3, r1, #0
1000568c:	e017      	b.n	100056be <_malloc_r+0x82>
1000568e:	1c0b      	adds	r3, r1, #0
10005690:	6849      	ldr	r1, [r1, #4]
10005692:	e7e9      	b.n	10005668 <_malloc_r+0x2c>
10005694:	4e14      	ldr	r6, [pc, #80]	; (100056e8 <_malloc_r+0xac>)
10005696:	6833      	ldr	r3, [r6, #0]
10005698:	2b00      	cmp	r3, #0
1000569a:	d103      	bne.n	100056a4 <_malloc_r+0x68>
1000569c:	1c28      	adds	r0, r5, #0
1000569e:	f000 fd27 	bl	100060f0 <_sbrk_r>
100056a2:	6030      	str	r0, [r6, #0]
100056a4:	1c28      	adds	r0, r5, #0
100056a6:	1c21      	adds	r1, r4, #0
100056a8:	f000 fd22 	bl	100060f0 <_sbrk_r>
100056ac:	1c03      	adds	r3, r0, #0
100056ae:	1c42      	adds	r2, r0, #1
100056b0:	d0d0      	beq.n	10005654 <_malloc_r+0x18>
100056b2:	2203      	movs	r2, #3
100056b4:	1cc6      	adds	r6, r0, #3
100056b6:	4396      	bics	r6, r2
100056b8:	4286      	cmp	r6, r0
100056ba:	d10a      	bne.n	100056d2 <_malloc_r+0x96>
100056bc:	601c      	str	r4, [r3, #0]
100056be:	1c18      	adds	r0, r3, #0
100056c0:	2107      	movs	r1, #7
100056c2:	300b      	adds	r0, #11
100056c4:	1d1a      	adds	r2, r3, #4
100056c6:	4388      	bics	r0, r1
100056c8:	1a82      	subs	r2, r0, r2
100056ca:	d00a      	beq.n	100056e2 <_malloc_r+0xa6>
100056cc:	4251      	negs	r1, r2
100056ce:	5099      	str	r1, [r3, r2]
100056d0:	e007      	b.n	100056e2 <_malloc_r+0xa6>
100056d2:	1a31      	subs	r1, r6, r0
100056d4:	1c28      	adds	r0, r5, #0
100056d6:	f000 fd0b 	bl	100060f0 <_sbrk_r>
100056da:	1c43      	adds	r3, r0, #1
100056dc:	d0ba      	beq.n	10005654 <_malloc_r+0x18>
100056de:	1c33      	adds	r3, r6, #0
100056e0:	e7ec      	b.n	100056bc <_malloc_r+0x80>
100056e2:	bd70      	pop	{r4, r5, r6, pc}
100056e4:	20000824 	.word	0x20000824
100056e8:	20000820 	.word	0x20000820

100056ec <__cvt>:
100056ec:	b5f0      	push	{r4, r5, r6, r7, lr}
100056ee:	b08b      	sub	sp, #44	; 0x2c
100056f0:	1c14      	adds	r4, r2, #0
100056f2:	1e1d      	subs	r5, r3, #0
100056f4:	9912      	ldr	r1, [sp, #72]	; 0x48
100056f6:	da06      	bge.n	10005706 <__cvt+0x1a>
100056f8:	2480      	movs	r4, #128	; 0x80
100056fa:	0624      	lsls	r4, r4, #24
100056fc:	192b      	adds	r3, r5, r4
100056fe:	1c1d      	adds	r5, r3, #0
10005700:	1c14      	adds	r4, r2, #0
10005702:	232d      	movs	r3, #45	; 0x2d
10005704:	e000      	b.n	10005708 <__cvt+0x1c>
10005706:	2300      	movs	r3, #0
10005708:	700b      	strb	r3, [r1, #0]
1000570a:	2320      	movs	r3, #32
1000570c:	9e14      	ldr	r6, [sp, #80]	; 0x50
1000570e:	2203      	movs	r2, #3
10005710:	439e      	bics	r6, r3
10005712:	2e46      	cmp	r6, #70	; 0x46
10005714:	d007      	beq.n	10005726 <__cvt+0x3a>
10005716:	1c33      	adds	r3, r6, #0
10005718:	3b45      	subs	r3, #69	; 0x45
1000571a:	4259      	negs	r1, r3
1000571c:	414b      	adcs	r3, r1
1000571e:	9910      	ldr	r1, [sp, #64]	; 0x40
10005720:	3a01      	subs	r2, #1
10005722:	18cb      	adds	r3, r1, r3
10005724:	9310      	str	r3, [sp, #64]	; 0x40
10005726:	9b10      	ldr	r3, [sp, #64]	; 0x40
10005728:	9200      	str	r2, [sp, #0]
1000572a:	9301      	str	r3, [sp, #4]
1000572c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
1000572e:	1c22      	adds	r2, r4, #0
10005730:	9302      	str	r3, [sp, #8]
10005732:	ab08      	add	r3, sp, #32
10005734:	9303      	str	r3, [sp, #12]
10005736:	ab09      	add	r3, sp, #36	; 0x24
10005738:	9304      	str	r3, [sp, #16]
1000573a:	1c2b      	adds	r3, r5, #0
1000573c:	f000 fe68 	bl	10006410 <_dtoa_r>
10005740:	1c07      	adds	r7, r0, #0
10005742:	2e47      	cmp	r6, #71	; 0x47
10005744:	d102      	bne.n	1000574c <__cvt+0x60>
10005746:	9b11      	ldr	r3, [sp, #68]	; 0x44
10005748:	07db      	lsls	r3, r3, #31
1000574a:	d52c      	bpl.n	100057a6 <__cvt+0xba>
1000574c:	9b10      	ldr	r3, [sp, #64]	; 0x40
1000574e:	18fb      	adds	r3, r7, r3
10005750:	9307      	str	r3, [sp, #28]
10005752:	2e46      	cmp	r6, #70	; 0x46
10005754:	d114      	bne.n	10005780 <__cvt+0x94>
10005756:	783b      	ldrb	r3, [r7, #0]
10005758:	2b30      	cmp	r3, #48	; 0x30
1000575a:	d10c      	bne.n	10005776 <__cvt+0x8a>
1000575c:	1c20      	adds	r0, r4, #0
1000575e:	1c29      	adds	r1, r5, #0
10005760:	2200      	movs	r2, #0
10005762:	2300      	movs	r3, #0
10005764:	f002 fcea 	bl	1000813c <__aeabi_dcmpeq>
10005768:	2800      	cmp	r0, #0
1000576a:	d104      	bne.n	10005776 <__cvt+0x8a>
1000576c:	2301      	movs	r3, #1
1000576e:	9a10      	ldr	r2, [sp, #64]	; 0x40
10005770:	1a9b      	subs	r3, r3, r2
10005772:	9a13      	ldr	r2, [sp, #76]	; 0x4c
10005774:	6013      	str	r3, [r2, #0]
10005776:	9b13      	ldr	r3, [sp, #76]	; 0x4c
10005778:	9a07      	ldr	r2, [sp, #28]
1000577a:	681b      	ldr	r3, [r3, #0]
1000577c:	18d3      	adds	r3, r2, r3
1000577e:	9307      	str	r3, [sp, #28]
10005780:	1c20      	adds	r0, r4, #0
10005782:	1c29      	adds	r1, r5, #0
10005784:	2200      	movs	r2, #0
10005786:	2300      	movs	r3, #0
10005788:	f002 fcd8 	bl	1000813c <__aeabi_dcmpeq>
1000578c:	2800      	cmp	r0, #0
1000578e:	d001      	beq.n	10005794 <__cvt+0xa8>
10005790:	9b07      	ldr	r3, [sp, #28]
10005792:	9309      	str	r3, [sp, #36]	; 0x24
10005794:	9b09      	ldr	r3, [sp, #36]	; 0x24
10005796:	9a07      	ldr	r2, [sp, #28]
10005798:	4293      	cmp	r3, r2
1000579a:	d204      	bcs.n	100057a6 <__cvt+0xba>
1000579c:	1c5a      	adds	r2, r3, #1
1000579e:	9209      	str	r2, [sp, #36]	; 0x24
100057a0:	2230      	movs	r2, #48	; 0x30
100057a2:	701a      	strb	r2, [r3, #0]
100057a4:	e7f6      	b.n	10005794 <__cvt+0xa8>
100057a6:	1c38      	adds	r0, r7, #0
100057a8:	9b09      	ldr	r3, [sp, #36]	; 0x24
100057aa:	9a15      	ldr	r2, [sp, #84]	; 0x54
100057ac:	1bdb      	subs	r3, r3, r7
100057ae:	6013      	str	r3, [r2, #0]
100057b0:	b00b      	add	sp, #44	; 0x2c
100057b2:	bdf0      	pop	{r4, r5, r6, r7, pc}

100057b4 <__exponent>:
100057b4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
100057b6:	232b      	movs	r3, #43	; 0x2b
100057b8:	1c07      	adds	r7, r0, #0
100057ba:	1c0c      	adds	r4, r1, #0
100057bc:	7002      	strb	r2, [r0, #0]
100057be:	1c86      	adds	r6, r0, #2
100057c0:	2900      	cmp	r1, #0
100057c2:	da01      	bge.n	100057c8 <__exponent+0x14>
100057c4:	232d      	movs	r3, #45	; 0x2d
100057c6:	424c      	negs	r4, r1
100057c8:	707b      	strb	r3, [r7, #1]
100057ca:	2c09      	cmp	r4, #9
100057cc:	dd1c      	ble.n	10005808 <__exponent+0x54>
100057ce:	466b      	mov	r3, sp
100057d0:	1ddd      	adds	r5, r3, #7
100057d2:	1c20      	adds	r0, r4, #0
100057d4:	210a      	movs	r1, #10
100057d6:	f7ff fe95 	bl	10005504 <__aeabi_idivmod>
100057da:	3d01      	subs	r5, #1
100057dc:	3130      	adds	r1, #48	; 0x30
100057de:	7029      	strb	r1, [r5, #0]
100057e0:	1c20      	adds	r0, r4, #0
100057e2:	210a      	movs	r1, #10
100057e4:	f7ff fda8 	bl	10005338 <__aeabi_idiv>
100057e8:	1e04      	subs	r4, r0, #0
100057ea:	2c09      	cmp	r4, #9
100057ec:	dcf1      	bgt.n	100057d2 <__exponent+0x1e>
100057ee:	3d01      	subs	r5, #1
100057f0:	3430      	adds	r4, #48	; 0x30
100057f2:	702c      	strb	r4, [r5, #0]
100057f4:	466b      	mov	r3, sp
100057f6:	3307      	adds	r3, #7
100057f8:	1c30      	adds	r0, r6, #0
100057fa:	42ab      	cmp	r3, r5
100057fc:	d909      	bls.n	10005812 <__exponent+0x5e>
100057fe:	782b      	ldrb	r3, [r5, #0]
10005800:	3501      	adds	r5, #1
10005802:	7033      	strb	r3, [r6, #0]
10005804:	3601      	adds	r6, #1
10005806:	e7f5      	b.n	100057f4 <__exponent+0x40>
10005808:	2330      	movs	r3, #48	; 0x30
1000580a:	18e4      	adds	r4, r4, r3
1000580c:	7033      	strb	r3, [r6, #0]
1000580e:	1cb0      	adds	r0, r6, #2
10005810:	7074      	strb	r4, [r6, #1]
10005812:	1bc0      	subs	r0, r0, r7
10005814:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	...

10005818 <_printf_float>:
10005818:	b5f0      	push	{r4, r5, r6, r7, lr}
1000581a:	b093      	sub	sp, #76	; 0x4c
1000581c:	1c0c      	adds	r4, r1, #0
1000581e:	9208      	str	r2, [sp, #32]
10005820:	9e18      	ldr	r6, [sp, #96]	; 0x60
10005822:	9309      	str	r3, [sp, #36]	; 0x24
10005824:	1c05      	adds	r5, r0, #0
10005826:	f001 fd7d 	bl	10007324 <_localeconv_r>
1000582a:	6803      	ldr	r3, [r0, #0]
1000582c:	1c18      	adds	r0, r3, #0
1000582e:	930b      	str	r3, [sp, #44]	; 0x2c
10005830:	f000 fc92 	bl	10006158 <strlen>
10005834:	2300      	movs	r3, #0
10005836:	2207      	movs	r2, #7
10005838:	9310      	str	r3, [sp, #64]	; 0x40
1000583a:	6833      	ldr	r3, [r6, #0]
1000583c:	900c      	str	r0, [sp, #48]	; 0x30
1000583e:	3307      	adds	r3, #7
10005840:	4393      	bics	r3, r2
10005842:	1c1a      	adds	r2, r3, #0
10005844:	6818      	ldr	r0, [r3, #0]
10005846:	6859      	ldr	r1, [r3, #4]
10005848:	3208      	adds	r2, #8
1000584a:	7e27      	ldrb	r7, [r4, #24]
1000584c:	6032      	str	r2, [r6, #0]
1000584e:	64a0      	str	r0, [r4, #72]	; 0x48
10005850:	64e1      	str	r1, [r4, #76]	; 0x4c
10005852:	f000 fc25 	bl	100060a0 <__fpclassifyd>
10005856:	2801      	cmp	r0, #1
10005858:	d118      	bne.n	1000588c <_printf_float+0x74>
1000585a:	6ca0      	ldr	r0, [r4, #72]	; 0x48
1000585c:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
1000585e:	2200      	movs	r2, #0
10005860:	2300      	movs	r3, #0
10005862:	f002 fc71 	bl	10008148 <__aeabi_dcmplt>
10005866:	2800      	cmp	r0, #0
10005868:	d003      	beq.n	10005872 <_printf_float+0x5a>
1000586a:	1c23      	adds	r3, r4, #0
1000586c:	222d      	movs	r2, #45	; 0x2d
1000586e:	3343      	adds	r3, #67	; 0x43
10005870:	701a      	strb	r2, [r3, #0]
10005872:	4bb7      	ldr	r3, [pc, #732]	; (10005b50 <_printf_float+0x338>)
10005874:	930a      	str	r3, [sp, #40]	; 0x28
10005876:	2f47      	cmp	r7, #71	; 0x47
10005878:	d901      	bls.n	1000587e <_printf_float+0x66>
1000587a:	4bb6      	ldr	r3, [pc, #728]	; (10005b54 <_printf_float+0x33c>)
1000587c:	930a      	str	r3, [sp, #40]	; 0x28
1000587e:	2303      	movs	r3, #3
10005880:	6822      	ldr	r2, [r4, #0]
10005882:	6123      	str	r3, [r4, #16]
10005884:	3301      	adds	r3, #1
10005886:	439a      	bics	r2, r3
10005888:	6022      	str	r2, [r4, #0]
1000588a:	e012      	b.n	100058b2 <_printf_float+0x9a>
1000588c:	6ca0      	ldr	r0, [r4, #72]	; 0x48
1000588e:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
10005890:	f000 fc06 	bl	100060a0 <__fpclassifyd>
10005894:	6826      	ldr	r6, [r4, #0]
10005896:	2800      	cmp	r0, #0
10005898:	d10d      	bne.n	100058b6 <_printf_float+0x9e>
1000589a:	4baf      	ldr	r3, [pc, #700]	; (10005b58 <_printf_float+0x340>)
1000589c:	930a      	str	r3, [sp, #40]	; 0x28
1000589e:	2f47      	cmp	r7, #71	; 0x47
100058a0:	d901      	bls.n	100058a6 <_printf_float+0x8e>
100058a2:	4bae      	ldr	r3, [pc, #696]	; (10005b5c <_printf_float+0x344>)
100058a4:	930a      	str	r3, [sp, #40]	; 0x28
100058a6:	2303      	movs	r3, #3
100058a8:	1c31      	adds	r1, r6, #0
100058aa:	6123      	str	r3, [r4, #16]
100058ac:	3301      	adds	r3, #1
100058ae:	4399      	bics	r1, r3
100058b0:	6021      	str	r1, [r4, #0]
100058b2:	2600      	movs	r6, #0
100058b4:	e080      	b.n	100059b8 <_printf_float+0x1a0>
100058b6:	2180      	movs	r1, #128	; 0x80
100058b8:	6860      	ldr	r0, [r4, #4]
100058ba:	00c9      	lsls	r1, r1, #3
100058bc:	1c43      	adds	r3, r0, #1
100058be:	d101      	bne.n	100058c4 <_printf_float+0xac>
100058c0:	2306      	movs	r3, #6
100058c2:	e009      	b.n	100058d8 <_printf_float+0xc0>
100058c4:	6ca2      	ldr	r2, [r4, #72]	; 0x48
100058c6:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
100058c8:	2f67      	cmp	r7, #103	; 0x67
100058ca:	d001      	beq.n	100058d0 <_printf_float+0xb8>
100058cc:	2f47      	cmp	r7, #71	; 0x47
100058ce:	d104      	bne.n	100058da <_printf_float+0xc2>
100058d0:	2800      	cmp	r0, #0
100058d2:	d000      	beq.n	100058d6 <_printf_float+0xbe>
100058d4:	e1c1      	b.n	10005c5a <_printf_float+0x442>
100058d6:	2301      	movs	r3, #1
100058d8:	6063      	str	r3, [r4, #4]
100058da:	6863      	ldr	r3, [r4, #4]
100058dc:	4331      	orrs	r1, r6
100058de:	9300      	str	r3, [sp, #0]
100058e0:	2323      	movs	r3, #35	; 0x23
100058e2:	6021      	str	r1, [r4, #0]
100058e4:	9101      	str	r1, [sp, #4]
100058e6:	2100      	movs	r1, #0
100058e8:	aa06      	add	r2, sp, #24
100058ea:	189b      	adds	r3, r3, r2
100058ec:	9302      	str	r3, [sp, #8]
100058ee:	ab0f      	add	r3, sp, #60	; 0x3c
100058f0:	9303      	str	r3, [sp, #12]
100058f2:	ab10      	add	r3, sp, #64	; 0x40
100058f4:	9305      	str	r3, [sp, #20]
100058f6:	9704      	str	r7, [sp, #16]
100058f8:	6ca2      	ldr	r2, [r4, #72]	; 0x48
100058fa:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
100058fc:	9106      	str	r1, [sp, #24]
100058fe:	1c28      	adds	r0, r5, #0
10005900:	f7ff fef4 	bl	100056ec <__cvt>
10005904:	2320      	movs	r3, #32
10005906:	1c3a      	adds	r2, r7, #0
10005908:	900a      	str	r0, [sp, #40]	; 0x28
1000590a:	439a      	bics	r2, r3
1000590c:	2a47      	cmp	r2, #71	; 0x47
1000590e:	d107      	bne.n	10005920 <_printf_float+0x108>
10005910:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
10005912:	1cda      	adds	r2, r3, #3
10005914:	db02      	blt.n	1000591c <_printf_float+0x104>
10005916:	6862      	ldr	r2, [r4, #4]
10005918:	4293      	cmp	r3, r2
1000591a:	dd2d      	ble.n	10005978 <_printf_float+0x160>
1000591c:	3f02      	subs	r7, #2
1000591e:	b2ff      	uxtb	r7, r7
10005920:	990f      	ldr	r1, [sp, #60]	; 0x3c
10005922:	2f65      	cmp	r7, #101	; 0x65
10005924:	d812      	bhi.n	1000594c <_printf_float+0x134>
10005926:	1c20      	adds	r0, r4, #0
10005928:	3901      	subs	r1, #1
1000592a:	1c3a      	adds	r2, r7, #0
1000592c:	3050      	adds	r0, #80	; 0x50
1000592e:	910f      	str	r1, [sp, #60]	; 0x3c
10005930:	f7ff ff40 	bl	100057b4 <__exponent>
10005934:	9a10      	ldr	r2, [sp, #64]	; 0x40
10005936:	1c06      	adds	r6, r0, #0
10005938:	1883      	adds	r3, r0, r2
1000593a:	6123      	str	r3, [r4, #16]
1000593c:	2a01      	cmp	r2, #1
1000593e:	dc02      	bgt.n	10005946 <_printf_float+0x12e>
10005940:	6822      	ldr	r2, [r4, #0]
10005942:	07d2      	lsls	r2, r2, #31
10005944:	d52e      	bpl.n	100059a4 <_printf_float+0x18c>
10005946:	3301      	adds	r3, #1
10005948:	6123      	str	r3, [r4, #16]
1000594a:	e02b      	b.n	100059a4 <_printf_float+0x18c>
1000594c:	2f66      	cmp	r7, #102	; 0x66
1000594e:	d114      	bne.n	1000597a <_printf_float+0x162>
10005950:	6863      	ldr	r3, [r4, #4]
10005952:	2900      	cmp	r1, #0
10005954:	dd08      	ble.n	10005968 <_printf_float+0x150>
10005956:	6121      	str	r1, [r4, #16]
10005958:	2b00      	cmp	r3, #0
1000595a:	d102      	bne.n	10005962 <_printf_float+0x14a>
1000595c:	6822      	ldr	r2, [r4, #0]
1000595e:	07d2      	lsls	r2, r2, #31
10005960:	d51d      	bpl.n	1000599e <_printf_float+0x186>
10005962:	3301      	adds	r3, #1
10005964:	18cb      	adds	r3, r1, r3
10005966:	e011      	b.n	1000598c <_printf_float+0x174>
10005968:	2b00      	cmp	r3, #0
1000596a:	d103      	bne.n	10005974 <_printf_float+0x15c>
1000596c:	2201      	movs	r2, #1
1000596e:	6821      	ldr	r1, [r4, #0]
10005970:	4211      	tst	r1, r2
10005972:	d013      	beq.n	1000599c <_printf_float+0x184>
10005974:	1c9a      	adds	r2, r3, #2
10005976:	e011      	b.n	1000599c <_printf_float+0x184>
10005978:	2767      	movs	r7, #103	; 0x67
1000597a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
1000597c:	9810      	ldr	r0, [sp, #64]	; 0x40
1000597e:	4283      	cmp	r3, r0
10005980:	db06      	blt.n	10005990 <_printf_float+0x178>
10005982:	6822      	ldr	r2, [r4, #0]
10005984:	6123      	str	r3, [r4, #16]
10005986:	07d2      	lsls	r2, r2, #31
10005988:	d509      	bpl.n	1000599e <_printf_float+0x186>
1000598a:	3301      	adds	r3, #1
1000598c:	6123      	str	r3, [r4, #16]
1000598e:	e006      	b.n	1000599e <_printf_float+0x186>
10005990:	2201      	movs	r2, #1
10005992:	2b00      	cmp	r3, #0
10005994:	dc01      	bgt.n	1000599a <_printf_float+0x182>
10005996:	2102      	movs	r1, #2
10005998:	1aca      	subs	r2, r1, r3
1000599a:	1882      	adds	r2, r0, r2
1000599c:	6122      	str	r2, [r4, #16]
1000599e:	2600      	movs	r6, #0
100059a0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
100059a2:	65a3      	str	r3, [r4, #88]	; 0x58
100059a4:	2323      	movs	r3, #35	; 0x23
100059a6:	aa06      	add	r2, sp, #24
100059a8:	189b      	adds	r3, r3, r2
100059aa:	781b      	ldrb	r3, [r3, #0]
100059ac:	2b00      	cmp	r3, #0
100059ae:	d003      	beq.n	100059b8 <_printf_float+0x1a0>
100059b0:	1c23      	adds	r3, r4, #0
100059b2:	222d      	movs	r2, #45	; 0x2d
100059b4:	3343      	adds	r3, #67	; 0x43
100059b6:	701a      	strb	r2, [r3, #0]
100059b8:	9b09      	ldr	r3, [sp, #36]	; 0x24
100059ba:	1c28      	adds	r0, r5, #0
100059bc:	9300      	str	r3, [sp, #0]
100059be:	1c21      	adds	r1, r4, #0
100059c0:	9b08      	ldr	r3, [sp, #32]
100059c2:	aa11      	add	r2, sp, #68	; 0x44
100059c4:	f000 f960 	bl	10005c88 <_printf_common>
100059c8:	1c43      	adds	r3, r0, #1
100059ca:	d102      	bne.n	100059d2 <_printf_float+0x1ba>
100059cc:	2001      	movs	r0, #1
100059ce:	4240      	negs	r0, r0
100059d0:	e157      	b.n	10005c82 <_printf_float+0x46a>
100059d2:	6822      	ldr	r2, [r4, #0]
100059d4:	0553      	lsls	r3, r2, #21
100059d6:	d404      	bmi.n	100059e2 <_printf_float+0x1ca>
100059d8:	1c28      	adds	r0, r5, #0
100059da:	9908      	ldr	r1, [sp, #32]
100059dc:	9a0a      	ldr	r2, [sp, #40]	; 0x28
100059de:	6923      	ldr	r3, [r4, #16]
100059e0:	e117      	b.n	10005c12 <_printf_float+0x3fa>
100059e2:	2f65      	cmp	r7, #101	; 0x65
100059e4:	d800      	bhi.n	100059e8 <_printf_float+0x1d0>
100059e6:	e0d5      	b.n	10005b94 <_printf_float+0x37c>
100059e8:	6ca0      	ldr	r0, [r4, #72]	; 0x48
100059ea:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
100059ec:	2200      	movs	r2, #0
100059ee:	2300      	movs	r3, #0
100059f0:	f002 fba4 	bl	1000813c <__aeabi_dcmpeq>
100059f4:	2800      	cmp	r0, #0
100059f6:	d02b      	beq.n	10005a50 <_printf_float+0x238>
100059f8:	2301      	movs	r3, #1
100059fa:	1c28      	adds	r0, r5, #0
100059fc:	9908      	ldr	r1, [sp, #32]
100059fe:	4a58      	ldr	r2, [pc, #352]	; (10005b60 <_printf_float+0x348>)
10005a00:	9e09      	ldr	r6, [sp, #36]	; 0x24
10005a02:	47b0      	blx	r6
10005a04:	1c43      	adds	r3, r0, #1
10005a06:	d0e1      	beq.n	100059cc <_printf_float+0x1b4>
10005a08:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
10005a0a:	9a10      	ldr	r2, [sp, #64]	; 0x40
10005a0c:	4293      	cmp	r3, r2
10005a0e:	db07      	blt.n	10005a20 <_printf_float+0x208>
10005a10:	6823      	ldr	r3, [r4, #0]
10005a12:	07db      	lsls	r3, r3, #31
10005a14:	d404      	bmi.n	10005a20 <_printf_float+0x208>
10005a16:	6823      	ldr	r3, [r4, #0]
10005a18:	079b      	lsls	r3, r3, #30
10005a1a:	d500      	bpl.n	10005a1e <_printf_float+0x206>
10005a1c:	e11b      	b.n	10005c56 <_printf_float+0x43e>
10005a1e:	e114      	b.n	10005c4a <_printf_float+0x432>
10005a20:	9e09      	ldr	r6, [sp, #36]	; 0x24
10005a22:	1c28      	adds	r0, r5, #0
10005a24:	9908      	ldr	r1, [sp, #32]
10005a26:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
10005a28:	9b0c      	ldr	r3, [sp, #48]	; 0x30
10005a2a:	47b0      	blx	r6
10005a2c:	2600      	movs	r6, #0
10005a2e:	1c43      	adds	r3, r0, #1
10005a30:	d0cc      	beq.n	100059cc <_printf_float+0x1b4>
10005a32:	9b10      	ldr	r3, [sp, #64]	; 0x40
10005a34:	3b01      	subs	r3, #1
10005a36:	429e      	cmp	r6, r3
10005a38:	daed      	bge.n	10005a16 <_printf_float+0x1fe>
10005a3a:	1c22      	adds	r2, r4, #0
10005a3c:	2301      	movs	r3, #1
10005a3e:	1c28      	adds	r0, r5, #0
10005a40:	9908      	ldr	r1, [sp, #32]
10005a42:	321a      	adds	r2, #26
10005a44:	9f09      	ldr	r7, [sp, #36]	; 0x24
10005a46:	47b8      	blx	r7
10005a48:	1c43      	adds	r3, r0, #1
10005a4a:	d0bf      	beq.n	100059cc <_printf_float+0x1b4>
10005a4c:	3601      	adds	r6, #1
10005a4e:	e7f0      	b.n	10005a32 <_printf_float+0x21a>
10005a50:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
10005a52:	2b00      	cmp	r3, #0
10005a54:	dc2b      	bgt.n	10005aae <_printf_float+0x296>
10005a56:	2301      	movs	r3, #1
10005a58:	1c28      	adds	r0, r5, #0
10005a5a:	9908      	ldr	r1, [sp, #32]
10005a5c:	4a40      	ldr	r2, [pc, #256]	; (10005b60 <_printf_float+0x348>)
10005a5e:	9e09      	ldr	r6, [sp, #36]	; 0x24
10005a60:	47b0      	blx	r6
10005a62:	1c43      	adds	r3, r0, #1
10005a64:	d0b2      	beq.n	100059cc <_printf_float+0x1b4>
10005a66:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
10005a68:	2b00      	cmp	r3, #0
10005a6a:	d105      	bne.n	10005a78 <_printf_float+0x260>
10005a6c:	9b10      	ldr	r3, [sp, #64]	; 0x40
10005a6e:	2b00      	cmp	r3, #0
10005a70:	d102      	bne.n	10005a78 <_printf_float+0x260>
10005a72:	6823      	ldr	r3, [r4, #0]
10005a74:	07db      	lsls	r3, r3, #31
10005a76:	d5ce      	bpl.n	10005a16 <_printf_float+0x1fe>
10005a78:	9e09      	ldr	r6, [sp, #36]	; 0x24
10005a7a:	1c28      	adds	r0, r5, #0
10005a7c:	9908      	ldr	r1, [sp, #32]
10005a7e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
10005a80:	9b0c      	ldr	r3, [sp, #48]	; 0x30
10005a82:	47b0      	blx	r6
10005a84:	2600      	movs	r6, #0
10005a86:	1c43      	adds	r3, r0, #1
10005a88:	d0a0      	beq.n	100059cc <_printf_float+0x1b4>
10005a8a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
10005a8c:	1c28      	adds	r0, r5, #0
10005a8e:	425b      	negs	r3, r3
10005a90:	9908      	ldr	r1, [sp, #32]
10005a92:	429e      	cmp	r6, r3
10005a94:	da08      	bge.n	10005aa8 <_printf_float+0x290>
10005a96:	1c22      	adds	r2, r4, #0
10005a98:	2301      	movs	r3, #1
10005a9a:	321a      	adds	r2, #26
10005a9c:	9f09      	ldr	r7, [sp, #36]	; 0x24
10005a9e:	47b8      	blx	r7
10005aa0:	1c43      	adds	r3, r0, #1
10005aa2:	d093      	beq.n	100059cc <_printf_float+0x1b4>
10005aa4:	3601      	adds	r6, #1
10005aa6:	e7f0      	b.n	10005a8a <_printf_float+0x272>
10005aa8:	9a0a      	ldr	r2, [sp, #40]	; 0x28
10005aaa:	9b10      	ldr	r3, [sp, #64]	; 0x40
10005aac:	e0b1      	b.n	10005c12 <_printf_float+0x3fa>
10005aae:	9b10      	ldr	r3, [sp, #64]	; 0x40
10005ab0:	6da6      	ldr	r6, [r4, #88]	; 0x58
10005ab2:	429e      	cmp	r6, r3
10005ab4:	dd00      	ble.n	10005ab8 <_printf_float+0x2a0>
10005ab6:	1c1e      	adds	r6, r3, #0
10005ab8:	2e00      	cmp	r6, #0
10005aba:	dc01      	bgt.n	10005ac0 <_printf_float+0x2a8>
10005abc:	2300      	movs	r3, #0
10005abe:	e014      	b.n	10005aea <_printf_float+0x2d2>
10005ac0:	1c33      	adds	r3, r6, #0
10005ac2:	1c28      	adds	r0, r5, #0
10005ac4:	9908      	ldr	r1, [sp, #32]
10005ac6:	9a0a      	ldr	r2, [sp, #40]	; 0x28
10005ac8:	9f09      	ldr	r7, [sp, #36]	; 0x24
10005aca:	47b8      	blx	r7
10005acc:	1c43      	adds	r3, r0, #1
10005ace:	d1f5      	bne.n	10005abc <_printf_float+0x2a4>
10005ad0:	e77c      	b.n	100059cc <_printf_float+0x1b4>
10005ad2:	1c22      	adds	r2, r4, #0
10005ad4:	2301      	movs	r3, #1
10005ad6:	1c28      	adds	r0, r5, #0
10005ad8:	9908      	ldr	r1, [sp, #32]
10005ada:	321a      	adds	r2, #26
10005adc:	9f09      	ldr	r7, [sp, #36]	; 0x24
10005ade:	47b8      	blx	r7
10005ae0:	1c43      	adds	r3, r0, #1
10005ae2:	d100      	bne.n	10005ae6 <_printf_float+0x2ce>
10005ae4:	e772      	b.n	100059cc <_printf_float+0x1b4>
10005ae6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
10005ae8:	3301      	adds	r3, #1
10005aea:	930d      	str	r3, [sp, #52]	; 0x34
10005aec:	43f3      	mvns	r3, r6
10005aee:	6da2      	ldr	r2, [r4, #88]	; 0x58
10005af0:	17db      	asrs	r3, r3, #31
10005af2:	990d      	ldr	r1, [sp, #52]	; 0x34
10005af4:	4033      	ands	r3, r6
10005af6:	1ad3      	subs	r3, r2, r3
10005af8:	4299      	cmp	r1, r3
10005afa:	dbea      	blt.n	10005ad2 <_printf_float+0x2ba>
10005afc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
10005afe:	189e      	adds	r6, r3, r2
10005b00:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
10005b02:	9a10      	ldr	r2, [sp, #64]	; 0x40
10005b04:	4293      	cmp	r3, r2
10005b06:	db0e      	blt.n	10005b26 <_printf_float+0x30e>
10005b08:	6823      	ldr	r3, [r4, #0]
10005b0a:	07db      	lsls	r3, r3, #31
10005b0c:	d40b      	bmi.n	10005b26 <_printf_float+0x30e>
10005b0e:	9b10      	ldr	r3, [sp, #64]	; 0x40
10005b10:	9a0a      	ldr	r2, [sp, #40]	; 0x28
10005b12:	18d7      	adds	r7, r2, r3
10005b14:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
10005b16:	1bbf      	subs	r7, r7, r6
10005b18:	1a9b      	subs	r3, r3, r2
10005b1a:	429f      	cmp	r7, r3
10005b1c:	dd00      	ble.n	10005b20 <_printf_float+0x308>
10005b1e:	1c1f      	adds	r7, r3, #0
10005b20:	2f00      	cmp	r7, #0
10005b22:	dc09      	bgt.n	10005b38 <_printf_float+0x320>
10005b24:	e011      	b.n	10005b4a <_printf_float+0x332>
10005b26:	9b0c      	ldr	r3, [sp, #48]	; 0x30
10005b28:	1c28      	adds	r0, r5, #0
10005b2a:	9908      	ldr	r1, [sp, #32]
10005b2c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
10005b2e:	9f09      	ldr	r7, [sp, #36]	; 0x24
10005b30:	47b8      	blx	r7
10005b32:	1c43      	adds	r3, r0, #1
10005b34:	d1eb      	bne.n	10005b0e <_printf_float+0x2f6>
10005b36:	e749      	b.n	100059cc <_printf_float+0x1b4>
10005b38:	1c32      	adds	r2, r6, #0
10005b3a:	1c3b      	adds	r3, r7, #0
10005b3c:	1c28      	adds	r0, r5, #0
10005b3e:	9908      	ldr	r1, [sp, #32]
10005b40:	9e09      	ldr	r6, [sp, #36]	; 0x24
10005b42:	47b0      	blx	r6
10005b44:	1c43      	adds	r3, r0, #1
10005b46:	d100      	bne.n	10005b4a <_printf_float+0x332>
10005b48:	e740      	b.n	100059cc <_printf_float+0x1b4>
10005b4a:	2300      	movs	r3, #0
10005b4c:	e016      	b.n	10005b7c <_printf_float+0x364>
10005b4e:	46c0      	nop			; (mov r8, r8)
10005b50:	1000a368 	.word	0x1000a368
10005b54:	1000a36c 	.word	0x1000a36c
10005b58:	1000a370 	.word	0x1000a370
10005b5c:	1000a374 	.word	0x1000a374
10005b60:	1000a378 	.word	0x1000a378
10005b64:	1c22      	adds	r2, r4, #0
10005b66:	2301      	movs	r3, #1
10005b68:	1c28      	adds	r0, r5, #0
10005b6a:	9908      	ldr	r1, [sp, #32]
10005b6c:	321a      	adds	r2, #26
10005b6e:	9e09      	ldr	r6, [sp, #36]	; 0x24
10005b70:	47b0      	blx	r6
10005b72:	1c43      	adds	r3, r0, #1
10005b74:	d100      	bne.n	10005b78 <_printf_float+0x360>
10005b76:	e729      	b.n	100059cc <_printf_float+0x1b4>
10005b78:	9b0a      	ldr	r3, [sp, #40]	; 0x28
10005b7a:	3301      	adds	r3, #1
10005b7c:	930a      	str	r3, [sp, #40]	; 0x28
10005b7e:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
10005b80:	9b10      	ldr	r3, [sp, #64]	; 0x40
10005b82:	1a9a      	subs	r2, r3, r2
10005b84:	43fb      	mvns	r3, r7
10005b86:	17db      	asrs	r3, r3, #31
10005b88:	403b      	ands	r3, r7
10005b8a:	1ad3      	subs	r3, r2, r3
10005b8c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
10005b8e:	429a      	cmp	r2, r3
10005b90:	dbe8      	blt.n	10005b64 <_printf_float+0x34c>
10005b92:	e740      	b.n	10005a16 <_printf_float+0x1fe>
10005b94:	9b10      	ldr	r3, [sp, #64]	; 0x40
10005b96:	1c28      	adds	r0, r5, #0
10005b98:	9908      	ldr	r1, [sp, #32]
10005b9a:	2b01      	cmp	r3, #1
10005b9c:	dc02      	bgt.n	10005ba4 <_printf_float+0x38c>
10005b9e:	2301      	movs	r3, #1
10005ba0:	421a      	tst	r2, r3
10005ba2:	d03c      	beq.n	10005c1e <_printf_float+0x406>
10005ba4:	2301      	movs	r3, #1
10005ba6:	9a0a      	ldr	r2, [sp, #40]	; 0x28
10005ba8:	9f09      	ldr	r7, [sp, #36]	; 0x24
10005baa:	47b8      	blx	r7
10005bac:	1c43      	adds	r3, r0, #1
10005bae:	d100      	bne.n	10005bb2 <_printf_float+0x39a>
10005bb0:	e70c      	b.n	100059cc <_printf_float+0x1b4>
10005bb2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
10005bb4:	1c28      	adds	r0, r5, #0
10005bb6:	9908      	ldr	r1, [sp, #32]
10005bb8:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
10005bba:	9f09      	ldr	r7, [sp, #36]	; 0x24
10005bbc:	47b8      	blx	r7
10005bbe:	1c43      	adds	r3, r0, #1
10005bc0:	d100      	bne.n	10005bc4 <_printf_float+0x3ac>
10005bc2:	e703      	b.n	100059cc <_printf_float+0x1b4>
10005bc4:	6ca0      	ldr	r0, [r4, #72]	; 0x48
10005bc6:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
10005bc8:	2300      	movs	r3, #0
10005bca:	2200      	movs	r2, #0
10005bcc:	f002 fab6 	bl	1000813c <__aeabi_dcmpeq>
10005bd0:	2300      	movs	r3, #0
10005bd2:	2800      	cmp	r0, #0
10005bd4:	d112      	bne.n	10005bfc <_printf_float+0x3e4>
10005bd6:	9a0a      	ldr	r2, [sp, #40]	; 0x28
10005bd8:	9b10      	ldr	r3, [sp, #64]	; 0x40
10005bda:	3201      	adds	r2, #1
10005bdc:	3b01      	subs	r3, #1
10005bde:	1c28      	adds	r0, r5, #0
10005be0:	9908      	ldr	r1, [sp, #32]
10005be2:	e01d      	b.n	10005c20 <_printf_float+0x408>
10005be4:	1c22      	adds	r2, r4, #0
10005be6:	2301      	movs	r3, #1
10005be8:	1c28      	adds	r0, r5, #0
10005bea:	9908      	ldr	r1, [sp, #32]
10005bec:	321a      	adds	r2, #26
10005bee:	9f09      	ldr	r7, [sp, #36]	; 0x24
10005bf0:	47b8      	blx	r7
10005bf2:	1c43      	adds	r3, r0, #1
10005bf4:	d100      	bne.n	10005bf8 <_printf_float+0x3e0>
10005bf6:	e6e9      	b.n	100059cc <_printf_float+0x1b4>
10005bf8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
10005bfa:	3301      	adds	r3, #1
10005bfc:	930a      	str	r3, [sp, #40]	; 0x28
10005bfe:	9b10      	ldr	r3, [sp, #64]	; 0x40
10005c00:	9a0a      	ldr	r2, [sp, #40]	; 0x28
10005c02:	3b01      	subs	r3, #1
10005c04:	429a      	cmp	r2, r3
10005c06:	dbed      	blt.n	10005be4 <_printf_float+0x3cc>
10005c08:	1c22      	adds	r2, r4, #0
10005c0a:	1c28      	adds	r0, r5, #0
10005c0c:	1c33      	adds	r3, r6, #0
10005c0e:	9908      	ldr	r1, [sp, #32]
10005c10:	3250      	adds	r2, #80	; 0x50
10005c12:	9e09      	ldr	r6, [sp, #36]	; 0x24
10005c14:	47b0      	blx	r6
10005c16:	1c43      	adds	r3, r0, #1
10005c18:	d000      	beq.n	10005c1c <_printf_float+0x404>
10005c1a:	e6fc      	b.n	10005a16 <_printf_float+0x1fe>
10005c1c:	e6d6      	b.n	100059cc <_printf_float+0x1b4>
10005c1e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
10005c20:	9f09      	ldr	r7, [sp, #36]	; 0x24
10005c22:	47b8      	blx	r7
10005c24:	1c43      	adds	r3, r0, #1
10005c26:	d1ef      	bne.n	10005c08 <_printf_float+0x3f0>
10005c28:	e6d0      	b.n	100059cc <_printf_float+0x1b4>
10005c2a:	1c22      	adds	r2, r4, #0
10005c2c:	2301      	movs	r3, #1
10005c2e:	1c28      	adds	r0, r5, #0
10005c30:	9908      	ldr	r1, [sp, #32]
10005c32:	3219      	adds	r2, #25
10005c34:	9f09      	ldr	r7, [sp, #36]	; 0x24
10005c36:	47b8      	blx	r7
10005c38:	1c43      	adds	r3, r0, #1
10005c3a:	d100      	bne.n	10005c3e <_printf_float+0x426>
10005c3c:	e6c6      	b.n	100059cc <_printf_float+0x1b4>
10005c3e:	3601      	adds	r6, #1
10005c40:	68e3      	ldr	r3, [r4, #12]
10005c42:	9a11      	ldr	r2, [sp, #68]	; 0x44
10005c44:	1a9b      	subs	r3, r3, r2
10005c46:	429e      	cmp	r6, r3
10005c48:	dbef      	blt.n	10005c2a <_printf_float+0x412>
10005c4a:	9b11      	ldr	r3, [sp, #68]	; 0x44
10005c4c:	68e0      	ldr	r0, [r4, #12]
10005c4e:	4298      	cmp	r0, r3
10005c50:	da17      	bge.n	10005c82 <_printf_float+0x46a>
10005c52:	1c18      	adds	r0, r3, #0
10005c54:	e015      	b.n	10005c82 <_printf_float+0x46a>
10005c56:	2600      	movs	r6, #0
10005c58:	e7f2      	b.n	10005c40 <_printf_float+0x428>
10005c5a:	4331      	orrs	r1, r6
10005c5c:	6021      	str	r1, [r4, #0]
10005c5e:	9101      	str	r1, [sp, #4]
10005c60:	2123      	movs	r1, #35	; 0x23
10005c62:	9000      	str	r0, [sp, #0]
10005c64:	a806      	add	r0, sp, #24
10005c66:	1809      	adds	r1, r1, r0
10005c68:	9102      	str	r1, [sp, #8]
10005c6a:	a90f      	add	r1, sp, #60	; 0x3c
10005c6c:	9103      	str	r1, [sp, #12]
10005c6e:	a910      	add	r1, sp, #64	; 0x40
10005c70:	9105      	str	r1, [sp, #20]
10005c72:	2100      	movs	r1, #0
10005c74:	9704      	str	r7, [sp, #16]
10005c76:	9106      	str	r1, [sp, #24]
10005c78:	1c28      	adds	r0, r5, #0
10005c7a:	f7ff fd37 	bl	100056ec <__cvt>
10005c7e:	900a      	str	r0, [sp, #40]	; 0x28
10005c80:	e646      	b.n	10005910 <_printf_float+0xf8>
10005c82:	b013      	add	sp, #76	; 0x4c
10005c84:	bdf0      	pop	{r4, r5, r6, r7, pc}
10005c86:	46c0      	nop			; (mov r8, r8)

10005c88 <_printf_common>:
10005c88:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
10005c8a:	1c17      	adds	r7, r2, #0
10005c8c:	9301      	str	r3, [sp, #4]
10005c8e:	690a      	ldr	r2, [r1, #16]
10005c90:	688b      	ldr	r3, [r1, #8]
10005c92:	9000      	str	r0, [sp, #0]
10005c94:	1c0c      	adds	r4, r1, #0
10005c96:	4293      	cmp	r3, r2
10005c98:	da00      	bge.n	10005c9c <_printf_common+0x14>
10005c9a:	1c13      	adds	r3, r2, #0
10005c9c:	1c22      	adds	r2, r4, #0
10005c9e:	603b      	str	r3, [r7, #0]
10005ca0:	3243      	adds	r2, #67	; 0x43
10005ca2:	7812      	ldrb	r2, [r2, #0]
10005ca4:	2a00      	cmp	r2, #0
10005ca6:	d001      	beq.n	10005cac <_printf_common+0x24>
10005ca8:	3301      	adds	r3, #1
10005caa:	603b      	str	r3, [r7, #0]
10005cac:	6823      	ldr	r3, [r4, #0]
10005cae:	069b      	lsls	r3, r3, #26
10005cb0:	d502      	bpl.n	10005cb8 <_printf_common+0x30>
10005cb2:	683b      	ldr	r3, [r7, #0]
10005cb4:	3302      	adds	r3, #2
10005cb6:	603b      	str	r3, [r7, #0]
10005cb8:	2506      	movs	r5, #6
10005cba:	6823      	ldr	r3, [r4, #0]
10005cbc:	401d      	ands	r5, r3
10005cbe:	d01e      	beq.n	10005cfe <_printf_common+0x76>
10005cc0:	1c23      	adds	r3, r4, #0
10005cc2:	3343      	adds	r3, #67	; 0x43
10005cc4:	781b      	ldrb	r3, [r3, #0]
10005cc6:	1e5a      	subs	r2, r3, #1
10005cc8:	4193      	sbcs	r3, r2
10005cca:	6822      	ldr	r2, [r4, #0]
10005ccc:	0692      	lsls	r2, r2, #26
10005cce:	d51c      	bpl.n	10005d0a <_printf_common+0x82>
10005cd0:	2030      	movs	r0, #48	; 0x30
10005cd2:	18e1      	adds	r1, r4, r3
10005cd4:	3140      	adds	r1, #64	; 0x40
10005cd6:	70c8      	strb	r0, [r1, #3]
10005cd8:	1c21      	adds	r1, r4, #0
10005cda:	1c5a      	adds	r2, r3, #1
10005cdc:	3145      	adds	r1, #69	; 0x45
10005cde:	7809      	ldrb	r1, [r1, #0]
10005ce0:	18a2      	adds	r2, r4, r2
10005ce2:	3240      	adds	r2, #64	; 0x40
10005ce4:	3302      	adds	r3, #2
10005ce6:	70d1      	strb	r1, [r2, #3]
10005ce8:	e00f      	b.n	10005d0a <_printf_common+0x82>
10005cea:	1c22      	adds	r2, r4, #0
10005cec:	2301      	movs	r3, #1
10005cee:	9800      	ldr	r0, [sp, #0]
10005cf0:	9901      	ldr	r1, [sp, #4]
10005cf2:	3219      	adds	r2, #25
10005cf4:	9e08      	ldr	r6, [sp, #32]
10005cf6:	47b0      	blx	r6
10005cf8:	1c43      	adds	r3, r0, #1
10005cfa:	d00e      	beq.n	10005d1a <_printf_common+0x92>
10005cfc:	3501      	adds	r5, #1
10005cfe:	68e3      	ldr	r3, [r4, #12]
10005d00:	683a      	ldr	r2, [r7, #0]
10005d02:	1a9b      	subs	r3, r3, r2
10005d04:	429d      	cmp	r5, r3
10005d06:	dbf0      	blt.n	10005cea <_printf_common+0x62>
10005d08:	e7da      	b.n	10005cc0 <_printf_common+0x38>
10005d0a:	1c22      	adds	r2, r4, #0
10005d0c:	9800      	ldr	r0, [sp, #0]
10005d0e:	9901      	ldr	r1, [sp, #4]
10005d10:	3243      	adds	r2, #67	; 0x43
10005d12:	9d08      	ldr	r5, [sp, #32]
10005d14:	47a8      	blx	r5
10005d16:	1c43      	adds	r3, r0, #1
10005d18:	d102      	bne.n	10005d20 <_printf_common+0x98>
10005d1a:	2001      	movs	r0, #1
10005d1c:	4240      	negs	r0, r0
10005d1e:	e020      	b.n	10005d62 <_printf_common+0xda>
10005d20:	2306      	movs	r3, #6
10005d22:	6820      	ldr	r0, [r4, #0]
10005d24:	68e1      	ldr	r1, [r4, #12]
10005d26:	683a      	ldr	r2, [r7, #0]
10005d28:	4003      	ands	r3, r0
10005d2a:	2500      	movs	r5, #0
10005d2c:	2b04      	cmp	r3, #4
10005d2e:	d103      	bne.n	10005d38 <_printf_common+0xb0>
10005d30:	1a8d      	subs	r5, r1, r2
10005d32:	43eb      	mvns	r3, r5
10005d34:	17db      	asrs	r3, r3, #31
10005d36:	401d      	ands	r5, r3
10005d38:	68a3      	ldr	r3, [r4, #8]
10005d3a:	6922      	ldr	r2, [r4, #16]
10005d3c:	4293      	cmp	r3, r2
10005d3e:	dd01      	ble.n	10005d44 <_printf_common+0xbc>
10005d40:	1a9b      	subs	r3, r3, r2
10005d42:	18ed      	adds	r5, r5, r3
10005d44:	2700      	movs	r7, #0
10005d46:	42af      	cmp	r7, r5
10005d48:	da0a      	bge.n	10005d60 <_printf_common+0xd8>
10005d4a:	1c22      	adds	r2, r4, #0
10005d4c:	2301      	movs	r3, #1
10005d4e:	9800      	ldr	r0, [sp, #0]
10005d50:	9901      	ldr	r1, [sp, #4]
10005d52:	321a      	adds	r2, #26
10005d54:	9e08      	ldr	r6, [sp, #32]
10005d56:	47b0      	blx	r6
10005d58:	1c43      	adds	r3, r0, #1
10005d5a:	d0de      	beq.n	10005d1a <_printf_common+0x92>
10005d5c:	3701      	adds	r7, #1
10005d5e:	e7f2      	b.n	10005d46 <_printf_common+0xbe>
10005d60:	2000      	movs	r0, #0
10005d62:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

10005d64 <_printf_i>:
10005d64:	b5f0      	push	{r4, r5, r6, r7, lr}
10005d66:	b08b      	sub	sp, #44	; 0x2c
10005d68:	9206      	str	r2, [sp, #24]
10005d6a:	1c0a      	adds	r2, r1, #0
10005d6c:	3243      	adds	r2, #67	; 0x43
10005d6e:	9307      	str	r3, [sp, #28]
10005d70:	9005      	str	r0, [sp, #20]
10005d72:	9204      	str	r2, [sp, #16]
10005d74:	7e0a      	ldrb	r2, [r1, #24]
10005d76:	1c0c      	adds	r4, r1, #0
10005d78:	9b10      	ldr	r3, [sp, #64]	; 0x40
10005d7a:	2a6e      	cmp	r2, #110	; 0x6e
10005d7c:	d100      	bne.n	10005d80 <_printf_i+0x1c>
10005d7e:	e0a8      	b.n	10005ed2 <_printf_i+0x16e>
10005d80:	d811      	bhi.n	10005da6 <_printf_i+0x42>
10005d82:	2a63      	cmp	r2, #99	; 0x63
10005d84:	d022      	beq.n	10005dcc <_printf_i+0x68>
10005d86:	d809      	bhi.n	10005d9c <_printf_i+0x38>
10005d88:	2a00      	cmp	r2, #0
10005d8a:	d100      	bne.n	10005d8e <_printf_i+0x2a>
10005d8c:	e0b2      	b.n	10005ef4 <_printf_i+0x190>
10005d8e:	2a58      	cmp	r2, #88	; 0x58
10005d90:	d000      	beq.n	10005d94 <_printf_i+0x30>
10005d92:	e0c2      	b.n	10005f1a <_printf_i+0x1b6>
10005d94:	3145      	adds	r1, #69	; 0x45
10005d96:	700a      	strb	r2, [r1, #0]
10005d98:	4a7c      	ldr	r2, [pc, #496]	; (10005f8c <_printf_i+0x228>)
10005d9a:	e04f      	b.n	10005e3c <_printf_i+0xd8>
10005d9c:	2a64      	cmp	r2, #100	; 0x64
10005d9e:	d01d      	beq.n	10005ddc <_printf_i+0x78>
10005da0:	2a69      	cmp	r2, #105	; 0x69
10005da2:	d01b      	beq.n	10005ddc <_printf_i+0x78>
10005da4:	e0b9      	b.n	10005f1a <_printf_i+0x1b6>
10005da6:	2a73      	cmp	r2, #115	; 0x73
10005da8:	d100      	bne.n	10005dac <_printf_i+0x48>
10005daa:	e0a7      	b.n	10005efc <_printf_i+0x198>
10005dac:	d809      	bhi.n	10005dc2 <_printf_i+0x5e>
10005dae:	2a6f      	cmp	r2, #111	; 0x6f
10005db0:	d029      	beq.n	10005e06 <_printf_i+0xa2>
10005db2:	2a70      	cmp	r2, #112	; 0x70
10005db4:	d000      	beq.n	10005db8 <_printf_i+0x54>
10005db6:	e0b0      	b.n	10005f1a <_printf_i+0x1b6>
10005db8:	2220      	movs	r2, #32
10005dba:	6809      	ldr	r1, [r1, #0]
10005dbc:	430a      	orrs	r2, r1
10005dbe:	6022      	str	r2, [r4, #0]
10005dc0:	e037      	b.n	10005e32 <_printf_i+0xce>
10005dc2:	2a75      	cmp	r2, #117	; 0x75
10005dc4:	d01f      	beq.n	10005e06 <_printf_i+0xa2>
10005dc6:	2a78      	cmp	r2, #120	; 0x78
10005dc8:	d033      	beq.n	10005e32 <_printf_i+0xce>
10005dca:	e0a6      	b.n	10005f1a <_printf_i+0x1b6>
10005dcc:	1c0d      	adds	r5, r1, #0
10005dce:	681a      	ldr	r2, [r3, #0]
10005dd0:	3542      	adds	r5, #66	; 0x42
10005dd2:	1d11      	adds	r1, r2, #4
10005dd4:	6019      	str	r1, [r3, #0]
10005dd6:	6813      	ldr	r3, [r2, #0]
10005dd8:	702b      	strb	r3, [r5, #0]
10005dda:	e0a1      	b.n	10005f20 <_printf_i+0x1bc>
10005ddc:	6821      	ldr	r1, [r4, #0]
10005dde:	681a      	ldr	r2, [r3, #0]
10005de0:	0608      	lsls	r0, r1, #24
10005de2:	d503      	bpl.n	10005dec <_printf_i+0x88>
10005de4:	1d11      	adds	r1, r2, #4
10005de6:	6019      	str	r1, [r3, #0]
10005de8:	6816      	ldr	r6, [r2, #0]
10005dea:	e005      	b.n	10005df8 <_printf_i+0x94>
10005dec:	0649      	lsls	r1, r1, #25
10005dee:	d5f9      	bpl.n	10005de4 <_printf_i+0x80>
10005df0:	1d11      	adds	r1, r2, #4
10005df2:	6019      	str	r1, [r3, #0]
10005df4:	2300      	movs	r3, #0
10005df6:	5ed6      	ldrsh	r6, [r2, r3]
10005df8:	2e00      	cmp	r6, #0
10005dfa:	da3b      	bge.n	10005e74 <_printf_i+0x110>
10005dfc:	232d      	movs	r3, #45	; 0x2d
10005dfe:	9a04      	ldr	r2, [sp, #16]
10005e00:	4276      	negs	r6, r6
10005e02:	7013      	strb	r3, [r2, #0]
10005e04:	e036      	b.n	10005e74 <_printf_i+0x110>
10005e06:	6821      	ldr	r1, [r4, #0]
10005e08:	681a      	ldr	r2, [r3, #0]
10005e0a:	0608      	lsls	r0, r1, #24
10005e0c:	d503      	bpl.n	10005e16 <_printf_i+0xb2>
10005e0e:	1d11      	adds	r1, r2, #4
10005e10:	6019      	str	r1, [r3, #0]
10005e12:	6816      	ldr	r6, [r2, #0]
10005e14:	e005      	b.n	10005e22 <_printf_i+0xbe>
10005e16:	0649      	lsls	r1, r1, #25
10005e18:	d5f9      	bpl.n	10005e0e <_printf_i+0xaa>
10005e1a:	1d11      	adds	r1, r2, #4
10005e1c:	6019      	str	r1, [r3, #0]
10005e1e:	6816      	ldr	r6, [r2, #0]
10005e20:	b2b6      	uxth	r6, r6
10005e22:	4b5a      	ldr	r3, [pc, #360]	; (10005f8c <_printf_i+0x228>)
10005e24:	7e22      	ldrb	r2, [r4, #24]
10005e26:	9303      	str	r3, [sp, #12]
10005e28:	270a      	movs	r7, #10
10005e2a:	2a6f      	cmp	r2, #111	; 0x6f
10005e2c:	d11d      	bne.n	10005e6a <_printf_i+0x106>
10005e2e:	2708      	movs	r7, #8
10005e30:	e01b      	b.n	10005e6a <_printf_i+0x106>
10005e32:	1c22      	adds	r2, r4, #0
10005e34:	2178      	movs	r1, #120	; 0x78
10005e36:	3245      	adds	r2, #69	; 0x45
10005e38:	7011      	strb	r1, [r2, #0]
10005e3a:	4a55      	ldr	r2, [pc, #340]	; (10005f90 <_printf_i+0x22c>)
10005e3c:	6819      	ldr	r1, [r3, #0]
10005e3e:	9203      	str	r2, [sp, #12]
10005e40:	1d08      	adds	r0, r1, #4
10005e42:	6822      	ldr	r2, [r4, #0]
10005e44:	6018      	str	r0, [r3, #0]
10005e46:	680e      	ldr	r6, [r1, #0]
10005e48:	0610      	lsls	r0, r2, #24
10005e4a:	d402      	bmi.n	10005e52 <_printf_i+0xee>
10005e4c:	0650      	lsls	r0, r2, #25
10005e4e:	d500      	bpl.n	10005e52 <_printf_i+0xee>
10005e50:	b2b6      	uxth	r6, r6
10005e52:	07d3      	lsls	r3, r2, #31
10005e54:	d502      	bpl.n	10005e5c <_printf_i+0xf8>
10005e56:	2320      	movs	r3, #32
10005e58:	431a      	orrs	r2, r3
10005e5a:	6022      	str	r2, [r4, #0]
10005e5c:	2710      	movs	r7, #16
10005e5e:	2e00      	cmp	r6, #0
10005e60:	d103      	bne.n	10005e6a <_printf_i+0x106>
10005e62:	2320      	movs	r3, #32
10005e64:	6822      	ldr	r2, [r4, #0]
10005e66:	439a      	bics	r2, r3
10005e68:	6022      	str	r2, [r4, #0]
10005e6a:	1c23      	adds	r3, r4, #0
10005e6c:	2200      	movs	r2, #0
10005e6e:	3343      	adds	r3, #67	; 0x43
10005e70:	701a      	strb	r2, [r3, #0]
10005e72:	e002      	b.n	10005e7a <_printf_i+0x116>
10005e74:	270a      	movs	r7, #10
10005e76:	4b45      	ldr	r3, [pc, #276]	; (10005f8c <_printf_i+0x228>)
10005e78:	9303      	str	r3, [sp, #12]
10005e7a:	6863      	ldr	r3, [r4, #4]
10005e7c:	60a3      	str	r3, [r4, #8]
10005e7e:	2b00      	cmp	r3, #0
10005e80:	db03      	blt.n	10005e8a <_printf_i+0x126>
10005e82:	2204      	movs	r2, #4
10005e84:	6821      	ldr	r1, [r4, #0]
10005e86:	4391      	bics	r1, r2
10005e88:	6021      	str	r1, [r4, #0]
10005e8a:	2e00      	cmp	r6, #0
10005e8c:	d102      	bne.n	10005e94 <_printf_i+0x130>
10005e8e:	9d04      	ldr	r5, [sp, #16]
10005e90:	2b00      	cmp	r3, #0
10005e92:	d00e      	beq.n	10005eb2 <_printf_i+0x14e>
10005e94:	9d04      	ldr	r5, [sp, #16]
10005e96:	1c30      	adds	r0, r6, #0
10005e98:	1c39      	adds	r1, r7, #0
10005e9a:	f7ff fa43 	bl	10005324 <__aeabi_uidivmod>
10005e9e:	9b03      	ldr	r3, [sp, #12]
10005ea0:	3d01      	subs	r5, #1
10005ea2:	5c5b      	ldrb	r3, [r3, r1]
10005ea4:	1c30      	adds	r0, r6, #0
10005ea6:	702b      	strb	r3, [r5, #0]
10005ea8:	1c39      	adds	r1, r7, #0
10005eaa:	f7ff f9b5 	bl	10005218 <__aeabi_uidiv>
10005eae:	1e06      	subs	r6, r0, #0
10005eb0:	d1f1      	bne.n	10005e96 <_printf_i+0x132>
10005eb2:	2f08      	cmp	r7, #8
10005eb4:	d109      	bne.n	10005eca <_printf_i+0x166>
10005eb6:	6823      	ldr	r3, [r4, #0]
10005eb8:	07db      	lsls	r3, r3, #31
10005eba:	d506      	bpl.n	10005eca <_printf_i+0x166>
10005ebc:	6863      	ldr	r3, [r4, #4]
10005ebe:	6922      	ldr	r2, [r4, #16]
10005ec0:	4293      	cmp	r3, r2
10005ec2:	dc02      	bgt.n	10005eca <_printf_i+0x166>
10005ec4:	2330      	movs	r3, #48	; 0x30
10005ec6:	3d01      	subs	r5, #1
10005ec8:	702b      	strb	r3, [r5, #0]
10005eca:	9b04      	ldr	r3, [sp, #16]
10005ecc:	1b5b      	subs	r3, r3, r5
10005ece:	6123      	str	r3, [r4, #16]
10005ed0:	e02b      	b.n	10005f2a <_printf_i+0x1c6>
10005ed2:	6809      	ldr	r1, [r1, #0]
10005ed4:	681a      	ldr	r2, [r3, #0]
10005ed6:	0608      	lsls	r0, r1, #24
10005ed8:	d407      	bmi.n	10005eea <_printf_i+0x186>
10005eda:	0649      	lsls	r1, r1, #25
10005edc:	d505      	bpl.n	10005eea <_printf_i+0x186>
10005ede:	1d11      	adds	r1, r2, #4
10005ee0:	6019      	str	r1, [r3, #0]
10005ee2:	6813      	ldr	r3, [r2, #0]
10005ee4:	8aa2      	ldrh	r2, [r4, #20]
10005ee6:	801a      	strh	r2, [r3, #0]
10005ee8:	e004      	b.n	10005ef4 <_printf_i+0x190>
10005eea:	1d11      	adds	r1, r2, #4
10005eec:	6019      	str	r1, [r3, #0]
10005eee:	6813      	ldr	r3, [r2, #0]
10005ef0:	6962      	ldr	r2, [r4, #20]
10005ef2:	601a      	str	r2, [r3, #0]
10005ef4:	2300      	movs	r3, #0
10005ef6:	9d04      	ldr	r5, [sp, #16]
10005ef8:	6123      	str	r3, [r4, #16]
10005efa:	e016      	b.n	10005f2a <_printf_i+0x1c6>
10005efc:	681a      	ldr	r2, [r3, #0]
10005efe:	1d11      	adds	r1, r2, #4
10005f00:	6019      	str	r1, [r3, #0]
10005f02:	6815      	ldr	r5, [r2, #0]
10005f04:	2100      	movs	r1, #0
10005f06:	1c28      	adds	r0, r5, #0
10005f08:	6862      	ldr	r2, [r4, #4]
10005f0a:	f001 fa67 	bl	100073dc <memchr>
10005f0e:	2800      	cmp	r0, #0
10005f10:	d001      	beq.n	10005f16 <_printf_i+0x1b2>
10005f12:	1b40      	subs	r0, r0, r5
10005f14:	6060      	str	r0, [r4, #4]
10005f16:	6863      	ldr	r3, [r4, #4]
10005f18:	e003      	b.n	10005f22 <_printf_i+0x1be>
10005f1a:	1c25      	adds	r5, r4, #0
10005f1c:	3542      	adds	r5, #66	; 0x42
10005f1e:	702a      	strb	r2, [r5, #0]
10005f20:	2301      	movs	r3, #1
10005f22:	6123      	str	r3, [r4, #16]
10005f24:	2300      	movs	r3, #0
10005f26:	9a04      	ldr	r2, [sp, #16]
10005f28:	7013      	strb	r3, [r2, #0]
10005f2a:	9b07      	ldr	r3, [sp, #28]
10005f2c:	9805      	ldr	r0, [sp, #20]
10005f2e:	9300      	str	r3, [sp, #0]
10005f30:	1c21      	adds	r1, r4, #0
10005f32:	9b06      	ldr	r3, [sp, #24]
10005f34:	aa09      	add	r2, sp, #36	; 0x24
10005f36:	f7ff fea7 	bl	10005c88 <_printf_common>
10005f3a:	1c43      	adds	r3, r0, #1
10005f3c:	d102      	bne.n	10005f44 <_printf_i+0x1e0>
10005f3e:	2001      	movs	r0, #1
10005f40:	4240      	negs	r0, r0
10005f42:	e021      	b.n	10005f88 <_printf_i+0x224>
10005f44:	1c2a      	adds	r2, r5, #0
10005f46:	6923      	ldr	r3, [r4, #16]
10005f48:	9805      	ldr	r0, [sp, #20]
10005f4a:	9906      	ldr	r1, [sp, #24]
10005f4c:	9d07      	ldr	r5, [sp, #28]
10005f4e:	47a8      	blx	r5
10005f50:	1c43      	adds	r3, r0, #1
10005f52:	d0f4      	beq.n	10005f3e <_printf_i+0x1da>
10005f54:	6823      	ldr	r3, [r4, #0]
10005f56:	079b      	lsls	r3, r3, #30
10005f58:	d405      	bmi.n	10005f66 <_printf_i+0x202>
10005f5a:	9b09      	ldr	r3, [sp, #36]	; 0x24
10005f5c:	68e0      	ldr	r0, [r4, #12]
10005f5e:	4298      	cmp	r0, r3
10005f60:	da12      	bge.n	10005f88 <_printf_i+0x224>
10005f62:	1c18      	adds	r0, r3, #0
10005f64:	e010      	b.n	10005f88 <_printf_i+0x224>
10005f66:	2500      	movs	r5, #0
10005f68:	68e3      	ldr	r3, [r4, #12]
10005f6a:	9a09      	ldr	r2, [sp, #36]	; 0x24
10005f6c:	1a9b      	subs	r3, r3, r2
10005f6e:	429d      	cmp	r5, r3
10005f70:	daf3      	bge.n	10005f5a <_printf_i+0x1f6>
10005f72:	1c22      	adds	r2, r4, #0
10005f74:	2301      	movs	r3, #1
10005f76:	9805      	ldr	r0, [sp, #20]
10005f78:	9906      	ldr	r1, [sp, #24]
10005f7a:	3219      	adds	r2, #25
10005f7c:	9e07      	ldr	r6, [sp, #28]
10005f7e:	47b0      	blx	r6
10005f80:	1c43      	adds	r3, r0, #1
10005f82:	d0dc      	beq.n	10005f3e <_printf_i+0x1da>
10005f84:	3501      	adds	r5, #1
10005f86:	e7ef      	b.n	10005f68 <_printf_i+0x204>
10005f88:	b00b      	add	sp, #44	; 0x2c
10005f8a:	bdf0      	pop	{r4, r5, r6, r7, pc}
10005f8c:	1000a37a 	.word	0x1000a37a
10005f90:	1000a38b 	.word	0x1000a38b

10005f94 <iprintf>:
10005f94:	b40f      	push	{r0, r1, r2, r3}
10005f96:	4b0b      	ldr	r3, [pc, #44]	; (10005fc4 <iprintf+0x30>)
10005f98:	b513      	push	{r0, r1, r4, lr}
10005f9a:	681c      	ldr	r4, [r3, #0]
10005f9c:	2c00      	cmp	r4, #0
10005f9e:	d005      	beq.n	10005fac <iprintf+0x18>
10005fa0:	69a3      	ldr	r3, [r4, #24]
10005fa2:	2b00      	cmp	r3, #0
10005fa4:	d102      	bne.n	10005fac <iprintf+0x18>
10005fa6:	1c20      	adds	r0, r4, #0
10005fa8:	f001 f92a 	bl	10007200 <__sinit>
10005fac:	ab05      	add	r3, sp, #20
10005fae:	1c20      	adds	r0, r4, #0
10005fb0:	68a1      	ldr	r1, [r4, #8]
10005fb2:	9a04      	ldr	r2, [sp, #16]
10005fb4:	9301      	str	r3, [sp, #4]
10005fb6:	f001 fe93 	bl	10007ce0 <_vfiprintf_r>
10005fba:	bc16      	pop	{r1, r2, r4}
10005fbc:	bc08      	pop	{r3}
10005fbe:	b004      	add	sp, #16
10005fc0:	4718      	bx	r3
10005fc2:	46c0      	nop			; (mov r8, r8)
10005fc4:	20000664 	.word	0x20000664

10005fc8 <_puts_r>:
10005fc8:	b570      	push	{r4, r5, r6, lr}
10005fca:	1c05      	adds	r5, r0, #0
10005fcc:	1c0e      	adds	r6, r1, #0
10005fce:	2800      	cmp	r0, #0
10005fd0:	d004      	beq.n	10005fdc <_puts_r+0x14>
10005fd2:	6983      	ldr	r3, [r0, #24]
10005fd4:	2b00      	cmp	r3, #0
10005fd6:	d101      	bne.n	10005fdc <_puts_r+0x14>
10005fd8:	f001 f912 	bl	10007200 <__sinit>
10005fdc:	68ac      	ldr	r4, [r5, #8]
10005fde:	89a3      	ldrh	r3, [r4, #12]
10005fe0:	071b      	lsls	r3, r3, #28
10005fe2:	d502      	bpl.n	10005fea <_puts_r+0x22>
10005fe4:	6923      	ldr	r3, [r4, #16]
10005fe6:	2b00      	cmp	r3, #0
10005fe8:	d119      	bne.n	1000601e <_puts_r+0x56>
10005fea:	1c28      	adds	r0, r5, #0
10005fec:	1c21      	adds	r1, r4, #0
10005fee:	f000 f913 	bl	10006218 <__swsetup_r>
10005ff2:	2800      	cmp	r0, #0
10005ff4:	d013      	beq.n	1000601e <_puts_r+0x56>
10005ff6:	2001      	movs	r0, #1
10005ff8:	4240      	negs	r0, r0
10005ffa:	e045      	b.n	10006088 <_puts_r+0xc0>
10005ffc:	7831      	ldrb	r1, [r6, #0]
10005ffe:	2b00      	cmp	r3, #0
10006000:	da1b      	bge.n	1000603a <_puts_r+0x72>
10006002:	69a2      	ldr	r2, [r4, #24]
10006004:	4293      	cmp	r3, r2
10006006:	da11      	bge.n	1000602c <_puts_r+0x64>
10006008:	1c22      	adds	r2, r4, #0
1000600a:	1c28      	adds	r0, r5, #0
1000600c:	f000 f8ac 	bl	10006168 <__swbuf_r>
10006010:	3001      	adds	r0, #1
10006012:	4242      	negs	r2, r0
10006014:	4142      	adcs	r2, r0
10006016:	b2d0      	uxtb	r0, r2
10006018:	2800      	cmp	r0, #0
1000601a:	d1ec      	bne.n	10005ff6 <_puts_r+0x2e>
1000601c:	3601      	adds	r6, #1
1000601e:	68a3      	ldr	r3, [r4, #8]
10006020:	7832      	ldrb	r2, [r6, #0]
10006022:	3b01      	subs	r3, #1
10006024:	60a3      	str	r3, [r4, #8]
10006026:	2a00      	cmp	r2, #0
10006028:	d1e8      	bne.n	10005ffc <_puts_r+0x34>
1000602a:	e00c      	b.n	10006046 <_puts_r+0x7e>
1000602c:	6823      	ldr	r3, [r4, #0]
1000602e:	7019      	strb	r1, [r3, #0]
10006030:	6823      	ldr	r3, [r4, #0]
10006032:	7819      	ldrb	r1, [r3, #0]
10006034:	290a      	cmp	r1, #10
10006036:	d103      	bne.n	10006040 <_puts_r+0x78>
10006038:	e7e6      	b.n	10006008 <_puts_r+0x40>
1000603a:	6823      	ldr	r3, [r4, #0]
1000603c:	7019      	strb	r1, [r3, #0]
1000603e:	6823      	ldr	r3, [r4, #0]
10006040:	3301      	adds	r3, #1
10006042:	6023      	str	r3, [r4, #0]
10006044:	e7ea      	b.n	1000601c <_puts_r+0x54>
10006046:	2b00      	cmp	r3, #0
10006048:	da17      	bge.n	1000607a <_puts_r+0xb2>
1000604a:	69a2      	ldr	r2, [r4, #24]
1000604c:	4293      	cmp	r3, r2
1000604e:	db08      	blt.n	10006062 <_puts_r+0x9a>
10006050:	230a      	movs	r3, #10
10006052:	6822      	ldr	r2, [r4, #0]
10006054:	7013      	strb	r3, [r2, #0]
10006056:	6823      	ldr	r3, [r4, #0]
10006058:	7819      	ldrb	r1, [r3, #0]
1000605a:	290a      	cmp	r1, #10
1000605c:	d111      	bne.n	10006082 <_puts_r+0xba>
1000605e:	1c28      	adds	r0, r5, #0
10006060:	e001      	b.n	10006066 <_puts_r+0x9e>
10006062:	1c28      	adds	r0, r5, #0
10006064:	210a      	movs	r1, #10
10006066:	1c22      	adds	r2, r4, #0
10006068:	f000 f87e 	bl	10006168 <__swbuf_r>
1000606c:	3001      	adds	r0, #1
1000606e:	4242      	negs	r2, r0
10006070:	4142      	adcs	r2, r0
10006072:	b2d0      	uxtb	r0, r2
10006074:	2800      	cmp	r0, #0
10006076:	d006      	beq.n	10006086 <_puts_r+0xbe>
10006078:	e7bd      	b.n	10005ff6 <_puts_r+0x2e>
1000607a:	230a      	movs	r3, #10
1000607c:	6822      	ldr	r2, [r4, #0]
1000607e:	7013      	strb	r3, [r2, #0]
10006080:	6823      	ldr	r3, [r4, #0]
10006082:	3301      	adds	r3, #1
10006084:	6023      	str	r3, [r4, #0]
10006086:	200a      	movs	r0, #10
10006088:	bd70      	pop	{r4, r5, r6, pc}
	...

1000608c <puts>:
1000608c:	b508      	push	{r3, lr}
1000608e:	4b03      	ldr	r3, [pc, #12]	; (1000609c <puts+0x10>)
10006090:	1c01      	adds	r1, r0, #0
10006092:	6818      	ldr	r0, [r3, #0]
10006094:	f7ff ff98 	bl	10005fc8 <_puts_r>
10006098:	bd08      	pop	{r3, pc}
1000609a:	46c0      	nop			; (mov r8, r8)
1000609c:	20000664 	.word	0x20000664

100060a0 <__fpclassifyd>:
100060a0:	b530      	push	{r4, r5, lr}
100060a2:	1c0c      	adds	r4, r1, #0
100060a4:	2302      	movs	r3, #2
100060a6:	4304      	orrs	r4, r0
100060a8:	d017      	beq.n	100060da <__fpclassifyd+0x3a>
100060aa:	2480      	movs	r4, #128	; 0x80
100060ac:	0624      	lsls	r4, r4, #24
100060ae:	42a1      	cmp	r1, r4
100060b0:	d101      	bne.n	100060b6 <__fpclassifyd+0x16>
100060b2:	2800      	cmp	r0, #0
100060b4:	d011      	beq.n	100060da <__fpclassifyd+0x3a>
100060b6:	4b0a      	ldr	r3, [pc, #40]	; (100060e0 <__fpclassifyd+0x40>)
100060b8:	0049      	lsls	r1, r1, #1
100060ba:	0849      	lsrs	r1, r1, #1
100060bc:	4a09      	ldr	r2, [pc, #36]	; (100060e4 <__fpclassifyd+0x44>)
100060be:	18cc      	adds	r4, r1, r3
100060c0:	2304      	movs	r3, #4
100060c2:	4294      	cmp	r4, r2
100060c4:	d909      	bls.n	100060da <__fpclassifyd+0x3a>
100060c6:	4a08      	ldr	r2, [pc, #32]	; (100060e8 <__fpclassifyd+0x48>)
100060c8:	3b01      	subs	r3, #1
100060ca:	4291      	cmp	r1, r2
100060cc:	d905      	bls.n	100060da <__fpclassifyd+0x3a>
100060ce:	4a07      	ldr	r2, [pc, #28]	; (100060ec <__fpclassifyd+0x4c>)
100060d0:	2300      	movs	r3, #0
100060d2:	4291      	cmp	r1, r2
100060d4:	d101      	bne.n	100060da <__fpclassifyd+0x3a>
100060d6:	4243      	negs	r3, r0
100060d8:	4143      	adcs	r3, r0
100060da:	1c18      	adds	r0, r3, #0
100060dc:	bd30      	pop	{r4, r5, pc}
100060de:	46c0      	nop			; (mov r8, r8)
100060e0:	fff00000 	.word	0xfff00000
100060e4:	7fdfffff 	.word	0x7fdfffff
100060e8:	000fffff 	.word	0x000fffff
100060ec:	7ff00000 	.word	0x7ff00000

100060f0 <_sbrk_r>:
100060f0:	b538      	push	{r3, r4, r5, lr}
100060f2:	2300      	movs	r3, #0
100060f4:	4c06      	ldr	r4, [pc, #24]	; (10006110 <_sbrk_r+0x20>)
100060f6:	1c05      	adds	r5, r0, #0
100060f8:	1c08      	adds	r0, r1, #0
100060fa:	6023      	str	r3, [r4, #0]
100060fc:	f7fb fdda 	bl	10001cb4 <_sbrk>
10006100:	1c43      	adds	r3, r0, #1
10006102:	d103      	bne.n	1000610c <_sbrk_r+0x1c>
10006104:	6823      	ldr	r3, [r4, #0]
10006106:	2b00      	cmp	r3, #0
10006108:	d000      	beq.n	1000610c <_sbrk_r+0x1c>
1000610a:	602b      	str	r3, [r5, #0]
1000610c:	bd38      	pop	{r3, r4, r5, pc}
1000610e:	46c0      	nop			; (mov r8, r8)
10006110:	20000928 	.word	0x20000928

10006114 <siprintf>:
10006114:	b40e      	push	{r1, r2, r3}
10006116:	b510      	push	{r4, lr}
10006118:	b09d      	sub	sp, #116	; 0x74
1000611a:	a902      	add	r1, sp, #8
1000611c:	9002      	str	r0, [sp, #8]
1000611e:	6108      	str	r0, [r1, #16]
10006120:	480b      	ldr	r0, [pc, #44]	; (10006150 <siprintf+0x3c>)
10006122:	2482      	movs	r4, #130	; 0x82
10006124:	6088      	str	r0, [r1, #8]
10006126:	6148      	str	r0, [r1, #20]
10006128:	2001      	movs	r0, #1
1000612a:	4240      	negs	r0, r0
1000612c:	ab1f      	add	r3, sp, #124	; 0x7c
1000612e:	81c8      	strh	r0, [r1, #14]
10006130:	4808      	ldr	r0, [pc, #32]	; (10006154 <siprintf+0x40>)
10006132:	cb04      	ldmia	r3!, {r2}
10006134:	00a4      	lsls	r4, r4, #2
10006136:	6800      	ldr	r0, [r0, #0]
10006138:	9301      	str	r3, [sp, #4]
1000613a:	818c      	strh	r4, [r1, #12]
1000613c:	f001 fcb2 	bl	10007aa4 <_svfiprintf_r>
10006140:	2300      	movs	r3, #0
10006142:	9a02      	ldr	r2, [sp, #8]
10006144:	7013      	strb	r3, [r2, #0]
10006146:	b01d      	add	sp, #116	; 0x74
10006148:	bc10      	pop	{r4}
1000614a:	bc08      	pop	{r3}
1000614c:	b003      	add	sp, #12
1000614e:	4718      	bx	r3
10006150:	7fffffff 	.word	0x7fffffff
10006154:	20000664 	.word	0x20000664

10006158 <strlen>:
10006158:	2300      	movs	r3, #0
1000615a:	5cc2      	ldrb	r2, [r0, r3]
1000615c:	3301      	adds	r3, #1
1000615e:	2a00      	cmp	r2, #0
10006160:	d1fb      	bne.n	1000615a <strlen+0x2>
10006162:	1e58      	subs	r0, r3, #1
10006164:	4770      	bx	lr
	...

10006168 <__swbuf_r>:
10006168:	b570      	push	{r4, r5, r6, lr}
1000616a:	1c05      	adds	r5, r0, #0
1000616c:	1c0e      	adds	r6, r1, #0
1000616e:	1c14      	adds	r4, r2, #0
10006170:	2800      	cmp	r0, #0
10006172:	d004      	beq.n	1000617e <__swbuf_r+0x16>
10006174:	6983      	ldr	r3, [r0, #24]
10006176:	2b00      	cmp	r3, #0
10006178:	d101      	bne.n	1000617e <__swbuf_r+0x16>
1000617a:	f001 f841 	bl	10007200 <__sinit>
1000617e:	4b23      	ldr	r3, [pc, #140]	; (1000620c <__swbuf_r+0xa4>)
10006180:	429c      	cmp	r4, r3
10006182:	d101      	bne.n	10006188 <__swbuf_r+0x20>
10006184:	686c      	ldr	r4, [r5, #4]
10006186:	e008      	b.n	1000619a <__swbuf_r+0x32>
10006188:	4b21      	ldr	r3, [pc, #132]	; (10006210 <__swbuf_r+0xa8>)
1000618a:	429c      	cmp	r4, r3
1000618c:	d101      	bne.n	10006192 <__swbuf_r+0x2a>
1000618e:	68ac      	ldr	r4, [r5, #8]
10006190:	e003      	b.n	1000619a <__swbuf_r+0x32>
10006192:	4b20      	ldr	r3, [pc, #128]	; (10006214 <__swbuf_r+0xac>)
10006194:	429c      	cmp	r4, r3
10006196:	d100      	bne.n	1000619a <__swbuf_r+0x32>
10006198:	68ec      	ldr	r4, [r5, #12]
1000619a:	69a3      	ldr	r3, [r4, #24]
1000619c:	60a3      	str	r3, [r4, #8]
1000619e:	89a3      	ldrh	r3, [r4, #12]
100061a0:	071b      	lsls	r3, r3, #28
100061a2:	d50a      	bpl.n	100061ba <__swbuf_r+0x52>
100061a4:	6923      	ldr	r3, [r4, #16]
100061a6:	2b00      	cmp	r3, #0
100061a8:	d007      	beq.n	100061ba <__swbuf_r+0x52>
100061aa:	6823      	ldr	r3, [r4, #0]
100061ac:	6922      	ldr	r2, [r4, #16]
100061ae:	b2f6      	uxtb	r6, r6
100061b0:	1a98      	subs	r0, r3, r2
100061b2:	6963      	ldr	r3, [r4, #20]
100061b4:	4298      	cmp	r0, r3
100061b6:	db0f      	blt.n	100061d8 <__swbuf_r+0x70>
100061b8:	e008      	b.n	100061cc <__swbuf_r+0x64>
100061ba:	1c28      	adds	r0, r5, #0
100061bc:	1c21      	adds	r1, r4, #0
100061be:	f000 f82b 	bl	10006218 <__swsetup_r>
100061c2:	2800      	cmp	r0, #0
100061c4:	d0f1      	beq.n	100061aa <__swbuf_r+0x42>
100061c6:	2001      	movs	r0, #1
100061c8:	4240      	negs	r0, r0
100061ca:	e01d      	b.n	10006208 <__swbuf_r+0xa0>
100061cc:	1c28      	adds	r0, r5, #0
100061ce:	1c21      	adds	r1, r4, #0
100061d0:	f000 ffa8 	bl	10007124 <_fflush_r>
100061d4:	2800      	cmp	r0, #0
100061d6:	d1f6      	bne.n	100061c6 <__swbuf_r+0x5e>
100061d8:	68a3      	ldr	r3, [r4, #8]
100061da:	3001      	adds	r0, #1
100061dc:	3b01      	subs	r3, #1
100061de:	60a3      	str	r3, [r4, #8]
100061e0:	6823      	ldr	r3, [r4, #0]
100061e2:	1c5a      	adds	r2, r3, #1
100061e4:	6022      	str	r2, [r4, #0]
100061e6:	701e      	strb	r6, [r3, #0]
100061e8:	6963      	ldr	r3, [r4, #20]
100061ea:	4298      	cmp	r0, r3
100061ec:	d005      	beq.n	100061fa <__swbuf_r+0x92>
100061ee:	89a3      	ldrh	r3, [r4, #12]
100061f0:	1c30      	adds	r0, r6, #0
100061f2:	07db      	lsls	r3, r3, #31
100061f4:	d508      	bpl.n	10006208 <__swbuf_r+0xa0>
100061f6:	2e0a      	cmp	r6, #10
100061f8:	d106      	bne.n	10006208 <__swbuf_r+0xa0>
100061fa:	1c28      	adds	r0, r5, #0
100061fc:	1c21      	adds	r1, r4, #0
100061fe:	f000 ff91 	bl	10007124 <_fflush_r>
10006202:	2800      	cmp	r0, #0
10006204:	d1df      	bne.n	100061c6 <__swbuf_r+0x5e>
10006206:	1c30      	adds	r0, r6, #0
10006208:	bd70      	pop	{r4, r5, r6, pc}
1000620a:	46c0      	nop			; (mov r8, r8)
1000620c:	1000a3ac 	.word	0x1000a3ac
10006210:	1000a3cc 	.word	0x1000a3cc
10006214:	1000a3ec 	.word	0x1000a3ec

10006218 <__swsetup_r>:
10006218:	4b35      	ldr	r3, [pc, #212]	; (100062f0 <__swsetup_r+0xd8>)
1000621a:	b570      	push	{r4, r5, r6, lr}
1000621c:	681d      	ldr	r5, [r3, #0]
1000621e:	1c06      	adds	r6, r0, #0
10006220:	1c0c      	adds	r4, r1, #0
10006222:	2d00      	cmp	r5, #0
10006224:	d005      	beq.n	10006232 <__swsetup_r+0x1a>
10006226:	69ab      	ldr	r3, [r5, #24]
10006228:	2b00      	cmp	r3, #0
1000622a:	d102      	bne.n	10006232 <__swsetup_r+0x1a>
1000622c:	1c28      	adds	r0, r5, #0
1000622e:	f000 ffe7 	bl	10007200 <__sinit>
10006232:	4b30      	ldr	r3, [pc, #192]	; (100062f4 <__swsetup_r+0xdc>)
10006234:	429c      	cmp	r4, r3
10006236:	d101      	bne.n	1000623c <__swsetup_r+0x24>
10006238:	686c      	ldr	r4, [r5, #4]
1000623a:	e008      	b.n	1000624e <__swsetup_r+0x36>
1000623c:	4b2e      	ldr	r3, [pc, #184]	; (100062f8 <__swsetup_r+0xe0>)
1000623e:	429c      	cmp	r4, r3
10006240:	d101      	bne.n	10006246 <__swsetup_r+0x2e>
10006242:	68ac      	ldr	r4, [r5, #8]
10006244:	e003      	b.n	1000624e <__swsetup_r+0x36>
10006246:	4b2d      	ldr	r3, [pc, #180]	; (100062fc <__swsetup_r+0xe4>)
10006248:	429c      	cmp	r4, r3
1000624a:	d100      	bne.n	1000624e <__swsetup_r+0x36>
1000624c:	68ec      	ldr	r4, [r5, #12]
1000624e:	89a3      	ldrh	r3, [r4, #12]
10006250:	b29a      	uxth	r2, r3
10006252:	0711      	lsls	r1, r2, #28
10006254:	d423      	bmi.n	1000629e <__swsetup_r+0x86>
10006256:	06d1      	lsls	r1, r2, #27
10006258:	d407      	bmi.n	1000626a <__swsetup_r+0x52>
1000625a:	2209      	movs	r2, #9
1000625c:	2001      	movs	r0, #1
1000625e:	6032      	str	r2, [r6, #0]
10006260:	3237      	adds	r2, #55	; 0x37
10006262:	4313      	orrs	r3, r2
10006264:	81a3      	strh	r3, [r4, #12]
10006266:	4240      	negs	r0, r0
10006268:	e040      	b.n	100062ec <__swsetup_r+0xd4>
1000626a:	0753      	lsls	r3, r2, #29
1000626c:	d513      	bpl.n	10006296 <__swsetup_r+0x7e>
1000626e:	6b61      	ldr	r1, [r4, #52]	; 0x34
10006270:	2900      	cmp	r1, #0
10006272:	d008      	beq.n	10006286 <__swsetup_r+0x6e>
10006274:	1c23      	adds	r3, r4, #0
10006276:	3344      	adds	r3, #68	; 0x44
10006278:	4299      	cmp	r1, r3
1000627a:	d002      	beq.n	10006282 <__swsetup_r+0x6a>
1000627c:	1c30      	adds	r0, r6, #0
1000627e:	f7ff f997 	bl	100055b0 <_free_r>
10006282:	2300      	movs	r3, #0
10006284:	6363      	str	r3, [r4, #52]	; 0x34
10006286:	2224      	movs	r2, #36	; 0x24
10006288:	89a3      	ldrh	r3, [r4, #12]
1000628a:	4393      	bics	r3, r2
1000628c:	81a3      	strh	r3, [r4, #12]
1000628e:	2300      	movs	r3, #0
10006290:	6063      	str	r3, [r4, #4]
10006292:	6923      	ldr	r3, [r4, #16]
10006294:	6023      	str	r3, [r4, #0]
10006296:	2208      	movs	r2, #8
10006298:	89a3      	ldrh	r3, [r4, #12]
1000629a:	4313      	orrs	r3, r2
1000629c:	81a3      	strh	r3, [r4, #12]
1000629e:	6923      	ldr	r3, [r4, #16]
100062a0:	2b00      	cmp	r3, #0
100062a2:	d10b      	bne.n	100062bc <__swsetup_r+0xa4>
100062a4:	23a0      	movs	r3, #160	; 0xa0
100062a6:	89a2      	ldrh	r2, [r4, #12]
100062a8:	009b      	lsls	r3, r3, #2
100062aa:	4013      	ands	r3, r2
100062ac:	2280      	movs	r2, #128	; 0x80
100062ae:	0092      	lsls	r2, r2, #2
100062b0:	4293      	cmp	r3, r2
100062b2:	d003      	beq.n	100062bc <__swsetup_r+0xa4>
100062b4:	1c30      	adds	r0, r6, #0
100062b6:	1c21      	adds	r1, r4, #0
100062b8:	f001 f838 	bl	1000732c <__smakebuf_r>
100062bc:	2301      	movs	r3, #1
100062be:	89a2      	ldrh	r2, [r4, #12]
100062c0:	4013      	ands	r3, r2
100062c2:	d005      	beq.n	100062d0 <__swsetup_r+0xb8>
100062c4:	2300      	movs	r3, #0
100062c6:	60a3      	str	r3, [r4, #8]
100062c8:	6963      	ldr	r3, [r4, #20]
100062ca:	425b      	negs	r3, r3
100062cc:	61a3      	str	r3, [r4, #24]
100062ce:	e003      	b.n	100062d8 <__swsetup_r+0xc0>
100062d0:	0791      	lsls	r1, r2, #30
100062d2:	d400      	bmi.n	100062d6 <__swsetup_r+0xbe>
100062d4:	6963      	ldr	r3, [r4, #20]
100062d6:	60a3      	str	r3, [r4, #8]
100062d8:	2000      	movs	r0, #0
100062da:	6923      	ldr	r3, [r4, #16]
100062dc:	4283      	cmp	r3, r0
100062de:	d105      	bne.n	100062ec <__swsetup_r+0xd4>
100062e0:	0613      	lsls	r3, r2, #24
100062e2:	d503      	bpl.n	100062ec <__swsetup_r+0xd4>
100062e4:	2340      	movs	r3, #64	; 0x40
100062e6:	431a      	orrs	r2, r3
100062e8:	81a2      	strh	r2, [r4, #12]
100062ea:	3801      	subs	r0, #1
100062ec:	bd70      	pop	{r4, r5, r6, pc}
100062ee:	46c0      	nop			; (mov r8, r8)
100062f0:	20000664 	.word	0x20000664
100062f4:	1000a3ac 	.word	0x1000a3ac
100062f8:	1000a3cc 	.word	0x1000a3cc
100062fc:	1000a3ec 	.word	0x1000a3ec

10006300 <quorem>:
10006300:	b5f0      	push	{r4, r5, r6, r7, lr}
10006302:	6903      	ldr	r3, [r0, #16]
10006304:	690c      	ldr	r4, [r1, #16]
10006306:	b089      	sub	sp, #36	; 0x24
10006308:	2600      	movs	r6, #0
1000630a:	42a3      	cmp	r3, r4
1000630c:	db7c      	blt.n	10006408 <quorem+0x108>
1000630e:	1c0b      	adds	r3, r1, #0
10006310:	3c01      	subs	r4, #1
10006312:	3314      	adds	r3, #20
10006314:	00a5      	lsls	r5, r4, #2
10006316:	9303      	str	r3, [sp, #12]
10006318:	195b      	adds	r3, r3, r5
1000631a:	9304      	str	r3, [sp, #16]
1000631c:	1c03      	adds	r3, r0, #0
1000631e:	3314      	adds	r3, #20
10006320:	9301      	str	r3, [sp, #4]
10006322:	195d      	adds	r5, r3, r5
10006324:	9b04      	ldr	r3, [sp, #16]
10006326:	9107      	str	r1, [sp, #28]
10006328:	681b      	ldr	r3, [r3, #0]
1000632a:	9002      	str	r0, [sp, #8]
1000632c:	1c59      	adds	r1, r3, #1
1000632e:	6828      	ldr	r0, [r5, #0]
10006330:	9305      	str	r3, [sp, #20]
10006332:	f7fe ff71 	bl	10005218 <__aeabi_uidiv>
10006336:	1e07      	subs	r7, r0, #0
10006338:	42b7      	cmp	r7, r6
1000633a:	d035      	beq.n	100063a8 <quorem+0xa8>
1000633c:	9b03      	ldr	r3, [sp, #12]
1000633e:	9801      	ldr	r0, [sp, #4]
10006340:	469c      	mov	ip, r3
10006342:	9605      	str	r6, [sp, #20]
10006344:	4663      	mov	r3, ip
10006346:	cb04      	ldmia	r3!, {r2}
10006348:	b291      	uxth	r1, r2
1000634a:	4379      	muls	r1, r7
1000634c:	0c12      	lsrs	r2, r2, #16
1000634e:	437a      	muls	r2, r7
10006350:	1871      	adds	r1, r6, r1
10006352:	0c0e      	lsrs	r6, r1, #16
10006354:	469c      	mov	ip, r3
10006356:	18b3      	adds	r3, r6, r2
10006358:	9306      	str	r3, [sp, #24]
1000635a:	8802      	ldrh	r2, [r0, #0]
1000635c:	0c1e      	lsrs	r6, r3, #16
1000635e:	9b05      	ldr	r3, [sp, #20]
10006360:	b289      	uxth	r1, r1
10006362:	18d2      	adds	r2, r2, r3
10006364:	6803      	ldr	r3, [r0, #0]
10006366:	1a52      	subs	r2, r2, r1
10006368:	0c19      	lsrs	r1, r3, #16
1000636a:	466b      	mov	r3, sp
1000636c:	8b1b      	ldrh	r3, [r3, #24]
1000636e:	1acb      	subs	r3, r1, r3
10006370:	1411      	asrs	r1, r2, #16
10006372:	185b      	adds	r3, r3, r1
10006374:	1419      	asrs	r1, r3, #16
10006376:	b292      	uxth	r2, r2
10006378:	041b      	lsls	r3, r3, #16
1000637a:	431a      	orrs	r2, r3
1000637c:	9b04      	ldr	r3, [sp, #16]
1000637e:	9105      	str	r1, [sp, #20]
10006380:	c004      	stmia	r0!, {r2}
10006382:	4563      	cmp	r3, ip
10006384:	d2de      	bcs.n	10006344 <quorem+0x44>
10006386:	682b      	ldr	r3, [r5, #0]
10006388:	2b00      	cmp	r3, #0
1000638a:	d10d      	bne.n	100063a8 <quorem+0xa8>
1000638c:	1c23      	adds	r3, r4, #0
1000638e:	9a01      	ldr	r2, [sp, #4]
10006390:	3d04      	subs	r5, #4
10006392:	4295      	cmp	r5, r2
10006394:	d803      	bhi.n	1000639e <quorem+0x9e>
10006396:	9a02      	ldr	r2, [sp, #8]
10006398:	1c1c      	adds	r4, r3, #0
1000639a:	6113      	str	r3, [r2, #16]
1000639c:	e004      	b.n	100063a8 <quorem+0xa8>
1000639e:	682a      	ldr	r2, [r5, #0]
100063a0:	2a00      	cmp	r2, #0
100063a2:	d1f8      	bne.n	10006396 <quorem+0x96>
100063a4:	3b01      	subs	r3, #1
100063a6:	e7f2      	b.n	1000638e <quorem+0x8e>
100063a8:	9802      	ldr	r0, [sp, #8]
100063aa:	9907      	ldr	r1, [sp, #28]
100063ac:	f001 fa32 	bl	10007814 <__mcmp>
100063b0:	2800      	cmp	r0, #0
100063b2:	db28      	blt.n	10006406 <quorem+0x106>
100063b4:	2000      	movs	r0, #0
100063b6:	9901      	ldr	r1, [sp, #4]
100063b8:	9a03      	ldr	r2, [sp, #12]
100063ba:	3701      	adds	r7, #1
100063bc:	ca20      	ldmia	r2!, {r5}
100063be:	880b      	ldrh	r3, [r1, #0]
100063c0:	1818      	adds	r0, r3, r0
100063c2:	b2ab      	uxth	r3, r5
100063c4:	1ac3      	subs	r3, r0, r3
100063c6:	6808      	ldr	r0, [r1, #0]
100063c8:	0c2d      	lsrs	r5, r5, #16
100063ca:	0c00      	lsrs	r0, r0, #16
100063cc:	1b45      	subs	r5, r0, r5
100063ce:	141e      	asrs	r6, r3, #16
100063d0:	19ad      	adds	r5, r5, r6
100063d2:	1428      	asrs	r0, r5, #16
100063d4:	b29b      	uxth	r3, r3
100063d6:	042d      	lsls	r5, r5, #16
100063d8:	432b      	orrs	r3, r5
100063da:	c108      	stmia	r1!, {r3}
100063dc:	9b04      	ldr	r3, [sp, #16]
100063de:	4293      	cmp	r3, r2
100063e0:	d2ec      	bcs.n	100063bc <quorem+0xbc>
100063e2:	9a01      	ldr	r2, [sp, #4]
100063e4:	00a3      	lsls	r3, r4, #2
100063e6:	18d3      	adds	r3, r2, r3
100063e8:	681a      	ldr	r2, [r3, #0]
100063ea:	2a00      	cmp	r2, #0
100063ec:	d10b      	bne.n	10006406 <quorem+0x106>
100063ee:	9a01      	ldr	r2, [sp, #4]
100063f0:	3b04      	subs	r3, #4
100063f2:	4293      	cmp	r3, r2
100063f4:	d802      	bhi.n	100063fc <quorem+0xfc>
100063f6:	9b02      	ldr	r3, [sp, #8]
100063f8:	611c      	str	r4, [r3, #16]
100063fa:	e004      	b.n	10006406 <quorem+0x106>
100063fc:	681a      	ldr	r2, [r3, #0]
100063fe:	2a00      	cmp	r2, #0
10006400:	d1f9      	bne.n	100063f6 <quorem+0xf6>
10006402:	3c01      	subs	r4, #1
10006404:	e7f3      	b.n	100063ee <quorem+0xee>
10006406:	1c3e      	adds	r6, r7, #0
10006408:	1c30      	adds	r0, r6, #0
1000640a:	b009      	add	sp, #36	; 0x24
1000640c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

10006410 <_dtoa_r>:
10006410:	b5f0      	push	{r4, r5, r6, r7, lr}
10006412:	1c16      	adds	r6, r2, #0
10006414:	1c1f      	adds	r7, r3, #0
10006416:	6a44      	ldr	r4, [r0, #36]	; 0x24
10006418:	b09b      	sub	sp, #108	; 0x6c
1000641a:	9008      	str	r0, [sp, #32]
1000641c:	9d23      	ldr	r5, [sp, #140]	; 0x8c
1000641e:	9606      	str	r6, [sp, #24]
10006420:	9707      	str	r7, [sp, #28]
10006422:	2c00      	cmp	r4, #0
10006424:	d108      	bne.n	10006438 <_dtoa_r+0x28>
10006426:	2010      	movs	r0, #16
10006428:	f7ff f89c 	bl	10005564 <malloc>
1000642c:	9b08      	ldr	r3, [sp, #32]
1000642e:	6258      	str	r0, [r3, #36]	; 0x24
10006430:	6044      	str	r4, [r0, #4]
10006432:	6084      	str	r4, [r0, #8]
10006434:	6004      	str	r4, [r0, #0]
10006436:	60c4      	str	r4, [r0, #12]
10006438:	9b08      	ldr	r3, [sp, #32]
1000643a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
1000643c:	6819      	ldr	r1, [r3, #0]
1000643e:	2900      	cmp	r1, #0
10006440:	d00b      	beq.n	1000645a <_dtoa_r+0x4a>
10006442:	685a      	ldr	r2, [r3, #4]
10006444:	2301      	movs	r3, #1
10006446:	4093      	lsls	r3, r2
10006448:	604a      	str	r2, [r1, #4]
1000644a:	608b      	str	r3, [r1, #8]
1000644c:	9808      	ldr	r0, [sp, #32]
1000644e:	f001 f808 	bl	10007462 <_Bfree>
10006452:	2200      	movs	r2, #0
10006454:	9b08      	ldr	r3, [sp, #32]
10006456:	6a5b      	ldr	r3, [r3, #36]	; 0x24
10006458:	601a      	str	r2, [r3, #0]
1000645a:	9b07      	ldr	r3, [sp, #28]
1000645c:	2b00      	cmp	r3, #0
1000645e:	da05      	bge.n	1000646c <_dtoa_r+0x5c>
10006460:	2301      	movs	r3, #1
10006462:	602b      	str	r3, [r5, #0]
10006464:	007b      	lsls	r3, r7, #1
10006466:	085b      	lsrs	r3, r3, #1
10006468:	9307      	str	r3, [sp, #28]
1000646a:	e001      	b.n	10006470 <_dtoa_r+0x60>
1000646c:	2300      	movs	r3, #0
1000646e:	602b      	str	r3, [r5, #0]
10006470:	9c07      	ldr	r4, [sp, #28]
10006472:	4bc6      	ldr	r3, [pc, #792]	; (1000678c <_dtoa_r+0x37c>)
10006474:	1c22      	adds	r2, r4, #0
10006476:	9317      	str	r3, [sp, #92]	; 0x5c
10006478:	401a      	ands	r2, r3
1000647a:	429a      	cmp	r2, r3
1000647c:	d119      	bne.n	100064b2 <_dtoa_r+0xa2>
1000647e:	4bc4      	ldr	r3, [pc, #784]	; (10006790 <_dtoa_r+0x380>)
10006480:	9a22      	ldr	r2, [sp, #136]	; 0x88
10006482:	6013      	str	r3, [r2, #0]
10006484:	9a06      	ldr	r2, [sp, #24]
10006486:	4bc3      	ldr	r3, [pc, #780]	; (10006794 <_dtoa_r+0x384>)
10006488:	2a00      	cmp	r2, #0
1000648a:	d102      	bne.n	10006492 <_dtoa_r+0x82>
1000648c:	0324      	lsls	r4, r4, #12
1000648e:	d100      	bne.n	10006492 <_dtoa_r+0x82>
10006490:	4bc1      	ldr	r3, [pc, #772]	; (10006798 <_dtoa_r+0x388>)
10006492:	9a24      	ldr	r2, [sp, #144]	; 0x90
10006494:	1c18      	adds	r0, r3, #0
10006496:	2a00      	cmp	r2, #0
10006498:	d101      	bne.n	1000649e <_dtoa_r+0x8e>
1000649a:	f000 fdb6 	bl	1000700a <_dtoa_r+0xbfa>
1000649e:	78d9      	ldrb	r1, [r3, #3]
100064a0:	1cda      	adds	r2, r3, #3
100064a2:	2900      	cmp	r1, #0
100064a4:	d000      	beq.n	100064a8 <_dtoa_r+0x98>
100064a6:	3205      	adds	r2, #5
100064a8:	9924      	ldr	r1, [sp, #144]	; 0x90
100064aa:	1c18      	adds	r0, r3, #0
100064ac:	600a      	str	r2, [r1, #0]
100064ae:	f000 fdac 	bl	1000700a <_dtoa_r+0xbfa>
100064b2:	9e06      	ldr	r6, [sp, #24]
100064b4:	9f07      	ldr	r7, [sp, #28]
100064b6:	2200      	movs	r2, #0
100064b8:	1c30      	adds	r0, r6, #0
100064ba:	1c39      	adds	r1, r7, #0
100064bc:	2300      	movs	r3, #0
100064be:	f001 fe3d 	bl	1000813c <__aeabi_dcmpeq>
100064c2:	1e05      	subs	r5, r0, #0
100064c4:	d00e      	beq.n	100064e4 <_dtoa_r+0xd4>
100064c6:	2301      	movs	r3, #1
100064c8:	9a22      	ldr	r2, [sp, #136]	; 0x88
100064ca:	6013      	str	r3, [r2, #0]
100064cc:	4bb3      	ldr	r3, [pc, #716]	; (1000679c <_dtoa_r+0x38c>)
100064ce:	9a24      	ldr	r2, [sp, #144]	; 0x90
100064d0:	1c18      	adds	r0, r3, #0
100064d2:	2a00      	cmp	r2, #0
100064d4:	d101      	bne.n	100064da <_dtoa_r+0xca>
100064d6:	f000 fd98 	bl	1000700a <_dtoa_r+0xbfa>
100064da:	4ab1      	ldr	r2, [pc, #708]	; (100067a0 <_dtoa_r+0x390>)
100064dc:	9924      	ldr	r1, [sp, #144]	; 0x90
100064de:	600a      	str	r2, [r1, #0]
100064e0:	f000 fd93 	bl	1000700a <_dtoa_r+0xbfa>
100064e4:	ab19      	add	r3, sp, #100	; 0x64
100064e6:	9300      	str	r3, [sp, #0]
100064e8:	ab18      	add	r3, sp, #96	; 0x60
100064ea:	9301      	str	r3, [sp, #4]
100064ec:	9808      	ldr	r0, [sp, #32]
100064ee:	1c32      	adds	r2, r6, #0
100064f0:	1c3b      	adds	r3, r7, #0
100064f2:	f001 fa15 	bl	10007920 <__d2b>
100064f6:	0061      	lsls	r1, r4, #1
100064f8:	900a      	str	r0, [sp, #40]	; 0x28
100064fa:	0d49      	lsrs	r1, r1, #21
100064fc:	d009      	beq.n	10006512 <_dtoa_r+0x102>
100064fe:	0338      	lsls	r0, r7, #12
10006500:	4ca8      	ldr	r4, [pc, #672]	; (100067a4 <_dtoa_r+0x394>)
10006502:	0b00      	lsrs	r0, r0, #12
10006504:	4304      	orrs	r4, r0
10006506:	48a8      	ldr	r0, [pc, #672]	; (100067a8 <_dtoa_r+0x398>)
10006508:	1c32      	adds	r2, r6, #0
1000650a:	1c23      	adds	r3, r4, #0
1000650c:	180e      	adds	r6, r1, r0
1000650e:	9516      	str	r5, [sp, #88]	; 0x58
10006510:	e01c      	b.n	1000654c <_dtoa_r+0x13c>
10006512:	9b18      	ldr	r3, [sp, #96]	; 0x60
10006514:	9a19      	ldr	r2, [sp, #100]	; 0x64
10006516:	189e      	adds	r6, r3, r2
10006518:	4ba4      	ldr	r3, [pc, #656]	; (100067ac <_dtoa_r+0x39c>)
1000651a:	429e      	cmp	r6, r3
1000651c:	db09      	blt.n	10006532 <_dtoa_r+0x122>
1000651e:	4ba4      	ldr	r3, [pc, #656]	; (100067b0 <_dtoa_r+0x3a0>)
10006520:	18f0      	adds	r0, r6, r3
10006522:	9b06      	ldr	r3, [sp, #24]
10006524:	40c3      	lsrs	r3, r0
10006526:	1c18      	adds	r0, r3, #0
10006528:	4ba2      	ldr	r3, [pc, #648]	; (100067b4 <_dtoa_r+0x3a4>)
1000652a:	1b9b      	subs	r3, r3, r6
1000652c:	409c      	lsls	r4, r3
1000652e:	4320      	orrs	r0, r4
10006530:	e004      	b.n	1000653c <_dtoa_r+0x12c>
10006532:	48a1      	ldr	r0, [pc, #644]	; (100067b8 <_dtoa_r+0x3a8>)
10006534:	9b06      	ldr	r3, [sp, #24]
10006536:	1b80      	subs	r0, r0, r6
10006538:	4083      	lsls	r3, r0
1000653a:	1c18      	adds	r0, r3, #0
1000653c:	f003 fc18 	bl	10009d70 <__aeabi_ui2d>
10006540:	4c9e      	ldr	r4, [pc, #632]	; (100067bc <_dtoa_r+0x3ac>)
10006542:	1c02      	adds	r2, r0, #0
10006544:	190b      	adds	r3, r1, r4
10006546:	2101      	movs	r1, #1
10006548:	3e01      	subs	r6, #1
1000654a:	9116      	str	r1, [sp, #88]	; 0x58
1000654c:	1c10      	adds	r0, r2, #0
1000654e:	1c19      	adds	r1, r3, #0
10006550:	2200      	movs	r2, #0
10006552:	4b9b      	ldr	r3, [pc, #620]	; (100067c0 <_dtoa_r+0x3b0>)
10006554:	f003 f820 	bl	10009598 <__aeabi_dsub>
10006558:	4a9a      	ldr	r2, [pc, #616]	; (100067c4 <_dtoa_r+0x3b4>)
1000655a:	4b9b      	ldr	r3, [pc, #620]	; (100067c8 <_dtoa_r+0x3b8>)
1000655c:	f002 fd82 	bl	10009064 <__aeabi_dmul>
10006560:	4a9a      	ldr	r2, [pc, #616]	; (100067cc <_dtoa_r+0x3bc>)
10006562:	4b9b      	ldr	r3, [pc, #620]	; (100067d0 <_dtoa_r+0x3c0>)
10006564:	f001 fe18 	bl	10008198 <__aeabi_dadd>
10006568:	1c04      	adds	r4, r0, #0
1000656a:	1c30      	adds	r0, r6, #0
1000656c:	1c0d      	adds	r5, r1, #0
1000656e:	f003 fbc3 	bl	10009cf8 <__aeabi_i2d>
10006572:	4a98      	ldr	r2, [pc, #608]	; (100067d4 <_dtoa_r+0x3c4>)
10006574:	4b98      	ldr	r3, [pc, #608]	; (100067d8 <_dtoa_r+0x3c8>)
10006576:	f002 fd75 	bl	10009064 <__aeabi_dmul>
1000657a:	1c02      	adds	r2, r0, #0
1000657c:	1c0b      	adds	r3, r1, #0
1000657e:	1c20      	adds	r0, r4, #0
10006580:	1c29      	adds	r1, r5, #0
10006582:	f001 fe09 	bl	10008198 <__aeabi_dadd>
10006586:	1c04      	adds	r4, r0, #0
10006588:	1c0d      	adds	r5, r1, #0
1000658a:	f003 fb7f 	bl	10009c8c <__aeabi_d2iz>
1000658e:	1c29      	adds	r1, r5, #0
10006590:	9003      	str	r0, [sp, #12]
10006592:	2200      	movs	r2, #0
10006594:	1c20      	adds	r0, r4, #0
10006596:	2300      	movs	r3, #0
10006598:	f001 fdd6 	bl	10008148 <__aeabi_dcmplt>
1000659c:	2800      	cmp	r0, #0
1000659e:	d00d      	beq.n	100065bc <_dtoa_r+0x1ac>
100065a0:	9803      	ldr	r0, [sp, #12]
100065a2:	f003 fba9 	bl	10009cf8 <__aeabi_i2d>
100065a6:	1c02      	adds	r2, r0, #0
100065a8:	1c0b      	adds	r3, r1, #0
100065aa:	1c20      	adds	r0, r4, #0
100065ac:	1c29      	adds	r1, r5, #0
100065ae:	f001 fdc5 	bl	1000813c <__aeabi_dcmpeq>
100065b2:	4243      	negs	r3, r0
100065b4:	4143      	adcs	r3, r0
100065b6:	9a03      	ldr	r2, [sp, #12]
100065b8:	1ad3      	subs	r3, r2, r3
100065ba:	9303      	str	r3, [sp, #12]
100065bc:	2301      	movs	r3, #1
100065be:	9313      	str	r3, [sp, #76]	; 0x4c
100065c0:	9b03      	ldr	r3, [sp, #12]
100065c2:	2b16      	cmp	r3, #22
100065c4:	d811      	bhi.n	100065ea <_dtoa_r+0x1da>
100065c6:	4a85      	ldr	r2, [pc, #532]	; (100067dc <_dtoa_r+0x3cc>)
100065c8:	00db      	lsls	r3, r3, #3
100065ca:	18d3      	adds	r3, r2, r3
100065cc:	6818      	ldr	r0, [r3, #0]
100065ce:	6859      	ldr	r1, [r3, #4]
100065d0:	9a06      	ldr	r2, [sp, #24]
100065d2:	9b07      	ldr	r3, [sp, #28]
100065d4:	f001 fdcc 	bl	10008170 <__aeabi_dcmpgt>
100065d8:	2800      	cmp	r0, #0
100065da:	d005      	beq.n	100065e8 <_dtoa_r+0x1d8>
100065dc:	9b03      	ldr	r3, [sp, #12]
100065de:	3b01      	subs	r3, #1
100065e0:	9303      	str	r3, [sp, #12]
100065e2:	2300      	movs	r3, #0
100065e4:	9313      	str	r3, [sp, #76]	; 0x4c
100065e6:	e000      	b.n	100065ea <_dtoa_r+0x1da>
100065e8:	9013      	str	r0, [sp, #76]	; 0x4c
100065ea:	9b18      	ldr	r3, [sp, #96]	; 0x60
100065ec:	1b9e      	subs	r6, r3, r6
100065ee:	2300      	movs	r3, #0
100065f0:	930d      	str	r3, [sp, #52]	; 0x34
100065f2:	3e01      	subs	r6, #1
100065f4:	960e      	str	r6, [sp, #56]	; 0x38
100065f6:	d504      	bpl.n	10006602 <_dtoa_r+0x1f2>
100065f8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
100065fa:	425b      	negs	r3, r3
100065fc:	930d      	str	r3, [sp, #52]	; 0x34
100065fe:	2300      	movs	r3, #0
10006600:	930e      	str	r3, [sp, #56]	; 0x38
10006602:	9b03      	ldr	r3, [sp, #12]
10006604:	2b00      	cmp	r3, #0
10006606:	db08      	blt.n	1000661a <_dtoa_r+0x20a>
10006608:	9a03      	ldr	r2, [sp, #12]
1000660a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
1000660c:	4694      	mov	ip, r2
1000660e:	4463      	add	r3, ip
10006610:	930e      	str	r3, [sp, #56]	; 0x38
10006612:	2300      	movs	r3, #0
10006614:	9212      	str	r2, [sp, #72]	; 0x48
10006616:	930f      	str	r3, [sp, #60]	; 0x3c
10006618:	e007      	b.n	1000662a <_dtoa_r+0x21a>
1000661a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
1000661c:	9a03      	ldr	r2, [sp, #12]
1000661e:	1a9b      	subs	r3, r3, r2
10006620:	930d      	str	r3, [sp, #52]	; 0x34
10006622:	4253      	negs	r3, r2
10006624:	930f      	str	r3, [sp, #60]	; 0x3c
10006626:	2300      	movs	r3, #0
10006628:	9312      	str	r3, [sp, #72]	; 0x48
1000662a:	9b20      	ldr	r3, [sp, #128]	; 0x80
1000662c:	2501      	movs	r5, #1
1000662e:	2b09      	cmp	r3, #9
10006630:	d827      	bhi.n	10006682 <_dtoa_r+0x272>
10006632:	2b05      	cmp	r3, #5
10006634:	dd02      	ble.n	1000663c <_dtoa_r+0x22c>
10006636:	2500      	movs	r5, #0
10006638:	3b04      	subs	r3, #4
1000663a:	9320      	str	r3, [sp, #128]	; 0x80
1000663c:	9b20      	ldr	r3, [sp, #128]	; 0x80
1000663e:	1e98      	subs	r0, r3, #2
10006640:	2803      	cmp	r0, #3
10006642:	d823      	bhi.n	1000668c <_dtoa_r+0x27c>
10006644:	f001 fd60 	bl	10008108 <__gnu_thumb1_case_uqi>
10006648:	10040e02 	.word	0x10040e02
1000664c:	2300      	movs	r3, #0
1000664e:	e000      	b.n	10006652 <_dtoa_r+0x242>
10006650:	2301      	movs	r3, #1
10006652:	9310      	str	r3, [sp, #64]	; 0x40
10006654:	9b21      	ldr	r3, [sp, #132]	; 0x84
10006656:	2b00      	cmp	r3, #0
10006658:	dc21      	bgt.n	1000669e <_dtoa_r+0x28e>
1000665a:	2301      	movs	r3, #1
1000665c:	930b      	str	r3, [sp, #44]	; 0x2c
1000665e:	9309      	str	r3, [sp, #36]	; 0x24
10006660:	1c1a      	adds	r2, r3, #0
10006662:	e01a      	b.n	1000669a <_dtoa_r+0x28a>
10006664:	2300      	movs	r3, #0
10006666:	e000      	b.n	1000666a <_dtoa_r+0x25a>
10006668:	2301      	movs	r3, #1
1000666a:	9a03      	ldr	r2, [sp, #12]
1000666c:	9310      	str	r3, [sp, #64]	; 0x40
1000666e:	4694      	mov	ip, r2
10006670:	9b21      	ldr	r3, [sp, #132]	; 0x84
10006672:	4463      	add	r3, ip
10006674:	930b      	str	r3, [sp, #44]	; 0x2c
10006676:	3301      	adds	r3, #1
10006678:	9309      	str	r3, [sp, #36]	; 0x24
1000667a:	2b00      	cmp	r3, #0
1000667c:	dc12      	bgt.n	100066a4 <_dtoa_r+0x294>
1000667e:	2301      	movs	r3, #1
10006680:	e010      	b.n	100066a4 <_dtoa_r+0x294>
10006682:	2300      	movs	r3, #0
10006684:	9510      	str	r5, [sp, #64]	; 0x40
10006686:	9320      	str	r3, [sp, #128]	; 0x80
10006688:	3b01      	subs	r3, #1
1000668a:	e002      	b.n	10006692 <_dtoa_r+0x282>
1000668c:	2301      	movs	r3, #1
1000668e:	9310      	str	r3, [sp, #64]	; 0x40
10006690:	3b02      	subs	r3, #2
10006692:	2200      	movs	r2, #0
10006694:	930b      	str	r3, [sp, #44]	; 0x2c
10006696:	9309      	str	r3, [sp, #36]	; 0x24
10006698:	3313      	adds	r3, #19
1000669a:	9221      	str	r2, [sp, #132]	; 0x84
1000669c:	e002      	b.n	100066a4 <_dtoa_r+0x294>
1000669e:	9b21      	ldr	r3, [sp, #132]	; 0x84
100066a0:	930b      	str	r3, [sp, #44]	; 0x2c
100066a2:	9309      	str	r3, [sp, #36]	; 0x24
100066a4:	9a08      	ldr	r2, [sp, #32]
100066a6:	6a54      	ldr	r4, [r2, #36]	; 0x24
100066a8:	2200      	movs	r2, #0
100066aa:	6062      	str	r2, [r4, #4]
100066ac:	3204      	adds	r2, #4
100066ae:	1c11      	adds	r1, r2, #0
100066b0:	3114      	adds	r1, #20
100066b2:	4299      	cmp	r1, r3
100066b4:	d804      	bhi.n	100066c0 <_dtoa_r+0x2b0>
100066b6:	6861      	ldr	r1, [r4, #4]
100066b8:	0052      	lsls	r2, r2, #1
100066ba:	3101      	adds	r1, #1
100066bc:	6061      	str	r1, [r4, #4]
100066be:	e7f6      	b.n	100066ae <_dtoa_r+0x29e>
100066c0:	9808      	ldr	r0, [sp, #32]
100066c2:	6861      	ldr	r1, [r4, #4]
100066c4:	f000 fe95 	bl	100073f2 <_Balloc>
100066c8:	9b08      	ldr	r3, [sp, #32]
100066ca:	6020      	str	r0, [r4, #0]
100066cc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
100066ce:	681b      	ldr	r3, [r3, #0]
100066d0:	930c      	str	r3, [sp, #48]	; 0x30
100066d2:	9b09      	ldr	r3, [sp, #36]	; 0x24
100066d4:	2b0e      	cmp	r3, #14
100066d6:	d900      	bls.n	100066da <_dtoa_r+0x2ca>
100066d8:	e188      	b.n	100069ec <_dtoa_r+0x5dc>
100066da:	2d00      	cmp	r5, #0
100066dc:	d100      	bne.n	100066e0 <_dtoa_r+0x2d0>
100066de:	e185      	b.n	100069ec <_dtoa_r+0x5dc>
100066e0:	9b06      	ldr	r3, [sp, #24]
100066e2:	9c07      	ldr	r4, [sp, #28]
100066e4:	9314      	str	r3, [sp, #80]	; 0x50
100066e6:	9415      	str	r4, [sp, #84]	; 0x54
100066e8:	9b03      	ldr	r3, [sp, #12]
100066ea:	2b00      	cmp	r3, #0
100066ec:	dd30      	ble.n	10006750 <_dtoa_r+0x340>
100066ee:	220f      	movs	r2, #15
100066f0:	493a      	ldr	r1, [pc, #232]	; (100067dc <_dtoa_r+0x3cc>)
100066f2:	4013      	ands	r3, r2
100066f4:	00db      	lsls	r3, r3, #3
100066f6:	18cb      	adds	r3, r1, r3
100066f8:	685c      	ldr	r4, [r3, #4]
100066fa:	681b      	ldr	r3, [r3, #0]
100066fc:	9304      	str	r3, [sp, #16]
100066fe:	9405      	str	r4, [sp, #20]
10006700:	9b03      	ldr	r3, [sp, #12]
10006702:	2702      	movs	r7, #2
10006704:	111d      	asrs	r5, r3, #4
10006706:	06eb      	lsls	r3, r5, #27
10006708:	d50a      	bpl.n	10006720 <_dtoa_r+0x310>
1000670a:	9814      	ldr	r0, [sp, #80]	; 0x50
1000670c:	9915      	ldr	r1, [sp, #84]	; 0x54
1000670e:	4b34      	ldr	r3, [pc, #208]	; (100067e0 <_dtoa_r+0x3d0>)
10006710:	4015      	ands	r5, r2
10006712:	6a1a      	ldr	r2, [r3, #32]
10006714:	6a5b      	ldr	r3, [r3, #36]	; 0x24
10006716:	f002 f867 	bl	100087e8 <__aeabi_ddiv>
1000671a:	9006      	str	r0, [sp, #24]
1000671c:	9107      	str	r1, [sp, #28]
1000671e:	3701      	adds	r7, #1
10006720:	4c2f      	ldr	r4, [pc, #188]	; (100067e0 <_dtoa_r+0x3d0>)
10006722:	2d00      	cmp	r5, #0
10006724:	d00d      	beq.n	10006742 <_dtoa_r+0x332>
10006726:	07eb      	lsls	r3, r5, #31
10006728:	d508      	bpl.n	1000673c <_dtoa_r+0x32c>
1000672a:	9804      	ldr	r0, [sp, #16]
1000672c:	9905      	ldr	r1, [sp, #20]
1000672e:	6822      	ldr	r2, [r4, #0]
10006730:	6863      	ldr	r3, [r4, #4]
10006732:	f002 fc97 	bl	10009064 <__aeabi_dmul>
10006736:	9004      	str	r0, [sp, #16]
10006738:	9105      	str	r1, [sp, #20]
1000673a:	3701      	adds	r7, #1
1000673c:	106d      	asrs	r5, r5, #1
1000673e:	3408      	adds	r4, #8
10006740:	e7ef      	b.n	10006722 <_dtoa_r+0x312>
10006742:	9806      	ldr	r0, [sp, #24]
10006744:	9907      	ldr	r1, [sp, #28]
10006746:	9a04      	ldr	r2, [sp, #16]
10006748:	9b05      	ldr	r3, [sp, #20]
1000674a:	f002 f84d 	bl	100087e8 <__aeabi_ddiv>
1000674e:	e049      	b.n	100067e4 <_dtoa_r+0x3d4>
10006750:	9b03      	ldr	r3, [sp, #12]
10006752:	2702      	movs	r7, #2
10006754:	425d      	negs	r5, r3
10006756:	2d00      	cmp	r5, #0
10006758:	d046      	beq.n	100067e8 <_dtoa_r+0x3d8>
1000675a:	9814      	ldr	r0, [sp, #80]	; 0x50
1000675c:	9915      	ldr	r1, [sp, #84]	; 0x54
1000675e:	230f      	movs	r3, #15
10006760:	4a1e      	ldr	r2, [pc, #120]	; (100067dc <_dtoa_r+0x3cc>)
10006762:	402b      	ands	r3, r5
10006764:	00db      	lsls	r3, r3, #3
10006766:	18d3      	adds	r3, r2, r3
10006768:	681a      	ldr	r2, [r3, #0]
1000676a:	685b      	ldr	r3, [r3, #4]
1000676c:	f002 fc7a 	bl	10009064 <__aeabi_dmul>
10006770:	4c1b      	ldr	r4, [pc, #108]	; (100067e0 <_dtoa_r+0x3d0>)
10006772:	112d      	asrs	r5, r5, #4
10006774:	2d00      	cmp	r5, #0
10006776:	d035      	beq.n	100067e4 <_dtoa_r+0x3d4>
10006778:	07eb      	lsls	r3, r5, #31
1000677a:	d504      	bpl.n	10006786 <_dtoa_r+0x376>
1000677c:	6822      	ldr	r2, [r4, #0]
1000677e:	6863      	ldr	r3, [r4, #4]
10006780:	3701      	adds	r7, #1
10006782:	f002 fc6f 	bl	10009064 <__aeabi_dmul>
10006786:	106d      	asrs	r5, r5, #1
10006788:	3408      	adds	r4, #8
1000678a:	e7f3      	b.n	10006774 <_dtoa_r+0x364>
1000678c:	7ff00000 	.word	0x7ff00000
10006790:	0000270f 	.word	0x0000270f
10006794:	1000a3a5 	.word	0x1000a3a5
10006798:	1000a39c 	.word	0x1000a39c
1000679c:	1000a378 	.word	0x1000a378
100067a0:	1000a379 	.word	0x1000a379
100067a4:	3ff00000 	.word	0x3ff00000
100067a8:	fffffc01 	.word	0xfffffc01
100067ac:	fffffbef 	.word	0xfffffbef
100067b0:	00000412 	.word	0x00000412
100067b4:	fffffc0e 	.word	0xfffffc0e
100067b8:	fffffbee 	.word	0xfffffbee
100067bc:	fe100000 	.word	0xfe100000
100067c0:	3ff80000 	.word	0x3ff80000
100067c4:	636f4361 	.word	0x636f4361
100067c8:	3fd287a7 	.word	0x3fd287a7
100067cc:	8b60c8b3 	.word	0x8b60c8b3
100067d0:	3fc68a28 	.word	0x3fc68a28
100067d4:	509f79fb 	.word	0x509f79fb
100067d8:	3fd34413 	.word	0x3fd34413
100067dc:	1000a418 	.word	0x1000a418
100067e0:	1000a4e0 	.word	0x1000a4e0
100067e4:	9006      	str	r0, [sp, #24]
100067e6:	9107      	str	r1, [sp, #28]
100067e8:	9b13      	ldr	r3, [sp, #76]	; 0x4c
100067ea:	2b00      	cmp	r3, #0
100067ec:	d01e      	beq.n	1000682c <_dtoa_r+0x41c>
100067ee:	9c06      	ldr	r4, [sp, #24]
100067f0:	9d07      	ldr	r5, [sp, #28]
100067f2:	2200      	movs	r2, #0
100067f4:	1c20      	adds	r0, r4, #0
100067f6:	1c29      	adds	r1, r5, #0
100067f8:	4bce      	ldr	r3, [pc, #824]	; (10006b34 <_dtoa_r+0x724>)
100067fa:	f001 fca5 	bl	10008148 <__aeabi_dcmplt>
100067fe:	2800      	cmp	r0, #0
10006800:	d014      	beq.n	1000682c <_dtoa_r+0x41c>
10006802:	9b09      	ldr	r3, [sp, #36]	; 0x24
10006804:	2b00      	cmp	r3, #0
10006806:	d011      	beq.n	1000682c <_dtoa_r+0x41c>
10006808:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
1000680a:	2b00      	cmp	r3, #0
1000680c:	dc00      	bgt.n	10006810 <_dtoa_r+0x400>
1000680e:	e0e9      	b.n	100069e4 <_dtoa_r+0x5d4>
10006810:	9b03      	ldr	r3, [sp, #12]
10006812:	1c29      	adds	r1, r5, #0
10006814:	3b01      	subs	r3, #1
10006816:	9311      	str	r3, [sp, #68]	; 0x44
10006818:	1c20      	adds	r0, r4, #0
1000681a:	2200      	movs	r2, #0
1000681c:	4bc6      	ldr	r3, [pc, #792]	; (10006b38 <_dtoa_r+0x728>)
1000681e:	f002 fc21 	bl	10009064 <__aeabi_dmul>
10006822:	3701      	adds	r7, #1
10006824:	9006      	str	r0, [sp, #24]
10006826:	9107      	str	r1, [sp, #28]
10006828:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
1000682a:	e002      	b.n	10006832 <_dtoa_r+0x422>
1000682c:	9b03      	ldr	r3, [sp, #12]
1000682e:	9d09      	ldr	r5, [sp, #36]	; 0x24
10006830:	9311      	str	r3, [sp, #68]	; 0x44
10006832:	1c38      	adds	r0, r7, #0
10006834:	9b06      	ldr	r3, [sp, #24]
10006836:	9c07      	ldr	r4, [sp, #28]
10006838:	9304      	str	r3, [sp, #16]
1000683a:	9405      	str	r4, [sp, #20]
1000683c:	f003 fa5c 	bl	10009cf8 <__aeabi_i2d>
10006840:	9a04      	ldr	r2, [sp, #16]
10006842:	9b05      	ldr	r3, [sp, #20]
10006844:	f002 fc0e 	bl	10009064 <__aeabi_dmul>
10006848:	2200      	movs	r2, #0
1000684a:	4bbc      	ldr	r3, [pc, #752]	; (10006b3c <_dtoa_r+0x72c>)
1000684c:	f001 fca4 	bl	10008198 <__aeabi_dadd>
10006850:	9006      	str	r0, [sp, #24]
10006852:	9107      	str	r1, [sp, #28]
10006854:	9e06      	ldr	r6, [sp, #24]
10006856:	9f07      	ldr	r7, [sp, #28]
10006858:	9b07      	ldr	r3, [sp, #28]
1000685a:	4ab9      	ldr	r2, [pc, #740]	; (10006b40 <_dtoa_r+0x730>)
1000685c:	189c      	adds	r4, r3, r2
1000685e:	2d00      	cmp	r5, #0
10006860:	d11c      	bne.n	1000689c <_dtoa_r+0x48c>
10006862:	9804      	ldr	r0, [sp, #16]
10006864:	9905      	ldr	r1, [sp, #20]
10006866:	2200      	movs	r2, #0
10006868:	4bb6      	ldr	r3, [pc, #728]	; (10006b44 <_dtoa_r+0x734>)
1000686a:	f002 fe95 	bl	10009598 <__aeabi_dsub>
1000686e:	1c32      	adds	r2, r6, #0
10006870:	1c23      	adds	r3, r4, #0
10006872:	9004      	str	r0, [sp, #16]
10006874:	9105      	str	r1, [sp, #20]
10006876:	f001 fc7b 	bl	10008170 <__aeabi_dcmpgt>
1000687a:	2800      	cmp	r0, #0
1000687c:	d000      	beq.n	10006880 <_dtoa_r+0x470>
1000687e:	e263      	b.n	10006d48 <_dtoa_r+0x938>
10006880:	9804      	ldr	r0, [sp, #16]
10006882:	9905      	ldr	r1, [sp, #20]
10006884:	1c32      	adds	r2, r6, #0
10006886:	4eb0      	ldr	r6, [pc, #704]	; (10006b48 <_dtoa_r+0x738>)
10006888:	9c07      	ldr	r4, [sp, #28]
1000688a:	46b4      	mov	ip, r6
1000688c:	4464      	add	r4, ip
1000688e:	1c23      	adds	r3, r4, #0
10006890:	f001 fc5a 	bl	10008148 <__aeabi_dcmplt>
10006894:	2800      	cmp	r0, #0
10006896:	d000      	beq.n	1000689a <_dtoa_r+0x48a>
10006898:	e24c      	b.n	10006d34 <_dtoa_r+0x924>
1000689a:	e0a3      	b.n	100069e4 <_dtoa_r+0x5d4>
1000689c:	4aab      	ldr	r2, [pc, #684]	; (10006b4c <_dtoa_r+0x73c>)
1000689e:	1e6b      	subs	r3, r5, #1
100068a0:	9910      	ldr	r1, [sp, #64]	; 0x40
100068a2:	00db      	lsls	r3, r3, #3
100068a4:	18d3      	adds	r3, r2, r3
100068a6:	2900      	cmp	r1, #0
100068a8:	d04e      	beq.n	10006948 <_dtoa_r+0x538>
100068aa:	681a      	ldr	r2, [r3, #0]
100068ac:	685b      	ldr	r3, [r3, #4]
100068ae:	2000      	movs	r0, #0
100068b0:	49a7      	ldr	r1, [pc, #668]	; (10006b50 <_dtoa_r+0x740>)
100068b2:	f001 ff99 	bl	100087e8 <__aeabi_ddiv>
100068b6:	1c32      	adds	r2, r6, #0
100068b8:	1c23      	adds	r3, r4, #0
100068ba:	f002 fe6d 	bl	10009598 <__aeabi_dsub>
100068be:	9e04      	ldr	r6, [sp, #16]
100068c0:	9f05      	ldr	r7, [sp, #20]
100068c2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
100068c4:	9006      	str	r0, [sp, #24]
100068c6:	9107      	str	r1, [sp, #28]
100068c8:	9304      	str	r3, [sp, #16]
100068ca:	1c39      	adds	r1, r7, #0
100068cc:	1c30      	adds	r0, r6, #0
100068ce:	f003 f9dd 	bl	10009c8c <__aeabi_d2iz>
100068d2:	1c04      	adds	r4, r0, #0
100068d4:	f003 fa10 	bl	10009cf8 <__aeabi_i2d>
100068d8:	1c02      	adds	r2, r0, #0
100068da:	1c0b      	adds	r3, r1, #0
100068dc:	1c30      	adds	r0, r6, #0
100068de:	1c39      	adds	r1, r7, #0
100068e0:	f002 fe5a 	bl	10009598 <__aeabi_dsub>
100068e4:	9b04      	ldr	r3, [sp, #16]
100068e6:	3430      	adds	r4, #48	; 0x30
100068e8:	3301      	adds	r3, #1
100068ea:	9304      	str	r3, [sp, #16]
100068ec:	3b01      	subs	r3, #1
100068ee:	701c      	strb	r4, [r3, #0]
100068f0:	9a06      	ldr	r2, [sp, #24]
100068f2:	9b07      	ldr	r3, [sp, #28]
100068f4:	1c06      	adds	r6, r0, #0
100068f6:	1c0f      	adds	r7, r1, #0
100068f8:	f001 fc26 	bl	10008148 <__aeabi_dcmplt>
100068fc:	2800      	cmp	r0, #0
100068fe:	d000      	beq.n	10006902 <_dtoa_r+0x4f2>
10006900:	e361      	b.n	10006fc6 <_dtoa_r+0xbb6>
10006902:	1c32      	adds	r2, r6, #0
10006904:	1c3b      	adds	r3, r7, #0
10006906:	2000      	movs	r0, #0
10006908:	498a      	ldr	r1, [pc, #552]	; (10006b34 <_dtoa_r+0x724>)
1000690a:	f002 fe45 	bl	10009598 <__aeabi_dsub>
1000690e:	9a06      	ldr	r2, [sp, #24]
10006910:	9b07      	ldr	r3, [sp, #28]
10006912:	f001 fc19 	bl	10008148 <__aeabi_dcmplt>
10006916:	2800      	cmp	r0, #0
10006918:	d000      	beq.n	1000691c <_dtoa_r+0x50c>
1000691a:	e0cd      	b.n	10006ab8 <_dtoa_r+0x6a8>
1000691c:	9b04      	ldr	r3, [sp, #16]
1000691e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
10006920:	1a9b      	subs	r3, r3, r2
10006922:	42ab      	cmp	r3, r5
10006924:	da5e      	bge.n	100069e4 <_dtoa_r+0x5d4>
10006926:	9806      	ldr	r0, [sp, #24]
10006928:	9907      	ldr	r1, [sp, #28]
1000692a:	2200      	movs	r2, #0
1000692c:	4b82      	ldr	r3, [pc, #520]	; (10006b38 <_dtoa_r+0x728>)
1000692e:	f002 fb99 	bl	10009064 <__aeabi_dmul>
10006932:	2200      	movs	r2, #0
10006934:	9006      	str	r0, [sp, #24]
10006936:	9107      	str	r1, [sp, #28]
10006938:	4b7f      	ldr	r3, [pc, #508]	; (10006b38 <_dtoa_r+0x728>)
1000693a:	1c30      	adds	r0, r6, #0
1000693c:	1c39      	adds	r1, r7, #0
1000693e:	f002 fb91 	bl	10009064 <__aeabi_dmul>
10006942:	1c06      	adds	r6, r0, #0
10006944:	1c0f      	adds	r7, r1, #0
10006946:	e7c0      	b.n	100068ca <_dtoa_r+0x4ba>
10006948:	6818      	ldr	r0, [r3, #0]
1000694a:	6859      	ldr	r1, [r3, #4]
1000694c:	1c32      	adds	r2, r6, #0
1000694e:	1c23      	adds	r3, r4, #0
10006950:	f002 fb88 	bl	10009064 <__aeabi_dmul>
10006954:	9e04      	ldr	r6, [sp, #16]
10006956:	9f05      	ldr	r7, [sp, #20]
10006958:	9c0c      	ldr	r4, [sp, #48]	; 0x30
1000695a:	9006      	str	r0, [sp, #24]
1000695c:	9107      	str	r1, [sp, #28]
1000695e:	1963      	adds	r3, r4, r5
10006960:	9304      	str	r3, [sp, #16]
10006962:	1c39      	adds	r1, r7, #0
10006964:	1c30      	adds	r0, r6, #0
10006966:	f003 f991 	bl	10009c8c <__aeabi_d2iz>
1000696a:	1c05      	adds	r5, r0, #0
1000696c:	f003 f9c4 	bl	10009cf8 <__aeabi_i2d>
10006970:	1c0b      	adds	r3, r1, #0
10006972:	1c02      	adds	r2, r0, #0
10006974:	1c39      	adds	r1, r7, #0
10006976:	1c30      	adds	r0, r6, #0
10006978:	f002 fe0e 	bl	10009598 <__aeabi_dsub>
1000697c:	3530      	adds	r5, #48	; 0x30
1000697e:	9b04      	ldr	r3, [sp, #16]
10006980:	7025      	strb	r5, [r4, #0]
10006982:	3401      	adds	r4, #1
10006984:	1c06      	adds	r6, r0, #0
10006986:	1c0f      	adds	r7, r1, #0
10006988:	42a3      	cmp	r3, r4
1000698a:	d124      	bne.n	100069d6 <_dtoa_r+0x5c6>
1000698c:	2200      	movs	r2, #0
1000698e:	9806      	ldr	r0, [sp, #24]
10006990:	9907      	ldr	r1, [sp, #28]
10006992:	4b6f      	ldr	r3, [pc, #444]	; (10006b50 <_dtoa_r+0x740>)
10006994:	f001 fc00 	bl	10008198 <__aeabi_dadd>
10006998:	1c02      	adds	r2, r0, #0
1000699a:	1c0b      	adds	r3, r1, #0
1000699c:	1c30      	adds	r0, r6, #0
1000699e:	1c39      	adds	r1, r7, #0
100069a0:	f001 fbe6 	bl	10008170 <__aeabi_dcmpgt>
100069a4:	2800      	cmp	r0, #0
100069a6:	d000      	beq.n	100069aa <_dtoa_r+0x59a>
100069a8:	e086      	b.n	10006ab8 <_dtoa_r+0x6a8>
100069aa:	9a06      	ldr	r2, [sp, #24]
100069ac:	9b07      	ldr	r3, [sp, #28]
100069ae:	2000      	movs	r0, #0
100069b0:	4967      	ldr	r1, [pc, #412]	; (10006b50 <_dtoa_r+0x740>)
100069b2:	f002 fdf1 	bl	10009598 <__aeabi_dsub>
100069b6:	1c02      	adds	r2, r0, #0
100069b8:	1c0b      	adds	r3, r1, #0
100069ba:	1c30      	adds	r0, r6, #0
100069bc:	1c39      	adds	r1, r7, #0
100069be:	f001 fbc3 	bl	10008148 <__aeabi_dcmplt>
100069c2:	2800      	cmp	r0, #0
100069c4:	d00e      	beq.n	100069e4 <_dtoa_r+0x5d4>
100069c6:	9b04      	ldr	r3, [sp, #16]
100069c8:	3b01      	subs	r3, #1
100069ca:	781a      	ldrb	r2, [r3, #0]
100069cc:	2a30      	cmp	r2, #48	; 0x30
100069ce:	d000      	beq.n	100069d2 <_dtoa_r+0x5c2>
100069d0:	e2f9      	b.n	10006fc6 <_dtoa_r+0xbb6>
100069d2:	9304      	str	r3, [sp, #16]
100069d4:	e7f7      	b.n	100069c6 <_dtoa_r+0x5b6>
100069d6:	2200      	movs	r2, #0
100069d8:	4b57      	ldr	r3, [pc, #348]	; (10006b38 <_dtoa_r+0x728>)
100069da:	f002 fb43 	bl	10009064 <__aeabi_dmul>
100069de:	1c06      	adds	r6, r0, #0
100069e0:	1c0f      	adds	r7, r1, #0
100069e2:	e7be      	b.n	10006962 <_dtoa_r+0x552>
100069e4:	9b14      	ldr	r3, [sp, #80]	; 0x50
100069e6:	9c15      	ldr	r4, [sp, #84]	; 0x54
100069e8:	9306      	str	r3, [sp, #24]
100069ea:	9407      	str	r4, [sp, #28]
100069ec:	9b19      	ldr	r3, [sp, #100]	; 0x64
100069ee:	2b00      	cmp	r3, #0
100069f0:	da00      	bge.n	100069f4 <_dtoa_r+0x5e4>
100069f2:	e086      	b.n	10006b02 <_dtoa_r+0x6f2>
100069f4:	9a03      	ldr	r2, [sp, #12]
100069f6:	2a0e      	cmp	r2, #14
100069f8:	dd00      	ble.n	100069fc <_dtoa_r+0x5ec>
100069fa:	e082      	b.n	10006b02 <_dtoa_r+0x6f2>
100069fc:	00d3      	lsls	r3, r2, #3
100069fe:	4a53      	ldr	r2, [pc, #332]	; (10006b4c <_dtoa_r+0x73c>)
10006a00:	18d3      	adds	r3, r2, r3
10006a02:	681e      	ldr	r6, [r3, #0]
10006a04:	685f      	ldr	r7, [r3, #4]
10006a06:	9b21      	ldr	r3, [sp, #132]	; 0x84
10006a08:	2b00      	cmp	r3, #0
10006a0a:	da14      	bge.n	10006a36 <_dtoa_r+0x626>
10006a0c:	9b09      	ldr	r3, [sp, #36]	; 0x24
10006a0e:	2b00      	cmp	r3, #0
10006a10:	dc11      	bgt.n	10006a36 <_dtoa_r+0x626>
10006a12:	d000      	beq.n	10006a16 <_dtoa_r+0x606>
10006a14:	e190      	b.n	10006d38 <_dtoa_r+0x928>
10006a16:	1c30      	adds	r0, r6, #0
10006a18:	1c39      	adds	r1, r7, #0
10006a1a:	2200      	movs	r2, #0
10006a1c:	4b49      	ldr	r3, [pc, #292]	; (10006b44 <_dtoa_r+0x734>)
10006a1e:	f002 fb21 	bl	10009064 <__aeabi_dmul>
10006a22:	9a06      	ldr	r2, [sp, #24]
10006a24:	9b07      	ldr	r3, [sp, #28]
10006a26:	f001 fbad 	bl	10008184 <__aeabi_dcmpge>
10006a2a:	9f09      	ldr	r7, [sp, #36]	; 0x24
10006a2c:	1c3e      	adds	r6, r7, #0
10006a2e:	2800      	cmp	r0, #0
10006a30:	d000      	beq.n	10006a34 <_dtoa_r+0x624>
10006a32:	e183      	b.n	10006d3c <_dtoa_r+0x92c>
10006a34:	e18c      	b.n	10006d50 <_dtoa_r+0x940>
10006a36:	9b0c      	ldr	r3, [sp, #48]	; 0x30
10006a38:	9c06      	ldr	r4, [sp, #24]
10006a3a:	9d07      	ldr	r5, [sp, #28]
10006a3c:	9304      	str	r3, [sp, #16]
10006a3e:	1c32      	adds	r2, r6, #0
10006a40:	1c3b      	adds	r3, r7, #0
10006a42:	1c20      	adds	r0, r4, #0
10006a44:	1c29      	adds	r1, r5, #0
10006a46:	f001 fecf 	bl	100087e8 <__aeabi_ddiv>
10006a4a:	f003 f91f 	bl	10009c8c <__aeabi_d2iz>
10006a4e:	9006      	str	r0, [sp, #24]
10006a50:	f003 f952 	bl	10009cf8 <__aeabi_i2d>
10006a54:	1c32      	adds	r2, r6, #0
10006a56:	1c3b      	adds	r3, r7, #0
10006a58:	f002 fb04 	bl	10009064 <__aeabi_dmul>
10006a5c:	1c02      	adds	r2, r0, #0
10006a5e:	1c0b      	adds	r3, r1, #0
10006a60:	1c20      	adds	r0, r4, #0
10006a62:	1c29      	adds	r1, r5, #0
10006a64:	f002 fd98 	bl	10009598 <__aeabi_dsub>
10006a68:	1c0b      	adds	r3, r1, #0
10006a6a:	9904      	ldr	r1, [sp, #16]
10006a6c:	1c02      	adds	r2, r0, #0
10006a6e:	9806      	ldr	r0, [sp, #24]
10006a70:	3101      	adds	r1, #1
10006a72:	9104      	str	r1, [sp, #16]
10006a74:	3030      	adds	r0, #48	; 0x30
10006a76:	3901      	subs	r1, #1
10006a78:	7008      	strb	r0, [r1, #0]
10006a7a:	980c      	ldr	r0, [sp, #48]	; 0x30
10006a7c:	9904      	ldr	r1, [sp, #16]
10006a7e:	1a09      	subs	r1, r1, r0
10006a80:	9809      	ldr	r0, [sp, #36]	; 0x24
10006a82:	4281      	cmp	r1, r0
10006a84:	d12e      	bne.n	10006ae4 <_dtoa_r+0x6d4>
10006a86:	1c10      	adds	r0, r2, #0
10006a88:	1c19      	adds	r1, r3, #0
10006a8a:	f001 fb85 	bl	10008198 <__aeabi_dadd>
10006a8e:	1c32      	adds	r2, r6, #0
10006a90:	1c3b      	adds	r3, r7, #0
10006a92:	1c04      	adds	r4, r0, #0
10006a94:	1c0d      	adds	r5, r1, #0
10006a96:	f001 fb6b 	bl	10008170 <__aeabi_dcmpgt>
10006a9a:	2800      	cmp	r0, #0
10006a9c:	d110      	bne.n	10006ac0 <_dtoa_r+0x6b0>
10006a9e:	1c20      	adds	r0, r4, #0
10006aa0:	1c29      	adds	r1, r5, #0
10006aa2:	1c32      	adds	r2, r6, #0
10006aa4:	1c3b      	adds	r3, r7, #0
10006aa6:	f001 fb49 	bl	1000813c <__aeabi_dcmpeq>
10006aaa:	2800      	cmp	r0, #0
10006aac:	d100      	bne.n	10006ab0 <_dtoa_r+0x6a0>
10006aae:	e28c      	b.n	10006fca <_dtoa_r+0xbba>
10006ab0:	9b06      	ldr	r3, [sp, #24]
10006ab2:	07db      	lsls	r3, r3, #31
10006ab4:	d404      	bmi.n	10006ac0 <_dtoa_r+0x6b0>
10006ab6:	e288      	b.n	10006fca <_dtoa_r+0xbba>
10006ab8:	9b11      	ldr	r3, [sp, #68]	; 0x44
10006aba:	9303      	str	r3, [sp, #12]
10006abc:	e000      	b.n	10006ac0 <_dtoa_r+0x6b0>
10006abe:	9304      	str	r3, [sp, #16]
10006ac0:	9b04      	ldr	r3, [sp, #16]
10006ac2:	3b01      	subs	r3, #1
10006ac4:	781a      	ldrb	r2, [r3, #0]
10006ac6:	2a39      	cmp	r2, #57	; 0x39
10006ac8:	d108      	bne.n	10006adc <_dtoa_r+0x6cc>
10006aca:	9a0c      	ldr	r2, [sp, #48]	; 0x30
10006acc:	4293      	cmp	r3, r2
10006ace:	d1f6      	bne.n	10006abe <_dtoa_r+0x6ae>
10006ad0:	9b03      	ldr	r3, [sp, #12]
10006ad2:	3301      	adds	r3, #1
10006ad4:	9303      	str	r3, [sp, #12]
10006ad6:	2330      	movs	r3, #48	; 0x30
10006ad8:	7013      	strb	r3, [r2, #0]
10006ada:	1c13      	adds	r3, r2, #0
10006adc:	781a      	ldrb	r2, [r3, #0]
10006ade:	3201      	adds	r2, #1
10006ae0:	701a      	strb	r2, [r3, #0]
10006ae2:	e272      	b.n	10006fca <_dtoa_r+0xbba>
10006ae4:	1c10      	adds	r0, r2, #0
10006ae6:	1c19      	adds	r1, r3, #0
10006ae8:	2200      	movs	r2, #0
10006aea:	4b13      	ldr	r3, [pc, #76]	; (10006b38 <_dtoa_r+0x728>)
10006aec:	f002 faba 	bl	10009064 <__aeabi_dmul>
10006af0:	2200      	movs	r2, #0
10006af2:	2300      	movs	r3, #0
10006af4:	1c04      	adds	r4, r0, #0
10006af6:	1c0d      	adds	r5, r1, #0
10006af8:	f001 fb20 	bl	1000813c <__aeabi_dcmpeq>
10006afc:	2800      	cmp	r0, #0
10006afe:	d09e      	beq.n	10006a3e <_dtoa_r+0x62e>
10006b00:	e263      	b.n	10006fca <_dtoa_r+0xbba>
10006b02:	9a10      	ldr	r2, [sp, #64]	; 0x40
10006b04:	2a00      	cmp	r2, #0
10006b06:	d044      	beq.n	10006b92 <_dtoa_r+0x782>
10006b08:	9a20      	ldr	r2, [sp, #128]	; 0x80
10006b0a:	2a01      	cmp	r2, #1
10006b0c:	dc0b      	bgt.n	10006b26 <_dtoa_r+0x716>
10006b0e:	9a16      	ldr	r2, [sp, #88]	; 0x58
10006b10:	2a00      	cmp	r2, #0
10006b12:	d002      	beq.n	10006b1a <_dtoa_r+0x70a>
10006b14:	4a0f      	ldr	r2, [pc, #60]	; (10006b54 <_dtoa_r+0x744>)
10006b16:	189b      	adds	r3, r3, r2
10006b18:	e002      	b.n	10006b20 <_dtoa_r+0x710>
10006b1a:	2336      	movs	r3, #54	; 0x36
10006b1c:	9a18      	ldr	r2, [sp, #96]	; 0x60
10006b1e:	1a9b      	subs	r3, r3, r2
10006b20:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
10006b22:	9c0d      	ldr	r4, [sp, #52]	; 0x34
10006b24:	e029      	b.n	10006b7a <_dtoa_r+0x76a>
10006b26:	9b09      	ldr	r3, [sp, #36]	; 0x24
10006b28:	1e5d      	subs	r5, r3, #1
10006b2a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
10006b2c:	42ab      	cmp	r3, r5
10006b2e:	db13      	blt.n	10006b58 <_dtoa_r+0x748>
10006b30:	1b5d      	subs	r5, r3, r5
10006b32:	e018      	b.n	10006b66 <_dtoa_r+0x756>
10006b34:	3ff00000 	.word	0x3ff00000
10006b38:	40240000 	.word	0x40240000
10006b3c:	401c0000 	.word	0x401c0000
10006b40:	fcc00000 	.word	0xfcc00000
10006b44:	40140000 	.word	0x40140000
10006b48:	7cc00000 	.word	0x7cc00000
10006b4c:	1000a418 	.word	0x1000a418
10006b50:	3fe00000 	.word	0x3fe00000
10006b54:	00000433 	.word	0x00000433
10006b58:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
10006b5a:	950f      	str	r5, [sp, #60]	; 0x3c
10006b5c:	1aea      	subs	r2, r5, r3
10006b5e:	2500      	movs	r5, #0
10006b60:	9b12      	ldr	r3, [sp, #72]	; 0x48
10006b62:	189b      	adds	r3, r3, r2
10006b64:	9312      	str	r3, [sp, #72]	; 0x48
10006b66:	9b09      	ldr	r3, [sp, #36]	; 0x24
10006b68:	2b00      	cmp	r3, #0
10006b6a:	da04      	bge.n	10006b76 <_dtoa_r+0x766>
10006b6c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
10006b6e:	9a09      	ldr	r2, [sp, #36]	; 0x24
10006b70:	1a9c      	subs	r4, r3, r2
10006b72:	2300      	movs	r3, #0
10006b74:	e001      	b.n	10006b7a <_dtoa_r+0x76a>
10006b76:	9c0d      	ldr	r4, [sp, #52]	; 0x34
10006b78:	9b09      	ldr	r3, [sp, #36]	; 0x24
10006b7a:	9a0d      	ldr	r2, [sp, #52]	; 0x34
10006b7c:	9808      	ldr	r0, [sp, #32]
10006b7e:	18d2      	adds	r2, r2, r3
10006b80:	920d      	str	r2, [sp, #52]	; 0x34
10006b82:	9a0e      	ldr	r2, [sp, #56]	; 0x38
10006b84:	2101      	movs	r1, #1
10006b86:	18d3      	adds	r3, r2, r3
10006b88:	930e      	str	r3, [sp, #56]	; 0x38
10006b8a:	f000 fd09 	bl	100075a0 <__i2b>
10006b8e:	1c06      	adds	r6, r0, #0
10006b90:	e002      	b.n	10006b98 <_dtoa_r+0x788>
10006b92:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
10006b94:	9c0d      	ldr	r4, [sp, #52]	; 0x34
10006b96:	9e10      	ldr	r6, [sp, #64]	; 0x40
10006b98:	2c00      	cmp	r4, #0
10006b9a:	d00c      	beq.n	10006bb6 <_dtoa_r+0x7a6>
10006b9c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
10006b9e:	2b00      	cmp	r3, #0
10006ba0:	dd09      	ble.n	10006bb6 <_dtoa_r+0x7a6>
10006ba2:	42a3      	cmp	r3, r4
10006ba4:	dd00      	ble.n	10006ba8 <_dtoa_r+0x798>
10006ba6:	1c23      	adds	r3, r4, #0
10006ba8:	9a0d      	ldr	r2, [sp, #52]	; 0x34
10006baa:	1ae4      	subs	r4, r4, r3
10006bac:	1ad2      	subs	r2, r2, r3
10006bae:	920d      	str	r2, [sp, #52]	; 0x34
10006bb0:	9a0e      	ldr	r2, [sp, #56]	; 0x38
10006bb2:	1ad3      	subs	r3, r2, r3
10006bb4:	930e      	str	r3, [sp, #56]	; 0x38
10006bb6:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
10006bb8:	2b00      	cmp	r3, #0
10006bba:	dd21      	ble.n	10006c00 <_dtoa_r+0x7f0>
10006bbc:	9b10      	ldr	r3, [sp, #64]	; 0x40
10006bbe:	2b00      	cmp	r3, #0
10006bc0:	d018      	beq.n	10006bf4 <_dtoa_r+0x7e4>
10006bc2:	2d00      	cmp	r5, #0
10006bc4:	dd10      	ble.n	10006be8 <_dtoa_r+0x7d8>
10006bc6:	1c31      	adds	r1, r6, #0
10006bc8:	1c2a      	adds	r2, r5, #0
10006bca:	9808      	ldr	r0, [sp, #32]
10006bcc:	f000 fd7e 	bl	100076cc <__pow5mult>
10006bd0:	1c06      	adds	r6, r0, #0
10006bd2:	9a0a      	ldr	r2, [sp, #40]	; 0x28
10006bd4:	1c31      	adds	r1, r6, #0
10006bd6:	9808      	ldr	r0, [sp, #32]
10006bd8:	f000 fceb 	bl	100075b2 <__multiply>
10006bdc:	1c07      	adds	r7, r0, #0
10006bde:	990a      	ldr	r1, [sp, #40]	; 0x28
10006be0:	9808      	ldr	r0, [sp, #32]
10006be2:	f000 fc3e 	bl	10007462 <_Bfree>
10006be6:	970a      	str	r7, [sp, #40]	; 0x28
10006be8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
10006bea:	1b5a      	subs	r2, r3, r5
10006bec:	d008      	beq.n	10006c00 <_dtoa_r+0x7f0>
10006bee:	9808      	ldr	r0, [sp, #32]
10006bf0:	990a      	ldr	r1, [sp, #40]	; 0x28
10006bf2:	e002      	b.n	10006bfa <_dtoa_r+0x7ea>
10006bf4:	9808      	ldr	r0, [sp, #32]
10006bf6:	990a      	ldr	r1, [sp, #40]	; 0x28
10006bf8:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
10006bfa:	f000 fd67 	bl	100076cc <__pow5mult>
10006bfe:	900a      	str	r0, [sp, #40]	; 0x28
10006c00:	9808      	ldr	r0, [sp, #32]
10006c02:	2101      	movs	r1, #1
10006c04:	f000 fccc 	bl	100075a0 <__i2b>
10006c08:	9b12      	ldr	r3, [sp, #72]	; 0x48
10006c0a:	1c07      	adds	r7, r0, #0
10006c0c:	2b00      	cmp	r3, #0
10006c0e:	dd0a      	ble.n	10006c26 <_dtoa_r+0x816>
10006c10:	1c39      	adds	r1, r7, #0
10006c12:	1c1a      	adds	r2, r3, #0
10006c14:	9808      	ldr	r0, [sp, #32]
10006c16:	f000 fd59 	bl	100076cc <__pow5mult>
10006c1a:	9b20      	ldr	r3, [sp, #128]	; 0x80
10006c1c:	1c07      	adds	r7, r0, #0
10006c1e:	2500      	movs	r5, #0
10006c20:	2b01      	cmp	r3, #1
10006c22:	dc1b      	bgt.n	10006c5c <_dtoa_r+0x84c>
10006c24:	e003      	b.n	10006c2e <_dtoa_r+0x81e>
10006c26:	9b20      	ldr	r3, [sp, #128]	; 0x80
10006c28:	2500      	movs	r5, #0
10006c2a:	2b01      	cmp	r3, #1
10006c2c:	dc12      	bgt.n	10006c54 <_dtoa_r+0x844>
10006c2e:	2500      	movs	r5, #0
10006c30:	9b06      	ldr	r3, [sp, #24]
10006c32:	42ab      	cmp	r3, r5
10006c34:	d10e      	bne.n	10006c54 <_dtoa_r+0x844>
10006c36:	9b07      	ldr	r3, [sp, #28]
10006c38:	031b      	lsls	r3, r3, #12
10006c3a:	42ab      	cmp	r3, r5
10006c3c:	d10a      	bne.n	10006c54 <_dtoa_r+0x844>
10006c3e:	9b17      	ldr	r3, [sp, #92]	; 0x5c
10006c40:	9a07      	ldr	r2, [sp, #28]
10006c42:	4213      	tst	r3, r2
10006c44:	d006      	beq.n	10006c54 <_dtoa_r+0x844>
10006c46:	9b0d      	ldr	r3, [sp, #52]	; 0x34
10006c48:	3501      	adds	r5, #1
10006c4a:	3301      	adds	r3, #1
10006c4c:	930d      	str	r3, [sp, #52]	; 0x34
10006c4e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
10006c50:	3301      	adds	r3, #1
10006c52:	930e      	str	r3, [sp, #56]	; 0x38
10006c54:	9b12      	ldr	r3, [sp, #72]	; 0x48
10006c56:	2001      	movs	r0, #1
10006c58:	2b00      	cmp	r3, #0
10006c5a:	d008      	beq.n	10006c6e <_dtoa_r+0x85e>
10006c5c:	693b      	ldr	r3, [r7, #16]
10006c5e:	3303      	adds	r3, #3
10006c60:	009b      	lsls	r3, r3, #2
10006c62:	18fb      	adds	r3, r7, r3
10006c64:	6858      	ldr	r0, [r3, #4]
10006c66:	f000 fc51 	bl	1000750c <__hi0bits>
10006c6a:	2320      	movs	r3, #32
10006c6c:	1a18      	subs	r0, r3, r0
10006c6e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
10006c70:	18c0      	adds	r0, r0, r3
10006c72:	231f      	movs	r3, #31
10006c74:	4018      	ands	r0, r3
10006c76:	d009      	beq.n	10006c8c <_dtoa_r+0x87c>
10006c78:	3301      	adds	r3, #1
10006c7a:	1a1b      	subs	r3, r3, r0
10006c7c:	2b04      	cmp	r3, #4
10006c7e:	dd02      	ble.n	10006c86 <_dtoa_r+0x876>
10006c80:	231c      	movs	r3, #28
10006c82:	1a18      	subs	r0, r3, r0
10006c84:	e003      	b.n	10006c8e <_dtoa_r+0x87e>
10006c86:	2b04      	cmp	r3, #4
10006c88:	d008      	beq.n	10006c9c <_dtoa_r+0x88c>
10006c8a:	1c18      	adds	r0, r3, #0
10006c8c:	301c      	adds	r0, #28
10006c8e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
10006c90:	1824      	adds	r4, r4, r0
10006c92:	181b      	adds	r3, r3, r0
10006c94:	930d      	str	r3, [sp, #52]	; 0x34
10006c96:	9b0e      	ldr	r3, [sp, #56]	; 0x38
10006c98:	181b      	adds	r3, r3, r0
10006c9a:	930e      	str	r3, [sp, #56]	; 0x38
10006c9c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
10006c9e:	2b00      	cmp	r3, #0
10006ca0:	dd05      	ble.n	10006cae <_dtoa_r+0x89e>
10006ca2:	9808      	ldr	r0, [sp, #32]
10006ca4:	990a      	ldr	r1, [sp, #40]	; 0x28
10006ca6:	1c1a      	adds	r2, r3, #0
10006ca8:	f000 fd62 	bl	10007770 <__lshift>
10006cac:	900a      	str	r0, [sp, #40]	; 0x28
10006cae:	9b0e      	ldr	r3, [sp, #56]	; 0x38
10006cb0:	2b00      	cmp	r3, #0
10006cb2:	dd05      	ble.n	10006cc0 <_dtoa_r+0x8b0>
10006cb4:	1c39      	adds	r1, r7, #0
10006cb6:	9808      	ldr	r0, [sp, #32]
10006cb8:	1c1a      	adds	r2, r3, #0
10006cba:	f000 fd59 	bl	10007770 <__lshift>
10006cbe:	1c07      	adds	r7, r0, #0
10006cc0:	9b13      	ldr	r3, [sp, #76]	; 0x4c
10006cc2:	2b00      	cmp	r3, #0
10006cc4:	d01e      	beq.n	10006d04 <_dtoa_r+0x8f4>
10006cc6:	980a      	ldr	r0, [sp, #40]	; 0x28
10006cc8:	1c39      	adds	r1, r7, #0
10006cca:	f000 fda3 	bl	10007814 <__mcmp>
10006cce:	2800      	cmp	r0, #0
10006cd0:	da18      	bge.n	10006d04 <_dtoa_r+0x8f4>
10006cd2:	9b03      	ldr	r3, [sp, #12]
10006cd4:	9808      	ldr	r0, [sp, #32]
10006cd6:	3b01      	subs	r3, #1
10006cd8:	9303      	str	r3, [sp, #12]
10006cda:	990a      	ldr	r1, [sp, #40]	; 0x28
10006cdc:	2300      	movs	r3, #0
10006cde:	220a      	movs	r2, #10
10006ce0:	f000 fbd8 	bl	10007494 <__multadd>
10006ce4:	9b10      	ldr	r3, [sp, #64]	; 0x40
10006ce6:	900a      	str	r0, [sp, #40]	; 0x28
10006ce8:	2b00      	cmp	r3, #0
10006cea:	d100      	bne.n	10006cee <_dtoa_r+0x8de>
10006cec:	e17f      	b.n	10006fee <_dtoa_r+0xbde>
10006cee:	1c31      	adds	r1, r6, #0
10006cf0:	2300      	movs	r3, #0
10006cf2:	9808      	ldr	r0, [sp, #32]
10006cf4:	220a      	movs	r2, #10
10006cf6:	f000 fbcd 	bl	10007494 <__multadd>
10006cfa:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
10006cfc:	1c06      	adds	r6, r0, #0
10006cfe:	2b00      	cmp	r3, #0
10006d00:	dc3c      	bgt.n	10006d7c <_dtoa_r+0x96c>
10006d02:	e17d      	b.n	10007000 <_dtoa_r+0xbf0>
10006d04:	9b09      	ldr	r3, [sp, #36]	; 0x24
10006d06:	2b00      	cmp	r3, #0
10006d08:	dc2e      	bgt.n	10006d68 <_dtoa_r+0x958>
10006d0a:	9b20      	ldr	r3, [sp, #128]	; 0x80
10006d0c:	2b02      	cmp	r3, #2
10006d0e:	dd2b      	ble.n	10006d68 <_dtoa_r+0x958>
10006d10:	9b09      	ldr	r3, [sp, #36]	; 0x24
10006d12:	930b      	str	r3, [sp, #44]	; 0x2c
10006d14:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
10006d16:	2b00      	cmp	r3, #0
10006d18:	d110      	bne.n	10006d3c <_dtoa_r+0x92c>
10006d1a:	1c39      	adds	r1, r7, #0
10006d1c:	9808      	ldr	r0, [sp, #32]
10006d1e:	2205      	movs	r2, #5
10006d20:	f000 fbb8 	bl	10007494 <__multadd>
10006d24:	1c07      	adds	r7, r0, #0
10006d26:	980a      	ldr	r0, [sp, #40]	; 0x28
10006d28:	1c39      	adds	r1, r7, #0
10006d2a:	f000 fd73 	bl	10007814 <__mcmp>
10006d2e:	2800      	cmp	r0, #0
10006d30:	dc0e      	bgt.n	10006d50 <_dtoa_r+0x940>
10006d32:	e003      	b.n	10006d3c <_dtoa_r+0x92c>
10006d34:	1c2f      	adds	r7, r5, #0
10006d36:	e000      	b.n	10006d3a <_dtoa_r+0x92a>
10006d38:	2700      	movs	r7, #0
10006d3a:	1c3e      	adds	r6, r7, #0
10006d3c:	9b21      	ldr	r3, [sp, #132]	; 0x84
10006d3e:	43db      	mvns	r3, r3
10006d40:	9303      	str	r3, [sp, #12]
10006d42:	9b0c      	ldr	r3, [sp, #48]	; 0x30
10006d44:	9304      	str	r3, [sp, #16]
10006d46:	e00c      	b.n	10006d62 <_dtoa_r+0x952>
10006d48:	1c2f      	adds	r7, r5, #0
10006d4a:	1c2e      	adds	r6, r5, #0
10006d4c:	9b11      	ldr	r3, [sp, #68]	; 0x44
10006d4e:	9303      	str	r3, [sp, #12]
10006d50:	9b0c      	ldr	r3, [sp, #48]	; 0x30
10006d52:	9a0c      	ldr	r2, [sp, #48]	; 0x30
10006d54:	3301      	adds	r3, #1
10006d56:	9304      	str	r3, [sp, #16]
10006d58:	2331      	movs	r3, #49	; 0x31
10006d5a:	7013      	strb	r3, [r2, #0]
10006d5c:	9b03      	ldr	r3, [sp, #12]
10006d5e:	3301      	adds	r3, #1
10006d60:	9303      	str	r3, [sp, #12]
10006d62:	9609      	str	r6, [sp, #36]	; 0x24
10006d64:	2600      	movs	r6, #0
10006d66:	e11a      	b.n	10006f9e <_dtoa_r+0xb8e>
10006d68:	9b10      	ldr	r3, [sp, #64]	; 0x40
10006d6a:	2b00      	cmp	r3, #0
10006d6c:	d104      	bne.n	10006d78 <_dtoa_r+0x968>
10006d6e:	9b09      	ldr	r3, [sp, #36]	; 0x24
10006d70:	930b      	str	r3, [sp, #44]	; 0x2c
10006d72:	9d0c      	ldr	r5, [sp, #48]	; 0x30
10006d74:	9c0a      	ldr	r4, [sp, #40]	; 0x28
10006d76:	e0d0      	b.n	10006f1a <_dtoa_r+0xb0a>
10006d78:	9b09      	ldr	r3, [sp, #36]	; 0x24
10006d7a:	930b      	str	r3, [sp, #44]	; 0x2c
10006d7c:	2c00      	cmp	r4, #0
10006d7e:	dd05      	ble.n	10006d8c <_dtoa_r+0x97c>
10006d80:	1c31      	adds	r1, r6, #0
10006d82:	9808      	ldr	r0, [sp, #32]
10006d84:	1c22      	adds	r2, r4, #0
10006d86:	f000 fcf3 	bl	10007770 <__lshift>
10006d8a:	1c06      	adds	r6, r0, #0
10006d8c:	9609      	str	r6, [sp, #36]	; 0x24
10006d8e:	2d00      	cmp	r5, #0
10006d90:	d012      	beq.n	10006db8 <_dtoa_r+0x9a8>
10006d92:	6871      	ldr	r1, [r6, #4]
10006d94:	9808      	ldr	r0, [sp, #32]
10006d96:	f000 fb2c 	bl	100073f2 <_Balloc>
10006d9a:	1c31      	adds	r1, r6, #0
10006d9c:	1c04      	adds	r4, r0, #0
10006d9e:	6933      	ldr	r3, [r6, #16]
10006da0:	310c      	adds	r1, #12
10006da2:	1c9a      	adds	r2, r3, #2
10006da4:	0092      	lsls	r2, r2, #2
10006da6:	300c      	adds	r0, #12
10006da8:	f7fe fbf0 	bl	1000558c <memcpy>
10006dac:	9808      	ldr	r0, [sp, #32]
10006dae:	1c21      	adds	r1, r4, #0
10006db0:	2201      	movs	r2, #1
10006db2:	f000 fcdd 	bl	10007770 <__lshift>
10006db6:	9009      	str	r0, [sp, #36]	; 0x24
10006db8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
10006dba:	9a0c      	ldr	r2, [sp, #48]	; 0x30
10006dbc:	930e      	str	r3, [sp, #56]	; 0x38
10006dbe:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
10006dc0:	9c0a      	ldr	r4, [sp, #40]	; 0x28
10006dc2:	3b01      	subs	r3, #1
10006dc4:	18d3      	adds	r3, r2, r3
10006dc6:	9310      	str	r3, [sp, #64]	; 0x40
10006dc8:	1c39      	adds	r1, r7, #0
10006dca:	1c20      	adds	r0, r4, #0
10006dcc:	f7ff fa98 	bl	10006300 <quorem>
10006dd0:	1c03      	adds	r3, r0, #0
10006dd2:	900f      	str	r0, [sp, #60]	; 0x3c
10006dd4:	3330      	adds	r3, #48	; 0x30
10006dd6:	1c31      	adds	r1, r6, #0
10006dd8:	1c20      	adds	r0, r4, #0
10006dda:	930d      	str	r3, [sp, #52]	; 0x34
10006ddc:	f000 fd1a 	bl	10007814 <__mcmp>
10006de0:	1c39      	adds	r1, r7, #0
10006de2:	900b      	str	r0, [sp, #44]	; 0x2c
10006de4:	9a09      	ldr	r2, [sp, #36]	; 0x24
10006de6:	9808      	ldr	r0, [sp, #32]
10006de8:	f000 fd2f 	bl	1000784a <__mdiff>
10006dec:	2301      	movs	r3, #1
10006dee:	9304      	str	r3, [sp, #16]
10006df0:	68c3      	ldr	r3, [r0, #12]
10006df2:	1c05      	adds	r5, r0, #0
10006df4:	2b00      	cmp	r3, #0
10006df6:	d104      	bne.n	10006e02 <_dtoa_r+0x9f2>
10006df8:	1c20      	adds	r0, r4, #0
10006dfa:	1c29      	adds	r1, r5, #0
10006dfc:	f000 fd0a 	bl	10007814 <__mcmp>
10006e00:	9004      	str	r0, [sp, #16]
10006e02:	9808      	ldr	r0, [sp, #32]
10006e04:	1c29      	adds	r1, r5, #0
10006e06:	f000 fb2c 	bl	10007462 <_Bfree>
10006e0a:	9b04      	ldr	r3, [sp, #16]
10006e0c:	9a20      	ldr	r2, [sp, #128]	; 0x80
10006e0e:	4313      	orrs	r3, r2
10006e10:	d110      	bne.n	10006e34 <_dtoa_r+0xa24>
10006e12:	9a06      	ldr	r2, [sp, #24]
10006e14:	3301      	adds	r3, #1
10006e16:	4213      	tst	r3, r2
10006e18:	d10c      	bne.n	10006e34 <_dtoa_r+0xa24>
10006e1a:	980d      	ldr	r0, [sp, #52]	; 0x34
10006e1c:	940a      	str	r4, [sp, #40]	; 0x28
10006e1e:	2839      	cmp	r0, #57	; 0x39
10006e20:	d03d      	beq.n	10006e9e <_dtoa_r+0xa8e>
10006e22:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
10006e24:	2b00      	cmp	r3, #0
10006e26:	dd01      	ble.n	10006e2c <_dtoa_r+0xa1c>
10006e28:	980f      	ldr	r0, [sp, #60]	; 0x3c
10006e2a:	3031      	adds	r0, #49	; 0x31
10006e2c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
10006e2e:	3301      	adds	r3, #1
10006e30:	9304      	str	r3, [sp, #16]
10006e32:	e03e      	b.n	10006eb2 <_dtoa_r+0xaa2>
10006e34:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
10006e36:	2b00      	cmp	r3, #0
10006e38:	da05      	bge.n	10006e46 <_dtoa_r+0xa36>
10006e3a:	9b04      	ldr	r3, [sp, #16]
10006e3c:	9d0d      	ldr	r5, [sp, #52]	; 0x34
10006e3e:	940a      	str	r4, [sp, #40]	; 0x28
10006e40:	2b00      	cmp	r3, #0
10006e42:	dc09      	bgt.n	10006e58 <_dtoa_r+0xa48>
10006e44:	e01c      	b.n	10006e80 <_dtoa_r+0xa70>
10006e46:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
10006e48:	9b20      	ldr	r3, [sp, #128]	; 0x80
10006e4a:	431d      	orrs	r5, r3
10006e4c:	d11e      	bne.n	10006e8c <_dtoa_r+0xa7c>
10006e4e:	2301      	movs	r3, #1
10006e50:	9a06      	ldr	r2, [sp, #24]
10006e52:	4213      	tst	r3, r2
10006e54:	d11a      	bne.n	10006e8c <_dtoa_r+0xa7c>
10006e56:	e7f0      	b.n	10006e3a <_dtoa_r+0xa2a>
10006e58:	1c21      	adds	r1, r4, #0
10006e5a:	9808      	ldr	r0, [sp, #32]
10006e5c:	2201      	movs	r2, #1
10006e5e:	f000 fc87 	bl	10007770 <__lshift>
10006e62:	1c39      	adds	r1, r7, #0
10006e64:	900a      	str	r0, [sp, #40]	; 0x28
10006e66:	f000 fcd5 	bl	10007814 <__mcmp>
10006e6a:	2800      	cmp	r0, #0
10006e6c:	dc03      	bgt.n	10006e76 <_dtoa_r+0xa66>
10006e6e:	d107      	bne.n	10006e80 <_dtoa_r+0xa70>
10006e70:	9b0d      	ldr	r3, [sp, #52]	; 0x34
10006e72:	07db      	lsls	r3, r3, #31
10006e74:	d504      	bpl.n	10006e80 <_dtoa_r+0xa70>
10006e76:	9b0d      	ldr	r3, [sp, #52]	; 0x34
10006e78:	2b39      	cmp	r3, #57	; 0x39
10006e7a:	d010      	beq.n	10006e9e <_dtoa_r+0xa8e>
10006e7c:	1c1d      	adds	r5, r3, #0
10006e7e:	3501      	adds	r5, #1
10006e80:	9b0e      	ldr	r3, [sp, #56]	; 0x38
10006e82:	3301      	adds	r3, #1
10006e84:	9304      	str	r3, [sp, #16]
10006e86:	9b0e      	ldr	r3, [sp, #56]	; 0x38
10006e88:	701d      	strb	r5, [r3, #0]
10006e8a:	e088      	b.n	10006f9e <_dtoa_r+0xb8e>
10006e8c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
10006e8e:	1c5d      	adds	r5, r3, #1
10006e90:	9b04      	ldr	r3, [sp, #16]
10006e92:	2b00      	cmp	r3, #0
10006e94:	dd10      	ble.n	10006eb8 <_dtoa_r+0xaa8>
10006e96:	9b0d      	ldr	r3, [sp, #52]	; 0x34
10006e98:	940a      	str	r4, [sp, #40]	; 0x28
10006e9a:	2b39      	cmp	r3, #57	; 0x39
10006e9c:	d106      	bne.n	10006eac <_dtoa_r+0xa9c>
10006e9e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
10006ea0:	9a0e      	ldr	r2, [sp, #56]	; 0x38
10006ea2:	3301      	adds	r3, #1
10006ea4:	9304      	str	r3, [sp, #16]
10006ea6:	2339      	movs	r3, #57	; 0x39
10006ea8:	7013      	strb	r3, [r2, #0]
10006eaa:	e060      	b.n	10006f6e <_dtoa_r+0xb5e>
10006eac:	980d      	ldr	r0, [sp, #52]	; 0x34
10006eae:	9504      	str	r5, [sp, #16]
10006eb0:	3001      	adds	r0, #1
10006eb2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
10006eb4:	7018      	strb	r0, [r3, #0]
10006eb6:	e072      	b.n	10006f9e <_dtoa_r+0xb8e>
10006eb8:	466a      	mov	r2, sp
10006eba:	2134      	movs	r1, #52	; 0x34
10006ebc:	1852      	adds	r2, r2, r1
10006ebe:	7812      	ldrb	r2, [r2, #0]
10006ec0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
10006ec2:	9504      	str	r5, [sp, #16]
10006ec4:	701a      	strb	r2, [r3, #0]
10006ec6:	9a10      	ldr	r2, [sp, #64]	; 0x40
10006ec8:	4293      	cmp	r3, r2
10006eca:	d03f      	beq.n	10006f4c <_dtoa_r+0xb3c>
10006ecc:	1c21      	adds	r1, r4, #0
10006ece:	220a      	movs	r2, #10
10006ed0:	2300      	movs	r3, #0
10006ed2:	9808      	ldr	r0, [sp, #32]
10006ed4:	f000 fade 	bl	10007494 <__multadd>
10006ed8:	9b09      	ldr	r3, [sp, #36]	; 0x24
10006eda:	1c04      	adds	r4, r0, #0
10006edc:	1c31      	adds	r1, r6, #0
10006ede:	9808      	ldr	r0, [sp, #32]
10006ee0:	220a      	movs	r2, #10
10006ee2:	429e      	cmp	r6, r3
10006ee4:	d105      	bne.n	10006ef2 <_dtoa_r+0xae2>
10006ee6:	2300      	movs	r3, #0
10006ee8:	f000 fad4 	bl	10007494 <__multadd>
10006eec:	1c06      	adds	r6, r0, #0
10006eee:	9009      	str	r0, [sp, #36]	; 0x24
10006ef0:	e00a      	b.n	10006f08 <_dtoa_r+0xaf8>
10006ef2:	2300      	movs	r3, #0
10006ef4:	f000 face 	bl	10007494 <__multadd>
10006ef8:	9909      	ldr	r1, [sp, #36]	; 0x24
10006efa:	1c06      	adds	r6, r0, #0
10006efc:	220a      	movs	r2, #10
10006efe:	9808      	ldr	r0, [sp, #32]
10006f00:	2300      	movs	r3, #0
10006f02:	f000 fac7 	bl	10007494 <__multadd>
10006f06:	9009      	str	r0, [sp, #36]	; 0x24
10006f08:	950e      	str	r5, [sp, #56]	; 0x38
10006f0a:	e75d      	b.n	10006dc8 <_dtoa_r+0x9b8>
10006f0c:	1c21      	adds	r1, r4, #0
10006f0e:	9808      	ldr	r0, [sp, #32]
10006f10:	220a      	movs	r2, #10
10006f12:	2300      	movs	r3, #0
10006f14:	f000 fabe 	bl	10007494 <__multadd>
10006f18:	1c04      	adds	r4, r0, #0
10006f1a:	1c20      	adds	r0, r4, #0
10006f1c:	1c39      	adds	r1, r7, #0
10006f1e:	f7ff f9ef 	bl	10006300 <quorem>
10006f22:	2234      	movs	r2, #52	; 0x34
10006f24:	466b      	mov	r3, sp
10006f26:	3030      	adds	r0, #48	; 0x30
10006f28:	189b      	adds	r3, r3, r2
10006f2a:	900d      	str	r0, [sp, #52]	; 0x34
10006f2c:	781b      	ldrb	r3, [r3, #0]
10006f2e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
10006f30:	702b      	strb	r3, [r5, #0]
10006f32:	9b0c      	ldr	r3, [sp, #48]	; 0x30
10006f34:	3501      	adds	r5, #1
10006f36:	1aeb      	subs	r3, r5, r3
10006f38:	4293      	cmp	r3, r2
10006f3a:	dbe7      	blt.n	10006f0c <_dtoa_r+0xafc>
10006f3c:	1e13      	subs	r3, r2, #0
10006f3e:	dc00      	bgt.n	10006f42 <_dtoa_r+0xb32>
10006f40:	2301      	movs	r3, #1
10006f42:	9609      	str	r6, [sp, #36]	; 0x24
10006f44:	2600      	movs	r6, #0
10006f46:	9a0c      	ldr	r2, [sp, #48]	; 0x30
10006f48:	18d3      	adds	r3, r2, r3
10006f4a:	9304      	str	r3, [sp, #16]
10006f4c:	1c21      	adds	r1, r4, #0
10006f4e:	9808      	ldr	r0, [sp, #32]
10006f50:	2201      	movs	r2, #1
10006f52:	f000 fc0d 	bl	10007770 <__lshift>
10006f56:	1c39      	adds	r1, r7, #0
10006f58:	900a      	str	r0, [sp, #40]	; 0x28
10006f5a:	f000 fc5b 	bl	10007814 <__mcmp>
10006f5e:	2800      	cmp	r0, #0
10006f60:	dc05      	bgt.n	10006f6e <_dtoa_r+0xb5e>
10006f62:	d115      	bne.n	10006f90 <_dtoa_r+0xb80>
10006f64:	9b0d      	ldr	r3, [sp, #52]	; 0x34
10006f66:	07db      	lsls	r3, r3, #31
10006f68:	d401      	bmi.n	10006f6e <_dtoa_r+0xb5e>
10006f6a:	e011      	b.n	10006f90 <_dtoa_r+0xb80>
10006f6c:	9304      	str	r3, [sp, #16]
10006f6e:	9b04      	ldr	r3, [sp, #16]
10006f70:	3b01      	subs	r3, #1
10006f72:	781a      	ldrb	r2, [r3, #0]
10006f74:	2a39      	cmp	r2, #57	; 0x39
10006f76:	d108      	bne.n	10006f8a <_dtoa_r+0xb7a>
10006f78:	9a0c      	ldr	r2, [sp, #48]	; 0x30
10006f7a:	4293      	cmp	r3, r2
10006f7c:	d1f6      	bne.n	10006f6c <_dtoa_r+0xb5c>
10006f7e:	9b03      	ldr	r3, [sp, #12]
10006f80:	3301      	adds	r3, #1
10006f82:	9303      	str	r3, [sp, #12]
10006f84:	2331      	movs	r3, #49	; 0x31
10006f86:	7013      	strb	r3, [r2, #0]
10006f88:	e009      	b.n	10006f9e <_dtoa_r+0xb8e>
10006f8a:	3201      	adds	r2, #1
10006f8c:	701a      	strb	r2, [r3, #0]
10006f8e:	e006      	b.n	10006f9e <_dtoa_r+0xb8e>
10006f90:	9b04      	ldr	r3, [sp, #16]
10006f92:	3b01      	subs	r3, #1
10006f94:	781a      	ldrb	r2, [r3, #0]
10006f96:	2a30      	cmp	r2, #48	; 0x30
10006f98:	d101      	bne.n	10006f9e <_dtoa_r+0xb8e>
10006f9a:	9304      	str	r3, [sp, #16]
10006f9c:	e7f8      	b.n	10006f90 <_dtoa_r+0xb80>
10006f9e:	9808      	ldr	r0, [sp, #32]
10006fa0:	1c39      	adds	r1, r7, #0
10006fa2:	f000 fa5e 	bl	10007462 <_Bfree>
10006fa6:	9b09      	ldr	r3, [sp, #36]	; 0x24
10006fa8:	2b00      	cmp	r3, #0
10006faa:	d00e      	beq.n	10006fca <_dtoa_r+0xbba>
10006fac:	2e00      	cmp	r6, #0
10006fae:	d005      	beq.n	10006fbc <_dtoa_r+0xbac>
10006fb0:	429e      	cmp	r6, r3
10006fb2:	d003      	beq.n	10006fbc <_dtoa_r+0xbac>
10006fb4:	9808      	ldr	r0, [sp, #32]
10006fb6:	1c31      	adds	r1, r6, #0
10006fb8:	f000 fa53 	bl	10007462 <_Bfree>
10006fbc:	9808      	ldr	r0, [sp, #32]
10006fbe:	9909      	ldr	r1, [sp, #36]	; 0x24
10006fc0:	f000 fa4f 	bl	10007462 <_Bfree>
10006fc4:	e001      	b.n	10006fca <_dtoa_r+0xbba>
10006fc6:	9b11      	ldr	r3, [sp, #68]	; 0x44
10006fc8:	9303      	str	r3, [sp, #12]
10006fca:	9808      	ldr	r0, [sp, #32]
10006fcc:	990a      	ldr	r1, [sp, #40]	; 0x28
10006fce:	f000 fa48 	bl	10007462 <_Bfree>
10006fd2:	2300      	movs	r3, #0
10006fd4:	9a04      	ldr	r2, [sp, #16]
10006fd6:	980c      	ldr	r0, [sp, #48]	; 0x30
10006fd8:	7013      	strb	r3, [r2, #0]
10006fda:	9b03      	ldr	r3, [sp, #12]
10006fdc:	9a22      	ldr	r2, [sp, #136]	; 0x88
10006fde:	3301      	adds	r3, #1
10006fe0:	6013      	str	r3, [r2, #0]
10006fe2:	9b24      	ldr	r3, [sp, #144]	; 0x90
10006fe4:	2b00      	cmp	r3, #0
10006fe6:	d010      	beq.n	1000700a <_dtoa_r+0xbfa>
10006fe8:	9a04      	ldr	r2, [sp, #16]
10006fea:	601a      	str	r2, [r3, #0]
10006fec:	e00d      	b.n	1000700a <_dtoa_r+0xbfa>
10006fee:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
10006ff0:	2b00      	cmp	r3, #0
10006ff2:	dd00      	ble.n	10006ff6 <_dtoa_r+0xbe6>
10006ff4:	e6bd      	b.n	10006d72 <_dtoa_r+0x962>
10006ff6:	9b20      	ldr	r3, [sp, #128]	; 0x80
10006ff8:	2b02      	cmp	r3, #2
10006ffa:	dd00      	ble.n	10006ffe <_dtoa_r+0xbee>
10006ffc:	e68a      	b.n	10006d14 <_dtoa_r+0x904>
10006ffe:	e6b8      	b.n	10006d72 <_dtoa_r+0x962>
10007000:	9b20      	ldr	r3, [sp, #128]	; 0x80
10007002:	2b02      	cmp	r3, #2
10007004:	dd00      	ble.n	10007008 <_dtoa_r+0xbf8>
10007006:	e685      	b.n	10006d14 <_dtoa_r+0x904>
10007008:	e6b8      	b.n	10006d7c <_dtoa_r+0x96c>
1000700a:	b01b      	add	sp, #108	; 0x6c
1000700c:	bdf0      	pop	{r4, r5, r6, r7, pc}
1000700e:	46c0      	nop			; (mov r8, r8)

10007010 <__sflush_r>:
10007010:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
10007012:	898a      	ldrh	r2, [r1, #12]
10007014:	1c05      	adds	r5, r0, #0
10007016:	1c0c      	adds	r4, r1, #0
10007018:	0713      	lsls	r3, r2, #28
1000701a:	d45e      	bmi.n	100070da <__sflush_r+0xca>
1000701c:	684b      	ldr	r3, [r1, #4]
1000701e:	2b00      	cmp	r3, #0
10007020:	dc02      	bgt.n	10007028 <__sflush_r+0x18>
10007022:	6c0b      	ldr	r3, [r1, #64]	; 0x40
10007024:	2b00      	cmp	r3, #0
10007026:	dd1a      	ble.n	1000705e <__sflush_r+0x4e>
10007028:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
1000702a:	2f00      	cmp	r7, #0
1000702c:	d017      	beq.n	1000705e <__sflush_r+0x4e>
1000702e:	2300      	movs	r3, #0
10007030:	682e      	ldr	r6, [r5, #0]
10007032:	602b      	str	r3, [r5, #0]
10007034:	2380      	movs	r3, #128	; 0x80
10007036:	015b      	lsls	r3, r3, #5
10007038:	401a      	ands	r2, r3
1000703a:	d001      	beq.n	10007040 <__sflush_r+0x30>
1000703c:	6d62      	ldr	r2, [r4, #84]	; 0x54
1000703e:	e015      	b.n	1000706c <__sflush_r+0x5c>
10007040:	1c28      	adds	r0, r5, #0
10007042:	6a21      	ldr	r1, [r4, #32]
10007044:	2301      	movs	r3, #1
10007046:	47b8      	blx	r7
10007048:	1c02      	adds	r2, r0, #0
1000704a:	1c43      	adds	r3, r0, #1
1000704c:	d10e      	bne.n	1000706c <__sflush_r+0x5c>
1000704e:	682b      	ldr	r3, [r5, #0]
10007050:	2b00      	cmp	r3, #0
10007052:	d00b      	beq.n	1000706c <__sflush_r+0x5c>
10007054:	2b1d      	cmp	r3, #29
10007056:	d001      	beq.n	1000705c <__sflush_r+0x4c>
10007058:	2b16      	cmp	r3, #22
1000705a:	d102      	bne.n	10007062 <__sflush_r+0x52>
1000705c:	602e      	str	r6, [r5, #0]
1000705e:	2000      	movs	r0, #0
10007060:	e05e      	b.n	10007120 <__sflush_r+0x110>
10007062:	2140      	movs	r1, #64	; 0x40
10007064:	89a3      	ldrh	r3, [r4, #12]
10007066:	430b      	orrs	r3, r1
10007068:	81a3      	strh	r3, [r4, #12]
1000706a:	e059      	b.n	10007120 <__sflush_r+0x110>
1000706c:	89a3      	ldrh	r3, [r4, #12]
1000706e:	075b      	lsls	r3, r3, #29
10007070:	d506      	bpl.n	10007080 <__sflush_r+0x70>
10007072:	6863      	ldr	r3, [r4, #4]
10007074:	1ad2      	subs	r2, r2, r3
10007076:	6b63      	ldr	r3, [r4, #52]	; 0x34
10007078:	2b00      	cmp	r3, #0
1000707a:	d001      	beq.n	10007080 <__sflush_r+0x70>
1000707c:	6c23      	ldr	r3, [r4, #64]	; 0x40
1000707e:	1ad2      	subs	r2, r2, r3
10007080:	2300      	movs	r3, #0
10007082:	1c28      	adds	r0, r5, #0
10007084:	6a21      	ldr	r1, [r4, #32]
10007086:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
10007088:	47b8      	blx	r7
1000708a:	89a3      	ldrh	r3, [r4, #12]
1000708c:	1c42      	adds	r2, r0, #1
1000708e:	d106      	bne.n	1000709e <__sflush_r+0x8e>
10007090:	682a      	ldr	r2, [r5, #0]
10007092:	2a00      	cmp	r2, #0
10007094:	d003      	beq.n	1000709e <__sflush_r+0x8e>
10007096:	2a1d      	cmp	r2, #29
10007098:	d001      	beq.n	1000709e <__sflush_r+0x8e>
1000709a:	2a16      	cmp	r2, #22
1000709c:	d119      	bne.n	100070d2 <__sflush_r+0xc2>
1000709e:	2200      	movs	r2, #0
100070a0:	6062      	str	r2, [r4, #4]
100070a2:	6922      	ldr	r2, [r4, #16]
100070a4:	6022      	str	r2, [r4, #0]
100070a6:	04db      	lsls	r3, r3, #19
100070a8:	d505      	bpl.n	100070b6 <__sflush_r+0xa6>
100070aa:	1c43      	adds	r3, r0, #1
100070ac:	d102      	bne.n	100070b4 <__sflush_r+0xa4>
100070ae:	682b      	ldr	r3, [r5, #0]
100070b0:	2b00      	cmp	r3, #0
100070b2:	d100      	bne.n	100070b6 <__sflush_r+0xa6>
100070b4:	6560      	str	r0, [r4, #84]	; 0x54
100070b6:	6b61      	ldr	r1, [r4, #52]	; 0x34
100070b8:	602e      	str	r6, [r5, #0]
100070ba:	2900      	cmp	r1, #0
100070bc:	d0cf      	beq.n	1000705e <__sflush_r+0x4e>
100070be:	1c23      	adds	r3, r4, #0
100070c0:	3344      	adds	r3, #68	; 0x44
100070c2:	4299      	cmp	r1, r3
100070c4:	d002      	beq.n	100070cc <__sflush_r+0xbc>
100070c6:	1c28      	adds	r0, r5, #0
100070c8:	f7fe fa72 	bl	100055b0 <_free_r>
100070cc:	2000      	movs	r0, #0
100070ce:	6360      	str	r0, [r4, #52]	; 0x34
100070d0:	e026      	b.n	10007120 <__sflush_r+0x110>
100070d2:	2240      	movs	r2, #64	; 0x40
100070d4:	4313      	orrs	r3, r2
100070d6:	81a3      	strh	r3, [r4, #12]
100070d8:	e022      	b.n	10007120 <__sflush_r+0x110>
100070da:	690f      	ldr	r7, [r1, #16]
100070dc:	2f00      	cmp	r7, #0
100070de:	d0be      	beq.n	1000705e <__sflush_r+0x4e>
100070e0:	680b      	ldr	r3, [r1, #0]
100070e2:	600f      	str	r7, [r1, #0]
100070e4:	1bdb      	subs	r3, r3, r7
100070e6:	9301      	str	r3, [sp, #4]
100070e8:	2300      	movs	r3, #0
100070ea:	0792      	lsls	r2, r2, #30
100070ec:	d100      	bne.n	100070f0 <__sflush_r+0xe0>
100070ee:	694b      	ldr	r3, [r1, #20]
100070f0:	60a3      	str	r3, [r4, #8]
100070f2:	9b01      	ldr	r3, [sp, #4]
100070f4:	2b00      	cmp	r3, #0
100070f6:	ddb2      	ble.n	1000705e <__sflush_r+0x4e>
100070f8:	1c28      	adds	r0, r5, #0
100070fa:	6a21      	ldr	r1, [r4, #32]
100070fc:	1c3a      	adds	r2, r7, #0
100070fe:	9b01      	ldr	r3, [sp, #4]
10007100:	6aa6      	ldr	r6, [r4, #40]	; 0x28
10007102:	47b0      	blx	r6
10007104:	2800      	cmp	r0, #0
10007106:	dc06      	bgt.n	10007116 <__sflush_r+0x106>
10007108:	2240      	movs	r2, #64	; 0x40
1000710a:	2001      	movs	r0, #1
1000710c:	89a3      	ldrh	r3, [r4, #12]
1000710e:	4240      	negs	r0, r0
10007110:	4313      	orrs	r3, r2
10007112:	81a3      	strh	r3, [r4, #12]
10007114:	e004      	b.n	10007120 <__sflush_r+0x110>
10007116:	9b01      	ldr	r3, [sp, #4]
10007118:	183f      	adds	r7, r7, r0
1000711a:	1a1b      	subs	r3, r3, r0
1000711c:	9301      	str	r3, [sp, #4]
1000711e:	e7e8      	b.n	100070f2 <__sflush_r+0xe2>
10007120:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	...

10007124 <_fflush_r>:
10007124:	b538      	push	{r3, r4, r5, lr}
10007126:	690b      	ldr	r3, [r1, #16]
10007128:	1c05      	adds	r5, r0, #0
1000712a:	1c0c      	adds	r4, r1, #0
1000712c:	2b00      	cmp	r3, #0
1000712e:	d101      	bne.n	10007134 <_fflush_r+0x10>
10007130:	2000      	movs	r0, #0
10007132:	e01c      	b.n	1000716e <_fflush_r+0x4a>
10007134:	2800      	cmp	r0, #0
10007136:	d004      	beq.n	10007142 <_fflush_r+0x1e>
10007138:	6983      	ldr	r3, [r0, #24]
1000713a:	2b00      	cmp	r3, #0
1000713c:	d101      	bne.n	10007142 <_fflush_r+0x1e>
1000713e:	f000 f85f 	bl	10007200 <__sinit>
10007142:	4b0b      	ldr	r3, [pc, #44]	; (10007170 <_fflush_r+0x4c>)
10007144:	429c      	cmp	r4, r3
10007146:	d101      	bne.n	1000714c <_fflush_r+0x28>
10007148:	686c      	ldr	r4, [r5, #4]
1000714a:	e008      	b.n	1000715e <_fflush_r+0x3a>
1000714c:	4b09      	ldr	r3, [pc, #36]	; (10007174 <_fflush_r+0x50>)
1000714e:	429c      	cmp	r4, r3
10007150:	d101      	bne.n	10007156 <_fflush_r+0x32>
10007152:	68ac      	ldr	r4, [r5, #8]
10007154:	e003      	b.n	1000715e <_fflush_r+0x3a>
10007156:	4b08      	ldr	r3, [pc, #32]	; (10007178 <_fflush_r+0x54>)
10007158:	429c      	cmp	r4, r3
1000715a:	d100      	bne.n	1000715e <_fflush_r+0x3a>
1000715c:	68ec      	ldr	r4, [r5, #12]
1000715e:	220c      	movs	r2, #12
10007160:	5ea3      	ldrsh	r3, [r4, r2]
10007162:	2b00      	cmp	r3, #0
10007164:	d0e4      	beq.n	10007130 <_fflush_r+0xc>
10007166:	1c28      	adds	r0, r5, #0
10007168:	1c21      	adds	r1, r4, #0
1000716a:	f7ff ff51 	bl	10007010 <__sflush_r>
1000716e:	bd38      	pop	{r3, r4, r5, pc}
10007170:	1000a3ac 	.word	0x1000a3ac
10007174:	1000a3cc 	.word	0x1000a3cc
10007178:	1000a3ec 	.word	0x1000a3ec

1000717c <_cleanup_r>:
1000717c:	b508      	push	{r3, lr}
1000717e:	4902      	ldr	r1, [pc, #8]	; (10007188 <_cleanup_r+0xc>)
10007180:	f000 f8ae 	bl	100072e0 <_fwalk_reent>
10007184:	bd08      	pop	{r3, pc}
10007186:	46c0      	nop			; (mov r8, r8)
10007188:	10007125 	.word	0x10007125

1000718c <std.isra.0>:
1000718c:	2300      	movs	r3, #0
1000718e:	b510      	push	{r4, lr}
10007190:	1c04      	adds	r4, r0, #0
10007192:	6003      	str	r3, [r0, #0]
10007194:	6043      	str	r3, [r0, #4]
10007196:	6083      	str	r3, [r0, #8]
10007198:	8181      	strh	r1, [r0, #12]
1000719a:	6643      	str	r3, [r0, #100]	; 0x64
1000719c:	81c2      	strh	r2, [r0, #14]
1000719e:	6103      	str	r3, [r0, #16]
100071a0:	6143      	str	r3, [r0, #20]
100071a2:	6183      	str	r3, [r0, #24]
100071a4:	1c19      	adds	r1, r3, #0
100071a6:	2208      	movs	r2, #8
100071a8:	305c      	adds	r0, #92	; 0x5c
100071aa:	f7fe f9f8 	bl	1000559e <memset>
100071ae:	4b05      	ldr	r3, [pc, #20]	; (100071c4 <std.isra.0+0x38>)
100071b0:	6224      	str	r4, [r4, #32]
100071b2:	6263      	str	r3, [r4, #36]	; 0x24
100071b4:	4b04      	ldr	r3, [pc, #16]	; (100071c8 <std.isra.0+0x3c>)
100071b6:	62a3      	str	r3, [r4, #40]	; 0x28
100071b8:	4b04      	ldr	r3, [pc, #16]	; (100071cc <std.isra.0+0x40>)
100071ba:	62e3      	str	r3, [r4, #44]	; 0x2c
100071bc:	4b04      	ldr	r3, [pc, #16]	; (100071d0 <std.isra.0+0x44>)
100071be:	6323      	str	r3, [r4, #48]	; 0x30
100071c0:	bd10      	pop	{r4, pc}
100071c2:	46c0      	nop			; (mov r8, r8)
100071c4:	10007f01 	.word	0x10007f01
100071c8:	10007f29 	.word	0x10007f29
100071cc:	10007f61 	.word	0x10007f61
100071d0:	10007f8d 	.word	0x10007f8d

100071d4 <__sfmoreglue>:
100071d4:	b570      	push	{r4, r5, r6, lr}
100071d6:	2568      	movs	r5, #104	; 0x68
100071d8:	1e4b      	subs	r3, r1, #1
100071da:	435d      	muls	r5, r3
100071dc:	1c0e      	adds	r6, r1, #0
100071de:	1c29      	adds	r1, r5, #0
100071e0:	3174      	adds	r1, #116	; 0x74
100071e2:	f7fe fa2b 	bl	1000563c <_malloc_r>
100071e6:	1e04      	subs	r4, r0, #0
100071e8:	d008      	beq.n	100071fc <__sfmoreglue+0x28>
100071ea:	2100      	movs	r1, #0
100071ec:	1c2a      	adds	r2, r5, #0
100071ee:	6001      	str	r1, [r0, #0]
100071f0:	6046      	str	r6, [r0, #4]
100071f2:	300c      	adds	r0, #12
100071f4:	60a0      	str	r0, [r4, #8]
100071f6:	3268      	adds	r2, #104	; 0x68
100071f8:	f7fe f9d1 	bl	1000559e <memset>
100071fc:	1c20      	adds	r0, r4, #0
100071fe:	bd70      	pop	{r4, r5, r6, pc}

10007200 <__sinit>:
10007200:	6983      	ldr	r3, [r0, #24]
10007202:	b513      	push	{r0, r1, r4, lr}
10007204:	2b00      	cmp	r3, #0
10007206:	d128      	bne.n	1000725a <__sinit+0x5a>
10007208:	6483      	str	r3, [r0, #72]	; 0x48
1000720a:	64c3      	str	r3, [r0, #76]	; 0x4c
1000720c:	6503      	str	r3, [r0, #80]	; 0x50
1000720e:	4b13      	ldr	r3, [pc, #76]	; (1000725c <__sinit+0x5c>)
10007210:	4a13      	ldr	r2, [pc, #76]	; (10007260 <__sinit+0x60>)
10007212:	681b      	ldr	r3, [r3, #0]
10007214:	6282      	str	r2, [r0, #40]	; 0x28
10007216:	9301      	str	r3, [sp, #4]
10007218:	4298      	cmp	r0, r3
1000721a:	d101      	bne.n	10007220 <__sinit+0x20>
1000721c:	2301      	movs	r3, #1
1000721e:	6183      	str	r3, [r0, #24]
10007220:	1c04      	adds	r4, r0, #0
10007222:	f000 f81f 	bl	10007264 <__sfp>
10007226:	6060      	str	r0, [r4, #4]
10007228:	1c20      	adds	r0, r4, #0
1000722a:	f000 f81b 	bl	10007264 <__sfp>
1000722e:	60a0      	str	r0, [r4, #8]
10007230:	1c20      	adds	r0, r4, #0
10007232:	f000 f817 	bl	10007264 <__sfp>
10007236:	2104      	movs	r1, #4
10007238:	60e0      	str	r0, [r4, #12]
1000723a:	2200      	movs	r2, #0
1000723c:	6860      	ldr	r0, [r4, #4]
1000723e:	f7ff ffa5 	bl	1000718c <std.isra.0>
10007242:	68a0      	ldr	r0, [r4, #8]
10007244:	2109      	movs	r1, #9
10007246:	2201      	movs	r2, #1
10007248:	f7ff ffa0 	bl	1000718c <std.isra.0>
1000724c:	68e0      	ldr	r0, [r4, #12]
1000724e:	2112      	movs	r1, #18
10007250:	2202      	movs	r2, #2
10007252:	f7ff ff9b 	bl	1000718c <std.isra.0>
10007256:	2301      	movs	r3, #1
10007258:	61a3      	str	r3, [r4, #24]
1000725a:	bd13      	pop	{r0, r1, r4, pc}
1000725c:	1000a364 	.word	0x1000a364
10007260:	1000717d 	.word	0x1000717d

10007264 <__sfp>:
10007264:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
10007266:	4b1d      	ldr	r3, [pc, #116]	; (100072dc <__sfp+0x78>)
10007268:	1c06      	adds	r6, r0, #0
1000726a:	681d      	ldr	r5, [r3, #0]
1000726c:	69ab      	ldr	r3, [r5, #24]
1000726e:	2b00      	cmp	r3, #0
10007270:	d102      	bne.n	10007278 <__sfp+0x14>
10007272:	1c28      	adds	r0, r5, #0
10007274:	f7ff ffc4 	bl	10007200 <__sinit>
10007278:	3548      	adds	r5, #72	; 0x48
1000727a:	68ac      	ldr	r4, [r5, #8]
1000727c:	686b      	ldr	r3, [r5, #4]
1000727e:	3b01      	subs	r3, #1
10007280:	d405      	bmi.n	1000728e <__sfp+0x2a>
10007282:	220c      	movs	r2, #12
10007284:	5ea7      	ldrsh	r7, [r4, r2]
10007286:	2f00      	cmp	r7, #0
10007288:	d010      	beq.n	100072ac <__sfp+0x48>
1000728a:	3468      	adds	r4, #104	; 0x68
1000728c:	e7f7      	b.n	1000727e <__sfp+0x1a>
1000728e:	682b      	ldr	r3, [r5, #0]
10007290:	2b00      	cmp	r3, #0
10007292:	d106      	bne.n	100072a2 <__sfp+0x3e>
10007294:	1c30      	adds	r0, r6, #0
10007296:	2104      	movs	r1, #4
10007298:	f7ff ff9c 	bl	100071d4 <__sfmoreglue>
1000729c:	6028      	str	r0, [r5, #0]
1000729e:	2800      	cmp	r0, #0
100072a0:	d001      	beq.n	100072a6 <__sfp+0x42>
100072a2:	682d      	ldr	r5, [r5, #0]
100072a4:	e7e9      	b.n	1000727a <__sfp+0x16>
100072a6:	230c      	movs	r3, #12
100072a8:	6033      	str	r3, [r6, #0]
100072aa:	e016      	b.n	100072da <__sfp+0x76>
100072ac:	2301      	movs	r3, #1
100072ae:	1c20      	adds	r0, r4, #0
100072b0:	425b      	negs	r3, r3
100072b2:	81e3      	strh	r3, [r4, #14]
100072b4:	3302      	adds	r3, #2
100072b6:	81a3      	strh	r3, [r4, #12]
100072b8:	6667      	str	r7, [r4, #100]	; 0x64
100072ba:	6027      	str	r7, [r4, #0]
100072bc:	60a7      	str	r7, [r4, #8]
100072be:	6067      	str	r7, [r4, #4]
100072c0:	6127      	str	r7, [r4, #16]
100072c2:	6167      	str	r7, [r4, #20]
100072c4:	61a7      	str	r7, [r4, #24]
100072c6:	305c      	adds	r0, #92	; 0x5c
100072c8:	1c39      	adds	r1, r7, #0
100072ca:	2208      	movs	r2, #8
100072cc:	f7fe f967 	bl	1000559e <memset>
100072d0:	1c20      	adds	r0, r4, #0
100072d2:	6367      	str	r7, [r4, #52]	; 0x34
100072d4:	63a7      	str	r7, [r4, #56]	; 0x38
100072d6:	64a7      	str	r7, [r4, #72]	; 0x48
100072d8:	64e7      	str	r7, [r4, #76]	; 0x4c
100072da:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
100072dc:	1000a364 	.word	0x1000a364

100072e0 <_fwalk_reent>:
100072e0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
100072e2:	1c04      	adds	r4, r0, #0
100072e4:	1c07      	adds	r7, r0, #0
100072e6:	2600      	movs	r6, #0
100072e8:	9101      	str	r1, [sp, #4]
100072ea:	3448      	adds	r4, #72	; 0x48
100072ec:	2c00      	cmp	r4, #0
100072ee:	d016      	beq.n	1000731e <_fwalk_reent+0x3e>
100072f0:	6863      	ldr	r3, [r4, #4]
100072f2:	68a5      	ldr	r5, [r4, #8]
100072f4:	9300      	str	r3, [sp, #0]
100072f6:	9b00      	ldr	r3, [sp, #0]
100072f8:	3b01      	subs	r3, #1
100072fa:	9300      	str	r3, [sp, #0]
100072fc:	d40d      	bmi.n	1000731a <_fwalk_reent+0x3a>
100072fe:	89ab      	ldrh	r3, [r5, #12]
10007300:	2b01      	cmp	r3, #1
10007302:	d908      	bls.n	10007316 <_fwalk_reent+0x36>
10007304:	220e      	movs	r2, #14
10007306:	5eab      	ldrsh	r3, [r5, r2]
10007308:	3301      	adds	r3, #1
1000730a:	d004      	beq.n	10007316 <_fwalk_reent+0x36>
1000730c:	1c38      	adds	r0, r7, #0
1000730e:	1c29      	adds	r1, r5, #0
10007310:	9b01      	ldr	r3, [sp, #4]
10007312:	4798      	blx	r3
10007314:	4306      	orrs	r6, r0
10007316:	3568      	adds	r5, #104	; 0x68
10007318:	e7ed      	b.n	100072f6 <_fwalk_reent+0x16>
1000731a:	6824      	ldr	r4, [r4, #0]
1000731c:	e7e6      	b.n	100072ec <_fwalk_reent+0xc>
1000731e:	1c30      	adds	r0, r6, #0
10007320:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	...

10007324 <_localeconv_r>:
10007324:	4800      	ldr	r0, [pc, #0]	; (10007328 <_localeconv_r+0x4>)
10007326:	4770      	bx	lr
10007328:	20000668 	.word	0x20000668

1000732c <__smakebuf_r>:
1000732c:	b5f0      	push	{r4, r5, r6, r7, lr}
1000732e:	898b      	ldrh	r3, [r1, #12]
10007330:	b091      	sub	sp, #68	; 0x44
10007332:	079b      	lsls	r3, r3, #30
10007334:	d506      	bpl.n	10007344 <__smakebuf_r+0x18>
10007336:	1c0b      	adds	r3, r1, #0
10007338:	3347      	adds	r3, #71	; 0x47
1000733a:	600b      	str	r3, [r1, #0]
1000733c:	610b      	str	r3, [r1, #16]
1000733e:	2301      	movs	r3, #1
10007340:	614b      	str	r3, [r1, #20]
10007342:	e045      	b.n	100073d0 <__smakebuf_r+0xa4>
10007344:	1c0c      	adds	r4, r1, #0
10007346:	230e      	movs	r3, #14
10007348:	5ec9      	ldrsh	r1, [r1, r3]
1000734a:	1c06      	adds	r6, r0, #0
1000734c:	2900      	cmp	r1, #0
1000734e:	da04      	bge.n	1000735a <__smakebuf_r+0x2e>
10007350:	2380      	movs	r3, #128	; 0x80
10007352:	89a5      	ldrh	r5, [r4, #12]
10007354:	401d      	ands	r5, r3
10007356:	d110      	bne.n	1000737a <__smakebuf_r+0x4e>
10007358:	e00c      	b.n	10007374 <__smakebuf_r+0x48>
1000735a:	aa01      	add	r2, sp, #4
1000735c:	f000 fe42 	bl	10007fe4 <_fstat_r>
10007360:	2800      	cmp	r0, #0
10007362:	dbf5      	blt.n	10007350 <__smakebuf_r+0x24>
10007364:	23f0      	movs	r3, #240	; 0xf0
10007366:	9d02      	ldr	r5, [sp, #8]
10007368:	021b      	lsls	r3, r3, #8
1000736a:	401d      	ands	r5, r3
1000736c:	4b19      	ldr	r3, [pc, #100]	; (100073d4 <__smakebuf_r+0xa8>)
1000736e:	18ed      	adds	r5, r5, r3
10007370:	426b      	negs	r3, r5
10007372:	415d      	adcs	r5, r3
10007374:	2780      	movs	r7, #128	; 0x80
10007376:	00ff      	lsls	r7, r7, #3
10007378:	e001      	b.n	1000737e <__smakebuf_r+0x52>
1000737a:	2500      	movs	r5, #0
1000737c:	2740      	movs	r7, #64	; 0x40
1000737e:	1c30      	adds	r0, r6, #0
10007380:	1c39      	adds	r1, r7, #0
10007382:	f7fe f95b 	bl	1000563c <_malloc_r>
10007386:	2800      	cmp	r0, #0
10007388:	d10c      	bne.n	100073a4 <__smakebuf_r+0x78>
1000738a:	89a3      	ldrh	r3, [r4, #12]
1000738c:	059a      	lsls	r2, r3, #22
1000738e:	d41f      	bmi.n	100073d0 <__smakebuf_r+0xa4>
10007390:	2202      	movs	r2, #2
10007392:	4313      	orrs	r3, r2
10007394:	81a3      	strh	r3, [r4, #12]
10007396:	1c23      	adds	r3, r4, #0
10007398:	3347      	adds	r3, #71	; 0x47
1000739a:	6023      	str	r3, [r4, #0]
1000739c:	6123      	str	r3, [r4, #16]
1000739e:	2301      	movs	r3, #1
100073a0:	6163      	str	r3, [r4, #20]
100073a2:	e015      	b.n	100073d0 <__smakebuf_r+0xa4>
100073a4:	2280      	movs	r2, #128	; 0x80
100073a6:	4b0c      	ldr	r3, [pc, #48]	; (100073d8 <__smakebuf_r+0xac>)
100073a8:	62b3      	str	r3, [r6, #40]	; 0x28
100073aa:	89a3      	ldrh	r3, [r4, #12]
100073ac:	6020      	str	r0, [r4, #0]
100073ae:	4313      	orrs	r3, r2
100073b0:	81a3      	strh	r3, [r4, #12]
100073b2:	6120      	str	r0, [r4, #16]
100073b4:	6167      	str	r7, [r4, #20]
100073b6:	2d00      	cmp	r5, #0
100073b8:	d00a      	beq.n	100073d0 <__smakebuf_r+0xa4>
100073ba:	230e      	movs	r3, #14
100073bc:	5ee1      	ldrsh	r1, [r4, r3]
100073be:	1c30      	adds	r0, r6, #0
100073c0:	f000 fe22 	bl	10008008 <_isatty_r>
100073c4:	2800      	cmp	r0, #0
100073c6:	d003      	beq.n	100073d0 <__smakebuf_r+0xa4>
100073c8:	2201      	movs	r2, #1
100073ca:	89a3      	ldrh	r3, [r4, #12]
100073cc:	4313      	orrs	r3, r2
100073ce:	81a3      	strh	r3, [r4, #12]
100073d0:	b011      	add	sp, #68	; 0x44
100073d2:	bdf0      	pop	{r4, r5, r6, r7, pc}
100073d4:	ffffe000 	.word	0xffffe000
100073d8:	1000717d 	.word	0x1000717d

100073dc <memchr>:
100073dc:	b2c9      	uxtb	r1, r1
100073de:	1882      	adds	r2, r0, r2
100073e0:	4290      	cmp	r0, r2
100073e2:	d004      	beq.n	100073ee <memchr+0x12>
100073e4:	7803      	ldrb	r3, [r0, #0]
100073e6:	428b      	cmp	r3, r1
100073e8:	d002      	beq.n	100073f0 <memchr+0x14>
100073ea:	3001      	adds	r0, #1
100073ec:	e7f8      	b.n	100073e0 <memchr+0x4>
100073ee:	2000      	movs	r0, #0
100073f0:	4770      	bx	lr

100073f2 <_Balloc>:
100073f2:	b570      	push	{r4, r5, r6, lr}
100073f4:	6a46      	ldr	r6, [r0, #36]	; 0x24
100073f6:	1c04      	adds	r4, r0, #0
100073f8:	1c0d      	adds	r5, r1, #0
100073fa:	2e00      	cmp	r6, #0
100073fc:	d107      	bne.n	1000740e <_Balloc+0x1c>
100073fe:	2010      	movs	r0, #16
10007400:	f7fe f8b0 	bl	10005564 <malloc>
10007404:	6260      	str	r0, [r4, #36]	; 0x24
10007406:	6046      	str	r6, [r0, #4]
10007408:	6086      	str	r6, [r0, #8]
1000740a:	6006      	str	r6, [r0, #0]
1000740c:	60c6      	str	r6, [r0, #12]
1000740e:	6a66      	ldr	r6, [r4, #36]	; 0x24
10007410:	68f3      	ldr	r3, [r6, #12]
10007412:	2b00      	cmp	r3, #0
10007414:	d009      	beq.n	1000742a <_Balloc+0x38>
10007416:	6a62      	ldr	r2, [r4, #36]	; 0x24
10007418:	00ab      	lsls	r3, r5, #2
1000741a:	68d2      	ldr	r2, [r2, #12]
1000741c:	18d3      	adds	r3, r2, r3
1000741e:	6818      	ldr	r0, [r3, #0]
10007420:	2800      	cmp	r0, #0
10007422:	d00e      	beq.n	10007442 <_Balloc+0x50>
10007424:	6802      	ldr	r2, [r0, #0]
10007426:	601a      	str	r2, [r3, #0]
10007428:	e017      	b.n	1000745a <_Balloc+0x68>
1000742a:	1c20      	adds	r0, r4, #0
1000742c:	2104      	movs	r1, #4
1000742e:	2221      	movs	r2, #33	; 0x21
10007430:	f000 faca 	bl	100079c8 <_calloc_r>
10007434:	6a63      	ldr	r3, [r4, #36]	; 0x24
10007436:	60f0      	str	r0, [r6, #12]
10007438:	68db      	ldr	r3, [r3, #12]
1000743a:	2b00      	cmp	r3, #0
1000743c:	d1eb      	bne.n	10007416 <_Balloc+0x24>
1000743e:	2000      	movs	r0, #0
10007440:	e00e      	b.n	10007460 <_Balloc+0x6e>
10007442:	2101      	movs	r1, #1
10007444:	1c0e      	adds	r6, r1, #0
10007446:	40ae      	lsls	r6, r5
10007448:	1d72      	adds	r2, r6, #5
1000744a:	0092      	lsls	r2, r2, #2
1000744c:	1c20      	adds	r0, r4, #0
1000744e:	f000 fabb 	bl	100079c8 <_calloc_r>
10007452:	2800      	cmp	r0, #0
10007454:	d0f3      	beq.n	1000743e <_Balloc+0x4c>
10007456:	6045      	str	r5, [r0, #4]
10007458:	6086      	str	r6, [r0, #8]
1000745a:	2300      	movs	r3, #0
1000745c:	6103      	str	r3, [r0, #16]
1000745e:	60c3      	str	r3, [r0, #12]
10007460:	bd70      	pop	{r4, r5, r6, pc}

10007462 <_Bfree>:
10007462:	b570      	push	{r4, r5, r6, lr}
10007464:	6a45      	ldr	r5, [r0, #36]	; 0x24
10007466:	1c06      	adds	r6, r0, #0
10007468:	1c0c      	adds	r4, r1, #0
1000746a:	2d00      	cmp	r5, #0
1000746c:	d107      	bne.n	1000747e <_Bfree+0x1c>
1000746e:	2010      	movs	r0, #16
10007470:	f7fe f878 	bl	10005564 <malloc>
10007474:	6270      	str	r0, [r6, #36]	; 0x24
10007476:	6045      	str	r5, [r0, #4]
10007478:	6085      	str	r5, [r0, #8]
1000747a:	6005      	str	r5, [r0, #0]
1000747c:	60c5      	str	r5, [r0, #12]
1000747e:	2c00      	cmp	r4, #0
10007480:	d007      	beq.n	10007492 <_Bfree+0x30>
10007482:	6a72      	ldr	r2, [r6, #36]	; 0x24
10007484:	6863      	ldr	r3, [r4, #4]
10007486:	68d2      	ldr	r2, [r2, #12]
10007488:	009b      	lsls	r3, r3, #2
1000748a:	18d3      	adds	r3, r2, r3
1000748c:	681a      	ldr	r2, [r3, #0]
1000748e:	6022      	str	r2, [r4, #0]
10007490:	601c      	str	r4, [r3, #0]
10007492:	bd70      	pop	{r4, r5, r6, pc}

10007494 <__multadd>:
10007494:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
10007496:	1c1e      	adds	r6, r3, #0
10007498:	2314      	movs	r3, #20
1000749a:	469c      	mov	ip, r3
1000749c:	1c07      	adds	r7, r0, #0
1000749e:	1c0c      	adds	r4, r1, #0
100074a0:	2000      	movs	r0, #0
100074a2:	690d      	ldr	r5, [r1, #16]
100074a4:	448c      	add	ip, r1
100074a6:	4663      	mov	r3, ip
100074a8:	8819      	ldrh	r1, [r3, #0]
100074aa:	681b      	ldr	r3, [r3, #0]
100074ac:	4351      	muls	r1, r2
100074ae:	0c1b      	lsrs	r3, r3, #16
100074b0:	4353      	muls	r3, r2
100074b2:	1989      	adds	r1, r1, r6
100074b4:	0c0e      	lsrs	r6, r1, #16
100074b6:	18f3      	adds	r3, r6, r3
100074b8:	b289      	uxth	r1, r1
100074ba:	0c1e      	lsrs	r6, r3, #16
100074bc:	041b      	lsls	r3, r3, #16
100074be:	185b      	adds	r3, r3, r1
100074c0:	4661      	mov	r1, ip
100074c2:	3001      	adds	r0, #1
100074c4:	c108      	stmia	r1!, {r3}
100074c6:	468c      	mov	ip, r1
100074c8:	42a8      	cmp	r0, r5
100074ca:	dbec      	blt.n	100074a6 <__multadd+0x12>
100074cc:	2e00      	cmp	r6, #0
100074ce:	d01b      	beq.n	10007508 <__multadd+0x74>
100074d0:	68a3      	ldr	r3, [r4, #8]
100074d2:	429d      	cmp	r5, r3
100074d4:	db12      	blt.n	100074fc <__multadd+0x68>
100074d6:	6863      	ldr	r3, [r4, #4]
100074d8:	1c38      	adds	r0, r7, #0
100074da:	1c59      	adds	r1, r3, #1
100074dc:	f7ff ff89 	bl	100073f2 <_Balloc>
100074e0:	1c21      	adds	r1, r4, #0
100074e2:	6923      	ldr	r3, [r4, #16]
100074e4:	9001      	str	r0, [sp, #4]
100074e6:	1c9a      	adds	r2, r3, #2
100074e8:	310c      	adds	r1, #12
100074ea:	0092      	lsls	r2, r2, #2
100074ec:	300c      	adds	r0, #12
100074ee:	f7fe f84d 	bl	1000558c <memcpy>
100074f2:	1c21      	adds	r1, r4, #0
100074f4:	1c38      	adds	r0, r7, #0
100074f6:	f7ff ffb4 	bl	10007462 <_Bfree>
100074fa:	9c01      	ldr	r4, [sp, #4]
100074fc:	1d2b      	adds	r3, r5, #4
100074fe:	009b      	lsls	r3, r3, #2
10007500:	18e3      	adds	r3, r4, r3
10007502:	3501      	adds	r5, #1
10007504:	605e      	str	r6, [r3, #4]
10007506:	6125      	str	r5, [r4, #16]
10007508:	1c20      	adds	r0, r4, #0
1000750a:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

1000750c <__hi0bits>:
1000750c:	2200      	movs	r2, #0
1000750e:	1c03      	adds	r3, r0, #0
10007510:	0c01      	lsrs	r1, r0, #16
10007512:	4291      	cmp	r1, r2
10007514:	d101      	bne.n	1000751a <__hi0bits+0xe>
10007516:	0403      	lsls	r3, r0, #16
10007518:	3210      	adds	r2, #16
1000751a:	0e19      	lsrs	r1, r3, #24
1000751c:	d101      	bne.n	10007522 <__hi0bits+0x16>
1000751e:	3208      	adds	r2, #8
10007520:	021b      	lsls	r3, r3, #8
10007522:	0f19      	lsrs	r1, r3, #28
10007524:	d101      	bne.n	1000752a <__hi0bits+0x1e>
10007526:	3204      	adds	r2, #4
10007528:	011b      	lsls	r3, r3, #4
1000752a:	0f99      	lsrs	r1, r3, #30
1000752c:	d101      	bne.n	10007532 <__hi0bits+0x26>
1000752e:	3202      	adds	r2, #2
10007530:	009b      	lsls	r3, r3, #2
10007532:	1c10      	adds	r0, r2, #0
10007534:	2b00      	cmp	r3, #0
10007536:	db03      	blt.n	10007540 <__hi0bits+0x34>
10007538:	2020      	movs	r0, #32
1000753a:	005b      	lsls	r3, r3, #1
1000753c:	d500      	bpl.n	10007540 <__hi0bits+0x34>
1000753e:	1c50      	adds	r0, r2, #1
10007540:	4770      	bx	lr

10007542 <__lo0bits>:
10007542:	2207      	movs	r2, #7
10007544:	6803      	ldr	r3, [r0, #0]
10007546:	b510      	push	{r4, lr}
10007548:	1c01      	adds	r1, r0, #0
1000754a:	401a      	ands	r2, r3
1000754c:	d00c      	beq.n	10007568 <__lo0bits+0x26>
1000754e:	2401      	movs	r4, #1
10007550:	2000      	movs	r0, #0
10007552:	4223      	tst	r3, r4
10007554:	d123      	bne.n	1000759e <__lo0bits+0x5c>
10007556:	2202      	movs	r2, #2
10007558:	4213      	tst	r3, r2
1000755a:	d003      	beq.n	10007564 <__lo0bits+0x22>
1000755c:	40e3      	lsrs	r3, r4
1000755e:	1c20      	adds	r0, r4, #0
10007560:	600b      	str	r3, [r1, #0]
10007562:	e01c      	b.n	1000759e <__lo0bits+0x5c>
10007564:	089b      	lsrs	r3, r3, #2
10007566:	e018      	b.n	1000759a <__lo0bits+0x58>
10007568:	b298      	uxth	r0, r3
1000756a:	2800      	cmp	r0, #0
1000756c:	d101      	bne.n	10007572 <__lo0bits+0x30>
1000756e:	2210      	movs	r2, #16
10007570:	0c1b      	lsrs	r3, r3, #16
10007572:	b2d8      	uxtb	r0, r3
10007574:	2800      	cmp	r0, #0
10007576:	d101      	bne.n	1000757c <__lo0bits+0x3a>
10007578:	3208      	adds	r2, #8
1000757a:	0a1b      	lsrs	r3, r3, #8
1000757c:	0718      	lsls	r0, r3, #28
1000757e:	d101      	bne.n	10007584 <__lo0bits+0x42>
10007580:	3204      	adds	r2, #4
10007582:	091b      	lsrs	r3, r3, #4
10007584:	0798      	lsls	r0, r3, #30
10007586:	d101      	bne.n	1000758c <__lo0bits+0x4a>
10007588:	3202      	adds	r2, #2
1000758a:	089b      	lsrs	r3, r3, #2
1000758c:	07d8      	lsls	r0, r3, #31
1000758e:	d404      	bmi.n	1000759a <__lo0bits+0x58>
10007590:	085b      	lsrs	r3, r3, #1
10007592:	2020      	movs	r0, #32
10007594:	2b00      	cmp	r3, #0
10007596:	d002      	beq.n	1000759e <__lo0bits+0x5c>
10007598:	3201      	adds	r2, #1
1000759a:	1c10      	adds	r0, r2, #0
1000759c:	600b      	str	r3, [r1, #0]
1000759e:	bd10      	pop	{r4, pc}

100075a0 <__i2b>:
100075a0:	b510      	push	{r4, lr}
100075a2:	1c0c      	adds	r4, r1, #0
100075a4:	2101      	movs	r1, #1
100075a6:	f7ff ff24 	bl	100073f2 <_Balloc>
100075aa:	2301      	movs	r3, #1
100075ac:	6144      	str	r4, [r0, #20]
100075ae:	6103      	str	r3, [r0, #16]
100075b0:	bd10      	pop	{r4, pc}

100075b2 <__multiply>:
100075b2:	b5f0      	push	{r4, r5, r6, r7, lr}
100075b4:	690b      	ldr	r3, [r1, #16]
100075b6:	1c14      	adds	r4, r2, #0
100075b8:	6912      	ldr	r2, [r2, #16]
100075ba:	b089      	sub	sp, #36	; 0x24
100075bc:	1c0d      	adds	r5, r1, #0
100075be:	4293      	cmp	r3, r2
100075c0:	da01      	bge.n	100075c6 <__multiply+0x14>
100075c2:	1c25      	adds	r5, r4, #0
100075c4:	1c0c      	adds	r4, r1, #0
100075c6:	692f      	ldr	r7, [r5, #16]
100075c8:	6926      	ldr	r6, [r4, #16]
100075ca:	68aa      	ldr	r2, [r5, #8]
100075cc:	19bb      	adds	r3, r7, r6
100075ce:	6869      	ldr	r1, [r5, #4]
100075d0:	9300      	str	r3, [sp, #0]
100075d2:	4293      	cmp	r3, r2
100075d4:	dd00      	ble.n	100075d8 <__multiply+0x26>
100075d6:	3101      	adds	r1, #1
100075d8:	f7ff ff0b 	bl	100073f2 <_Balloc>
100075dc:	1c01      	adds	r1, r0, #0
100075de:	9b00      	ldr	r3, [sp, #0]
100075e0:	3114      	adds	r1, #20
100075e2:	4684      	mov	ip, r0
100075e4:	0098      	lsls	r0, r3, #2
100075e6:	1c0b      	adds	r3, r1, #0
100075e8:	1808      	adds	r0, r1, r0
100075ea:	4283      	cmp	r3, r0
100075ec:	d202      	bcs.n	100075f4 <__multiply+0x42>
100075ee:	2200      	movs	r2, #0
100075f0:	c304      	stmia	r3!, {r2}
100075f2:	e7fa      	b.n	100075ea <__multiply+0x38>
100075f4:	3514      	adds	r5, #20
100075f6:	00bf      	lsls	r7, r7, #2
100075f8:	19eb      	adds	r3, r5, r7
100075fa:	3414      	adds	r4, #20
100075fc:	00b6      	lsls	r6, r6, #2
100075fe:	9304      	str	r3, [sp, #16]
10007600:	19a3      	adds	r3, r4, r6
10007602:	9502      	str	r5, [sp, #8]
10007604:	9306      	str	r3, [sp, #24]
10007606:	9b06      	ldr	r3, [sp, #24]
10007608:	429c      	cmp	r4, r3
1000760a:	d256      	bcs.n	100076ba <__multiply+0x108>
1000760c:	8823      	ldrh	r3, [r4, #0]
1000760e:	9303      	str	r3, [sp, #12]
10007610:	2b00      	cmp	r3, #0
10007612:	d022      	beq.n	1000765a <__multiply+0xa8>
10007614:	1c0e      	adds	r6, r1, #0
10007616:	2700      	movs	r7, #0
10007618:	9b02      	ldr	r3, [sp, #8]
1000761a:	9301      	str	r3, [sp, #4]
1000761c:	9b01      	ldr	r3, [sp, #4]
1000761e:	9d03      	ldr	r5, [sp, #12]
10007620:	cb04      	ldmia	r3!, {r2}
10007622:	9605      	str	r6, [sp, #20]
10007624:	9301      	str	r3, [sp, #4]
10007626:	8833      	ldrh	r3, [r6, #0]
10007628:	9307      	str	r3, [sp, #28]
1000762a:	b293      	uxth	r3, r2
1000762c:	436b      	muls	r3, r5
1000762e:	9d07      	ldr	r5, [sp, #28]
10007630:	0c12      	lsrs	r2, r2, #16
10007632:	18eb      	adds	r3, r5, r3
10007634:	6835      	ldr	r5, [r6, #0]
10007636:	19db      	adds	r3, r3, r7
10007638:	0c2f      	lsrs	r7, r5, #16
1000763a:	9d03      	ldr	r5, [sp, #12]
1000763c:	436a      	muls	r2, r5
1000763e:	18ba      	adds	r2, r7, r2
10007640:	0c1f      	lsrs	r7, r3, #16
10007642:	19d2      	adds	r2, r2, r7
10007644:	0c17      	lsrs	r7, r2, #16
10007646:	b29b      	uxth	r3, r3
10007648:	0412      	lsls	r2, r2, #16
1000764a:	4313      	orrs	r3, r2
1000764c:	c608      	stmia	r6!, {r3}
1000764e:	9a01      	ldr	r2, [sp, #4]
10007650:	9b04      	ldr	r3, [sp, #16]
10007652:	429a      	cmp	r2, r3
10007654:	d3e2      	bcc.n	1000761c <__multiply+0x6a>
10007656:	9b05      	ldr	r3, [sp, #20]
10007658:	605f      	str	r7, [r3, #4]
1000765a:	6823      	ldr	r3, [r4, #0]
1000765c:	0c1b      	lsrs	r3, r3, #16
1000765e:	9301      	str	r3, [sp, #4]
10007660:	d021      	beq.n	100076a6 <__multiply+0xf4>
10007662:	2200      	movs	r2, #0
10007664:	1c0d      	adds	r5, r1, #0
10007666:	680b      	ldr	r3, [r1, #0]
10007668:	9f02      	ldr	r7, [sp, #8]
1000766a:	9203      	str	r2, [sp, #12]
1000766c:	883e      	ldrh	r6, [r7, #0]
1000766e:	9a01      	ldr	r2, [sp, #4]
10007670:	b29b      	uxth	r3, r3
10007672:	4356      	muls	r6, r2
10007674:	682a      	ldr	r2, [r5, #0]
10007676:	9505      	str	r5, [sp, #20]
10007678:	0c12      	lsrs	r2, r2, #16
1000767a:	18b2      	adds	r2, r6, r2
1000767c:	9e03      	ldr	r6, [sp, #12]
1000767e:	1992      	adds	r2, r2, r6
10007680:	0416      	lsls	r6, r2, #16
10007682:	4333      	orrs	r3, r6
10007684:	602b      	str	r3, [r5, #0]
10007686:	cf08      	ldmia	r7!, {r3}
10007688:	9e01      	ldr	r6, [sp, #4]
1000768a:	0c1b      	lsrs	r3, r3, #16
1000768c:	4373      	muls	r3, r6
1000768e:	88ae      	ldrh	r6, [r5, #4]
10007690:	0c12      	lsrs	r2, r2, #16
10007692:	199b      	adds	r3, r3, r6
10007694:	189b      	adds	r3, r3, r2
10007696:	0c1a      	lsrs	r2, r3, #16
10007698:	9203      	str	r2, [sp, #12]
1000769a:	9a04      	ldr	r2, [sp, #16]
1000769c:	3504      	adds	r5, #4
1000769e:	42ba      	cmp	r2, r7
100076a0:	d8e4      	bhi.n	1000766c <__multiply+0xba>
100076a2:	9a05      	ldr	r2, [sp, #20]
100076a4:	6053      	str	r3, [r2, #4]
100076a6:	3404      	adds	r4, #4
100076a8:	3104      	adds	r1, #4
100076aa:	e7ac      	b.n	10007606 <__multiply+0x54>
100076ac:	3804      	subs	r0, #4
100076ae:	6803      	ldr	r3, [r0, #0]
100076b0:	2b00      	cmp	r3, #0
100076b2:	d105      	bne.n	100076c0 <__multiply+0x10e>
100076b4:	9b00      	ldr	r3, [sp, #0]
100076b6:	3b01      	subs	r3, #1
100076b8:	9300      	str	r3, [sp, #0]
100076ba:	9b00      	ldr	r3, [sp, #0]
100076bc:	2b00      	cmp	r3, #0
100076be:	dcf5      	bgt.n	100076ac <__multiply+0xfa>
100076c0:	4663      	mov	r3, ip
100076c2:	4660      	mov	r0, ip
100076c4:	9a00      	ldr	r2, [sp, #0]
100076c6:	611a      	str	r2, [r3, #16]
100076c8:	b009      	add	sp, #36	; 0x24
100076ca:	bdf0      	pop	{r4, r5, r6, r7, pc}

100076cc <__pow5mult>:
100076cc:	2303      	movs	r3, #3
100076ce:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
100076d0:	4013      	ands	r3, r2
100076d2:	1c05      	adds	r5, r0, #0
100076d4:	1c0e      	adds	r6, r1, #0
100076d6:	1c14      	adds	r4, r2, #0
100076d8:	2b00      	cmp	r3, #0
100076da:	d007      	beq.n	100076ec <__pow5mult+0x20>
100076dc:	4a22      	ldr	r2, [pc, #136]	; (10007768 <__pow5mult+0x9c>)
100076de:	3b01      	subs	r3, #1
100076e0:	009b      	lsls	r3, r3, #2
100076e2:	589a      	ldr	r2, [r3, r2]
100076e4:	2300      	movs	r3, #0
100076e6:	f7ff fed5 	bl	10007494 <__multadd>
100076ea:	1c06      	adds	r6, r0, #0
100076ec:	10a3      	asrs	r3, r4, #2
100076ee:	9301      	str	r3, [sp, #4]
100076f0:	d037      	beq.n	10007762 <__pow5mult+0x96>
100076f2:	6a6c      	ldr	r4, [r5, #36]	; 0x24
100076f4:	2c00      	cmp	r4, #0
100076f6:	d107      	bne.n	10007708 <__pow5mult+0x3c>
100076f8:	2010      	movs	r0, #16
100076fa:	f7fd ff33 	bl	10005564 <malloc>
100076fe:	6268      	str	r0, [r5, #36]	; 0x24
10007700:	6044      	str	r4, [r0, #4]
10007702:	6084      	str	r4, [r0, #8]
10007704:	6004      	str	r4, [r0, #0]
10007706:	60c4      	str	r4, [r0, #12]
10007708:	6a6f      	ldr	r7, [r5, #36]	; 0x24
1000770a:	68bc      	ldr	r4, [r7, #8]
1000770c:	2c00      	cmp	r4, #0
1000770e:	d110      	bne.n	10007732 <__pow5mult+0x66>
10007710:	1c28      	adds	r0, r5, #0
10007712:	4916      	ldr	r1, [pc, #88]	; (1000776c <__pow5mult+0xa0>)
10007714:	f7ff ff44 	bl	100075a0 <__i2b>
10007718:	2300      	movs	r3, #0
1000771a:	60b8      	str	r0, [r7, #8]
1000771c:	1c04      	adds	r4, r0, #0
1000771e:	6003      	str	r3, [r0, #0]
10007720:	e007      	b.n	10007732 <__pow5mult+0x66>
10007722:	9b01      	ldr	r3, [sp, #4]
10007724:	105b      	asrs	r3, r3, #1
10007726:	9301      	str	r3, [sp, #4]
10007728:	d01b      	beq.n	10007762 <__pow5mult+0x96>
1000772a:	6820      	ldr	r0, [r4, #0]
1000772c:	2800      	cmp	r0, #0
1000772e:	d00f      	beq.n	10007750 <__pow5mult+0x84>
10007730:	1c04      	adds	r4, r0, #0
10007732:	9b01      	ldr	r3, [sp, #4]
10007734:	07db      	lsls	r3, r3, #31
10007736:	d5f4      	bpl.n	10007722 <__pow5mult+0x56>
10007738:	1c31      	adds	r1, r6, #0
1000773a:	1c22      	adds	r2, r4, #0
1000773c:	1c28      	adds	r0, r5, #0
1000773e:	f7ff ff38 	bl	100075b2 <__multiply>
10007742:	1c07      	adds	r7, r0, #0
10007744:	1c31      	adds	r1, r6, #0
10007746:	1c28      	adds	r0, r5, #0
10007748:	f7ff fe8b 	bl	10007462 <_Bfree>
1000774c:	1c3e      	adds	r6, r7, #0
1000774e:	e7e8      	b.n	10007722 <__pow5mult+0x56>
10007750:	1c28      	adds	r0, r5, #0
10007752:	1c21      	adds	r1, r4, #0
10007754:	1c22      	adds	r2, r4, #0
10007756:	f7ff ff2c 	bl	100075b2 <__multiply>
1000775a:	2300      	movs	r3, #0
1000775c:	6020      	str	r0, [r4, #0]
1000775e:	6003      	str	r3, [r0, #0]
10007760:	e7e6      	b.n	10007730 <__pow5mult+0x64>
10007762:	1c30      	adds	r0, r6, #0
10007764:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
10007766:	46c0      	nop			; (mov r8, r8)
10007768:	1000a508 	.word	0x1000a508
1000776c:	00000271 	.word	0x00000271

10007770 <__lshift>:
10007770:	b5f0      	push	{r4, r5, r6, r7, lr}
10007772:	1c0c      	adds	r4, r1, #0
10007774:	1c17      	adds	r7, r2, #0
10007776:	6923      	ldr	r3, [r4, #16]
10007778:	1155      	asrs	r5, r2, #5
1000777a:	b085      	sub	sp, #20
1000777c:	18eb      	adds	r3, r5, r3
1000777e:	9301      	str	r3, [sp, #4]
10007780:	3301      	adds	r3, #1
10007782:	9300      	str	r3, [sp, #0]
10007784:	6849      	ldr	r1, [r1, #4]
10007786:	68a3      	ldr	r3, [r4, #8]
10007788:	9002      	str	r0, [sp, #8]
1000778a:	9a00      	ldr	r2, [sp, #0]
1000778c:	429a      	cmp	r2, r3
1000778e:	dd02      	ble.n	10007796 <__lshift+0x26>
10007790:	3101      	adds	r1, #1
10007792:	005b      	lsls	r3, r3, #1
10007794:	e7f9      	b.n	1000778a <__lshift+0x1a>
10007796:	9802      	ldr	r0, [sp, #8]
10007798:	f7ff fe2b 	bl	100073f2 <_Balloc>
1000779c:	1c02      	adds	r2, r0, #0
1000779e:	1c06      	adds	r6, r0, #0
100077a0:	2300      	movs	r3, #0
100077a2:	3214      	adds	r2, #20
100077a4:	42ab      	cmp	r3, r5
100077a6:	da04      	bge.n	100077b2 <__lshift+0x42>
100077a8:	2000      	movs	r0, #0
100077aa:	0099      	lsls	r1, r3, #2
100077ac:	5050      	str	r0, [r2, r1]
100077ae:	3301      	adds	r3, #1
100077b0:	e7f8      	b.n	100077a4 <__lshift+0x34>
100077b2:	43eb      	mvns	r3, r5
100077b4:	17db      	asrs	r3, r3, #31
100077b6:	401d      	ands	r5, r3
100077b8:	1c23      	adds	r3, r4, #0
100077ba:	00ad      	lsls	r5, r5, #2
100077bc:	1955      	adds	r5, r2, r5
100077be:	6922      	ldr	r2, [r4, #16]
100077c0:	3314      	adds	r3, #20
100077c2:	0092      	lsls	r2, r2, #2
100077c4:	189a      	adds	r2, r3, r2
100077c6:	4694      	mov	ip, r2
100077c8:	221f      	movs	r2, #31
100077ca:	4017      	ands	r7, r2
100077cc:	d014      	beq.n	100077f8 <__lshift+0x88>
100077ce:	3201      	adds	r2, #1
100077d0:	1bd2      	subs	r2, r2, r7
100077d2:	9203      	str	r2, [sp, #12]
100077d4:	2200      	movs	r2, #0
100077d6:	6819      	ldr	r1, [r3, #0]
100077d8:	1c28      	adds	r0, r5, #0
100077da:	40b9      	lsls	r1, r7
100077dc:	430a      	orrs	r2, r1
100077de:	c504      	stmia	r5!, {r2}
100077e0:	cb04      	ldmia	r3!, {r2}
100077e2:	9903      	ldr	r1, [sp, #12]
100077e4:	40ca      	lsrs	r2, r1
100077e6:	459c      	cmp	ip, r3
100077e8:	d8f5      	bhi.n	100077d6 <__lshift+0x66>
100077ea:	6042      	str	r2, [r0, #4]
100077ec:	2a00      	cmp	r2, #0
100077ee:	d007      	beq.n	10007800 <__lshift+0x90>
100077f0:	9b01      	ldr	r3, [sp, #4]
100077f2:	3302      	adds	r3, #2
100077f4:	9300      	str	r3, [sp, #0]
100077f6:	e003      	b.n	10007800 <__lshift+0x90>
100077f8:	cb04      	ldmia	r3!, {r2}
100077fa:	c504      	stmia	r5!, {r2}
100077fc:	459c      	cmp	ip, r3
100077fe:	d8fb      	bhi.n	100077f8 <__lshift+0x88>
10007800:	9b00      	ldr	r3, [sp, #0]
10007802:	9802      	ldr	r0, [sp, #8]
10007804:	3b01      	subs	r3, #1
10007806:	6133      	str	r3, [r6, #16]
10007808:	1c21      	adds	r1, r4, #0
1000780a:	f7ff fe2a 	bl	10007462 <_Bfree>
1000780e:	1c30      	adds	r0, r6, #0
10007810:	b005      	add	sp, #20
10007812:	bdf0      	pop	{r4, r5, r6, r7, pc}

10007814 <__mcmp>:
10007814:	6903      	ldr	r3, [r0, #16]
10007816:	690a      	ldr	r2, [r1, #16]
10007818:	b510      	push	{r4, lr}
1000781a:	1a9b      	subs	r3, r3, r2
1000781c:	1c04      	adds	r4, r0, #0
1000781e:	1e18      	subs	r0, r3, #0
10007820:	d112      	bne.n	10007848 <__mcmp+0x34>
10007822:	0093      	lsls	r3, r2, #2
10007824:	3414      	adds	r4, #20
10007826:	3114      	adds	r1, #20
10007828:	18e2      	adds	r2, r4, r3
1000782a:	18c9      	adds	r1, r1, r3
1000782c:	3a04      	subs	r2, #4
1000782e:	3904      	subs	r1, #4
10007830:	6813      	ldr	r3, [r2, #0]
10007832:	6808      	ldr	r0, [r1, #0]
10007834:	4283      	cmp	r3, r0
10007836:	d004      	beq.n	10007842 <__mcmp+0x2e>
10007838:	4283      	cmp	r3, r0
1000783a:	419b      	sbcs	r3, r3
1000783c:	2001      	movs	r0, #1
1000783e:	4318      	orrs	r0, r3
10007840:	e002      	b.n	10007848 <__mcmp+0x34>
10007842:	42a2      	cmp	r2, r4
10007844:	d8f2      	bhi.n	1000782c <__mcmp+0x18>
10007846:	2000      	movs	r0, #0
10007848:	bd10      	pop	{r4, pc}

1000784a <__mdiff>:
1000784a:	b5f0      	push	{r4, r5, r6, r7, lr}
1000784c:	1c07      	adds	r7, r0, #0
1000784e:	b085      	sub	sp, #20
10007850:	1c08      	adds	r0, r1, #0
10007852:	1c0c      	adds	r4, r1, #0
10007854:	1c11      	adds	r1, r2, #0
10007856:	1c15      	adds	r5, r2, #0
10007858:	f7ff ffdc 	bl	10007814 <__mcmp>
1000785c:	1e06      	subs	r6, r0, #0
1000785e:	d107      	bne.n	10007870 <__mdiff+0x26>
10007860:	1c38      	adds	r0, r7, #0
10007862:	1c31      	adds	r1, r6, #0
10007864:	f7ff fdc5 	bl	100073f2 <_Balloc>
10007868:	2301      	movs	r3, #1
1000786a:	6146      	str	r6, [r0, #20]
1000786c:	6103      	str	r3, [r0, #16]
1000786e:	e055      	b.n	1000791c <__mdiff+0xd2>
10007870:	2300      	movs	r3, #0
10007872:	9301      	str	r3, [sp, #4]
10007874:	4298      	cmp	r0, r3
10007876:	da04      	bge.n	10007882 <__mdiff+0x38>
10007878:	1c23      	adds	r3, r4, #0
1000787a:	1c2c      	adds	r4, r5, #0
1000787c:	1c1d      	adds	r5, r3, #0
1000787e:	2301      	movs	r3, #1
10007880:	9301      	str	r3, [sp, #4]
10007882:	1c38      	adds	r0, r7, #0
10007884:	6861      	ldr	r1, [r4, #4]
10007886:	f7ff fdb4 	bl	100073f2 <_Balloc>
1000788a:	9b01      	ldr	r3, [sp, #4]
1000788c:	6926      	ldr	r6, [r4, #16]
1000788e:	1c2f      	adds	r7, r5, #0
10007890:	60c3      	str	r3, [r0, #12]
10007892:	3414      	adds	r4, #20
10007894:	00b3      	lsls	r3, r6, #2
10007896:	18e3      	adds	r3, r4, r3
10007898:	1c02      	adds	r2, r0, #0
1000789a:	9302      	str	r3, [sp, #8]
1000789c:	692b      	ldr	r3, [r5, #16]
1000789e:	2500      	movs	r5, #0
100078a0:	3714      	adds	r7, #20
100078a2:	009b      	lsls	r3, r3, #2
100078a4:	18fb      	adds	r3, r7, r3
100078a6:	9303      	str	r3, [sp, #12]
100078a8:	3214      	adds	r2, #20
100078aa:	cc08      	ldmia	r4!, {r3}
100078ac:	4669      	mov	r1, sp
100078ae:	469c      	mov	ip, r3
100078b0:	cf08      	ldmia	r7!, {r3}
100078b2:	3204      	adds	r2, #4
100078b4:	9300      	str	r3, [sp, #0]
100078b6:	4663      	mov	r3, ip
100078b8:	808b      	strh	r3, [r1, #4]
100078ba:	888b      	ldrh	r3, [r1, #4]
100078bc:	195d      	adds	r5, r3, r5
100078be:	9b00      	ldr	r3, [sp, #0]
100078c0:	b29b      	uxth	r3, r3
100078c2:	1aeb      	subs	r3, r5, r3
100078c4:	4665      	mov	r5, ip
100078c6:	9301      	str	r3, [sp, #4]
100078c8:	9b00      	ldr	r3, [sp, #0]
100078ca:	0c2d      	lsrs	r5, r5, #16
100078cc:	0c19      	lsrs	r1, r3, #16
100078ce:	9b01      	ldr	r3, [sp, #4]
100078d0:	1a69      	subs	r1, r5, r1
100078d2:	141d      	asrs	r5, r3, #16
100078d4:	1f13      	subs	r3, r2, #4
100078d6:	469c      	mov	ip, r3
100078d8:	466b      	mov	r3, sp
100078da:	1949      	adds	r1, r1, r5
100078dc:	889b      	ldrh	r3, [r3, #4]
100078de:	140d      	asrs	r5, r1, #16
100078e0:	0409      	lsls	r1, r1, #16
100078e2:	430b      	orrs	r3, r1
100078e4:	4661      	mov	r1, ip
100078e6:	600b      	str	r3, [r1, #0]
100078e8:	9b03      	ldr	r3, [sp, #12]
100078ea:	429f      	cmp	r7, r3
100078ec:	d3dd      	bcc.n	100078aa <__mdiff+0x60>
100078ee:	9902      	ldr	r1, [sp, #8]
100078f0:	1c13      	adds	r3, r2, #0
100078f2:	428c      	cmp	r4, r1
100078f4:	d20b      	bcs.n	1000790e <__mdiff+0xc4>
100078f6:	cc08      	ldmia	r4!, {r3}
100078f8:	b299      	uxth	r1, r3
100078fa:	1949      	adds	r1, r1, r5
100078fc:	140d      	asrs	r5, r1, #16
100078fe:	0c1b      	lsrs	r3, r3, #16
10007900:	18eb      	adds	r3, r5, r3
10007902:	141d      	asrs	r5, r3, #16
10007904:	b289      	uxth	r1, r1
10007906:	041b      	lsls	r3, r3, #16
10007908:	430b      	orrs	r3, r1
1000790a:	c208      	stmia	r2!, {r3}
1000790c:	e7ef      	b.n	100078ee <__mdiff+0xa4>
1000790e:	3b04      	subs	r3, #4
10007910:	681a      	ldr	r2, [r3, #0]
10007912:	2a00      	cmp	r2, #0
10007914:	d101      	bne.n	1000791a <__mdiff+0xd0>
10007916:	3e01      	subs	r6, #1
10007918:	e7f9      	b.n	1000790e <__mdiff+0xc4>
1000791a:	6106      	str	r6, [r0, #16]
1000791c:	b005      	add	sp, #20
1000791e:	bdf0      	pop	{r4, r5, r6, r7, pc}

10007920 <__d2b>:
10007920:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
10007922:	1c1d      	adds	r5, r3, #0
10007924:	2101      	movs	r1, #1
10007926:	9f08      	ldr	r7, [sp, #32]
10007928:	1c14      	adds	r4, r2, #0
1000792a:	f7ff fd62 	bl	100073f2 <_Balloc>
1000792e:	032b      	lsls	r3, r5, #12
10007930:	006d      	lsls	r5, r5, #1
10007932:	1c06      	adds	r6, r0, #0
10007934:	0b1b      	lsrs	r3, r3, #12
10007936:	0d6d      	lsrs	r5, r5, #21
10007938:	d002      	beq.n	10007940 <__d2b+0x20>
1000793a:	2280      	movs	r2, #128	; 0x80
1000793c:	0352      	lsls	r2, r2, #13
1000793e:	4313      	orrs	r3, r2
10007940:	9301      	str	r3, [sp, #4]
10007942:	2c00      	cmp	r4, #0
10007944:	d018      	beq.n	10007978 <__d2b+0x58>
10007946:	4668      	mov	r0, sp
10007948:	9400      	str	r4, [sp, #0]
1000794a:	f7ff fdfa 	bl	10007542 <__lo0bits>
1000794e:	9c00      	ldr	r4, [sp, #0]
10007950:	2800      	cmp	r0, #0
10007952:	d009      	beq.n	10007968 <__d2b+0x48>
10007954:	2320      	movs	r3, #32
10007956:	9a01      	ldr	r2, [sp, #4]
10007958:	1a19      	subs	r1, r3, r0
1000795a:	1c13      	adds	r3, r2, #0
1000795c:	408b      	lsls	r3, r1
1000795e:	40c2      	lsrs	r2, r0
10007960:	4323      	orrs	r3, r4
10007962:	6173      	str	r3, [r6, #20]
10007964:	9201      	str	r2, [sp, #4]
10007966:	e000      	b.n	1000796a <__d2b+0x4a>
10007968:	6174      	str	r4, [r6, #20]
1000796a:	9c01      	ldr	r4, [sp, #4]
1000796c:	61b4      	str	r4, [r6, #24]
1000796e:	1e63      	subs	r3, r4, #1
10007970:	419c      	sbcs	r4, r3
10007972:	3401      	adds	r4, #1
10007974:	6134      	str	r4, [r6, #16]
10007976:	e007      	b.n	10007988 <__d2b+0x68>
10007978:	a801      	add	r0, sp, #4
1000797a:	f7ff fde2 	bl	10007542 <__lo0bits>
1000797e:	2401      	movs	r4, #1
10007980:	9b01      	ldr	r3, [sp, #4]
10007982:	6134      	str	r4, [r6, #16]
10007984:	6173      	str	r3, [r6, #20]
10007986:	3020      	adds	r0, #32
10007988:	2d00      	cmp	r5, #0
1000798a:	d006      	beq.n	1000799a <__d2b+0x7a>
1000798c:	4b0b      	ldr	r3, [pc, #44]	; (100079bc <__d2b+0x9c>)
1000798e:	18ed      	adds	r5, r5, r3
10007990:	2335      	movs	r3, #53	; 0x35
10007992:	182d      	adds	r5, r5, r0
10007994:	603d      	str	r5, [r7, #0]
10007996:	1a18      	subs	r0, r3, r0
10007998:	e00b      	b.n	100079b2 <__d2b+0x92>
1000799a:	4b09      	ldr	r3, [pc, #36]	; (100079c0 <__d2b+0xa0>)
1000799c:	18c0      	adds	r0, r0, r3
1000799e:	4b09      	ldr	r3, [pc, #36]	; (100079c4 <__d2b+0xa4>)
100079a0:	6038      	str	r0, [r7, #0]
100079a2:	18e3      	adds	r3, r4, r3
100079a4:	009b      	lsls	r3, r3, #2
100079a6:	18f3      	adds	r3, r6, r3
100079a8:	6958      	ldr	r0, [r3, #20]
100079aa:	f7ff fdaf 	bl	1000750c <__hi0bits>
100079ae:	0164      	lsls	r4, r4, #5
100079b0:	1a20      	subs	r0, r4, r0
100079b2:	9b09      	ldr	r3, [sp, #36]	; 0x24
100079b4:	6018      	str	r0, [r3, #0]
100079b6:	1c30      	adds	r0, r6, #0
100079b8:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
100079ba:	46c0      	nop			; (mov r8, r8)
100079bc:	fffffbcd 	.word	0xfffffbcd
100079c0:	fffffbce 	.word	0xfffffbce
100079c4:	3fffffff 	.word	0x3fffffff

100079c8 <_calloc_r>:
100079c8:	434a      	muls	r2, r1
100079ca:	b538      	push	{r3, r4, r5, lr}
100079cc:	1c11      	adds	r1, r2, #0
100079ce:	1c14      	adds	r4, r2, #0
100079d0:	f7fd fe34 	bl	1000563c <_malloc_r>
100079d4:	1e05      	subs	r5, r0, #0
100079d6:	d003      	beq.n	100079e0 <_calloc_r+0x18>
100079d8:	2100      	movs	r1, #0
100079da:	1c22      	adds	r2, r4, #0
100079dc:	f7fd fddf 	bl	1000559e <memset>
100079e0:	1c28      	adds	r0, r5, #0
100079e2:	bd38      	pop	{r3, r4, r5, pc}

100079e4 <__ssputs_r>:
100079e4:	b5f0      	push	{r4, r5, r6, r7, lr}
100079e6:	688e      	ldr	r6, [r1, #8]
100079e8:	b085      	sub	sp, #20
100079ea:	1c07      	adds	r7, r0, #0
100079ec:	1c0c      	adds	r4, r1, #0
100079ee:	9203      	str	r2, [sp, #12]
100079f0:	9301      	str	r3, [sp, #4]
100079f2:	42b3      	cmp	r3, r6
100079f4:	d345      	bcc.n	10007a82 <__ssputs_r+0x9e>
100079f6:	2390      	movs	r3, #144	; 0x90
100079f8:	898a      	ldrh	r2, [r1, #12]
100079fa:	00db      	lsls	r3, r3, #3
100079fc:	421a      	tst	r2, r3
100079fe:	d03d      	beq.n	10007a7c <__ssputs_r+0x98>
10007a00:	2503      	movs	r5, #3
10007a02:	6909      	ldr	r1, [r1, #16]
10007a04:	6823      	ldr	r3, [r4, #0]
10007a06:	9801      	ldr	r0, [sp, #4]
10007a08:	1a5b      	subs	r3, r3, r1
10007a0a:	9302      	str	r3, [sp, #8]
10007a0c:	6963      	ldr	r3, [r4, #20]
10007a0e:	435d      	muls	r5, r3
10007a10:	0feb      	lsrs	r3, r5, #31
10007a12:	195d      	adds	r5, r3, r5
10007a14:	9b02      	ldr	r3, [sp, #8]
10007a16:	106d      	asrs	r5, r5, #1
10007a18:	3301      	adds	r3, #1
10007a1a:	181b      	adds	r3, r3, r0
10007a1c:	429d      	cmp	r5, r3
10007a1e:	d200      	bcs.n	10007a22 <__ssputs_r+0x3e>
10007a20:	1c1d      	adds	r5, r3, #0
10007a22:	1c38      	adds	r0, r7, #0
10007a24:	0553      	lsls	r3, r2, #21
10007a26:	d50f      	bpl.n	10007a48 <__ssputs_r+0x64>
10007a28:	1c29      	adds	r1, r5, #0
10007a2a:	f7fd fe07 	bl	1000563c <_malloc_r>
10007a2e:	1e06      	subs	r6, r0, #0
10007a30:	d013      	beq.n	10007a5a <__ssputs_r+0x76>
10007a32:	9a02      	ldr	r2, [sp, #8]
10007a34:	6921      	ldr	r1, [r4, #16]
10007a36:	f7fd fda9 	bl	1000558c <memcpy>
10007a3a:	89a2      	ldrh	r2, [r4, #12]
10007a3c:	4b18      	ldr	r3, [pc, #96]	; (10007aa0 <__ssputs_r+0xbc>)
10007a3e:	4013      	ands	r3, r2
10007a40:	2280      	movs	r2, #128	; 0x80
10007a42:	4313      	orrs	r3, r2
10007a44:	81a3      	strh	r3, [r4, #12]
10007a46:	e011      	b.n	10007a6c <__ssputs_r+0x88>
10007a48:	1c2a      	adds	r2, r5, #0
10007a4a:	f000 fb17 	bl	1000807c <_realloc_r>
10007a4e:	1e06      	subs	r6, r0, #0
10007a50:	d10c      	bne.n	10007a6c <__ssputs_r+0x88>
10007a52:	1c38      	adds	r0, r7, #0
10007a54:	6921      	ldr	r1, [r4, #16]
10007a56:	f7fd fdab 	bl	100055b0 <_free_r>
10007a5a:	230c      	movs	r3, #12
10007a5c:	2240      	movs	r2, #64	; 0x40
10007a5e:	2001      	movs	r0, #1
10007a60:	603b      	str	r3, [r7, #0]
10007a62:	89a3      	ldrh	r3, [r4, #12]
10007a64:	4240      	negs	r0, r0
10007a66:	4313      	orrs	r3, r2
10007a68:	81a3      	strh	r3, [r4, #12]
10007a6a:	e017      	b.n	10007a9c <__ssputs_r+0xb8>
10007a6c:	9b02      	ldr	r3, [sp, #8]
10007a6e:	6126      	str	r6, [r4, #16]
10007a70:	18f6      	adds	r6, r6, r3
10007a72:	6026      	str	r6, [r4, #0]
10007a74:	6165      	str	r5, [r4, #20]
10007a76:	9e01      	ldr	r6, [sp, #4]
10007a78:	1aed      	subs	r5, r5, r3
10007a7a:	60a5      	str	r5, [r4, #8]
10007a7c:	9b01      	ldr	r3, [sp, #4]
10007a7e:	42b3      	cmp	r3, r6
10007a80:	d200      	bcs.n	10007a84 <__ssputs_r+0xa0>
10007a82:	9e01      	ldr	r6, [sp, #4]
10007a84:	1c32      	adds	r2, r6, #0
10007a86:	6820      	ldr	r0, [r4, #0]
10007a88:	9903      	ldr	r1, [sp, #12]
10007a8a:	f000 fae3 	bl	10008054 <memmove>
10007a8e:	2000      	movs	r0, #0
10007a90:	68a3      	ldr	r3, [r4, #8]
10007a92:	1b9b      	subs	r3, r3, r6
10007a94:	60a3      	str	r3, [r4, #8]
10007a96:	6823      	ldr	r3, [r4, #0]
10007a98:	199e      	adds	r6, r3, r6
10007a9a:	6026      	str	r6, [r4, #0]
10007a9c:	b005      	add	sp, #20
10007a9e:	bdf0      	pop	{r4, r5, r6, r7, pc}
10007aa0:	fffffb7f 	.word	0xfffffb7f

10007aa4 <_svfiprintf_r>:
10007aa4:	b5f0      	push	{r4, r5, r6, r7, lr}
10007aa6:	b09f      	sub	sp, #124	; 0x7c
10007aa8:	9002      	str	r0, [sp, #8]
10007aaa:	9305      	str	r3, [sp, #20]
10007aac:	898b      	ldrh	r3, [r1, #12]
10007aae:	1c0e      	adds	r6, r1, #0
10007ab0:	1c17      	adds	r7, r2, #0
10007ab2:	061b      	lsls	r3, r3, #24
10007ab4:	d510      	bpl.n	10007ad8 <_svfiprintf_r+0x34>
10007ab6:	690b      	ldr	r3, [r1, #16]
10007ab8:	2b00      	cmp	r3, #0
10007aba:	d10d      	bne.n	10007ad8 <_svfiprintf_r+0x34>
10007abc:	2140      	movs	r1, #64	; 0x40
10007abe:	f7fd fdbd 	bl	1000563c <_malloc_r>
10007ac2:	6030      	str	r0, [r6, #0]
10007ac4:	6130      	str	r0, [r6, #16]
10007ac6:	2800      	cmp	r0, #0
10007ac8:	d104      	bne.n	10007ad4 <_svfiprintf_r+0x30>
10007aca:	230c      	movs	r3, #12
10007acc:	9a02      	ldr	r2, [sp, #8]
10007ace:	3801      	subs	r0, #1
10007ad0:	6013      	str	r3, [r2, #0]
10007ad2:	e0d0      	b.n	10007c76 <_svfiprintf_r+0x1d2>
10007ad4:	2340      	movs	r3, #64	; 0x40
10007ad6:	6173      	str	r3, [r6, #20]
10007ad8:	2300      	movs	r3, #0
10007ada:	ad06      	add	r5, sp, #24
10007adc:	616b      	str	r3, [r5, #20]
10007ade:	3320      	adds	r3, #32
10007ae0:	766b      	strb	r3, [r5, #25]
10007ae2:	3310      	adds	r3, #16
10007ae4:	76ab      	strb	r3, [r5, #26]
10007ae6:	1c3c      	adds	r4, r7, #0
10007ae8:	7823      	ldrb	r3, [r4, #0]
10007aea:	2b00      	cmp	r3, #0
10007aec:	d103      	bne.n	10007af6 <_svfiprintf_r+0x52>
10007aee:	1be3      	subs	r3, r4, r7
10007af0:	9304      	str	r3, [sp, #16]
10007af2:	d012      	beq.n	10007b1a <_svfiprintf_r+0x76>
10007af4:	e003      	b.n	10007afe <_svfiprintf_r+0x5a>
10007af6:	2b25      	cmp	r3, #37	; 0x25
10007af8:	d0f9      	beq.n	10007aee <_svfiprintf_r+0x4a>
10007afa:	3401      	adds	r4, #1
10007afc:	e7f4      	b.n	10007ae8 <_svfiprintf_r+0x44>
10007afe:	9b04      	ldr	r3, [sp, #16]
10007b00:	9802      	ldr	r0, [sp, #8]
10007b02:	1c31      	adds	r1, r6, #0
10007b04:	1c3a      	adds	r2, r7, #0
10007b06:	f7ff ff6d 	bl	100079e4 <__ssputs_r>
10007b0a:	1c43      	adds	r3, r0, #1
10007b0c:	d100      	bne.n	10007b10 <_svfiprintf_r+0x6c>
10007b0e:	e0ac      	b.n	10007c6a <_svfiprintf_r+0x1c6>
10007b10:	696a      	ldr	r2, [r5, #20]
10007b12:	9b04      	ldr	r3, [sp, #16]
10007b14:	4694      	mov	ip, r2
10007b16:	4463      	add	r3, ip
10007b18:	616b      	str	r3, [r5, #20]
10007b1a:	7823      	ldrb	r3, [r4, #0]
10007b1c:	2b00      	cmp	r3, #0
10007b1e:	d100      	bne.n	10007b22 <_svfiprintf_r+0x7e>
10007b20:	e0a3      	b.n	10007c6a <_svfiprintf_r+0x1c6>
10007b22:	2201      	movs	r2, #1
10007b24:	2300      	movs	r3, #0
10007b26:	4252      	negs	r2, r2
10007b28:	606a      	str	r2, [r5, #4]
10007b2a:	a902      	add	r1, sp, #8
10007b2c:	3254      	adds	r2, #84	; 0x54
10007b2e:	1852      	adds	r2, r2, r1
10007b30:	3401      	adds	r4, #1
10007b32:	602b      	str	r3, [r5, #0]
10007b34:	60eb      	str	r3, [r5, #12]
10007b36:	60ab      	str	r3, [r5, #8]
10007b38:	7013      	strb	r3, [r2, #0]
10007b3a:	65ab      	str	r3, [r5, #88]	; 0x58
10007b3c:	4f4f      	ldr	r7, [pc, #316]	; (10007c7c <_svfiprintf_r+0x1d8>)
10007b3e:	7821      	ldrb	r1, [r4, #0]
10007b40:	1c38      	adds	r0, r7, #0
10007b42:	2205      	movs	r2, #5
10007b44:	f7ff fc4a 	bl	100073dc <memchr>
10007b48:	2800      	cmp	r0, #0
10007b4a:	d008      	beq.n	10007b5e <_svfiprintf_r+0xba>
10007b4c:	1bc0      	subs	r0, r0, r7
10007b4e:	2701      	movs	r7, #1
10007b50:	4087      	lsls	r7, r0
10007b52:	1c38      	adds	r0, r7, #0
10007b54:	682b      	ldr	r3, [r5, #0]
10007b56:	3401      	adds	r4, #1
10007b58:	4318      	orrs	r0, r3
10007b5a:	6028      	str	r0, [r5, #0]
10007b5c:	e7ee      	b.n	10007b3c <_svfiprintf_r+0x98>
10007b5e:	682b      	ldr	r3, [r5, #0]
10007b60:	06da      	lsls	r2, r3, #27
10007b62:	d504      	bpl.n	10007b6e <_svfiprintf_r+0xca>
10007b64:	2253      	movs	r2, #83	; 0x53
10007b66:	2120      	movs	r1, #32
10007b68:	a802      	add	r0, sp, #8
10007b6a:	1812      	adds	r2, r2, r0
10007b6c:	7011      	strb	r1, [r2, #0]
10007b6e:	071a      	lsls	r2, r3, #28
10007b70:	d504      	bpl.n	10007b7c <_svfiprintf_r+0xd8>
10007b72:	2253      	movs	r2, #83	; 0x53
10007b74:	212b      	movs	r1, #43	; 0x2b
10007b76:	a802      	add	r0, sp, #8
10007b78:	1812      	adds	r2, r2, r0
10007b7a:	7011      	strb	r1, [r2, #0]
10007b7c:	7822      	ldrb	r2, [r4, #0]
10007b7e:	2a2a      	cmp	r2, #42	; 0x2a
10007b80:	d001      	beq.n	10007b86 <_svfiprintf_r+0xe2>
10007b82:	9b09      	ldr	r3, [sp, #36]	; 0x24
10007b84:	e00e      	b.n	10007ba4 <_svfiprintf_r+0x100>
10007b86:	9a05      	ldr	r2, [sp, #20]
10007b88:	1d11      	adds	r1, r2, #4
10007b8a:	6812      	ldr	r2, [r2, #0]
10007b8c:	9105      	str	r1, [sp, #20]
10007b8e:	2a00      	cmp	r2, #0
10007b90:	db01      	blt.n	10007b96 <_svfiprintf_r+0xf2>
10007b92:	9209      	str	r2, [sp, #36]	; 0x24
10007b94:	e004      	b.n	10007ba0 <_svfiprintf_r+0xfc>
10007b96:	4252      	negs	r2, r2
10007b98:	60ea      	str	r2, [r5, #12]
10007b9a:	2202      	movs	r2, #2
10007b9c:	4313      	orrs	r3, r2
10007b9e:	602b      	str	r3, [r5, #0]
10007ba0:	3401      	adds	r4, #1
10007ba2:	e009      	b.n	10007bb8 <_svfiprintf_r+0x114>
10007ba4:	7822      	ldrb	r2, [r4, #0]
10007ba6:	3a30      	subs	r2, #48	; 0x30
10007ba8:	2a09      	cmp	r2, #9
10007baa:	d804      	bhi.n	10007bb6 <_svfiprintf_r+0x112>
10007bac:	210a      	movs	r1, #10
10007bae:	434b      	muls	r3, r1
10007bb0:	3401      	adds	r4, #1
10007bb2:	189b      	adds	r3, r3, r2
10007bb4:	e7f6      	b.n	10007ba4 <_svfiprintf_r+0x100>
10007bb6:	9309      	str	r3, [sp, #36]	; 0x24
10007bb8:	7823      	ldrb	r3, [r4, #0]
10007bba:	2b2e      	cmp	r3, #46	; 0x2e
10007bbc:	d118      	bne.n	10007bf0 <_svfiprintf_r+0x14c>
10007bbe:	7863      	ldrb	r3, [r4, #1]
10007bc0:	2b2a      	cmp	r3, #42	; 0x2a
10007bc2:	d109      	bne.n	10007bd8 <_svfiprintf_r+0x134>
10007bc4:	9b05      	ldr	r3, [sp, #20]
10007bc6:	3402      	adds	r4, #2
10007bc8:	1d1a      	adds	r2, r3, #4
10007bca:	681b      	ldr	r3, [r3, #0]
10007bcc:	9205      	str	r2, [sp, #20]
10007bce:	2b00      	cmp	r3, #0
10007bd0:	da0d      	bge.n	10007bee <_svfiprintf_r+0x14a>
10007bd2:	2301      	movs	r3, #1
10007bd4:	425b      	negs	r3, r3
10007bd6:	e00a      	b.n	10007bee <_svfiprintf_r+0x14a>
10007bd8:	2300      	movs	r3, #0
10007bda:	3401      	adds	r4, #1
10007bdc:	7822      	ldrb	r2, [r4, #0]
10007bde:	3a30      	subs	r2, #48	; 0x30
10007be0:	2a09      	cmp	r2, #9
10007be2:	d804      	bhi.n	10007bee <_svfiprintf_r+0x14a>
10007be4:	210a      	movs	r1, #10
10007be6:	434b      	muls	r3, r1
10007be8:	3401      	adds	r4, #1
10007bea:	189b      	adds	r3, r3, r2
10007bec:	e7f6      	b.n	10007bdc <_svfiprintf_r+0x138>
10007bee:	9307      	str	r3, [sp, #28]
10007bf0:	4f23      	ldr	r7, [pc, #140]	; (10007c80 <_svfiprintf_r+0x1dc>)
10007bf2:	7821      	ldrb	r1, [r4, #0]
10007bf4:	1c38      	adds	r0, r7, #0
10007bf6:	2203      	movs	r2, #3
10007bf8:	f7ff fbf0 	bl	100073dc <memchr>
10007bfc:	2800      	cmp	r0, #0
10007bfe:	d007      	beq.n	10007c10 <_svfiprintf_r+0x16c>
10007c00:	1bc0      	subs	r0, r0, r7
10007c02:	2740      	movs	r7, #64	; 0x40
10007c04:	4087      	lsls	r7, r0
10007c06:	1c38      	adds	r0, r7, #0
10007c08:	682b      	ldr	r3, [r5, #0]
10007c0a:	3401      	adds	r4, #1
10007c0c:	4318      	orrs	r0, r3
10007c0e:	6028      	str	r0, [r5, #0]
10007c10:	7821      	ldrb	r1, [r4, #0]
10007c12:	481c      	ldr	r0, [pc, #112]	; (10007c84 <_svfiprintf_r+0x1e0>)
10007c14:	2206      	movs	r2, #6
10007c16:	1c67      	adds	r7, r4, #1
10007c18:	7629      	strb	r1, [r5, #24]
10007c1a:	f7ff fbdf 	bl	100073dc <memchr>
10007c1e:	2800      	cmp	r0, #0
10007c20:	d012      	beq.n	10007c48 <_svfiprintf_r+0x1a4>
10007c22:	4b19      	ldr	r3, [pc, #100]	; (10007c88 <_svfiprintf_r+0x1e4>)
10007c24:	2b00      	cmp	r3, #0
10007c26:	d106      	bne.n	10007c36 <_svfiprintf_r+0x192>
10007c28:	2207      	movs	r2, #7
10007c2a:	9b05      	ldr	r3, [sp, #20]
10007c2c:	3307      	adds	r3, #7
10007c2e:	4393      	bics	r3, r2
10007c30:	3308      	adds	r3, #8
10007c32:	9305      	str	r3, [sp, #20]
10007c34:	e014      	b.n	10007c60 <_svfiprintf_r+0x1bc>
10007c36:	ab05      	add	r3, sp, #20
10007c38:	9300      	str	r3, [sp, #0]
10007c3a:	9802      	ldr	r0, [sp, #8]
10007c3c:	1c29      	adds	r1, r5, #0
10007c3e:	1c32      	adds	r2, r6, #0
10007c40:	4b12      	ldr	r3, [pc, #72]	; (10007c8c <_svfiprintf_r+0x1e8>)
10007c42:	f7fd fde9 	bl	10005818 <_printf_float>
10007c46:	e007      	b.n	10007c58 <_svfiprintf_r+0x1b4>
10007c48:	ab05      	add	r3, sp, #20
10007c4a:	9300      	str	r3, [sp, #0]
10007c4c:	9802      	ldr	r0, [sp, #8]
10007c4e:	1c29      	adds	r1, r5, #0
10007c50:	1c32      	adds	r2, r6, #0
10007c52:	4b0e      	ldr	r3, [pc, #56]	; (10007c8c <_svfiprintf_r+0x1e8>)
10007c54:	f7fe f886 	bl	10005d64 <_printf_i>
10007c58:	9003      	str	r0, [sp, #12]
10007c5a:	9b03      	ldr	r3, [sp, #12]
10007c5c:	3301      	adds	r3, #1
10007c5e:	d004      	beq.n	10007c6a <_svfiprintf_r+0x1c6>
10007c60:	696b      	ldr	r3, [r5, #20]
10007c62:	9a03      	ldr	r2, [sp, #12]
10007c64:	189b      	adds	r3, r3, r2
10007c66:	616b      	str	r3, [r5, #20]
10007c68:	e73d      	b.n	10007ae6 <_svfiprintf_r+0x42>
10007c6a:	89b3      	ldrh	r3, [r6, #12]
10007c6c:	980b      	ldr	r0, [sp, #44]	; 0x2c
10007c6e:	065b      	lsls	r3, r3, #25
10007c70:	d501      	bpl.n	10007c76 <_svfiprintf_r+0x1d2>
10007c72:	2001      	movs	r0, #1
10007c74:	4240      	negs	r0, r0
10007c76:	b01f      	add	sp, #124	; 0x7c
10007c78:	bdf0      	pop	{r4, r5, r6, r7, pc}
10007c7a:	46c0      	nop			; (mov r8, r8)
10007c7c:	1000a514 	.word	0x1000a514
10007c80:	1000a51a 	.word	0x1000a51a
10007c84:	1000a51e 	.word	0x1000a51e
10007c88:	10005819 	.word	0x10005819
10007c8c:	100079e5 	.word	0x100079e5

10007c90 <__sfputc_r>:
10007c90:	6893      	ldr	r3, [r2, #8]
10007c92:	b510      	push	{r4, lr}
10007c94:	3b01      	subs	r3, #1
10007c96:	6093      	str	r3, [r2, #8]
10007c98:	2b00      	cmp	r3, #0
10007c9a:	da05      	bge.n	10007ca8 <__sfputc_r+0x18>
10007c9c:	6994      	ldr	r4, [r2, #24]
10007c9e:	42a3      	cmp	r3, r4
10007ca0:	db08      	blt.n	10007cb4 <__sfputc_r+0x24>
10007ca2:	b2cb      	uxtb	r3, r1
10007ca4:	2b0a      	cmp	r3, #10
10007ca6:	d005      	beq.n	10007cb4 <__sfputc_r+0x24>
10007ca8:	6813      	ldr	r3, [r2, #0]
10007caa:	1c58      	adds	r0, r3, #1
10007cac:	6010      	str	r0, [r2, #0]
10007cae:	7019      	strb	r1, [r3, #0]
10007cb0:	b2c8      	uxtb	r0, r1
10007cb2:	e001      	b.n	10007cb8 <__sfputc_r+0x28>
10007cb4:	f7fe fa58 	bl	10006168 <__swbuf_r>
10007cb8:	bd10      	pop	{r4, pc}

10007cba <__sfputs_r>:
10007cba:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
10007cbc:	1c06      	adds	r6, r0, #0
10007cbe:	1c0f      	adds	r7, r1, #0
10007cc0:	1c14      	adds	r4, r2, #0
10007cc2:	18d5      	adds	r5, r2, r3
10007cc4:	42ac      	cmp	r4, r5
10007cc6:	d008      	beq.n	10007cda <__sfputs_r+0x20>
10007cc8:	7821      	ldrb	r1, [r4, #0]
10007cca:	1c30      	adds	r0, r6, #0
10007ccc:	1c3a      	adds	r2, r7, #0
10007cce:	f7ff ffdf 	bl	10007c90 <__sfputc_r>
10007cd2:	3401      	adds	r4, #1
10007cd4:	1c43      	adds	r3, r0, #1
10007cd6:	d1f5      	bne.n	10007cc4 <__sfputs_r+0xa>
10007cd8:	e000      	b.n	10007cdc <__sfputs_r+0x22>
10007cda:	2000      	movs	r0, #0
10007cdc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

10007ce0 <_vfiprintf_r>:
10007ce0:	b5f0      	push	{r4, r5, r6, r7, lr}
10007ce2:	b09f      	sub	sp, #124	; 0x7c
10007ce4:	1c06      	adds	r6, r0, #0
10007ce6:	1c0f      	adds	r7, r1, #0
10007ce8:	9202      	str	r2, [sp, #8]
10007cea:	9305      	str	r3, [sp, #20]
10007cec:	2800      	cmp	r0, #0
10007cee:	d004      	beq.n	10007cfa <_vfiprintf_r+0x1a>
10007cf0:	6983      	ldr	r3, [r0, #24]
10007cf2:	2b00      	cmp	r3, #0
10007cf4:	d101      	bne.n	10007cfa <_vfiprintf_r+0x1a>
10007cf6:	f7ff fa83 	bl	10007200 <__sinit>
10007cfa:	4b79      	ldr	r3, [pc, #484]	; (10007ee0 <_vfiprintf_r+0x200>)
10007cfc:	429f      	cmp	r7, r3
10007cfe:	d101      	bne.n	10007d04 <_vfiprintf_r+0x24>
10007d00:	6877      	ldr	r7, [r6, #4]
10007d02:	e008      	b.n	10007d16 <_vfiprintf_r+0x36>
10007d04:	4b77      	ldr	r3, [pc, #476]	; (10007ee4 <_vfiprintf_r+0x204>)
10007d06:	429f      	cmp	r7, r3
10007d08:	d101      	bne.n	10007d0e <_vfiprintf_r+0x2e>
10007d0a:	68b7      	ldr	r7, [r6, #8]
10007d0c:	e003      	b.n	10007d16 <_vfiprintf_r+0x36>
10007d0e:	4b76      	ldr	r3, [pc, #472]	; (10007ee8 <_vfiprintf_r+0x208>)
10007d10:	429f      	cmp	r7, r3
10007d12:	d100      	bne.n	10007d16 <_vfiprintf_r+0x36>
10007d14:	68f7      	ldr	r7, [r6, #12]
10007d16:	89bb      	ldrh	r3, [r7, #12]
10007d18:	071b      	lsls	r3, r3, #28
10007d1a:	d50a      	bpl.n	10007d32 <_vfiprintf_r+0x52>
10007d1c:	693b      	ldr	r3, [r7, #16]
10007d1e:	2b00      	cmp	r3, #0
10007d20:	d007      	beq.n	10007d32 <_vfiprintf_r+0x52>
10007d22:	2300      	movs	r3, #0
10007d24:	ad06      	add	r5, sp, #24
10007d26:	616b      	str	r3, [r5, #20]
10007d28:	3320      	adds	r3, #32
10007d2a:	766b      	strb	r3, [r5, #25]
10007d2c:	3310      	adds	r3, #16
10007d2e:	76ab      	strb	r3, [r5, #26]
10007d30:	e03d      	b.n	10007dae <_vfiprintf_r+0xce>
10007d32:	1c30      	adds	r0, r6, #0
10007d34:	1c39      	adds	r1, r7, #0
10007d36:	f7fe fa6f 	bl	10006218 <__swsetup_r>
10007d3a:	2800      	cmp	r0, #0
10007d3c:	d0f1      	beq.n	10007d22 <_vfiprintf_r+0x42>
10007d3e:	2001      	movs	r0, #1
10007d40:	4240      	negs	r0, r0
10007d42:	e0ca      	b.n	10007eda <_vfiprintf_r+0x1fa>
10007d44:	9a05      	ldr	r2, [sp, #20]
10007d46:	1d11      	adds	r1, r2, #4
10007d48:	6812      	ldr	r2, [r2, #0]
10007d4a:	9105      	str	r1, [sp, #20]
10007d4c:	2a00      	cmp	r2, #0
10007d4e:	db7e      	blt.n	10007e4e <_vfiprintf_r+0x16e>
10007d50:	9209      	str	r2, [sp, #36]	; 0x24
10007d52:	3401      	adds	r4, #1
10007d54:	7823      	ldrb	r3, [r4, #0]
10007d56:	2b2e      	cmp	r3, #46	; 0x2e
10007d58:	d100      	bne.n	10007d5c <_vfiprintf_r+0x7c>
10007d5a:	e089      	b.n	10007e70 <_vfiprintf_r+0x190>
10007d5c:	7821      	ldrb	r1, [r4, #0]
10007d5e:	4863      	ldr	r0, [pc, #396]	; (10007eec <_vfiprintf_r+0x20c>)
10007d60:	2203      	movs	r2, #3
10007d62:	f7ff fb3b 	bl	100073dc <memchr>
10007d66:	2800      	cmp	r0, #0
10007d68:	d008      	beq.n	10007d7c <_vfiprintf_r+0x9c>
10007d6a:	4b60      	ldr	r3, [pc, #384]	; (10007eec <_vfiprintf_r+0x20c>)
10007d6c:	3401      	adds	r4, #1
10007d6e:	1ac0      	subs	r0, r0, r3
10007d70:	2340      	movs	r3, #64	; 0x40
10007d72:	4083      	lsls	r3, r0
10007d74:	1c18      	adds	r0, r3, #0
10007d76:	682b      	ldr	r3, [r5, #0]
10007d78:	4318      	orrs	r0, r3
10007d7a:	6028      	str	r0, [r5, #0]
10007d7c:	7821      	ldrb	r1, [r4, #0]
10007d7e:	1c63      	adds	r3, r4, #1
10007d80:	485b      	ldr	r0, [pc, #364]	; (10007ef0 <_vfiprintf_r+0x210>)
10007d82:	2206      	movs	r2, #6
10007d84:	9302      	str	r3, [sp, #8]
10007d86:	7629      	strb	r1, [r5, #24]
10007d88:	f7ff fb28 	bl	100073dc <memchr>
10007d8c:	2800      	cmp	r0, #0
10007d8e:	d100      	bne.n	10007d92 <_vfiprintf_r+0xb2>
10007d90:	e091      	b.n	10007eb6 <_vfiprintf_r+0x1d6>
10007d92:	4b58      	ldr	r3, [pc, #352]	; (10007ef4 <_vfiprintf_r+0x214>)
10007d94:	2b00      	cmp	r3, #0
10007d96:	d000      	beq.n	10007d9a <_vfiprintf_r+0xba>
10007d98:	e084      	b.n	10007ea4 <_vfiprintf_r+0x1c4>
10007d9a:	2207      	movs	r2, #7
10007d9c:	9b05      	ldr	r3, [sp, #20]
10007d9e:	3307      	adds	r3, #7
10007da0:	4393      	bics	r3, r2
10007da2:	3308      	adds	r3, #8
10007da4:	9305      	str	r3, [sp, #20]
10007da6:	696b      	ldr	r3, [r5, #20]
10007da8:	9a03      	ldr	r2, [sp, #12]
10007daa:	189b      	adds	r3, r3, r2
10007dac:	616b      	str	r3, [r5, #20]
10007dae:	9c02      	ldr	r4, [sp, #8]
10007db0:	7823      	ldrb	r3, [r4, #0]
10007db2:	2b00      	cmp	r3, #0
10007db4:	d104      	bne.n	10007dc0 <_vfiprintf_r+0xe0>
10007db6:	9b02      	ldr	r3, [sp, #8]
10007db8:	1ae3      	subs	r3, r4, r3
10007dba:	9304      	str	r3, [sp, #16]
10007dbc:	d011      	beq.n	10007de2 <_vfiprintf_r+0x102>
10007dbe:	e003      	b.n	10007dc8 <_vfiprintf_r+0xe8>
10007dc0:	2b25      	cmp	r3, #37	; 0x25
10007dc2:	d0f8      	beq.n	10007db6 <_vfiprintf_r+0xd6>
10007dc4:	3401      	adds	r4, #1
10007dc6:	e7f3      	b.n	10007db0 <_vfiprintf_r+0xd0>
10007dc8:	9b04      	ldr	r3, [sp, #16]
10007dca:	1c30      	adds	r0, r6, #0
10007dcc:	1c39      	adds	r1, r7, #0
10007dce:	9a02      	ldr	r2, [sp, #8]
10007dd0:	f7ff ff73 	bl	10007cba <__sfputs_r>
10007dd4:	1c43      	adds	r3, r0, #1
10007dd6:	d07b      	beq.n	10007ed0 <_vfiprintf_r+0x1f0>
10007dd8:	696a      	ldr	r2, [r5, #20]
10007dda:	9b04      	ldr	r3, [sp, #16]
10007ddc:	4694      	mov	ip, r2
10007dde:	4463      	add	r3, ip
10007de0:	616b      	str	r3, [r5, #20]
10007de2:	7823      	ldrb	r3, [r4, #0]
10007de4:	2b00      	cmp	r3, #0
10007de6:	d073      	beq.n	10007ed0 <_vfiprintf_r+0x1f0>
10007de8:	2201      	movs	r2, #1
10007dea:	2300      	movs	r3, #0
10007dec:	4252      	negs	r2, r2
10007dee:	606a      	str	r2, [r5, #4]
10007df0:	a902      	add	r1, sp, #8
10007df2:	3254      	adds	r2, #84	; 0x54
10007df4:	1852      	adds	r2, r2, r1
10007df6:	3401      	adds	r4, #1
10007df8:	602b      	str	r3, [r5, #0]
10007dfa:	60eb      	str	r3, [r5, #12]
10007dfc:	60ab      	str	r3, [r5, #8]
10007dfe:	7013      	strb	r3, [r2, #0]
10007e00:	65ab      	str	r3, [r5, #88]	; 0x58
10007e02:	7821      	ldrb	r1, [r4, #0]
10007e04:	483c      	ldr	r0, [pc, #240]	; (10007ef8 <_vfiprintf_r+0x218>)
10007e06:	2205      	movs	r2, #5
10007e08:	f7ff fae8 	bl	100073dc <memchr>
10007e0c:	2800      	cmp	r0, #0
10007e0e:	d009      	beq.n	10007e24 <_vfiprintf_r+0x144>
10007e10:	4b39      	ldr	r3, [pc, #228]	; (10007ef8 <_vfiprintf_r+0x218>)
10007e12:	3401      	adds	r4, #1
10007e14:	1ac0      	subs	r0, r0, r3
10007e16:	2301      	movs	r3, #1
10007e18:	4083      	lsls	r3, r0
10007e1a:	1c18      	adds	r0, r3, #0
10007e1c:	682b      	ldr	r3, [r5, #0]
10007e1e:	4318      	orrs	r0, r3
10007e20:	6028      	str	r0, [r5, #0]
10007e22:	e7ee      	b.n	10007e02 <_vfiprintf_r+0x122>
10007e24:	682b      	ldr	r3, [r5, #0]
10007e26:	06da      	lsls	r2, r3, #27
10007e28:	d504      	bpl.n	10007e34 <_vfiprintf_r+0x154>
10007e2a:	2253      	movs	r2, #83	; 0x53
10007e2c:	2120      	movs	r1, #32
10007e2e:	a802      	add	r0, sp, #8
10007e30:	1812      	adds	r2, r2, r0
10007e32:	7011      	strb	r1, [r2, #0]
10007e34:	071a      	lsls	r2, r3, #28
10007e36:	d504      	bpl.n	10007e42 <_vfiprintf_r+0x162>
10007e38:	2253      	movs	r2, #83	; 0x53
10007e3a:	212b      	movs	r1, #43	; 0x2b
10007e3c:	a802      	add	r0, sp, #8
10007e3e:	1812      	adds	r2, r2, r0
10007e40:	7011      	strb	r1, [r2, #0]
10007e42:	7822      	ldrb	r2, [r4, #0]
10007e44:	2a2a      	cmp	r2, #42	; 0x2a
10007e46:	d100      	bne.n	10007e4a <_vfiprintf_r+0x16a>
10007e48:	e77c      	b.n	10007d44 <_vfiprintf_r+0x64>
10007e4a:	9b09      	ldr	r3, [sp, #36]	; 0x24
10007e4c:	e005      	b.n	10007e5a <_vfiprintf_r+0x17a>
10007e4e:	4252      	negs	r2, r2
10007e50:	60ea      	str	r2, [r5, #12]
10007e52:	2202      	movs	r2, #2
10007e54:	4313      	orrs	r3, r2
10007e56:	602b      	str	r3, [r5, #0]
10007e58:	e77b      	b.n	10007d52 <_vfiprintf_r+0x72>
10007e5a:	7822      	ldrb	r2, [r4, #0]
10007e5c:	3a30      	subs	r2, #48	; 0x30
10007e5e:	2a09      	cmp	r2, #9
10007e60:	d804      	bhi.n	10007e6c <_vfiprintf_r+0x18c>
10007e62:	210a      	movs	r1, #10
10007e64:	434b      	muls	r3, r1
10007e66:	3401      	adds	r4, #1
10007e68:	189b      	adds	r3, r3, r2
10007e6a:	e7f6      	b.n	10007e5a <_vfiprintf_r+0x17a>
10007e6c:	9309      	str	r3, [sp, #36]	; 0x24
10007e6e:	e771      	b.n	10007d54 <_vfiprintf_r+0x74>
10007e70:	7863      	ldrb	r3, [r4, #1]
10007e72:	2b2a      	cmp	r3, #42	; 0x2a
10007e74:	d109      	bne.n	10007e8a <_vfiprintf_r+0x1aa>
10007e76:	9b05      	ldr	r3, [sp, #20]
10007e78:	3402      	adds	r4, #2
10007e7a:	1d1a      	adds	r2, r3, #4
10007e7c:	681b      	ldr	r3, [r3, #0]
10007e7e:	9205      	str	r2, [sp, #20]
10007e80:	2b00      	cmp	r3, #0
10007e82:	da0d      	bge.n	10007ea0 <_vfiprintf_r+0x1c0>
10007e84:	2301      	movs	r3, #1
10007e86:	425b      	negs	r3, r3
10007e88:	e00a      	b.n	10007ea0 <_vfiprintf_r+0x1c0>
10007e8a:	2300      	movs	r3, #0
10007e8c:	3401      	adds	r4, #1
10007e8e:	7822      	ldrb	r2, [r4, #0]
10007e90:	3a30      	subs	r2, #48	; 0x30
10007e92:	2a09      	cmp	r2, #9
10007e94:	d804      	bhi.n	10007ea0 <_vfiprintf_r+0x1c0>
10007e96:	210a      	movs	r1, #10
10007e98:	434b      	muls	r3, r1
10007e9a:	3401      	adds	r4, #1
10007e9c:	189b      	adds	r3, r3, r2
10007e9e:	e7f6      	b.n	10007e8e <_vfiprintf_r+0x1ae>
10007ea0:	9307      	str	r3, [sp, #28]
10007ea2:	e75b      	b.n	10007d5c <_vfiprintf_r+0x7c>
10007ea4:	ab05      	add	r3, sp, #20
10007ea6:	9300      	str	r3, [sp, #0]
10007ea8:	1c30      	adds	r0, r6, #0
10007eaa:	1c29      	adds	r1, r5, #0
10007eac:	1c3a      	adds	r2, r7, #0
10007eae:	4b13      	ldr	r3, [pc, #76]	; (10007efc <_vfiprintf_r+0x21c>)
10007eb0:	f7fd fcb2 	bl	10005818 <_printf_float>
10007eb4:	e007      	b.n	10007ec6 <_vfiprintf_r+0x1e6>
10007eb6:	ab05      	add	r3, sp, #20
10007eb8:	9300      	str	r3, [sp, #0]
10007eba:	1c30      	adds	r0, r6, #0
10007ebc:	1c29      	adds	r1, r5, #0
10007ebe:	1c3a      	adds	r2, r7, #0
10007ec0:	4b0e      	ldr	r3, [pc, #56]	; (10007efc <_vfiprintf_r+0x21c>)
10007ec2:	f7fd ff4f 	bl	10005d64 <_printf_i>
10007ec6:	9003      	str	r0, [sp, #12]
10007ec8:	9b03      	ldr	r3, [sp, #12]
10007eca:	3301      	adds	r3, #1
10007ecc:	d000      	beq.n	10007ed0 <_vfiprintf_r+0x1f0>
10007ece:	e76a      	b.n	10007da6 <_vfiprintf_r+0xc6>
10007ed0:	89bb      	ldrh	r3, [r7, #12]
10007ed2:	065b      	lsls	r3, r3, #25
10007ed4:	d500      	bpl.n	10007ed8 <_vfiprintf_r+0x1f8>
10007ed6:	e732      	b.n	10007d3e <_vfiprintf_r+0x5e>
10007ed8:	980b      	ldr	r0, [sp, #44]	; 0x2c
10007eda:	b01f      	add	sp, #124	; 0x7c
10007edc:	bdf0      	pop	{r4, r5, r6, r7, pc}
10007ede:	46c0      	nop			; (mov r8, r8)
10007ee0:	1000a3ac 	.word	0x1000a3ac
10007ee4:	1000a3cc 	.word	0x1000a3cc
10007ee8:	1000a3ec 	.word	0x1000a3ec
10007eec:	1000a51a 	.word	0x1000a51a
10007ef0:	1000a51e 	.word	0x1000a51e
10007ef4:	10005819 	.word	0x10005819
10007ef8:	1000a514 	.word	0x1000a514
10007efc:	10007cbb 	.word	0x10007cbb

10007f00 <__sread>:
10007f00:	b538      	push	{r3, r4, r5, lr}
10007f02:	1c0c      	adds	r4, r1, #0
10007f04:	250e      	movs	r5, #14
10007f06:	5f49      	ldrsh	r1, [r1, r5]
10007f08:	f000 f8de 	bl	100080c8 <_read_r>
10007f0c:	2800      	cmp	r0, #0
10007f0e:	db03      	blt.n	10007f18 <__sread+0x18>
10007f10:	6d63      	ldr	r3, [r4, #84]	; 0x54
10007f12:	181b      	adds	r3, r3, r0
10007f14:	6563      	str	r3, [r4, #84]	; 0x54
10007f16:	e003      	b.n	10007f20 <__sread+0x20>
10007f18:	89a2      	ldrh	r2, [r4, #12]
10007f1a:	4b02      	ldr	r3, [pc, #8]	; (10007f24 <__sread+0x24>)
10007f1c:	4013      	ands	r3, r2
10007f1e:	81a3      	strh	r3, [r4, #12]
10007f20:	bd38      	pop	{r3, r4, r5, pc}
10007f22:	46c0      	nop			; (mov r8, r8)
10007f24:	ffffefff 	.word	0xffffefff

10007f28 <__swrite>:
10007f28:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
10007f2a:	1c1e      	adds	r6, r3, #0
10007f2c:	898b      	ldrh	r3, [r1, #12]
10007f2e:	1c05      	adds	r5, r0, #0
10007f30:	1c0c      	adds	r4, r1, #0
10007f32:	1c17      	adds	r7, r2, #0
10007f34:	05db      	lsls	r3, r3, #23
10007f36:	d505      	bpl.n	10007f44 <__swrite+0x1c>
10007f38:	230e      	movs	r3, #14
10007f3a:	5ec9      	ldrsh	r1, [r1, r3]
10007f3c:	2200      	movs	r2, #0
10007f3e:	2302      	movs	r3, #2
10007f40:	f000 f874 	bl	1000802c <_lseek_r>
10007f44:	89a2      	ldrh	r2, [r4, #12]
10007f46:	4b05      	ldr	r3, [pc, #20]	; (10007f5c <__swrite+0x34>)
10007f48:	1c28      	adds	r0, r5, #0
10007f4a:	4013      	ands	r3, r2
10007f4c:	81a3      	strh	r3, [r4, #12]
10007f4e:	1c3a      	adds	r2, r7, #0
10007f50:	230e      	movs	r3, #14
10007f52:	5ee1      	ldrsh	r1, [r4, r3]
10007f54:	1c33      	adds	r3, r6, #0
10007f56:	f000 f81f 	bl	10007f98 <_write_r>
10007f5a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
10007f5c:	ffffefff 	.word	0xffffefff

10007f60 <__sseek>:
10007f60:	b538      	push	{r3, r4, r5, lr}
10007f62:	1c0c      	adds	r4, r1, #0
10007f64:	250e      	movs	r5, #14
10007f66:	5f49      	ldrsh	r1, [r1, r5]
10007f68:	f000 f860 	bl	1000802c <_lseek_r>
10007f6c:	89a3      	ldrh	r3, [r4, #12]
10007f6e:	1c42      	adds	r2, r0, #1
10007f70:	d103      	bne.n	10007f7a <__sseek+0x1a>
10007f72:	4a05      	ldr	r2, [pc, #20]	; (10007f88 <__sseek+0x28>)
10007f74:	4013      	ands	r3, r2
10007f76:	81a3      	strh	r3, [r4, #12]
10007f78:	e004      	b.n	10007f84 <__sseek+0x24>
10007f7a:	2280      	movs	r2, #128	; 0x80
10007f7c:	0152      	lsls	r2, r2, #5
10007f7e:	4313      	orrs	r3, r2
10007f80:	81a3      	strh	r3, [r4, #12]
10007f82:	6560      	str	r0, [r4, #84]	; 0x54
10007f84:	bd38      	pop	{r3, r4, r5, pc}
10007f86:	46c0      	nop			; (mov r8, r8)
10007f88:	ffffefff 	.word	0xffffefff

10007f8c <__sclose>:
10007f8c:	b508      	push	{r3, lr}
10007f8e:	230e      	movs	r3, #14
10007f90:	5ec9      	ldrsh	r1, [r1, r3]
10007f92:	f000 f815 	bl	10007fc0 <_close_r>
10007f96:	bd08      	pop	{r3, pc}

10007f98 <_write_r>:
10007f98:	b538      	push	{r3, r4, r5, lr}
10007f9a:	1c05      	adds	r5, r0, #0
10007f9c:	2000      	movs	r0, #0
10007f9e:	4c07      	ldr	r4, [pc, #28]	; (10007fbc <_write_r+0x24>)
10007fa0:	6020      	str	r0, [r4, #0]
10007fa2:	1c08      	adds	r0, r1, #0
10007fa4:	1c11      	adds	r1, r2, #0
10007fa6:	1c1a      	adds	r2, r3, #0
10007fa8:	f002 f808 	bl	10009fbc <_write>
10007fac:	1c43      	adds	r3, r0, #1
10007fae:	d103      	bne.n	10007fb8 <_write_r+0x20>
10007fb0:	6823      	ldr	r3, [r4, #0]
10007fb2:	2b00      	cmp	r3, #0
10007fb4:	d000      	beq.n	10007fb8 <_write_r+0x20>
10007fb6:	602b      	str	r3, [r5, #0]
10007fb8:	bd38      	pop	{r3, r4, r5, pc}
10007fba:	46c0      	nop			; (mov r8, r8)
10007fbc:	20000928 	.word	0x20000928

10007fc0 <_close_r>:
10007fc0:	b538      	push	{r3, r4, r5, lr}
10007fc2:	2300      	movs	r3, #0
10007fc4:	4c06      	ldr	r4, [pc, #24]	; (10007fe0 <_close_r+0x20>)
10007fc6:	1c05      	adds	r5, r0, #0
10007fc8:	1c08      	adds	r0, r1, #0
10007fca:	6023      	str	r3, [r4, #0]
10007fcc:	f002 f822 	bl	1000a014 <_close>
10007fd0:	1c43      	adds	r3, r0, #1
10007fd2:	d103      	bne.n	10007fdc <_close_r+0x1c>
10007fd4:	6823      	ldr	r3, [r4, #0]
10007fd6:	2b00      	cmp	r3, #0
10007fd8:	d000      	beq.n	10007fdc <_close_r+0x1c>
10007fda:	602b      	str	r3, [r5, #0]
10007fdc:	bd38      	pop	{r3, r4, r5, pc}
10007fde:	46c0      	nop			; (mov r8, r8)
10007fe0:	20000928 	.word	0x20000928

10007fe4 <_fstat_r>:
10007fe4:	b538      	push	{r3, r4, r5, lr}
10007fe6:	2300      	movs	r3, #0
10007fe8:	4c06      	ldr	r4, [pc, #24]	; (10008004 <_fstat_r+0x20>)
10007fea:	1c05      	adds	r5, r0, #0
10007fec:	1c08      	adds	r0, r1, #0
10007fee:	1c11      	adds	r1, r2, #0
10007ff0:	6023      	str	r3, [r4, #0]
10007ff2:	f002 f858 	bl	1000a0a6 <_fstat>
10007ff6:	1c43      	adds	r3, r0, #1
10007ff8:	d103      	bne.n	10008002 <_fstat_r+0x1e>
10007ffa:	6823      	ldr	r3, [r4, #0]
10007ffc:	2b00      	cmp	r3, #0
10007ffe:	d000      	beq.n	10008002 <_fstat_r+0x1e>
10008000:	602b      	str	r3, [r5, #0]
10008002:	bd38      	pop	{r3, r4, r5, pc}
10008004:	20000928 	.word	0x20000928

10008008 <_isatty_r>:
10008008:	b538      	push	{r3, r4, r5, lr}
1000800a:	2300      	movs	r3, #0
1000800c:	4c06      	ldr	r4, [pc, #24]	; (10008028 <_isatty_r+0x20>)
1000800e:	1c05      	adds	r5, r0, #0
10008010:	1c08      	adds	r0, r1, #0
10008012:	6023      	str	r3, [r4, #0]
10008014:	f002 f854 	bl	1000a0c0 <_isatty>
10008018:	1c43      	adds	r3, r0, #1
1000801a:	d103      	bne.n	10008024 <_isatty_r+0x1c>
1000801c:	6823      	ldr	r3, [r4, #0]
1000801e:	2b00      	cmp	r3, #0
10008020:	d000      	beq.n	10008024 <_isatty_r+0x1c>
10008022:	602b      	str	r3, [r5, #0]
10008024:	bd38      	pop	{r3, r4, r5, pc}
10008026:	46c0      	nop			; (mov r8, r8)
10008028:	20000928 	.word	0x20000928

1000802c <_lseek_r>:
1000802c:	b538      	push	{r3, r4, r5, lr}
1000802e:	1c05      	adds	r5, r0, #0
10008030:	2000      	movs	r0, #0
10008032:	4c07      	ldr	r4, [pc, #28]	; (10008050 <_lseek_r+0x24>)
10008034:	6020      	str	r0, [r4, #0]
10008036:	1c08      	adds	r0, r1, #0
10008038:	1c11      	adds	r1, r2, #0
1000803a:	1c1a      	adds	r2, r3, #0
1000803c:	f001 ffaa 	bl	10009f94 <_lseek>
10008040:	1c43      	adds	r3, r0, #1
10008042:	d103      	bne.n	1000804c <_lseek_r+0x20>
10008044:	6823      	ldr	r3, [r4, #0]
10008046:	2b00      	cmp	r3, #0
10008048:	d000      	beq.n	1000804c <_lseek_r+0x20>
1000804a:	602b      	str	r3, [r5, #0]
1000804c:	bd38      	pop	{r3, r4, r5, pc}
1000804e:	46c0      	nop			; (mov r8, r8)
10008050:	20000928 	.word	0x20000928

10008054 <memmove>:
10008054:	b510      	push	{r4, lr}
10008056:	4281      	cmp	r1, r0
10008058:	d208      	bcs.n	1000806c <memmove+0x18>
1000805a:	188b      	adds	r3, r1, r2
1000805c:	4298      	cmp	r0, r3
1000805e:	d205      	bcs.n	1000806c <memmove+0x18>
10008060:	1a9b      	subs	r3, r3, r2
10008062:	3a01      	subs	r2, #1
10008064:	d309      	bcc.n	1000807a <memmove+0x26>
10008066:	5c99      	ldrb	r1, [r3, r2]
10008068:	5481      	strb	r1, [r0, r2]
1000806a:	e7fa      	b.n	10008062 <memmove+0xe>
1000806c:	2300      	movs	r3, #0
1000806e:	4293      	cmp	r3, r2
10008070:	d003      	beq.n	1000807a <memmove+0x26>
10008072:	5ccc      	ldrb	r4, [r1, r3]
10008074:	54c4      	strb	r4, [r0, r3]
10008076:	3301      	adds	r3, #1
10008078:	e7f9      	b.n	1000806e <memmove+0x1a>
1000807a:	bd10      	pop	{r4, pc}

1000807c <_realloc_r>:
1000807c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
1000807e:	1c06      	adds	r6, r0, #0
10008080:	1c0c      	adds	r4, r1, #0
10008082:	1c15      	adds	r5, r2, #0
10008084:	2900      	cmp	r1, #0
10008086:	d104      	bne.n	10008092 <_realloc_r+0x16>
10008088:	1c11      	adds	r1, r2, #0
1000808a:	f7fd fad7 	bl	1000563c <_malloc_r>
1000808e:	1c04      	adds	r4, r0, #0
10008090:	e018      	b.n	100080c4 <_realloc_r+0x48>
10008092:	2a00      	cmp	r2, #0
10008094:	d103      	bne.n	1000809e <_realloc_r+0x22>
10008096:	f7fd fa8b 	bl	100055b0 <_free_r>
1000809a:	1c2c      	adds	r4, r5, #0
1000809c:	e012      	b.n	100080c4 <_realloc_r+0x48>
1000809e:	f000 f827 	bl	100080f0 <_malloc_usable_size_r>
100080a2:	42a8      	cmp	r0, r5
100080a4:	d20e      	bcs.n	100080c4 <_realloc_r+0x48>
100080a6:	1c30      	adds	r0, r6, #0
100080a8:	1c29      	adds	r1, r5, #0
100080aa:	f7fd fac7 	bl	1000563c <_malloc_r>
100080ae:	1e07      	subs	r7, r0, #0
100080b0:	d007      	beq.n	100080c2 <_realloc_r+0x46>
100080b2:	1c21      	adds	r1, r4, #0
100080b4:	1c2a      	adds	r2, r5, #0
100080b6:	f7fd fa69 	bl	1000558c <memcpy>
100080ba:	1c30      	adds	r0, r6, #0
100080bc:	1c21      	adds	r1, r4, #0
100080be:	f7fd fa77 	bl	100055b0 <_free_r>
100080c2:	1c3c      	adds	r4, r7, #0
100080c4:	1c20      	adds	r0, r4, #0
100080c6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

100080c8 <_read_r>:
100080c8:	b538      	push	{r3, r4, r5, lr}
100080ca:	1c05      	adds	r5, r0, #0
100080cc:	2000      	movs	r0, #0
100080ce:	4c07      	ldr	r4, [pc, #28]	; (100080ec <_read_r+0x24>)
100080d0:	6020      	str	r0, [r4, #0]
100080d2:	1c08      	adds	r0, r1, #0
100080d4:	1c11      	adds	r1, r2, #0
100080d6:	1c1a      	adds	r2, r3, #0
100080d8:	f001 ff06 	bl	10009ee8 <_read>
100080dc:	1c43      	adds	r3, r0, #1
100080de:	d103      	bne.n	100080e8 <_read_r+0x20>
100080e0:	6823      	ldr	r3, [r4, #0]
100080e2:	2b00      	cmp	r3, #0
100080e4:	d000      	beq.n	100080e8 <_read_r+0x20>
100080e6:	602b      	str	r3, [r5, #0]
100080e8:	bd38      	pop	{r3, r4, r5, pc}
100080ea:	46c0      	nop			; (mov r8, r8)
100080ec:	20000928 	.word	0x20000928

100080f0 <_malloc_usable_size_r>:
100080f0:	1f0b      	subs	r3, r1, #4
100080f2:	681a      	ldr	r2, [r3, #0]
100080f4:	1f10      	subs	r0, r2, #4
100080f6:	2a00      	cmp	r2, #0
100080f8:	da04      	bge.n	10008104 <_malloc_usable_size_r+0x14>
100080fa:	1889      	adds	r1, r1, r2
100080fc:	3904      	subs	r1, #4
100080fe:	680b      	ldr	r3, [r1, #0]
10008100:	18d0      	adds	r0, r2, r3
10008102:	3804      	subs	r0, #4
10008104:	4770      	bx	lr
	...

10008108 <__gnu_thumb1_case_uqi>:
10008108:	b402      	push	{r1}
1000810a:	4671      	mov	r1, lr
1000810c:	0849      	lsrs	r1, r1, #1
1000810e:	0049      	lsls	r1, r1, #1
10008110:	5c09      	ldrb	r1, [r1, r0]
10008112:	0049      	lsls	r1, r1, #1
10008114:	448e      	add	lr, r1
10008116:	bc02      	pop	{r1}
10008118:	4770      	bx	lr
1000811a:	46c0      	nop			; (mov r8, r8)

1000811c <__aeabi_cdrcmple>:
1000811c:	4684      	mov	ip, r0
1000811e:	1c10      	adds	r0, r2, #0
10008120:	4662      	mov	r2, ip
10008122:	468c      	mov	ip, r1
10008124:	1c19      	adds	r1, r3, #0
10008126:	4663      	mov	r3, ip
10008128:	e000      	b.n	1000812c <__aeabi_cdcmpeq>
1000812a:	46c0      	nop			; (mov r8, r8)

1000812c <__aeabi_cdcmpeq>:
1000812c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
1000812e:	f000 ff33 	bl	10008f98 <__ledf2>
10008132:	2800      	cmp	r0, #0
10008134:	d401      	bmi.n	1000813a <__aeabi_cdcmpeq+0xe>
10008136:	2100      	movs	r1, #0
10008138:	42c8      	cmn	r0, r1
1000813a:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}

1000813c <__aeabi_dcmpeq>:
1000813c:	b510      	push	{r4, lr}
1000813e:	f000 fe77 	bl	10008e30 <__eqdf2>
10008142:	4240      	negs	r0, r0
10008144:	3001      	adds	r0, #1
10008146:	bd10      	pop	{r4, pc}

10008148 <__aeabi_dcmplt>:
10008148:	b510      	push	{r4, lr}
1000814a:	f000 ff25 	bl	10008f98 <__ledf2>
1000814e:	2800      	cmp	r0, #0
10008150:	db01      	blt.n	10008156 <__aeabi_dcmplt+0xe>
10008152:	2000      	movs	r0, #0
10008154:	bd10      	pop	{r4, pc}
10008156:	2001      	movs	r0, #1
10008158:	bd10      	pop	{r4, pc}
1000815a:	46c0      	nop			; (mov r8, r8)

1000815c <__aeabi_dcmple>:
1000815c:	b510      	push	{r4, lr}
1000815e:	f000 ff1b 	bl	10008f98 <__ledf2>
10008162:	2800      	cmp	r0, #0
10008164:	dd01      	ble.n	1000816a <__aeabi_dcmple+0xe>
10008166:	2000      	movs	r0, #0
10008168:	bd10      	pop	{r4, pc}
1000816a:	2001      	movs	r0, #1
1000816c:	bd10      	pop	{r4, pc}
1000816e:	46c0      	nop			; (mov r8, r8)

10008170 <__aeabi_dcmpgt>:
10008170:	b510      	push	{r4, lr}
10008172:	f000 fea1 	bl	10008eb8 <__gedf2>
10008176:	2800      	cmp	r0, #0
10008178:	dc01      	bgt.n	1000817e <__aeabi_dcmpgt+0xe>
1000817a:	2000      	movs	r0, #0
1000817c:	bd10      	pop	{r4, pc}
1000817e:	2001      	movs	r0, #1
10008180:	bd10      	pop	{r4, pc}
10008182:	46c0      	nop			; (mov r8, r8)

10008184 <__aeabi_dcmpge>:
10008184:	b510      	push	{r4, lr}
10008186:	f000 fe97 	bl	10008eb8 <__gedf2>
1000818a:	2800      	cmp	r0, #0
1000818c:	da01      	bge.n	10008192 <__aeabi_dcmpge+0xe>
1000818e:	2000      	movs	r0, #0
10008190:	bd10      	pop	{r4, pc}
10008192:	2001      	movs	r0, #1
10008194:	bd10      	pop	{r4, pc}
10008196:	46c0      	nop			; (mov r8, r8)

10008198 <__aeabi_dadd>:
10008198:	b5f0      	push	{r4, r5, r6, r7, lr}
1000819a:	4645      	mov	r5, r8
1000819c:	4657      	mov	r7, sl
1000819e:	464e      	mov	r6, r9
100081a0:	4694      	mov	ip, r2
100081a2:	004c      	lsls	r4, r1, #1
100081a4:	030a      	lsls	r2, r1, #12
100081a6:	0fc9      	lsrs	r1, r1, #31
100081a8:	b4e0      	push	{r5, r6, r7}
100081aa:	4688      	mov	r8, r1
100081ac:	1c0e      	adds	r6, r1, #0
100081ae:	0319      	lsls	r1, r3, #12
100081b0:	0f47      	lsrs	r7, r0, #29
100081b2:	00c5      	lsls	r5, r0, #3
100081b4:	0a48      	lsrs	r0, r1, #9
100081b6:	4661      	mov	r1, ip
100081b8:	0f49      	lsrs	r1, r1, #29
100081ba:	4301      	orrs	r1, r0
100081bc:	4660      	mov	r0, ip
100081be:	0a52      	lsrs	r2, r2, #9
100081c0:	4317      	orrs	r7, r2
100081c2:	00c0      	lsls	r0, r0, #3
100081c4:	005a      	lsls	r2, r3, #1
100081c6:	0d64      	lsrs	r4, r4, #21
100081c8:	0d52      	lsrs	r2, r2, #21
100081ca:	0fdb      	lsrs	r3, r3, #31
100081cc:	4684      	mov	ip, r0
100081ce:	4598      	cmp	r8, r3
100081d0:	d100      	bne.n	100081d4 <__aeabi_dadd+0x3c>
100081d2:	e0a7      	b.n	10008324 <__aeabi_dadd+0x18c>
100081d4:	1aa0      	subs	r0, r4, r2
100081d6:	2800      	cmp	r0, #0
100081d8:	dc00      	bgt.n	100081dc <__aeabi_dadd+0x44>
100081da:	e101      	b.n	100083e0 <__aeabi_dadd+0x248>
100081dc:	2a00      	cmp	r2, #0
100081de:	d13d      	bne.n	1000825c <__aeabi_dadd+0xc4>
100081e0:	4663      	mov	r3, ip
100081e2:	430b      	orrs	r3, r1
100081e4:	d000      	beq.n	100081e8 <__aeabi_dadd+0x50>
100081e6:	e0d4      	b.n	10008392 <__aeabi_dadd+0x1fa>
100081e8:	076b      	lsls	r3, r5, #29
100081ea:	d100      	bne.n	100081ee <__aeabi_dadd+0x56>
100081ec:	e088      	b.n	10008300 <__aeabi_dadd+0x168>
100081ee:	230f      	movs	r3, #15
100081f0:	402b      	ands	r3, r5
100081f2:	2b04      	cmp	r3, #4
100081f4:	d100      	bne.n	100081f8 <__aeabi_dadd+0x60>
100081f6:	e083      	b.n	10008300 <__aeabi_dadd+0x168>
100081f8:	1d2a      	adds	r2, r5, #4
100081fa:	42aa      	cmp	r2, r5
100081fc:	41ad      	sbcs	r5, r5
100081fe:	2380      	movs	r3, #128	; 0x80
10008200:	426d      	negs	r5, r5
10008202:	197f      	adds	r7, r7, r5
10008204:	041b      	lsls	r3, r3, #16
10008206:	403b      	ands	r3, r7
10008208:	4646      	mov	r6, r8
1000820a:	1c15      	adds	r5, r2, #0
1000820c:	2b00      	cmp	r3, #0
1000820e:	d100      	bne.n	10008212 <__aeabi_dadd+0x7a>
10008210:	e07c      	b.n	1000830c <__aeabi_dadd+0x174>
10008212:	4bcc      	ldr	r3, [pc, #816]	; (10008544 <__aeabi_dadd+0x3ac>)
10008214:	3401      	adds	r4, #1
10008216:	429c      	cmp	r4, r3
10008218:	d100      	bne.n	1000821c <__aeabi_dadd+0x84>
1000821a:	e0fd      	b.n	10008418 <__aeabi_dadd+0x280>
1000821c:	1c3a      	adds	r2, r7, #0
1000821e:	4bca      	ldr	r3, [pc, #808]	; (10008548 <__aeabi_dadd+0x3b0>)
10008220:	08ed      	lsrs	r5, r5, #3
10008222:	401a      	ands	r2, r3
10008224:	0750      	lsls	r0, r2, #29
10008226:	0564      	lsls	r4, r4, #21
10008228:	0252      	lsls	r2, r2, #9
1000822a:	4305      	orrs	r5, r0
1000822c:	0b12      	lsrs	r2, r2, #12
1000822e:	0d64      	lsrs	r4, r4, #21
10008230:	2100      	movs	r1, #0
10008232:	0312      	lsls	r2, r2, #12
10008234:	0d0b      	lsrs	r3, r1, #20
10008236:	051b      	lsls	r3, r3, #20
10008238:	0564      	lsls	r4, r4, #21
1000823a:	0b12      	lsrs	r2, r2, #12
1000823c:	431a      	orrs	r2, r3
1000823e:	0863      	lsrs	r3, r4, #1
10008240:	4cc2      	ldr	r4, [pc, #776]	; (1000854c <__aeabi_dadd+0x3b4>)
10008242:	07f6      	lsls	r6, r6, #31
10008244:	4014      	ands	r4, r2
10008246:	431c      	orrs	r4, r3
10008248:	0064      	lsls	r4, r4, #1
1000824a:	0864      	lsrs	r4, r4, #1
1000824c:	4334      	orrs	r4, r6
1000824e:	1c28      	adds	r0, r5, #0
10008250:	1c21      	adds	r1, r4, #0
10008252:	bc1c      	pop	{r2, r3, r4}
10008254:	4690      	mov	r8, r2
10008256:	4699      	mov	r9, r3
10008258:	46a2      	mov	sl, r4
1000825a:	bdf0      	pop	{r4, r5, r6, r7, pc}
1000825c:	4bb9      	ldr	r3, [pc, #740]	; (10008544 <__aeabi_dadd+0x3ac>)
1000825e:	429c      	cmp	r4, r3
10008260:	d0c2      	beq.n	100081e8 <__aeabi_dadd+0x50>
10008262:	2380      	movs	r3, #128	; 0x80
10008264:	041b      	lsls	r3, r3, #16
10008266:	4319      	orrs	r1, r3
10008268:	2838      	cmp	r0, #56	; 0x38
1000826a:	dd00      	ble.n	1000826e <__aeabi_dadd+0xd6>
1000826c:	e0ec      	b.n	10008448 <__aeabi_dadd+0x2b0>
1000826e:	281f      	cmp	r0, #31
10008270:	dd00      	ble.n	10008274 <__aeabi_dadd+0xdc>
10008272:	e121      	b.n	100084b8 <__aeabi_dadd+0x320>
10008274:	2220      	movs	r2, #32
10008276:	1c0e      	adds	r6, r1, #0
10008278:	4663      	mov	r3, ip
1000827a:	1a12      	subs	r2, r2, r0
1000827c:	4096      	lsls	r6, r2
1000827e:	40c3      	lsrs	r3, r0
10008280:	4333      	orrs	r3, r6
10008282:	4666      	mov	r6, ip
10008284:	4096      	lsls	r6, r2
10008286:	1c32      	adds	r2, r6, #0
10008288:	1e56      	subs	r6, r2, #1
1000828a:	41b2      	sbcs	r2, r6
1000828c:	4313      	orrs	r3, r2
1000828e:	1c0a      	adds	r2, r1, #0
10008290:	40c2      	lsrs	r2, r0
10008292:	1aeb      	subs	r3, r5, r3
10008294:	429d      	cmp	r5, r3
10008296:	41b6      	sbcs	r6, r6
10008298:	1c1d      	adds	r5, r3, #0
1000829a:	1aba      	subs	r2, r7, r2
1000829c:	4276      	negs	r6, r6
1000829e:	1b97      	subs	r7, r2, r6
100082a0:	023b      	lsls	r3, r7, #8
100082a2:	d400      	bmi.n	100082a6 <__aeabi_dadd+0x10e>
100082a4:	e097      	b.n	100083d6 <__aeabi_dadd+0x23e>
100082a6:	027a      	lsls	r2, r7, #9
100082a8:	0a56      	lsrs	r6, r2, #9
100082aa:	2e00      	cmp	r6, #0
100082ac:	d100      	bne.n	100082b0 <__aeabi_dadd+0x118>
100082ae:	e0b6      	b.n	1000841e <__aeabi_dadd+0x286>
100082b0:	1c30      	adds	r0, r6, #0
100082b2:	f7fd f933 	bl	1000551c <__clzsi2>
100082b6:	1c03      	adds	r3, r0, #0
100082b8:	3b08      	subs	r3, #8
100082ba:	2b1f      	cmp	r3, #31
100082bc:	dd00      	ble.n	100082c0 <__aeabi_dadd+0x128>
100082be:	e0b7      	b.n	10008430 <__aeabi_dadd+0x298>
100082c0:	409e      	lsls	r6, r3
100082c2:	1c37      	adds	r7, r6, #0
100082c4:	2628      	movs	r6, #40	; 0x28
100082c6:	1c2a      	adds	r2, r5, #0
100082c8:	1a36      	subs	r6, r6, r0
100082ca:	40f2      	lsrs	r2, r6
100082cc:	1c16      	adds	r6, r2, #0
100082ce:	409d      	lsls	r5, r3
100082d0:	433e      	orrs	r6, r7
100082d2:	429c      	cmp	r4, r3
100082d4:	dd00      	ble.n	100082d8 <__aeabi_dadd+0x140>
100082d6:	e0b2      	b.n	1000843e <__aeabi_dadd+0x2a6>
100082d8:	1b1c      	subs	r4, r3, r4
100082da:	1c62      	adds	r2, r4, #1
100082dc:	2a1f      	cmp	r2, #31
100082de:	dd00      	ble.n	100082e2 <__aeabi_dadd+0x14a>
100082e0:	e0d8      	b.n	10008494 <__aeabi_dadd+0x2fc>
100082e2:	231f      	movs	r3, #31
100082e4:	1c29      	adds	r1, r5, #0
100082e6:	1b1c      	subs	r4, r3, r4
100082e8:	1c33      	adds	r3, r6, #0
100082ea:	40a5      	lsls	r5, r4
100082ec:	40a3      	lsls	r3, r4
100082ee:	40d1      	lsrs	r1, r2
100082f0:	1e6c      	subs	r4, r5, #1
100082f2:	41a5      	sbcs	r5, r4
100082f4:	40d6      	lsrs	r6, r2
100082f6:	4319      	orrs	r1, r3
100082f8:	430d      	orrs	r5, r1
100082fa:	1c37      	adds	r7, r6, #0
100082fc:	2400      	movs	r4, #0
100082fe:	e773      	b.n	100081e8 <__aeabi_dadd+0x50>
10008300:	2380      	movs	r3, #128	; 0x80
10008302:	041b      	lsls	r3, r3, #16
10008304:	403b      	ands	r3, r7
10008306:	4646      	mov	r6, r8
10008308:	d000      	beq.n	1000830c <__aeabi_dadd+0x174>
1000830a:	e782      	b.n	10008212 <__aeabi_dadd+0x7a>
1000830c:	4b8d      	ldr	r3, [pc, #564]	; (10008544 <__aeabi_dadd+0x3ac>)
1000830e:	08ed      	lsrs	r5, r5, #3
10008310:	0778      	lsls	r0, r7, #29
10008312:	4305      	orrs	r5, r0
10008314:	08fa      	lsrs	r2, r7, #3
10008316:	429c      	cmp	r4, r3
10008318:	d032      	beq.n	10008380 <__aeabi_dadd+0x1e8>
1000831a:	0312      	lsls	r2, r2, #12
1000831c:	0564      	lsls	r4, r4, #21
1000831e:	0b12      	lsrs	r2, r2, #12
10008320:	0d64      	lsrs	r4, r4, #21
10008322:	e785      	b.n	10008230 <__aeabi_dadd+0x98>
10008324:	1aa3      	subs	r3, r4, r2
10008326:	2b00      	cmp	r3, #0
10008328:	dc00      	bgt.n	1000832c <__aeabi_dadd+0x194>
1000832a:	e094      	b.n	10008456 <__aeabi_dadd+0x2be>
1000832c:	2a00      	cmp	r2, #0
1000832e:	d03c      	beq.n	100083aa <__aeabi_dadd+0x212>
10008330:	4a84      	ldr	r2, [pc, #528]	; (10008544 <__aeabi_dadd+0x3ac>)
10008332:	4294      	cmp	r4, r2
10008334:	d100      	bne.n	10008338 <__aeabi_dadd+0x1a0>
10008336:	e757      	b.n	100081e8 <__aeabi_dadd+0x50>
10008338:	2280      	movs	r2, #128	; 0x80
1000833a:	0412      	lsls	r2, r2, #16
1000833c:	4311      	orrs	r1, r2
1000833e:	2b38      	cmp	r3, #56	; 0x38
10008340:	dc00      	bgt.n	10008344 <__aeabi_dadd+0x1ac>
10008342:	e105      	b.n	10008550 <__aeabi_dadd+0x3b8>
10008344:	4663      	mov	r3, ip
10008346:	4319      	orrs	r1, r3
10008348:	1e48      	subs	r0, r1, #1
1000834a:	4181      	sbcs	r1, r0
1000834c:	2200      	movs	r2, #0
1000834e:	b2c8      	uxtb	r0, r1
10008350:	1940      	adds	r0, r0, r5
10008352:	42a8      	cmp	r0, r5
10008354:	419b      	sbcs	r3, r3
10008356:	1c05      	adds	r5, r0, #0
10008358:	19d2      	adds	r2, r2, r7
1000835a:	425b      	negs	r3, r3
1000835c:	18d7      	adds	r7, r2, r3
1000835e:	023b      	lsls	r3, r7, #8
10008360:	d539      	bpl.n	100083d6 <__aeabi_dadd+0x23e>
10008362:	4b78      	ldr	r3, [pc, #480]	; (10008544 <__aeabi_dadd+0x3ac>)
10008364:	3401      	adds	r4, #1
10008366:	429c      	cmp	r4, r3
10008368:	d100      	bne.n	1000836c <__aeabi_dadd+0x1d4>
1000836a:	e14c      	b.n	10008606 <__aeabi_dadd+0x46e>
1000836c:	2001      	movs	r0, #1
1000836e:	4a76      	ldr	r2, [pc, #472]	; (10008548 <__aeabi_dadd+0x3b0>)
10008370:	086b      	lsrs	r3, r5, #1
10008372:	403a      	ands	r2, r7
10008374:	4028      	ands	r0, r5
10008376:	4318      	orrs	r0, r3
10008378:	07d5      	lsls	r5, r2, #31
1000837a:	4305      	orrs	r5, r0
1000837c:	0857      	lsrs	r7, r2, #1
1000837e:	e733      	b.n	100081e8 <__aeabi_dadd+0x50>
10008380:	1c2b      	adds	r3, r5, #0
10008382:	4313      	orrs	r3, r2
10008384:	d048      	beq.n	10008418 <__aeabi_dadd+0x280>
10008386:	2380      	movs	r3, #128	; 0x80
10008388:	031b      	lsls	r3, r3, #12
1000838a:	431a      	orrs	r2, r3
1000838c:	0312      	lsls	r2, r2, #12
1000838e:	0b12      	lsrs	r2, r2, #12
10008390:	e74e      	b.n	10008230 <__aeabi_dadd+0x98>
10008392:	3801      	subs	r0, #1
10008394:	2800      	cmp	r0, #0
10008396:	d178      	bne.n	1000848a <__aeabi_dadd+0x2f2>
10008398:	4663      	mov	r3, ip
1000839a:	1aee      	subs	r6, r5, r3
1000839c:	42b5      	cmp	r5, r6
1000839e:	419b      	sbcs	r3, r3
100083a0:	1a7a      	subs	r2, r7, r1
100083a2:	425b      	negs	r3, r3
100083a4:	1ad7      	subs	r7, r2, r3
100083a6:	1c35      	adds	r5, r6, #0
100083a8:	e77a      	b.n	100082a0 <__aeabi_dadd+0x108>
100083aa:	1c02      	adds	r2, r0, #0
100083ac:	430a      	orrs	r2, r1
100083ae:	d100      	bne.n	100083b2 <__aeabi_dadd+0x21a>
100083b0:	e71a      	b.n	100081e8 <__aeabi_dadd+0x50>
100083b2:	3b01      	subs	r3, #1
100083b4:	2b00      	cmp	r3, #0
100083b6:	d000      	beq.n	100083ba <__aeabi_dadd+0x222>
100083b8:	e0f2      	b.n	100085a0 <__aeabi_dadd+0x408>
100083ba:	1940      	adds	r0, r0, r5
100083bc:	42a8      	cmp	r0, r5
100083be:	419b      	sbcs	r3, r3
100083c0:	19ca      	adds	r2, r1, r7
100083c2:	425b      	negs	r3, r3
100083c4:	18d7      	adds	r7, r2, r3
100083c6:	1c05      	adds	r5, r0, #0
100083c8:	e7c9      	b.n	1000835e <__aeabi_dadd+0x1c6>
100083ca:	1c13      	adds	r3, r2, #0
100083cc:	4333      	orrs	r3, r6
100083ce:	d100      	bne.n	100083d2 <__aeabi_dadd+0x23a>
100083d0:	e118      	b.n	10008604 <__aeabi_dadd+0x46c>
100083d2:	1c17      	adds	r7, r2, #0
100083d4:	1c35      	adds	r5, r6, #0
100083d6:	4646      	mov	r6, r8
100083d8:	076b      	lsls	r3, r5, #29
100083da:	d000      	beq.n	100083de <__aeabi_dadd+0x246>
100083dc:	e707      	b.n	100081ee <__aeabi_dadd+0x56>
100083de:	e795      	b.n	1000830c <__aeabi_dadd+0x174>
100083e0:	2800      	cmp	r0, #0
100083e2:	d17a      	bne.n	100084da <__aeabi_dadd+0x342>
100083e4:	1c62      	adds	r2, r4, #1
100083e6:	0552      	lsls	r2, r2, #21
100083e8:	0d52      	lsrs	r2, r2, #21
100083ea:	2a01      	cmp	r2, #1
100083ec:	dc00      	bgt.n	100083f0 <__aeabi_dadd+0x258>
100083ee:	e0fb      	b.n	100085e8 <__aeabi_dadd+0x450>
100083f0:	4662      	mov	r2, ip
100083f2:	1aaa      	subs	r2, r5, r2
100083f4:	4295      	cmp	r5, r2
100083f6:	41b6      	sbcs	r6, r6
100083f8:	4691      	mov	r9, r2
100083fa:	1a78      	subs	r0, r7, r1
100083fc:	4272      	negs	r2, r6
100083fe:	1a86      	subs	r6, r0, r2
10008400:	0232      	lsls	r2, r6, #8
10008402:	d400      	bmi.n	10008406 <__aeabi_dadd+0x26e>
10008404:	e093      	b.n	1000852e <__aeabi_dadd+0x396>
10008406:	4662      	mov	r2, ip
10008408:	1b55      	subs	r5, r2, r5
1000840a:	45ac      	cmp	ip, r5
1000840c:	4180      	sbcs	r0, r0
1000840e:	1bcf      	subs	r7, r1, r7
10008410:	4240      	negs	r0, r0
10008412:	1a3e      	subs	r6, r7, r0
10008414:	4698      	mov	r8, r3
10008416:	e748      	b.n	100082aa <__aeabi_dadd+0x112>
10008418:	2200      	movs	r2, #0
1000841a:	2500      	movs	r5, #0
1000841c:	e708      	b.n	10008230 <__aeabi_dadd+0x98>
1000841e:	1c28      	adds	r0, r5, #0
10008420:	f7fd f87c 	bl	1000551c <__clzsi2>
10008424:	3020      	adds	r0, #32
10008426:	1c03      	adds	r3, r0, #0
10008428:	3b08      	subs	r3, #8
1000842a:	2b1f      	cmp	r3, #31
1000842c:	dc00      	bgt.n	10008430 <__aeabi_dadd+0x298>
1000842e:	e747      	b.n	100082c0 <__aeabi_dadd+0x128>
10008430:	3828      	subs	r0, #40	; 0x28
10008432:	4085      	lsls	r5, r0
10008434:	1c2e      	adds	r6, r5, #0
10008436:	2500      	movs	r5, #0
10008438:	429c      	cmp	r4, r3
1000843a:	dc00      	bgt.n	1000843e <__aeabi_dadd+0x2a6>
1000843c:	e74c      	b.n	100082d8 <__aeabi_dadd+0x140>
1000843e:	4a42      	ldr	r2, [pc, #264]	; (10008548 <__aeabi_dadd+0x3b0>)
10008440:	1ae4      	subs	r4, r4, r3
10008442:	4016      	ands	r6, r2
10008444:	1c37      	adds	r7, r6, #0
10008446:	e6cf      	b.n	100081e8 <__aeabi_dadd+0x50>
10008448:	4663      	mov	r3, ip
1000844a:	4319      	orrs	r1, r3
1000844c:	1e4b      	subs	r3, r1, #1
1000844e:	4199      	sbcs	r1, r3
10008450:	2200      	movs	r2, #0
10008452:	b2cb      	uxtb	r3, r1
10008454:	e71d      	b.n	10008292 <__aeabi_dadd+0xfa>
10008456:	2b00      	cmp	r3, #0
10008458:	d000      	beq.n	1000845c <__aeabi_dadd+0x2c4>
1000845a:	e0f2      	b.n	10008642 <__aeabi_dadd+0x4aa>
1000845c:	1c60      	adds	r0, r4, #1
1000845e:	0543      	lsls	r3, r0, #21
10008460:	0d5b      	lsrs	r3, r3, #21
10008462:	2b01      	cmp	r3, #1
10008464:	dc00      	bgt.n	10008468 <__aeabi_dadd+0x2d0>
10008466:	e0a4      	b.n	100085b2 <__aeabi_dadd+0x41a>
10008468:	4b36      	ldr	r3, [pc, #216]	; (10008544 <__aeabi_dadd+0x3ac>)
1000846a:	4298      	cmp	r0, r3
1000846c:	d100      	bne.n	10008470 <__aeabi_dadd+0x2d8>
1000846e:	e121      	b.n	100086b4 <__aeabi_dadd+0x51c>
10008470:	4663      	mov	r3, ip
10008472:	195c      	adds	r4, r3, r5
10008474:	42ac      	cmp	r4, r5
10008476:	419b      	sbcs	r3, r3
10008478:	19cf      	adds	r7, r1, r7
1000847a:	425b      	negs	r3, r3
1000847c:	18fa      	adds	r2, r7, r3
1000847e:	0864      	lsrs	r4, r4, #1
10008480:	07d5      	lsls	r5, r2, #31
10008482:	4325      	orrs	r5, r4
10008484:	0857      	lsrs	r7, r2, #1
10008486:	1c04      	adds	r4, r0, #0
10008488:	e6ae      	b.n	100081e8 <__aeabi_dadd+0x50>
1000848a:	4b2e      	ldr	r3, [pc, #184]	; (10008544 <__aeabi_dadd+0x3ac>)
1000848c:	429c      	cmp	r4, r3
1000848e:	d000      	beq.n	10008492 <__aeabi_dadd+0x2fa>
10008490:	e6ea      	b.n	10008268 <__aeabi_dadd+0xd0>
10008492:	e6a9      	b.n	100081e8 <__aeabi_dadd+0x50>
10008494:	1c21      	adds	r1, r4, #0
10008496:	1c33      	adds	r3, r6, #0
10008498:	391f      	subs	r1, #31
1000849a:	40cb      	lsrs	r3, r1
1000849c:	1c19      	adds	r1, r3, #0
1000849e:	2a20      	cmp	r2, #32
100084a0:	d100      	bne.n	100084a4 <__aeabi_dadd+0x30c>
100084a2:	e082      	b.n	100085aa <__aeabi_dadd+0x412>
100084a4:	233f      	movs	r3, #63	; 0x3f
100084a6:	1b1c      	subs	r4, r3, r4
100084a8:	40a6      	lsls	r6, r4
100084aa:	4335      	orrs	r5, r6
100084ac:	1e6e      	subs	r6, r5, #1
100084ae:	41b5      	sbcs	r5, r6
100084b0:	2700      	movs	r7, #0
100084b2:	430d      	orrs	r5, r1
100084b4:	2400      	movs	r4, #0
100084b6:	e78e      	b.n	100083d6 <__aeabi_dadd+0x23e>
100084b8:	1c03      	adds	r3, r0, #0
100084ba:	1c0e      	adds	r6, r1, #0
100084bc:	3b20      	subs	r3, #32
100084be:	40de      	lsrs	r6, r3
100084c0:	2820      	cmp	r0, #32
100084c2:	d074      	beq.n	100085ae <__aeabi_dadd+0x416>
100084c4:	2340      	movs	r3, #64	; 0x40
100084c6:	1a1b      	subs	r3, r3, r0
100084c8:	4099      	lsls	r1, r3
100084ca:	1c0b      	adds	r3, r1, #0
100084cc:	4662      	mov	r2, ip
100084ce:	4313      	orrs	r3, r2
100084d0:	1e59      	subs	r1, r3, #1
100084d2:	418b      	sbcs	r3, r1
100084d4:	2200      	movs	r2, #0
100084d6:	4333      	orrs	r3, r6
100084d8:	e6db      	b.n	10008292 <__aeabi_dadd+0xfa>
100084da:	2c00      	cmp	r4, #0
100084dc:	d050      	beq.n	10008580 <__aeabi_dadd+0x3e8>
100084de:	4c19      	ldr	r4, [pc, #100]	; (10008544 <__aeabi_dadd+0x3ac>)
100084e0:	42a2      	cmp	r2, r4
100084e2:	d100      	bne.n	100084e6 <__aeabi_dadd+0x34e>
100084e4:	e0a8      	b.n	10008638 <__aeabi_dadd+0x4a0>
100084e6:	2480      	movs	r4, #128	; 0x80
100084e8:	0424      	lsls	r4, r4, #16
100084ea:	4240      	negs	r0, r0
100084ec:	4327      	orrs	r7, r4
100084ee:	2838      	cmp	r0, #56	; 0x38
100084f0:	dd00      	ble.n	100084f4 <__aeabi_dadd+0x35c>
100084f2:	e0d9      	b.n	100086a8 <__aeabi_dadd+0x510>
100084f4:	281f      	cmp	r0, #31
100084f6:	dd00      	ble.n	100084fa <__aeabi_dadd+0x362>
100084f8:	e139      	b.n	1000876e <__aeabi_dadd+0x5d6>
100084fa:	2420      	movs	r4, #32
100084fc:	1c3e      	adds	r6, r7, #0
100084fe:	1a24      	subs	r4, r4, r0
10008500:	40a6      	lsls	r6, r4
10008502:	46b0      	mov	r8, r6
10008504:	1c2e      	adds	r6, r5, #0
10008506:	46a1      	mov	r9, r4
10008508:	40c6      	lsrs	r6, r0
1000850a:	4644      	mov	r4, r8
1000850c:	4326      	orrs	r6, r4
1000850e:	464c      	mov	r4, r9
10008510:	40a5      	lsls	r5, r4
10008512:	1e6c      	subs	r4, r5, #1
10008514:	41a5      	sbcs	r5, r4
10008516:	40c7      	lsrs	r7, r0
10008518:	4335      	orrs	r5, r6
1000851a:	4660      	mov	r0, ip
1000851c:	1b45      	subs	r5, r0, r5
1000851e:	1bcf      	subs	r7, r1, r7
10008520:	45ac      	cmp	ip, r5
10008522:	4189      	sbcs	r1, r1
10008524:	4249      	negs	r1, r1
10008526:	1a7f      	subs	r7, r7, r1
10008528:	1c14      	adds	r4, r2, #0
1000852a:	4698      	mov	r8, r3
1000852c:	e6b8      	b.n	100082a0 <__aeabi_dadd+0x108>
1000852e:	464b      	mov	r3, r9
10008530:	464d      	mov	r5, r9
10008532:	4333      	orrs	r3, r6
10008534:	d000      	beq.n	10008538 <__aeabi_dadd+0x3a0>
10008536:	e6b8      	b.n	100082aa <__aeabi_dadd+0x112>
10008538:	2600      	movs	r6, #0
1000853a:	2700      	movs	r7, #0
1000853c:	2400      	movs	r4, #0
1000853e:	2500      	movs	r5, #0
10008540:	e6e4      	b.n	1000830c <__aeabi_dadd+0x174>
10008542:	46c0      	nop			; (mov r8, r8)
10008544:	000007ff 	.word	0x000007ff
10008548:	ff7fffff 	.word	0xff7fffff
1000854c:	800fffff 	.word	0x800fffff
10008550:	2b1f      	cmp	r3, #31
10008552:	dc5b      	bgt.n	1000860c <__aeabi_dadd+0x474>
10008554:	2220      	movs	r2, #32
10008556:	1c08      	adds	r0, r1, #0
10008558:	1ad2      	subs	r2, r2, r3
1000855a:	4090      	lsls	r0, r2
1000855c:	4681      	mov	r9, r0
1000855e:	4660      	mov	r0, ip
10008560:	4692      	mov	sl, r2
10008562:	40d8      	lsrs	r0, r3
10008564:	464a      	mov	r2, r9
10008566:	4310      	orrs	r0, r2
10008568:	4681      	mov	r9, r0
1000856a:	4652      	mov	r2, sl
1000856c:	4660      	mov	r0, ip
1000856e:	4090      	lsls	r0, r2
10008570:	1c02      	adds	r2, r0, #0
10008572:	1e50      	subs	r0, r2, #1
10008574:	4182      	sbcs	r2, r0
10008576:	4648      	mov	r0, r9
10008578:	4310      	orrs	r0, r2
1000857a:	1c0a      	adds	r2, r1, #0
1000857c:	40da      	lsrs	r2, r3
1000857e:	e6e7      	b.n	10008350 <__aeabi_dadd+0x1b8>
10008580:	1c3c      	adds	r4, r7, #0
10008582:	432c      	orrs	r4, r5
10008584:	d058      	beq.n	10008638 <__aeabi_dadd+0x4a0>
10008586:	43c0      	mvns	r0, r0
10008588:	2800      	cmp	r0, #0
1000858a:	d151      	bne.n	10008630 <__aeabi_dadd+0x498>
1000858c:	4660      	mov	r0, ip
1000858e:	1b45      	subs	r5, r0, r5
10008590:	45ac      	cmp	ip, r5
10008592:	4180      	sbcs	r0, r0
10008594:	1bcf      	subs	r7, r1, r7
10008596:	4240      	negs	r0, r0
10008598:	1a3f      	subs	r7, r7, r0
1000859a:	1c14      	adds	r4, r2, #0
1000859c:	4698      	mov	r8, r3
1000859e:	e67f      	b.n	100082a0 <__aeabi_dadd+0x108>
100085a0:	4a8f      	ldr	r2, [pc, #572]	; (100087e0 <__aeabi_dadd+0x648>)
100085a2:	4294      	cmp	r4, r2
100085a4:	d000      	beq.n	100085a8 <__aeabi_dadd+0x410>
100085a6:	e6ca      	b.n	1000833e <__aeabi_dadd+0x1a6>
100085a8:	e61e      	b.n	100081e8 <__aeabi_dadd+0x50>
100085aa:	2600      	movs	r6, #0
100085ac:	e77d      	b.n	100084aa <__aeabi_dadd+0x312>
100085ae:	2300      	movs	r3, #0
100085b0:	e78c      	b.n	100084cc <__aeabi_dadd+0x334>
100085b2:	1c3b      	adds	r3, r7, #0
100085b4:	432b      	orrs	r3, r5
100085b6:	2c00      	cmp	r4, #0
100085b8:	d000      	beq.n	100085bc <__aeabi_dadd+0x424>
100085ba:	e0bd      	b.n	10008738 <__aeabi_dadd+0x5a0>
100085bc:	2b00      	cmp	r3, #0
100085be:	d100      	bne.n	100085c2 <__aeabi_dadd+0x42a>
100085c0:	e0f5      	b.n	100087ae <__aeabi_dadd+0x616>
100085c2:	4663      	mov	r3, ip
100085c4:	430b      	orrs	r3, r1
100085c6:	d100      	bne.n	100085ca <__aeabi_dadd+0x432>
100085c8:	e60e      	b.n	100081e8 <__aeabi_dadd+0x50>
100085ca:	4663      	mov	r3, ip
100085cc:	195b      	adds	r3, r3, r5
100085ce:	42ab      	cmp	r3, r5
100085d0:	4180      	sbcs	r0, r0
100085d2:	19ca      	adds	r2, r1, r7
100085d4:	4240      	negs	r0, r0
100085d6:	1817      	adds	r7, r2, r0
100085d8:	023a      	lsls	r2, r7, #8
100085da:	d400      	bmi.n	100085de <__aeabi_dadd+0x446>
100085dc:	e0fc      	b.n	100087d8 <__aeabi_dadd+0x640>
100085de:	4a81      	ldr	r2, [pc, #516]	; (100087e4 <__aeabi_dadd+0x64c>)
100085e0:	1c1d      	adds	r5, r3, #0
100085e2:	4017      	ands	r7, r2
100085e4:	3401      	adds	r4, #1
100085e6:	e5ff      	b.n	100081e8 <__aeabi_dadd+0x50>
100085e8:	1c3a      	adds	r2, r7, #0
100085ea:	432a      	orrs	r2, r5
100085ec:	2c00      	cmp	r4, #0
100085ee:	d151      	bne.n	10008694 <__aeabi_dadd+0x4fc>
100085f0:	2a00      	cmp	r2, #0
100085f2:	d000      	beq.n	100085f6 <__aeabi_dadd+0x45e>
100085f4:	e085      	b.n	10008702 <__aeabi_dadd+0x56a>
100085f6:	4662      	mov	r2, ip
100085f8:	430a      	orrs	r2, r1
100085fa:	d003      	beq.n	10008604 <__aeabi_dadd+0x46c>
100085fc:	1c0f      	adds	r7, r1, #0
100085fe:	4665      	mov	r5, ip
10008600:	4698      	mov	r8, r3
10008602:	e5f1      	b.n	100081e8 <__aeabi_dadd+0x50>
10008604:	2600      	movs	r6, #0
10008606:	2700      	movs	r7, #0
10008608:	2500      	movs	r5, #0
1000860a:	e67f      	b.n	1000830c <__aeabi_dadd+0x174>
1000860c:	1c18      	adds	r0, r3, #0
1000860e:	1c0a      	adds	r2, r1, #0
10008610:	3820      	subs	r0, #32
10008612:	40c2      	lsrs	r2, r0
10008614:	2b20      	cmp	r3, #32
10008616:	d100      	bne.n	1000861a <__aeabi_dadd+0x482>
10008618:	e0a7      	b.n	1000876a <__aeabi_dadd+0x5d2>
1000861a:	2040      	movs	r0, #64	; 0x40
1000861c:	1ac0      	subs	r0, r0, r3
1000861e:	4081      	lsls	r1, r0
10008620:	1c08      	adds	r0, r1, #0
10008622:	4663      	mov	r3, ip
10008624:	4318      	orrs	r0, r3
10008626:	1e41      	subs	r1, r0, #1
10008628:	4188      	sbcs	r0, r1
1000862a:	4310      	orrs	r0, r2
1000862c:	2200      	movs	r2, #0
1000862e:	e68f      	b.n	10008350 <__aeabi_dadd+0x1b8>
10008630:	4c6b      	ldr	r4, [pc, #428]	; (100087e0 <__aeabi_dadd+0x648>)
10008632:	42a2      	cmp	r2, r4
10008634:	d000      	beq.n	10008638 <__aeabi_dadd+0x4a0>
10008636:	e75a      	b.n	100084ee <__aeabi_dadd+0x356>
10008638:	1c0f      	adds	r7, r1, #0
1000863a:	4665      	mov	r5, ip
1000863c:	1c14      	adds	r4, r2, #0
1000863e:	4698      	mov	r8, r3
10008640:	e5d2      	b.n	100081e8 <__aeabi_dadd+0x50>
10008642:	2c00      	cmp	r4, #0
10008644:	d13a      	bne.n	100086bc <__aeabi_dadd+0x524>
10008646:	1c38      	adds	r0, r7, #0
10008648:	4328      	orrs	r0, r5
1000864a:	d071      	beq.n	10008730 <__aeabi_dadd+0x598>
1000864c:	43db      	mvns	r3, r3
1000864e:	2b00      	cmp	r3, #0
10008650:	d018      	beq.n	10008684 <__aeabi_dadd+0x4ec>
10008652:	4863      	ldr	r0, [pc, #396]	; (100087e0 <__aeabi_dadd+0x648>)
10008654:	4282      	cmp	r2, r0
10008656:	d06b      	beq.n	10008730 <__aeabi_dadd+0x598>
10008658:	2b38      	cmp	r3, #56	; 0x38
1000865a:	dd00      	ble.n	1000865e <__aeabi_dadd+0x4c6>
1000865c:	e09d      	b.n	1000879a <__aeabi_dadd+0x602>
1000865e:	2b1f      	cmp	r3, #31
10008660:	dd00      	ble.n	10008664 <__aeabi_dadd+0x4cc>
10008662:	e0a7      	b.n	100087b4 <__aeabi_dadd+0x61c>
10008664:	2020      	movs	r0, #32
10008666:	1c3c      	adds	r4, r7, #0
10008668:	1ac0      	subs	r0, r0, r3
1000866a:	4084      	lsls	r4, r0
1000866c:	46a1      	mov	r9, r4
1000866e:	1c2c      	adds	r4, r5, #0
10008670:	4682      	mov	sl, r0
10008672:	40dc      	lsrs	r4, r3
10008674:	4648      	mov	r0, r9
10008676:	4304      	orrs	r4, r0
10008678:	4650      	mov	r0, sl
1000867a:	4085      	lsls	r5, r0
1000867c:	1e68      	subs	r0, r5, #1
1000867e:	4185      	sbcs	r5, r0
10008680:	40df      	lsrs	r7, r3
10008682:	4325      	orrs	r5, r4
10008684:	4465      	add	r5, ip
10008686:	4565      	cmp	r5, ip
10008688:	419b      	sbcs	r3, r3
1000868a:	187f      	adds	r7, r7, r1
1000868c:	425b      	negs	r3, r3
1000868e:	18ff      	adds	r7, r7, r3
10008690:	1c14      	adds	r4, r2, #0
10008692:	e664      	b.n	1000835e <__aeabi_dadd+0x1c6>
10008694:	2a00      	cmp	r2, #0
10008696:	d119      	bne.n	100086cc <__aeabi_dadd+0x534>
10008698:	4662      	mov	r2, ip
1000869a:	430a      	orrs	r2, r1
1000869c:	d077      	beq.n	1000878e <__aeabi_dadd+0x5f6>
1000869e:	1c0f      	adds	r7, r1, #0
100086a0:	4665      	mov	r5, ip
100086a2:	4698      	mov	r8, r3
100086a4:	4c4e      	ldr	r4, [pc, #312]	; (100087e0 <__aeabi_dadd+0x648>)
100086a6:	e59f      	b.n	100081e8 <__aeabi_dadd+0x50>
100086a8:	433d      	orrs	r5, r7
100086aa:	1e6f      	subs	r7, r5, #1
100086ac:	41bd      	sbcs	r5, r7
100086ae:	2700      	movs	r7, #0
100086b0:	b2ed      	uxtb	r5, r5
100086b2:	e732      	b.n	1000851a <__aeabi_dadd+0x382>
100086b4:	1c04      	adds	r4, r0, #0
100086b6:	2700      	movs	r7, #0
100086b8:	2500      	movs	r5, #0
100086ba:	e627      	b.n	1000830c <__aeabi_dadd+0x174>
100086bc:	4848      	ldr	r0, [pc, #288]	; (100087e0 <__aeabi_dadd+0x648>)
100086be:	4282      	cmp	r2, r0
100086c0:	d036      	beq.n	10008730 <__aeabi_dadd+0x598>
100086c2:	2080      	movs	r0, #128	; 0x80
100086c4:	0400      	lsls	r0, r0, #16
100086c6:	425b      	negs	r3, r3
100086c8:	4307      	orrs	r7, r0
100086ca:	e7c5      	b.n	10008658 <__aeabi_dadd+0x4c0>
100086cc:	4662      	mov	r2, ip
100086ce:	430a      	orrs	r2, r1
100086d0:	d049      	beq.n	10008766 <__aeabi_dadd+0x5ce>
100086d2:	2480      	movs	r4, #128	; 0x80
100086d4:	08ed      	lsrs	r5, r5, #3
100086d6:	0778      	lsls	r0, r7, #29
100086d8:	08fa      	lsrs	r2, r7, #3
100086da:	0324      	lsls	r4, r4, #12
100086dc:	4328      	orrs	r0, r5
100086de:	4222      	tst	r2, r4
100086e0:	d009      	beq.n	100086f6 <__aeabi_dadd+0x55e>
100086e2:	08ce      	lsrs	r6, r1, #3
100086e4:	4226      	tst	r6, r4
100086e6:	d106      	bne.n	100086f6 <__aeabi_dadd+0x55e>
100086e8:	4662      	mov	r2, ip
100086ea:	074f      	lsls	r7, r1, #29
100086ec:	1c38      	adds	r0, r7, #0
100086ee:	08d2      	lsrs	r2, r2, #3
100086f0:	4310      	orrs	r0, r2
100086f2:	4698      	mov	r8, r3
100086f4:	1c32      	adds	r2, r6, #0
100086f6:	00d2      	lsls	r2, r2, #3
100086f8:	0f47      	lsrs	r7, r0, #29
100086fa:	4317      	orrs	r7, r2
100086fc:	00c5      	lsls	r5, r0, #3
100086fe:	4c38      	ldr	r4, [pc, #224]	; (100087e0 <__aeabi_dadd+0x648>)
10008700:	e572      	b.n	100081e8 <__aeabi_dadd+0x50>
10008702:	4662      	mov	r2, ip
10008704:	430a      	orrs	r2, r1
10008706:	d100      	bne.n	1000870a <__aeabi_dadd+0x572>
10008708:	e56e      	b.n	100081e8 <__aeabi_dadd+0x50>
1000870a:	4662      	mov	r2, ip
1000870c:	1aae      	subs	r6, r5, r2
1000870e:	42b5      	cmp	r5, r6
10008710:	4192      	sbcs	r2, r2
10008712:	1a78      	subs	r0, r7, r1
10008714:	4252      	negs	r2, r2
10008716:	1a82      	subs	r2, r0, r2
10008718:	0210      	lsls	r0, r2, #8
1000871a:	d400      	bmi.n	1000871e <__aeabi_dadd+0x586>
1000871c:	e655      	b.n	100083ca <__aeabi_dadd+0x232>
1000871e:	4662      	mov	r2, ip
10008720:	1b55      	subs	r5, r2, r5
10008722:	45ac      	cmp	ip, r5
10008724:	4180      	sbcs	r0, r0
10008726:	1bca      	subs	r2, r1, r7
10008728:	4240      	negs	r0, r0
1000872a:	1a17      	subs	r7, r2, r0
1000872c:	4698      	mov	r8, r3
1000872e:	e55b      	b.n	100081e8 <__aeabi_dadd+0x50>
10008730:	1c0f      	adds	r7, r1, #0
10008732:	4665      	mov	r5, ip
10008734:	1c14      	adds	r4, r2, #0
10008736:	e557      	b.n	100081e8 <__aeabi_dadd+0x50>
10008738:	2b00      	cmp	r3, #0
1000873a:	d034      	beq.n	100087a6 <__aeabi_dadd+0x60e>
1000873c:	4663      	mov	r3, ip
1000873e:	430b      	orrs	r3, r1
10008740:	d011      	beq.n	10008766 <__aeabi_dadd+0x5ce>
10008742:	2480      	movs	r4, #128	; 0x80
10008744:	08ed      	lsrs	r5, r5, #3
10008746:	0778      	lsls	r0, r7, #29
10008748:	08fa      	lsrs	r2, r7, #3
1000874a:	0324      	lsls	r4, r4, #12
1000874c:	4328      	orrs	r0, r5
1000874e:	4222      	tst	r2, r4
10008750:	d0d1      	beq.n	100086f6 <__aeabi_dadd+0x55e>
10008752:	08cb      	lsrs	r3, r1, #3
10008754:	4223      	tst	r3, r4
10008756:	d1ce      	bne.n	100086f6 <__aeabi_dadd+0x55e>
10008758:	4662      	mov	r2, ip
1000875a:	074f      	lsls	r7, r1, #29
1000875c:	1c38      	adds	r0, r7, #0
1000875e:	08d2      	lsrs	r2, r2, #3
10008760:	4310      	orrs	r0, r2
10008762:	1c1a      	adds	r2, r3, #0
10008764:	e7c7      	b.n	100086f6 <__aeabi_dadd+0x55e>
10008766:	4c1e      	ldr	r4, [pc, #120]	; (100087e0 <__aeabi_dadd+0x648>)
10008768:	e53e      	b.n	100081e8 <__aeabi_dadd+0x50>
1000876a:	2000      	movs	r0, #0
1000876c:	e759      	b.n	10008622 <__aeabi_dadd+0x48a>
1000876e:	1c04      	adds	r4, r0, #0
10008770:	1c3e      	adds	r6, r7, #0
10008772:	3c20      	subs	r4, #32
10008774:	40e6      	lsrs	r6, r4
10008776:	1c34      	adds	r4, r6, #0
10008778:	2820      	cmp	r0, #32
1000877a:	d02b      	beq.n	100087d4 <__aeabi_dadd+0x63c>
1000877c:	2640      	movs	r6, #64	; 0x40
1000877e:	1a30      	subs	r0, r6, r0
10008780:	4087      	lsls	r7, r0
10008782:	433d      	orrs	r5, r7
10008784:	1e6f      	subs	r7, r5, #1
10008786:	41bd      	sbcs	r5, r7
10008788:	2700      	movs	r7, #0
1000878a:	4325      	orrs	r5, r4
1000878c:	e6c5      	b.n	1000851a <__aeabi_dadd+0x382>
1000878e:	2780      	movs	r7, #128	; 0x80
10008790:	2600      	movs	r6, #0
10008792:	03ff      	lsls	r7, r7, #15
10008794:	4c12      	ldr	r4, [pc, #72]	; (100087e0 <__aeabi_dadd+0x648>)
10008796:	2500      	movs	r5, #0
10008798:	e5b8      	b.n	1000830c <__aeabi_dadd+0x174>
1000879a:	433d      	orrs	r5, r7
1000879c:	1e6f      	subs	r7, r5, #1
1000879e:	41bd      	sbcs	r5, r7
100087a0:	2700      	movs	r7, #0
100087a2:	b2ed      	uxtb	r5, r5
100087a4:	e76e      	b.n	10008684 <__aeabi_dadd+0x4ec>
100087a6:	1c0f      	adds	r7, r1, #0
100087a8:	4665      	mov	r5, ip
100087aa:	4c0d      	ldr	r4, [pc, #52]	; (100087e0 <__aeabi_dadd+0x648>)
100087ac:	e51c      	b.n	100081e8 <__aeabi_dadd+0x50>
100087ae:	1c0f      	adds	r7, r1, #0
100087b0:	4665      	mov	r5, ip
100087b2:	e519      	b.n	100081e8 <__aeabi_dadd+0x50>
100087b4:	1c1c      	adds	r4, r3, #0
100087b6:	1c38      	adds	r0, r7, #0
100087b8:	3c20      	subs	r4, #32
100087ba:	40e0      	lsrs	r0, r4
100087bc:	1c04      	adds	r4, r0, #0
100087be:	2b20      	cmp	r3, #32
100087c0:	d00c      	beq.n	100087dc <__aeabi_dadd+0x644>
100087c2:	2040      	movs	r0, #64	; 0x40
100087c4:	1ac3      	subs	r3, r0, r3
100087c6:	409f      	lsls	r7, r3
100087c8:	433d      	orrs	r5, r7
100087ca:	1e6f      	subs	r7, r5, #1
100087cc:	41bd      	sbcs	r5, r7
100087ce:	2700      	movs	r7, #0
100087d0:	4325      	orrs	r5, r4
100087d2:	e757      	b.n	10008684 <__aeabi_dadd+0x4ec>
100087d4:	2700      	movs	r7, #0
100087d6:	e7d4      	b.n	10008782 <__aeabi_dadd+0x5ea>
100087d8:	1c1d      	adds	r5, r3, #0
100087da:	e5fc      	b.n	100083d6 <__aeabi_dadd+0x23e>
100087dc:	2700      	movs	r7, #0
100087de:	e7f3      	b.n	100087c8 <__aeabi_dadd+0x630>
100087e0:	000007ff 	.word	0x000007ff
100087e4:	ff7fffff 	.word	0xff7fffff

100087e8 <__aeabi_ddiv>:
100087e8:	b5f0      	push	{r4, r5, r6, r7, lr}
100087ea:	465f      	mov	r7, fp
100087ec:	4656      	mov	r6, sl
100087ee:	464d      	mov	r5, r9
100087f0:	4644      	mov	r4, r8
100087f2:	b4f0      	push	{r4, r5, r6, r7}
100087f4:	030f      	lsls	r7, r1, #12
100087f6:	b087      	sub	sp, #28
100087f8:	4698      	mov	r8, r3
100087fa:	004d      	lsls	r5, r1, #1
100087fc:	0b3b      	lsrs	r3, r7, #12
100087fe:	0fcc      	lsrs	r4, r1, #31
10008800:	1c06      	adds	r6, r0, #0
10008802:	4692      	mov	sl, r2
10008804:	4681      	mov	r9, r0
10008806:	469b      	mov	fp, r3
10008808:	0d6d      	lsrs	r5, r5, #21
1000880a:	9401      	str	r4, [sp, #4]
1000880c:	d06b      	beq.n	100088e6 <__aeabi_ddiv+0xfe>
1000880e:	4b66      	ldr	r3, [pc, #408]	; (100089a8 <__aeabi_ddiv+0x1c0>)
10008810:	429d      	cmp	r5, r3
10008812:	d035      	beq.n	10008880 <__aeabi_ddiv+0x98>
10008814:	2780      	movs	r7, #128	; 0x80
10008816:	465b      	mov	r3, fp
10008818:	037f      	lsls	r7, r7, #13
1000881a:	431f      	orrs	r7, r3
1000881c:	00f3      	lsls	r3, r6, #3
1000881e:	4699      	mov	r9, r3
10008820:	4b62      	ldr	r3, [pc, #392]	; (100089ac <__aeabi_ddiv+0x1c4>)
10008822:	00ff      	lsls	r7, r7, #3
10008824:	0f40      	lsrs	r0, r0, #29
10008826:	469c      	mov	ip, r3
10008828:	4307      	orrs	r7, r0
1000882a:	2300      	movs	r3, #0
1000882c:	46bb      	mov	fp, r7
1000882e:	2600      	movs	r6, #0
10008830:	4465      	add	r5, ip
10008832:	9300      	str	r3, [sp, #0]
10008834:	4642      	mov	r2, r8
10008836:	0317      	lsls	r7, r2, #12
10008838:	0050      	lsls	r0, r2, #1
1000883a:	0fd2      	lsrs	r2, r2, #31
1000883c:	4653      	mov	r3, sl
1000883e:	0b3f      	lsrs	r7, r7, #12
10008840:	0d40      	lsrs	r0, r0, #21
10008842:	4690      	mov	r8, r2
10008844:	d100      	bne.n	10008848 <__aeabi_ddiv+0x60>
10008846:	e072      	b.n	1000892e <__aeabi_ddiv+0x146>
10008848:	4a57      	ldr	r2, [pc, #348]	; (100089a8 <__aeabi_ddiv+0x1c0>)
1000884a:	4290      	cmp	r0, r2
1000884c:	d067      	beq.n	1000891e <__aeabi_ddiv+0x136>
1000884e:	2380      	movs	r3, #128	; 0x80
10008850:	035b      	lsls	r3, r3, #13
10008852:	431f      	orrs	r7, r3
10008854:	4653      	mov	r3, sl
10008856:	4a55      	ldr	r2, [pc, #340]	; (100089ac <__aeabi_ddiv+0x1c4>)
10008858:	0f5b      	lsrs	r3, r3, #29
1000885a:	00ff      	lsls	r7, r7, #3
1000885c:	431f      	orrs	r7, r3
1000885e:	4694      	mov	ip, r2
10008860:	4653      	mov	r3, sl
10008862:	2100      	movs	r1, #0
10008864:	00db      	lsls	r3, r3, #3
10008866:	4460      	add	r0, ip
10008868:	4642      	mov	r2, r8
1000886a:	4062      	eors	r2, r4
1000886c:	4692      	mov	sl, r2
1000886e:	1a2d      	subs	r5, r5, r0
10008870:	430e      	orrs	r6, r1
10008872:	2e0f      	cmp	r6, #15
10008874:	d900      	bls.n	10008878 <__aeabi_ddiv+0x90>
10008876:	e0a1      	b.n	100089bc <__aeabi_ddiv+0x1d4>
10008878:	484d      	ldr	r0, [pc, #308]	; (100089b0 <__aeabi_ddiv+0x1c8>)
1000887a:	00b6      	lsls	r6, r6, #2
1000887c:	5980      	ldr	r0, [r0, r6]
1000887e:	4687      	mov	pc, r0
10008880:	465b      	mov	r3, fp
10008882:	431e      	orrs	r6, r3
10008884:	d000      	beq.n	10008888 <__aeabi_ddiv+0xa0>
10008886:	e076      	b.n	10008976 <__aeabi_ddiv+0x18e>
10008888:	2300      	movs	r3, #0
1000888a:	469b      	mov	fp, r3
1000888c:	4699      	mov	r9, r3
1000888e:	3302      	adds	r3, #2
10008890:	2608      	movs	r6, #8
10008892:	9300      	str	r3, [sp, #0]
10008894:	e7ce      	b.n	10008834 <__aeabi_ddiv+0x4c>
10008896:	4699      	mov	r9, r3
10008898:	4643      	mov	r3, r8
1000889a:	46bb      	mov	fp, r7
1000889c:	9301      	str	r3, [sp, #4]
1000889e:	9100      	str	r1, [sp, #0]
100088a0:	9b00      	ldr	r3, [sp, #0]
100088a2:	2b02      	cmp	r3, #2
100088a4:	d16b      	bne.n	1000897e <__aeabi_ddiv+0x196>
100088a6:	9b01      	ldr	r3, [sp, #4]
100088a8:	469a      	mov	sl, r3
100088aa:	2100      	movs	r1, #0
100088ac:	4653      	mov	r3, sl
100088ae:	2201      	movs	r2, #1
100088b0:	2700      	movs	r7, #0
100088b2:	4689      	mov	r9, r1
100088b4:	401a      	ands	r2, r3
100088b6:	4b3c      	ldr	r3, [pc, #240]	; (100089a8 <__aeabi_ddiv+0x1c0>)
100088b8:	2100      	movs	r1, #0
100088ba:	033f      	lsls	r7, r7, #12
100088bc:	0d0c      	lsrs	r4, r1, #20
100088be:	0524      	lsls	r4, r4, #20
100088c0:	0b3f      	lsrs	r7, r7, #12
100088c2:	4327      	orrs	r7, r4
100088c4:	4c3b      	ldr	r4, [pc, #236]	; (100089b4 <__aeabi_ddiv+0x1cc>)
100088c6:	051b      	lsls	r3, r3, #20
100088c8:	4027      	ands	r7, r4
100088ca:	431f      	orrs	r7, r3
100088cc:	007f      	lsls	r7, r7, #1
100088ce:	07d2      	lsls	r2, r2, #31
100088d0:	087f      	lsrs	r7, r7, #1
100088d2:	4317      	orrs	r7, r2
100088d4:	4648      	mov	r0, r9
100088d6:	1c39      	adds	r1, r7, #0
100088d8:	b007      	add	sp, #28
100088da:	bc3c      	pop	{r2, r3, r4, r5}
100088dc:	4690      	mov	r8, r2
100088de:	4699      	mov	r9, r3
100088e0:	46a2      	mov	sl, r4
100088e2:	46ab      	mov	fp, r5
100088e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
100088e6:	4303      	orrs	r3, r0
100088e8:	d03e      	beq.n	10008968 <__aeabi_ddiv+0x180>
100088ea:	465b      	mov	r3, fp
100088ec:	2b00      	cmp	r3, #0
100088ee:	d100      	bne.n	100088f2 <__aeabi_ddiv+0x10a>
100088f0:	e19c      	b.n	10008c2c <__aeabi_ddiv+0x444>
100088f2:	4658      	mov	r0, fp
100088f4:	f7fc fe12 	bl	1000551c <__clzsi2>
100088f8:	2328      	movs	r3, #40	; 0x28
100088fa:	1c31      	adds	r1, r6, #0
100088fc:	1a1b      	subs	r3, r3, r0
100088fe:	1c02      	adds	r2, r0, #0
10008900:	465f      	mov	r7, fp
10008902:	40d9      	lsrs	r1, r3
10008904:	3a08      	subs	r2, #8
10008906:	4097      	lsls	r7, r2
10008908:	1c0b      	adds	r3, r1, #0
1000890a:	4096      	lsls	r6, r2
1000890c:	433b      	orrs	r3, r7
1000890e:	469b      	mov	fp, r3
10008910:	46b1      	mov	r9, r6
10008912:	2300      	movs	r3, #0
10008914:	4d28      	ldr	r5, [pc, #160]	; (100089b8 <__aeabi_ddiv+0x1d0>)
10008916:	2600      	movs	r6, #0
10008918:	1a2d      	subs	r5, r5, r0
1000891a:	9300      	str	r3, [sp, #0]
1000891c:	e78a      	b.n	10008834 <__aeabi_ddiv+0x4c>
1000891e:	4652      	mov	r2, sl
10008920:	2103      	movs	r1, #3
10008922:	433a      	orrs	r2, r7
10008924:	d1a0      	bne.n	10008868 <__aeabi_ddiv+0x80>
10008926:	2700      	movs	r7, #0
10008928:	2300      	movs	r3, #0
1000892a:	2102      	movs	r1, #2
1000892c:	e79c      	b.n	10008868 <__aeabi_ddiv+0x80>
1000892e:	4652      	mov	r2, sl
10008930:	433a      	orrs	r2, r7
10008932:	d015      	beq.n	10008960 <__aeabi_ddiv+0x178>
10008934:	2f00      	cmp	r7, #0
10008936:	d100      	bne.n	1000893a <__aeabi_ddiv+0x152>
10008938:	e185      	b.n	10008c46 <__aeabi_ddiv+0x45e>
1000893a:	1c38      	adds	r0, r7, #0
1000893c:	f7fc fdee 	bl	1000551c <__clzsi2>
10008940:	1c02      	adds	r2, r0, #0
10008942:	2128      	movs	r1, #40	; 0x28
10008944:	4650      	mov	r0, sl
10008946:	1a89      	subs	r1, r1, r2
10008948:	1c13      	adds	r3, r2, #0
1000894a:	40c8      	lsrs	r0, r1
1000894c:	4651      	mov	r1, sl
1000894e:	3b08      	subs	r3, #8
10008950:	4099      	lsls	r1, r3
10008952:	409f      	lsls	r7, r3
10008954:	1c0b      	adds	r3, r1, #0
10008956:	4307      	orrs	r7, r0
10008958:	4817      	ldr	r0, [pc, #92]	; (100089b8 <__aeabi_ddiv+0x1d0>)
1000895a:	2100      	movs	r1, #0
1000895c:	1a80      	subs	r0, r0, r2
1000895e:	e783      	b.n	10008868 <__aeabi_ddiv+0x80>
10008960:	2700      	movs	r7, #0
10008962:	2300      	movs	r3, #0
10008964:	2101      	movs	r1, #1
10008966:	e77f      	b.n	10008868 <__aeabi_ddiv+0x80>
10008968:	2300      	movs	r3, #0
1000896a:	469b      	mov	fp, r3
1000896c:	4699      	mov	r9, r3
1000896e:	3301      	adds	r3, #1
10008970:	2604      	movs	r6, #4
10008972:	9300      	str	r3, [sp, #0]
10008974:	e75e      	b.n	10008834 <__aeabi_ddiv+0x4c>
10008976:	2303      	movs	r3, #3
10008978:	260c      	movs	r6, #12
1000897a:	9300      	str	r3, [sp, #0]
1000897c:	e75a      	b.n	10008834 <__aeabi_ddiv+0x4c>
1000897e:	2b03      	cmp	r3, #3
10008980:	d100      	bne.n	10008984 <__aeabi_ddiv+0x19c>
10008982:	e23c      	b.n	10008dfe <__aeabi_ddiv+0x616>
10008984:	2b01      	cmp	r3, #1
10008986:	d000      	beq.n	1000898a <__aeabi_ddiv+0x1a2>
10008988:	e1bf      	b.n	10008d0a <__aeabi_ddiv+0x522>
1000898a:	1c1a      	adds	r2, r3, #0
1000898c:	9b01      	ldr	r3, [sp, #4]
1000898e:	401a      	ands	r2, r3
10008990:	2100      	movs	r1, #0
10008992:	2300      	movs	r3, #0
10008994:	2700      	movs	r7, #0
10008996:	4689      	mov	r9, r1
10008998:	e78e      	b.n	100088b8 <__aeabi_ddiv+0xd0>
1000899a:	2300      	movs	r3, #0
1000899c:	2780      	movs	r7, #128	; 0x80
1000899e:	4699      	mov	r9, r3
100089a0:	2200      	movs	r2, #0
100089a2:	033f      	lsls	r7, r7, #12
100089a4:	4b00      	ldr	r3, [pc, #0]	; (100089a8 <__aeabi_ddiv+0x1c0>)
100089a6:	e787      	b.n	100088b8 <__aeabi_ddiv+0xd0>
100089a8:	000007ff 	.word	0x000007ff
100089ac:	fffffc01 	.word	0xfffffc01
100089b0:	1000a528 	.word	0x1000a528
100089b4:	800fffff 	.word	0x800fffff
100089b8:	fffffc0d 	.word	0xfffffc0d
100089bc:	45bb      	cmp	fp, r7
100089be:	d900      	bls.n	100089c2 <__aeabi_ddiv+0x1da>
100089c0:	e151      	b.n	10008c66 <__aeabi_ddiv+0x47e>
100089c2:	d100      	bne.n	100089c6 <__aeabi_ddiv+0x1de>
100089c4:	e14c      	b.n	10008c60 <__aeabi_ddiv+0x478>
100089c6:	464a      	mov	r2, r9
100089c8:	9203      	str	r2, [sp, #12]
100089ca:	2200      	movs	r2, #0
100089cc:	465c      	mov	r4, fp
100089ce:	4690      	mov	r8, r2
100089d0:	3d01      	subs	r5, #1
100089d2:	0e18      	lsrs	r0, r3, #24
100089d4:	023f      	lsls	r7, r7, #8
100089d6:	4338      	orrs	r0, r7
100089d8:	021b      	lsls	r3, r3, #8
100089da:	9301      	str	r3, [sp, #4]
100089dc:	0c03      	lsrs	r3, r0, #16
100089de:	4699      	mov	r9, r3
100089e0:	0403      	lsls	r3, r0, #16
100089e2:	0c1b      	lsrs	r3, r3, #16
100089e4:	4649      	mov	r1, r9
100089e6:	1c06      	adds	r6, r0, #0
100089e8:	1c20      	adds	r0, r4, #0
100089ea:	1c1f      	adds	r7, r3, #0
100089ec:	9300      	str	r3, [sp, #0]
100089ee:	f7fc fc13 	bl	10005218 <__aeabi_uidiv>
100089f2:	1c02      	adds	r2, r0, #0
100089f4:	437a      	muls	r2, r7
100089f6:	9002      	str	r0, [sp, #8]
100089f8:	4649      	mov	r1, r9
100089fa:	1c20      	adds	r0, r4, #0
100089fc:	1c17      	adds	r7, r2, #0
100089fe:	f7fc fc91 	bl	10005324 <__aeabi_uidivmod>
10008a02:	9b03      	ldr	r3, [sp, #12]
10008a04:	0409      	lsls	r1, r1, #16
10008a06:	0c1b      	lsrs	r3, r3, #16
10008a08:	4319      	orrs	r1, r3
10008a0a:	428f      	cmp	r7, r1
10008a0c:	d90c      	bls.n	10008a28 <__aeabi_ddiv+0x240>
10008a0e:	9b02      	ldr	r3, [sp, #8]
10008a10:	1989      	adds	r1, r1, r6
10008a12:	3b01      	subs	r3, #1
10008a14:	428e      	cmp	r6, r1
10008a16:	d900      	bls.n	10008a1a <__aeabi_ddiv+0x232>
10008a18:	e152      	b.n	10008cc0 <__aeabi_ddiv+0x4d8>
10008a1a:	428f      	cmp	r7, r1
10008a1c:	d800      	bhi.n	10008a20 <__aeabi_ddiv+0x238>
10008a1e:	e14f      	b.n	10008cc0 <__aeabi_ddiv+0x4d8>
10008a20:	9b02      	ldr	r3, [sp, #8]
10008a22:	1989      	adds	r1, r1, r6
10008a24:	3b02      	subs	r3, #2
10008a26:	9302      	str	r3, [sp, #8]
10008a28:	1bcc      	subs	r4, r1, r7
10008a2a:	1c20      	adds	r0, r4, #0
10008a2c:	4649      	mov	r1, r9
10008a2e:	f7fc fbf3 	bl	10005218 <__aeabi_uidiv>
10008a32:	9f00      	ldr	r7, [sp, #0]
10008a34:	4683      	mov	fp, r0
10008a36:	4347      	muls	r7, r0
10008a38:	4649      	mov	r1, r9
10008a3a:	1c20      	adds	r0, r4, #0
10008a3c:	f7fc fc72 	bl	10005324 <__aeabi_uidivmod>
10008a40:	9a03      	ldr	r2, [sp, #12]
10008a42:	040b      	lsls	r3, r1, #16
10008a44:	0414      	lsls	r4, r2, #16
10008a46:	0c24      	lsrs	r4, r4, #16
10008a48:	4323      	orrs	r3, r4
10008a4a:	429f      	cmp	r7, r3
10008a4c:	d90d      	bls.n	10008a6a <__aeabi_ddiv+0x282>
10008a4e:	465a      	mov	r2, fp
10008a50:	199b      	adds	r3, r3, r6
10008a52:	3a01      	subs	r2, #1
10008a54:	429e      	cmp	r6, r3
10008a56:	d900      	bls.n	10008a5a <__aeabi_ddiv+0x272>
10008a58:	e130      	b.n	10008cbc <__aeabi_ddiv+0x4d4>
10008a5a:	429f      	cmp	r7, r3
10008a5c:	d800      	bhi.n	10008a60 <__aeabi_ddiv+0x278>
10008a5e:	e12d      	b.n	10008cbc <__aeabi_ddiv+0x4d4>
10008a60:	2202      	movs	r2, #2
10008a62:	4252      	negs	r2, r2
10008a64:	4694      	mov	ip, r2
10008a66:	199b      	adds	r3, r3, r6
10008a68:	44e3      	add	fp, ip
10008a6a:	9a02      	ldr	r2, [sp, #8]
10008a6c:	1bdb      	subs	r3, r3, r7
10008a6e:	0417      	lsls	r7, r2, #16
10008a70:	465a      	mov	r2, fp
10008a72:	433a      	orrs	r2, r7
10008a74:	4693      	mov	fp, r2
10008a76:	9c01      	ldr	r4, [sp, #4]
10008a78:	0c17      	lsrs	r7, r2, #16
10008a7a:	0c22      	lsrs	r2, r4, #16
10008a7c:	1c10      	adds	r0, r2, #0
10008a7e:	9204      	str	r2, [sp, #16]
10008a80:	465a      	mov	r2, fp
10008a82:	0411      	lsls	r1, r2, #16
10008a84:	0422      	lsls	r2, r4, #16
10008a86:	0c12      	lsrs	r2, r2, #16
10008a88:	1c14      	adds	r4, r2, #0
10008a8a:	0c09      	lsrs	r1, r1, #16
10008a8c:	437c      	muls	r4, r7
10008a8e:	9205      	str	r2, [sp, #20]
10008a90:	434a      	muls	r2, r1
10008a92:	4341      	muls	r1, r0
10008a94:	4347      	muls	r7, r0
10008a96:	1861      	adds	r1, r4, r1
10008a98:	0c10      	lsrs	r0, r2, #16
10008a9a:	1809      	adds	r1, r1, r0
10008a9c:	428c      	cmp	r4, r1
10008a9e:	d903      	bls.n	10008aa8 <__aeabi_ddiv+0x2c0>
10008aa0:	2080      	movs	r0, #128	; 0x80
10008aa2:	0240      	lsls	r0, r0, #9
10008aa4:	4684      	mov	ip, r0
10008aa6:	4467      	add	r7, ip
10008aa8:	0c0c      	lsrs	r4, r1, #16
10008aaa:	0412      	lsls	r2, r2, #16
10008aac:	0408      	lsls	r0, r1, #16
10008aae:	0c12      	lsrs	r2, r2, #16
10008ab0:	193c      	adds	r4, r7, r4
10008ab2:	1881      	adds	r1, r0, r2
10008ab4:	42a3      	cmp	r3, r4
10008ab6:	d200      	bcs.n	10008aba <__aeabi_ddiv+0x2d2>
10008ab8:	e0e5      	b.n	10008c86 <__aeabi_ddiv+0x49e>
10008aba:	d100      	bne.n	10008abe <__aeabi_ddiv+0x2d6>
10008abc:	e0df      	b.n	10008c7e <__aeabi_ddiv+0x496>
10008abe:	1b1f      	subs	r7, r3, r4
10008ac0:	4643      	mov	r3, r8
10008ac2:	1a5c      	subs	r4, r3, r1
10008ac4:	45a0      	cmp	r8, r4
10008ac6:	4192      	sbcs	r2, r2
10008ac8:	4252      	negs	r2, r2
10008aca:	1abf      	subs	r7, r7, r2
10008acc:	42b7      	cmp	r7, r6
10008ace:	d100      	bne.n	10008ad2 <__aeabi_ddiv+0x2ea>
10008ad0:	e10e      	b.n	10008cf0 <__aeabi_ddiv+0x508>
10008ad2:	1c38      	adds	r0, r7, #0
10008ad4:	4649      	mov	r1, r9
10008ad6:	f7fc fb9f 	bl	10005218 <__aeabi_uidiv>
10008ada:	9b00      	ldr	r3, [sp, #0]
10008adc:	9002      	str	r0, [sp, #8]
10008ade:	4343      	muls	r3, r0
10008ae0:	4649      	mov	r1, r9
10008ae2:	1c38      	adds	r0, r7, #0
10008ae4:	4698      	mov	r8, r3
10008ae6:	f7fc fc1d 	bl	10005324 <__aeabi_uidivmod>
10008aea:	0c23      	lsrs	r3, r4, #16
10008aec:	040f      	lsls	r7, r1, #16
10008aee:	431f      	orrs	r7, r3
10008af0:	45b8      	cmp	r8, r7
10008af2:	d90c      	bls.n	10008b0e <__aeabi_ddiv+0x326>
10008af4:	9b02      	ldr	r3, [sp, #8]
10008af6:	19bf      	adds	r7, r7, r6
10008af8:	3b01      	subs	r3, #1
10008afa:	42be      	cmp	r6, r7
10008afc:	d900      	bls.n	10008b00 <__aeabi_ddiv+0x318>
10008afe:	e0fb      	b.n	10008cf8 <__aeabi_ddiv+0x510>
10008b00:	45b8      	cmp	r8, r7
10008b02:	d800      	bhi.n	10008b06 <__aeabi_ddiv+0x31e>
10008b04:	e0f8      	b.n	10008cf8 <__aeabi_ddiv+0x510>
10008b06:	9b02      	ldr	r3, [sp, #8]
10008b08:	19bf      	adds	r7, r7, r6
10008b0a:	3b02      	subs	r3, #2
10008b0c:	9302      	str	r3, [sp, #8]
10008b0e:	4643      	mov	r3, r8
10008b10:	1aff      	subs	r7, r7, r3
10008b12:	4649      	mov	r1, r9
10008b14:	1c38      	adds	r0, r7, #0
10008b16:	f7fc fb7f 	bl	10005218 <__aeabi_uidiv>
10008b1a:	9b00      	ldr	r3, [sp, #0]
10008b1c:	9003      	str	r0, [sp, #12]
10008b1e:	4343      	muls	r3, r0
10008b20:	4649      	mov	r1, r9
10008b22:	1c38      	adds	r0, r7, #0
10008b24:	4698      	mov	r8, r3
10008b26:	f7fc fbfd 	bl	10005324 <__aeabi_uidivmod>
10008b2a:	0424      	lsls	r4, r4, #16
10008b2c:	0409      	lsls	r1, r1, #16
10008b2e:	0c24      	lsrs	r4, r4, #16
10008b30:	4321      	orrs	r1, r4
10008b32:	4588      	cmp	r8, r1
10008b34:	d90c      	bls.n	10008b50 <__aeabi_ddiv+0x368>
10008b36:	9b03      	ldr	r3, [sp, #12]
10008b38:	1989      	adds	r1, r1, r6
10008b3a:	3b01      	subs	r3, #1
10008b3c:	428e      	cmp	r6, r1
10008b3e:	d900      	bls.n	10008b42 <__aeabi_ddiv+0x35a>
10008b40:	e0dc      	b.n	10008cfc <__aeabi_ddiv+0x514>
10008b42:	4588      	cmp	r8, r1
10008b44:	d800      	bhi.n	10008b48 <__aeabi_ddiv+0x360>
10008b46:	e0d9      	b.n	10008cfc <__aeabi_ddiv+0x514>
10008b48:	9b03      	ldr	r3, [sp, #12]
10008b4a:	1989      	adds	r1, r1, r6
10008b4c:	3b02      	subs	r3, #2
10008b4e:	9303      	str	r3, [sp, #12]
10008b50:	4643      	mov	r3, r8
10008b52:	1ac9      	subs	r1, r1, r3
10008b54:	9b02      	ldr	r3, [sp, #8]
10008b56:	9a03      	ldr	r2, [sp, #12]
10008b58:	041b      	lsls	r3, r3, #16
10008b5a:	9c05      	ldr	r4, [sp, #20]
10008b5c:	431a      	orrs	r2, r3
10008b5e:	0c10      	lsrs	r0, r2, #16
10008b60:	0413      	lsls	r3, r2, #16
10008b62:	4691      	mov	r9, r2
10008b64:	1c22      	adds	r2, r4, #0
10008b66:	9f04      	ldr	r7, [sp, #16]
10008b68:	0c1b      	lsrs	r3, r3, #16
10008b6a:	435a      	muls	r2, r3
10008b6c:	4344      	muls	r4, r0
10008b6e:	437b      	muls	r3, r7
10008b70:	4378      	muls	r0, r7
10008b72:	18e3      	adds	r3, r4, r3
10008b74:	0c17      	lsrs	r7, r2, #16
10008b76:	19db      	adds	r3, r3, r7
10008b78:	429c      	cmp	r4, r3
10008b7a:	d903      	bls.n	10008b84 <__aeabi_ddiv+0x39c>
10008b7c:	2480      	movs	r4, #128	; 0x80
10008b7e:	0264      	lsls	r4, r4, #9
10008b80:	46a4      	mov	ip, r4
10008b82:	4460      	add	r0, ip
10008b84:	0c1c      	lsrs	r4, r3, #16
10008b86:	0412      	lsls	r2, r2, #16
10008b88:	041b      	lsls	r3, r3, #16
10008b8a:	0c12      	lsrs	r2, r2, #16
10008b8c:	1900      	adds	r0, r0, r4
10008b8e:	189b      	adds	r3, r3, r2
10008b90:	4281      	cmp	r1, r0
10008b92:	d200      	bcs.n	10008b96 <__aeabi_ddiv+0x3ae>
10008b94:	e096      	b.n	10008cc4 <__aeabi_ddiv+0x4dc>
10008b96:	d100      	bne.n	10008b9a <__aeabi_ddiv+0x3b2>
10008b98:	e0fc      	b.n	10008d94 <__aeabi_ddiv+0x5ac>
10008b9a:	464a      	mov	r2, r9
10008b9c:	2301      	movs	r3, #1
10008b9e:	431a      	orrs	r2, r3
10008ba0:	4691      	mov	r9, r2
10008ba2:	4b9b      	ldr	r3, [pc, #620]	; (10008e10 <__aeabi_ddiv+0x628>)
10008ba4:	18eb      	adds	r3, r5, r3
10008ba6:	2b00      	cmp	r3, #0
10008ba8:	dc00      	bgt.n	10008bac <__aeabi_ddiv+0x3c4>
10008baa:	e099      	b.n	10008ce0 <__aeabi_ddiv+0x4f8>
10008bac:	464a      	mov	r2, r9
10008bae:	0752      	lsls	r2, r2, #29
10008bb0:	d00a      	beq.n	10008bc8 <__aeabi_ddiv+0x3e0>
10008bb2:	220f      	movs	r2, #15
10008bb4:	4649      	mov	r1, r9
10008bb6:	400a      	ands	r2, r1
10008bb8:	2a04      	cmp	r2, #4
10008bba:	d005      	beq.n	10008bc8 <__aeabi_ddiv+0x3e0>
10008bbc:	3104      	adds	r1, #4
10008bbe:	4549      	cmp	r1, r9
10008bc0:	4192      	sbcs	r2, r2
10008bc2:	4689      	mov	r9, r1
10008bc4:	4252      	negs	r2, r2
10008bc6:	4493      	add	fp, r2
10008bc8:	465a      	mov	r2, fp
10008bca:	01d2      	lsls	r2, r2, #7
10008bcc:	d506      	bpl.n	10008bdc <__aeabi_ddiv+0x3f4>
10008bce:	465a      	mov	r2, fp
10008bd0:	4b90      	ldr	r3, [pc, #576]	; (10008e14 <__aeabi_ddiv+0x62c>)
10008bd2:	401a      	ands	r2, r3
10008bd4:	2380      	movs	r3, #128	; 0x80
10008bd6:	4693      	mov	fp, r2
10008bd8:	00db      	lsls	r3, r3, #3
10008bda:	18eb      	adds	r3, r5, r3
10008bdc:	4a8e      	ldr	r2, [pc, #568]	; (10008e18 <__aeabi_ddiv+0x630>)
10008bde:	4293      	cmp	r3, r2
10008be0:	dd00      	ble.n	10008be4 <__aeabi_ddiv+0x3fc>
10008be2:	e662      	b.n	100088aa <__aeabi_ddiv+0xc2>
10008be4:	464a      	mov	r2, r9
10008be6:	4659      	mov	r1, fp
10008be8:	08d2      	lsrs	r2, r2, #3
10008bea:	0749      	lsls	r1, r1, #29
10008bec:	4311      	orrs	r1, r2
10008bee:	465a      	mov	r2, fp
10008bf0:	4689      	mov	r9, r1
10008bf2:	0257      	lsls	r7, r2, #9
10008bf4:	4651      	mov	r1, sl
10008bf6:	2201      	movs	r2, #1
10008bf8:	055b      	lsls	r3, r3, #21
10008bfa:	0b3f      	lsrs	r7, r7, #12
10008bfc:	0d5b      	lsrs	r3, r3, #21
10008bfe:	400a      	ands	r2, r1
10008c00:	e65a      	b.n	100088b8 <__aeabi_ddiv+0xd0>
10008c02:	2080      	movs	r0, #128	; 0x80
10008c04:	465a      	mov	r2, fp
10008c06:	0300      	lsls	r0, r0, #12
10008c08:	4202      	tst	r2, r0
10008c0a:	d008      	beq.n	10008c1e <__aeabi_ddiv+0x436>
10008c0c:	4207      	tst	r7, r0
10008c0e:	d106      	bne.n	10008c1e <__aeabi_ddiv+0x436>
10008c10:	4307      	orrs	r7, r0
10008c12:	033f      	lsls	r7, r7, #12
10008c14:	4699      	mov	r9, r3
10008c16:	0b3f      	lsrs	r7, r7, #12
10008c18:	4642      	mov	r2, r8
10008c1a:	4b80      	ldr	r3, [pc, #512]	; (10008e1c <__aeabi_ddiv+0x634>)
10008c1c:	e64c      	b.n	100088b8 <__aeabi_ddiv+0xd0>
10008c1e:	465f      	mov	r7, fp
10008c20:	4307      	orrs	r7, r0
10008c22:	033f      	lsls	r7, r7, #12
10008c24:	0b3f      	lsrs	r7, r7, #12
10008c26:	1c22      	adds	r2, r4, #0
10008c28:	4b7c      	ldr	r3, [pc, #496]	; (10008e1c <__aeabi_ddiv+0x634>)
10008c2a:	e645      	b.n	100088b8 <__aeabi_ddiv+0xd0>
10008c2c:	f7fc fc76 	bl	1000551c <__clzsi2>
10008c30:	1c03      	adds	r3, r0, #0
10008c32:	3020      	adds	r0, #32
10008c34:	2827      	cmp	r0, #39	; 0x27
10008c36:	dc00      	bgt.n	10008c3a <__aeabi_ddiv+0x452>
10008c38:	e65e      	b.n	100088f8 <__aeabi_ddiv+0x110>
10008c3a:	3b08      	subs	r3, #8
10008c3c:	409e      	lsls	r6, r3
10008c3e:	2300      	movs	r3, #0
10008c40:	46b3      	mov	fp, r6
10008c42:	4699      	mov	r9, r3
10008c44:	e665      	b.n	10008912 <__aeabi_ddiv+0x12a>
10008c46:	4650      	mov	r0, sl
10008c48:	f7fc fc68 	bl	1000551c <__clzsi2>
10008c4c:	1c02      	adds	r2, r0, #0
10008c4e:	3220      	adds	r2, #32
10008c50:	2a27      	cmp	r2, #39	; 0x27
10008c52:	dc00      	bgt.n	10008c56 <__aeabi_ddiv+0x46e>
10008c54:	e675      	b.n	10008942 <__aeabi_ddiv+0x15a>
10008c56:	4657      	mov	r7, sl
10008c58:	3808      	subs	r0, #8
10008c5a:	4087      	lsls	r7, r0
10008c5c:	2300      	movs	r3, #0
10008c5e:	e67b      	b.n	10008958 <__aeabi_ddiv+0x170>
10008c60:	4599      	cmp	r9, r3
10008c62:	d200      	bcs.n	10008c66 <__aeabi_ddiv+0x47e>
10008c64:	e6af      	b.n	100089c6 <__aeabi_ddiv+0x1de>
10008c66:	465a      	mov	r2, fp
10008c68:	4659      	mov	r1, fp
10008c6a:	0854      	lsrs	r4, r2, #1
10008c6c:	464a      	mov	r2, r9
10008c6e:	07c8      	lsls	r0, r1, #31
10008c70:	0852      	lsrs	r2, r2, #1
10008c72:	4302      	orrs	r2, r0
10008c74:	9203      	str	r2, [sp, #12]
10008c76:	464a      	mov	r2, r9
10008c78:	07d2      	lsls	r2, r2, #31
10008c7a:	4690      	mov	r8, r2
10008c7c:	e6a9      	b.n	100089d2 <__aeabi_ddiv+0x1ea>
10008c7e:	2700      	movs	r7, #0
10008c80:	4588      	cmp	r8, r1
10008c82:	d300      	bcc.n	10008c86 <__aeabi_ddiv+0x49e>
10008c84:	e71c      	b.n	10008ac0 <__aeabi_ddiv+0x2d8>
10008c86:	9f01      	ldr	r7, [sp, #4]
10008c88:	465a      	mov	r2, fp
10008c8a:	46bc      	mov	ip, r7
10008c8c:	44e0      	add	r8, ip
10008c8e:	45b8      	cmp	r8, r7
10008c90:	41bf      	sbcs	r7, r7
10008c92:	427f      	negs	r7, r7
10008c94:	19bf      	adds	r7, r7, r6
10008c96:	18ff      	adds	r7, r7, r3
10008c98:	3a01      	subs	r2, #1
10008c9a:	42be      	cmp	r6, r7
10008c9c:	d206      	bcs.n	10008cac <__aeabi_ddiv+0x4c4>
10008c9e:	42bc      	cmp	r4, r7
10008ca0:	d85f      	bhi.n	10008d62 <__aeabi_ddiv+0x57a>
10008ca2:	d100      	bne.n	10008ca6 <__aeabi_ddiv+0x4be>
10008ca4:	e09f      	b.n	10008de6 <__aeabi_ddiv+0x5fe>
10008ca6:	1b3f      	subs	r7, r7, r4
10008ca8:	4693      	mov	fp, r2
10008caa:	e709      	b.n	10008ac0 <__aeabi_ddiv+0x2d8>
10008cac:	42b7      	cmp	r7, r6
10008cae:	d1fa      	bne.n	10008ca6 <__aeabi_ddiv+0x4be>
10008cb0:	9b01      	ldr	r3, [sp, #4]
10008cb2:	4543      	cmp	r3, r8
10008cb4:	d9f3      	bls.n	10008c9e <__aeabi_ddiv+0x4b6>
10008cb6:	1b37      	subs	r7, r6, r4
10008cb8:	4693      	mov	fp, r2
10008cba:	e701      	b.n	10008ac0 <__aeabi_ddiv+0x2d8>
10008cbc:	4693      	mov	fp, r2
10008cbe:	e6d4      	b.n	10008a6a <__aeabi_ddiv+0x282>
10008cc0:	9302      	str	r3, [sp, #8]
10008cc2:	e6b1      	b.n	10008a28 <__aeabi_ddiv+0x240>
10008cc4:	464a      	mov	r2, r9
10008cc6:	1989      	adds	r1, r1, r6
10008cc8:	3a01      	subs	r2, #1
10008cca:	428e      	cmp	r6, r1
10008ccc:	d918      	bls.n	10008d00 <__aeabi_ddiv+0x518>
10008cce:	4691      	mov	r9, r2
10008cd0:	4281      	cmp	r1, r0
10008cd2:	d000      	beq.n	10008cd6 <__aeabi_ddiv+0x4ee>
10008cd4:	e761      	b.n	10008b9a <__aeabi_ddiv+0x3b2>
10008cd6:	9a01      	ldr	r2, [sp, #4]
10008cd8:	429a      	cmp	r2, r3
10008cda:	d000      	beq.n	10008cde <__aeabi_ddiv+0x4f6>
10008cdc:	e75d      	b.n	10008b9a <__aeabi_ddiv+0x3b2>
10008cde:	e760      	b.n	10008ba2 <__aeabi_ddiv+0x3ba>
10008ce0:	4f4f      	ldr	r7, [pc, #316]	; (10008e20 <__aeabi_ddiv+0x638>)
10008ce2:	1b7f      	subs	r7, r7, r5
10008ce4:	2f38      	cmp	r7, #56	; 0x38
10008ce6:	dd13      	ble.n	10008d10 <__aeabi_ddiv+0x528>
10008ce8:	2201      	movs	r2, #1
10008cea:	4653      	mov	r3, sl
10008cec:	401a      	ands	r2, r3
10008cee:	e64f      	b.n	10008990 <__aeabi_ddiv+0x1a8>
10008cf0:	2301      	movs	r3, #1
10008cf2:	425b      	negs	r3, r3
10008cf4:	4699      	mov	r9, r3
10008cf6:	e754      	b.n	10008ba2 <__aeabi_ddiv+0x3ba>
10008cf8:	9302      	str	r3, [sp, #8]
10008cfa:	e708      	b.n	10008b0e <__aeabi_ddiv+0x326>
10008cfc:	9303      	str	r3, [sp, #12]
10008cfe:	e727      	b.n	10008b50 <__aeabi_ddiv+0x368>
10008d00:	4288      	cmp	r0, r1
10008d02:	d83c      	bhi.n	10008d7e <__aeabi_ddiv+0x596>
10008d04:	d074      	beq.n	10008df0 <__aeabi_ddiv+0x608>
10008d06:	4691      	mov	r9, r2
10008d08:	e747      	b.n	10008b9a <__aeabi_ddiv+0x3b2>
10008d0a:	9b01      	ldr	r3, [sp, #4]
10008d0c:	469a      	mov	sl, r3
10008d0e:	e748      	b.n	10008ba2 <__aeabi_ddiv+0x3ba>
10008d10:	2f1f      	cmp	r7, #31
10008d12:	dc44      	bgt.n	10008d9e <__aeabi_ddiv+0x5b6>
10008d14:	4b43      	ldr	r3, [pc, #268]	; (10008e24 <__aeabi_ddiv+0x63c>)
10008d16:	464a      	mov	r2, r9
10008d18:	469c      	mov	ip, r3
10008d1a:	465b      	mov	r3, fp
10008d1c:	4465      	add	r5, ip
10008d1e:	40fa      	lsrs	r2, r7
10008d20:	40ab      	lsls	r3, r5
10008d22:	4313      	orrs	r3, r2
10008d24:	464a      	mov	r2, r9
10008d26:	40aa      	lsls	r2, r5
10008d28:	1c15      	adds	r5, r2, #0
10008d2a:	1e6a      	subs	r2, r5, #1
10008d2c:	4195      	sbcs	r5, r2
10008d2e:	465a      	mov	r2, fp
10008d30:	40fa      	lsrs	r2, r7
10008d32:	432b      	orrs	r3, r5
10008d34:	1c17      	adds	r7, r2, #0
10008d36:	075a      	lsls	r2, r3, #29
10008d38:	d009      	beq.n	10008d4e <__aeabi_ddiv+0x566>
10008d3a:	220f      	movs	r2, #15
10008d3c:	401a      	ands	r2, r3
10008d3e:	2a04      	cmp	r2, #4
10008d40:	d005      	beq.n	10008d4e <__aeabi_ddiv+0x566>
10008d42:	1d1a      	adds	r2, r3, #4
10008d44:	429a      	cmp	r2, r3
10008d46:	419b      	sbcs	r3, r3
10008d48:	425b      	negs	r3, r3
10008d4a:	18ff      	adds	r7, r7, r3
10008d4c:	1c13      	adds	r3, r2, #0
10008d4e:	023a      	lsls	r2, r7, #8
10008d50:	d53e      	bpl.n	10008dd0 <__aeabi_ddiv+0x5e8>
10008d52:	4653      	mov	r3, sl
10008d54:	2201      	movs	r2, #1
10008d56:	2100      	movs	r1, #0
10008d58:	401a      	ands	r2, r3
10008d5a:	2700      	movs	r7, #0
10008d5c:	2301      	movs	r3, #1
10008d5e:	4689      	mov	r9, r1
10008d60:	e5aa      	b.n	100088b8 <__aeabi_ddiv+0xd0>
10008d62:	2302      	movs	r3, #2
10008d64:	425b      	negs	r3, r3
10008d66:	469c      	mov	ip, r3
10008d68:	9a01      	ldr	r2, [sp, #4]
10008d6a:	44e3      	add	fp, ip
10008d6c:	4694      	mov	ip, r2
10008d6e:	44e0      	add	r8, ip
10008d70:	4590      	cmp	r8, r2
10008d72:	419b      	sbcs	r3, r3
10008d74:	425b      	negs	r3, r3
10008d76:	199b      	adds	r3, r3, r6
10008d78:	19df      	adds	r7, r3, r7
10008d7a:	1b3f      	subs	r7, r7, r4
10008d7c:	e6a0      	b.n	10008ac0 <__aeabi_ddiv+0x2d8>
10008d7e:	9f01      	ldr	r7, [sp, #4]
10008d80:	464a      	mov	r2, r9
10008d82:	007c      	lsls	r4, r7, #1
10008d84:	42bc      	cmp	r4, r7
10008d86:	41bf      	sbcs	r7, r7
10008d88:	427f      	negs	r7, r7
10008d8a:	19bf      	adds	r7, r7, r6
10008d8c:	3a02      	subs	r2, #2
10008d8e:	19c9      	adds	r1, r1, r7
10008d90:	9401      	str	r4, [sp, #4]
10008d92:	e79c      	b.n	10008cce <__aeabi_ddiv+0x4e6>
10008d94:	2b00      	cmp	r3, #0
10008d96:	d195      	bne.n	10008cc4 <__aeabi_ddiv+0x4dc>
10008d98:	2200      	movs	r2, #0
10008d9a:	9201      	str	r2, [sp, #4]
10008d9c:	e79b      	b.n	10008cd6 <__aeabi_ddiv+0x4ee>
10008d9e:	465a      	mov	r2, fp
10008da0:	4b21      	ldr	r3, [pc, #132]	; (10008e28 <__aeabi_ddiv+0x640>)
10008da2:	1b5b      	subs	r3, r3, r5
10008da4:	40da      	lsrs	r2, r3
10008da6:	2f20      	cmp	r7, #32
10008da8:	d027      	beq.n	10008dfa <__aeabi_ddiv+0x612>
10008daa:	4b20      	ldr	r3, [pc, #128]	; (10008e2c <__aeabi_ddiv+0x644>)
10008dac:	469c      	mov	ip, r3
10008dae:	465b      	mov	r3, fp
10008db0:	4465      	add	r5, ip
10008db2:	40ab      	lsls	r3, r5
10008db4:	4649      	mov	r1, r9
10008db6:	430b      	orrs	r3, r1
10008db8:	1e59      	subs	r1, r3, #1
10008dba:	418b      	sbcs	r3, r1
10008dbc:	4313      	orrs	r3, r2
10008dbe:	2207      	movs	r2, #7
10008dc0:	2700      	movs	r7, #0
10008dc2:	401a      	ands	r2, r3
10008dc4:	d007      	beq.n	10008dd6 <__aeabi_ddiv+0x5ee>
10008dc6:	220f      	movs	r2, #15
10008dc8:	2700      	movs	r7, #0
10008dca:	401a      	ands	r2, r3
10008dcc:	2a04      	cmp	r2, #4
10008dce:	d1b8      	bne.n	10008d42 <__aeabi_ddiv+0x55a>
10008dd0:	077a      	lsls	r2, r7, #29
10008dd2:	027f      	lsls	r7, r7, #9
10008dd4:	0b3f      	lsrs	r7, r7, #12
10008dd6:	08db      	lsrs	r3, r3, #3
10008dd8:	4313      	orrs	r3, r2
10008dda:	4699      	mov	r9, r3
10008ddc:	2201      	movs	r2, #1
10008dde:	4653      	mov	r3, sl
10008de0:	401a      	ands	r2, r3
10008de2:	2300      	movs	r3, #0
10008de4:	e568      	b.n	100088b8 <__aeabi_ddiv+0xd0>
10008de6:	4541      	cmp	r1, r8
10008de8:	d8bb      	bhi.n	10008d62 <__aeabi_ddiv+0x57a>
10008dea:	4693      	mov	fp, r2
10008dec:	2700      	movs	r7, #0
10008dee:	e667      	b.n	10008ac0 <__aeabi_ddiv+0x2d8>
10008df0:	9c01      	ldr	r4, [sp, #4]
10008df2:	429c      	cmp	r4, r3
10008df4:	d3c3      	bcc.n	10008d7e <__aeabi_ddiv+0x596>
10008df6:	4691      	mov	r9, r2
10008df8:	e76d      	b.n	10008cd6 <__aeabi_ddiv+0x4ee>
10008dfa:	2300      	movs	r3, #0
10008dfc:	e7da      	b.n	10008db4 <__aeabi_ddiv+0x5cc>
10008dfe:	2780      	movs	r7, #128	; 0x80
10008e00:	465b      	mov	r3, fp
10008e02:	033f      	lsls	r7, r7, #12
10008e04:	431f      	orrs	r7, r3
10008e06:	033f      	lsls	r7, r7, #12
10008e08:	0b3f      	lsrs	r7, r7, #12
10008e0a:	9a01      	ldr	r2, [sp, #4]
10008e0c:	4b03      	ldr	r3, [pc, #12]	; (10008e1c <__aeabi_ddiv+0x634>)
10008e0e:	e553      	b.n	100088b8 <__aeabi_ddiv+0xd0>
10008e10:	000003ff 	.word	0x000003ff
10008e14:	feffffff 	.word	0xfeffffff
10008e18:	000007fe 	.word	0x000007fe
10008e1c:	000007ff 	.word	0x000007ff
10008e20:	fffffc02 	.word	0xfffffc02
10008e24:	0000041e 	.word	0x0000041e
10008e28:	fffffbe2 	.word	0xfffffbe2
10008e2c:	0000043e 	.word	0x0000043e

10008e30 <__eqdf2>:
10008e30:	b5f0      	push	{r4, r5, r6, r7, lr}
10008e32:	465f      	mov	r7, fp
10008e34:	464d      	mov	r5, r9
10008e36:	4644      	mov	r4, r8
10008e38:	4656      	mov	r6, sl
10008e3a:	b4f0      	push	{r4, r5, r6, r7}
10008e3c:	031f      	lsls	r7, r3, #12
10008e3e:	005c      	lsls	r4, r3, #1
10008e40:	0fdb      	lsrs	r3, r3, #31
10008e42:	4699      	mov	r9, r3
10008e44:	4b1b      	ldr	r3, [pc, #108]	; (10008eb4 <__eqdf2+0x84>)
10008e46:	030e      	lsls	r6, r1, #12
10008e48:	004d      	lsls	r5, r1, #1
10008e4a:	0fc9      	lsrs	r1, r1, #31
10008e4c:	4684      	mov	ip, r0
10008e4e:	0b36      	lsrs	r6, r6, #12
10008e50:	0d6d      	lsrs	r5, r5, #21
10008e52:	468b      	mov	fp, r1
10008e54:	4690      	mov	r8, r2
10008e56:	0b3f      	lsrs	r7, r7, #12
10008e58:	0d64      	lsrs	r4, r4, #21
10008e5a:	429d      	cmp	r5, r3
10008e5c:	d00c      	beq.n	10008e78 <__eqdf2+0x48>
10008e5e:	4b15      	ldr	r3, [pc, #84]	; (10008eb4 <__eqdf2+0x84>)
10008e60:	429c      	cmp	r4, r3
10008e62:	d010      	beq.n	10008e86 <__eqdf2+0x56>
10008e64:	2301      	movs	r3, #1
10008e66:	42a5      	cmp	r5, r4
10008e68:	d014      	beq.n	10008e94 <__eqdf2+0x64>
10008e6a:	1c18      	adds	r0, r3, #0
10008e6c:	bc3c      	pop	{r2, r3, r4, r5}
10008e6e:	4690      	mov	r8, r2
10008e70:	4699      	mov	r9, r3
10008e72:	46a2      	mov	sl, r4
10008e74:	46ab      	mov	fp, r5
10008e76:	bdf0      	pop	{r4, r5, r6, r7, pc}
10008e78:	1c31      	adds	r1, r6, #0
10008e7a:	2301      	movs	r3, #1
10008e7c:	4301      	orrs	r1, r0
10008e7e:	d1f4      	bne.n	10008e6a <__eqdf2+0x3a>
10008e80:	4b0c      	ldr	r3, [pc, #48]	; (10008eb4 <__eqdf2+0x84>)
10008e82:	429c      	cmp	r4, r3
10008e84:	d1ee      	bne.n	10008e64 <__eqdf2+0x34>
10008e86:	433a      	orrs	r2, r7
10008e88:	2301      	movs	r3, #1
10008e8a:	2a00      	cmp	r2, #0
10008e8c:	d1ed      	bne.n	10008e6a <__eqdf2+0x3a>
10008e8e:	2301      	movs	r3, #1
10008e90:	42a5      	cmp	r5, r4
10008e92:	d1ea      	bne.n	10008e6a <__eqdf2+0x3a>
10008e94:	42be      	cmp	r6, r7
10008e96:	d1e8      	bne.n	10008e6a <__eqdf2+0x3a>
10008e98:	45c4      	cmp	ip, r8
10008e9a:	d1e6      	bne.n	10008e6a <__eqdf2+0x3a>
10008e9c:	45cb      	cmp	fp, r9
10008e9e:	d006      	beq.n	10008eae <__eqdf2+0x7e>
10008ea0:	2d00      	cmp	r5, #0
10008ea2:	d1e2      	bne.n	10008e6a <__eqdf2+0x3a>
10008ea4:	4330      	orrs	r0, r6
10008ea6:	1c03      	adds	r3, r0, #0
10008ea8:	1e58      	subs	r0, r3, #1
10008eaa:	4183      	sbcs	r3, r0
10008eac:	e7dd      	b.n	10008e6a <__eqdf2+0x3a>
10008eae:	2300      	movs	r3, #0
10008eb0:	e7db      	b.n	10008e6a <__eqdf2+0x3a>
10008eb2:	46c0      	nop			; (mov r8, r8)
10008eb4:	000007ff 	.word	0x000007ff

10008eb8 <__gedf2>:
10008eb8:	b5f0      	push	{r4, r5, r6, r7, lr}
10008eba:	4657      	mov	r7, sl
10008ebc:	4645      	mov	r5, r8
10008ebe:	464e      	mov	r6, r9
10008ec0:	b4e0      	push	{r5, r6, r7}
10008ec2:	030f      	lsls	r7, r1, #12
10008ec4:	004e      	lsls	r6, r1, #1
10008ec6:	0fc9      	lsrs	r1, r1, #31
10008ec8:	468a      	mov	sl, r1
10008eca:	4932      	ldr	r1, [pc, #200]	; (10008f94 <__gedf2+0xdc>)
10008ecc:	031d      	lsls	r5, r3, #12
10008ece:	005c      	lsls	r4, r3, #1
10008ed0:	4684      	mov	ip, r0
10008ed2:	0b3f      	lsrs	r7, r7, #12
10008ed4:	0d76      	lsrs	r6, r6, #21
10008ed6:	4690      	mov	r8, r2
10008ed8:	0b2d      	lsrs	r5, r5, #12
10008eda:	0d64      	lsrs	r4, r4, #21
10008edc:	0fdb      	lsrs	r3, r3, #31
10008ede:	428e      	cmp	r6, r1
10008ee0:	d00f      	beq.n	10008f02 <__gedf2+0x4a>
10008ee2:	428c      	cmp	r4, r1
10008ee4:	d039      	beq.n	10008f5a <__gedf2+0xa2>
10008ee6:	2e00      	cmp	r6, #0
10008ee8:	d110      	bne.n	10008f0c <__gedf2+0x54>
10008eea:	4338      	orrs	r0, r7
10008eec:	4241      	negs	r1, r0
10008eee:	4141      	adcs	r1, r0
10008ef0:	4689      	mov	r9, r1
10008ef2:	2c00      	cmp	r4, #0
10008ef4:	d127      	bne.n	10008f46 <__gedf2+0x8e>
10008ef6:	432a      	orrs	r2, r5
10008ef8:	d125      	bne.n	10008f46 <__gedf2+0x8e>
10008efa:	2000      	movs	r0, #0
10008efc:	2900      	cmp	r1, #0
10008efe:	d10e      	bne.n	10008f1e <__gedf2+0x66>
10008f00:	e008      	b.n	10008f14 <__gedf2+0x5c>
10008f02:	1c39      	adds	r1, r7, #0
10008f04:	4301      	orrs	r1, r0
10008f06:	d12e      	bne.n	10008f66 <__gedf2+0xae>
10008f08:	42b4      	cmp	r4, r6
10008f0a:	d026      	beq.n	10008f5a <__gedf2+0xa2>
10008f0c:	2c00      	cmp	r4, #0
10008f0e:	d00b      	beq.n	10008f28 <__gedf2+0x70>
10008f10:	459a      	cmp	sl, r3
10008f12:	d00d      	beq.n	10008f30 <__gedf2+0x78>
10008f14:	4653      	mov	r3, sl
10008f16:	4259      	negs	r1, r3
10008f18:	2301      	movs	r3, #1
10008f1a:	4319      	orrs	r1, r3
10008f1c:	1c08      	adds	r0, r1, #0
10008f1e:	bc1c      	pop	{r2, r3, r4}
10008f20:	4690      	mov	r8, r2
10008f22:	4699      	mov	r9, r3
10008f24:	46a2      	mov	sl, r4
10008f26:	bdf0      	pop	{r4, r5, r6, r7, pc}
10008f28:	432a      	orrs	r2, r5
10008f2a:	d0f3      	beq.n	10008f14 <__gedf2+0x5c>
10008f2c:	459a      	cmp	sl, r3
10008f2e:	d1f1      	bne.n	10008f14 <__gedf2+0x5c>
10008f30:	42a6      	cmp	r6, r4
10008f32:	dcef      	bgt.n	10008f14 <__gedf2+0x5c>
10008f34:	da1a      	bge.n	10008f6c <__gedf2+0xb4>
10008f36:	4650      	mov	r0, sl
10008f38:	4241      	negs	r1, r0
10008f3a:	4148      	adcs	r0, r1
10008f3c:	2301      	movs	r3, #1
10008f3e:	4241      	negs	r1, r0
10008f40:	4319      	orrs	r1, r3
10008f42:	1c08      	adds	r0, r1, #0
10008f44:	e7eb      	b.n	10008f1e <__gedf2+0x66>
10008f46:	464a      	mov	r2, r9
10008f48:	2a00      	cmp	r2, #0
10008f4a:	d0e1      	beq.n	10008f10 <__gedf2+0x58>
10008f4c:	4258      	negs	r0, r3
10008f4e:	4158      	adcs	r0, r3
10008f50:	2201      	movs	r2, #1
10008f52:	4241      	negs	r1, r0
10008f54:	4311      	orrs	r1, r2
10008f56:	1c08      	adds	r0, r1, #0
10008f58:	e7e1      	b.n	10008f1e <__gedf2+0x66>
10008f5a:	1c29      	adds	r1, r5, #0
10008f5c:	4311      	orrs	r1, r2
10008f5e:	d102      	bne.n	10008f66 <__gedf2+0xae>
10008f60:	2e00      	cmp	r6, #0
10008f62:	d0c2      	beq.n	10008eea <__gedf2+0x32>
10008f64:	e7d4      	b.n	10008f10 <__gedf2+0x58>
10008f66:	2002      	movs	r0, #2
10008f68:	4240      	negs	r0, r0
10008f6a:	e7d8      	b.n	10008f1e <__gedf2+0x66>
10008f6c:	42af      	cmp	r7, r5
10008f6e:	d8d1      	bhi.n	10008f14 <__gedf2+0x5c>
10008f70:	d009      	beq.n	10008f86 <__gedf2+0xce>
10008f72:	2000      	movs	r0, #0
10008f74:	42af      	cmp	r7, r5
10008f76:	d2d2      	bcs.n	10008f1e <__gedf2+0x66>
10008f78:	4650      	mov	r0, sl
10008f7a:	4241      	negs	r1, r0
10008f7c:	4148      	adcs	r0, r1
10008f7e:	2301      	movs	r3, #1
10008f80:	4240      	negs	r0, r0
10008f82:	4318      	orrs	r0, r3
10008f84:	e7cb      	b.n	10008f1e <__gedf2+0x66>
10008f86:	45c4      	cmp	ip, r8
10008f88:	d8c4      	bhi.n	10008f14 <__gedf2+0x5c>
10008f8a:	2000      	movs	r0, #0
10008f8c:	45c4      	cmp	ip, r8
10008f8e:	d3f3      	bcc.n	10008f78 <__gedf2+0xc0>
10008f90:	e7c5      	b.n	10008f1e <__gedf2+0x66>
10008f92:	46c0      	nop			; (mov r8, r8)
10008f94:	000007ff 	.word	0x000007ff

10008f98 <__ledf2>:
10008f98:	b5f0      	push	{r4, r5, r6, r7, lr}
10008f9a:	465f      	mov	r7, fp
10008f9c:	464d      	mov	r5, r9
10008f9e:	4644      	mov	r4, r8
10008fa0:	4656      	mov	r6, sl
10008fa2:	4680      	mov	r8, r0
10008fa4:	b4f0      	push	{r4, r5, r6, r7}
10008fa6:	1c06      	adds	r6, r0, #0
10008fa8:	0308      	lsls	r0, r1, #12
10008faa:	0b00      	lsrs	r0, r0, #12
10008fac:	4684      	mov	ip, r0
10008fae:	482c      	ldr	r0, [pc, #176]	; (10009060 <__ledf2+0xc8>)
10008fb0:	004c      	lsls	r4, r1, #1
10008fb2:	031f      	lsls	r7, r3, #12
10008fb4:	005d      	lsls	r5, r3, #1
10008fb6:	0fc9      	lsrs	r1, r1, #31
10008fb8:	0d64      	lsrs	r4, r4, #21
10008fba:	468b      	mov	fp, r1
10008fbc:	4691      	mov	r9, r2
10008fbe:	0b3f      	lsrs	r7, r7, #12
10008fc0:	0d6d      	lsrs	r5, r5, #21
10008fc2:	0fdb      	lsrs	r3, r3, #31
10008fc4:	4284      	cmp	r4, r0
10008fc6:	d012      	beq.n	10008fee <__ledf2+0x56>
10008fc8:	4285      	cmp	r5, r0
10008fca:	d025      	beq.n	10009018 <__ledf2+0x80>
10008fcc:	2c00      	cmp	r4, #0
10008fce:	d114      	bne.n	10008ffa <__ledf2+0x62>
10008fd0:	4661      	mov	r1, ip
10008fd2:	430e      	orrs	r6, r1
10008fd4:	4270      	negs	r0, r6
10008fd6:	4146      	adcs	r6, r0
10008fd8:	2d00      	cmp	r5, #0
10008fda:	d035      	beq.n	10009048 <__ledf2+0xb0>
10008fdc:	2e00      	cmp	r6, #0
10008fde:	d021      	beq.n	10009024 <__ledf2+0x8c>
10008fe0:	4258      	negs	r0, r3
10008fe2:	4158      	adcs	r0, r3
10008fe4:	2101      	movs	r1, #1
10008fe6:	4243      	negs	r3, r0
10008fe8:	430b      	orrs	r3, r1
10008fea:	1c18      	adds	r0, r3, #0
10008fec:	e00e      	b.n	1000900c <__ledf2+0x74>
10008fee:	4661      	mov	r1, ip
10008ff0:	2002      	movs	r0, #2
10008ff2:	4331      	orrs	r1, r6
10008ff4:	d10a      	bne.n	1000900c <__ledf2+0x74>
10008ff6:	42a5      	cmp	r5, r4
10008ff8:	d00e      	beq.n	10009018 <__ledf2+0x80>
10008ffa:	2d00      	cmp	r5, #0
10008ffc:	d112      	bne.n	10009024 <__ledf2+0x8c>
10008ffe:	433a      	orrs	r2, r7
10009000:	d110      	bne.n	10009024 <__ledf2+0x8c>
10009002:	465b      	mov	r3, fp
10009004:	4259      	negs	r1, r3
10009006:	2301      	movs	r3, #1
10009008:	4319      	orrs	r1, r3
1000900a:	1c08      	adds	r0, r1, #0
1000900c:	bc3c      	pop	{r2, r3, r4, r5}
1000900e:	4690      	mov	r8, r2
10009010:	4699      	mov	r9, r3
10009012:	46a2      	mov	sl, r4
10009014:	46ab      	mov	fp, r5
10009016:	bdf0      	pop	{r4, r5, r6, r7, pc}
10009018:	1c39      	adds	r1, r7, #0
1000901a:	2002      	movs	r0, #2
1000901c:	4311      	orrs	r1, r2
1000901e:	d1f5      	bne.n	1000900c <__ledf2+0x74>
10009020:	2c00      	cmp	r4, #0
10009022:	d0d5      	beq.n	10008fd0 <__ledf2+0x38>
10009024:	459b      	cmp	fp, r3
10009026:	d1ec      	bne.n	10009002 <__ledf2+0x6a>
10009028:	42ac      	cmp	r4, r5
1000902a:	dcea      	bgt.n	10009002 <__ledf2+0x6a>
1000902c:	db05      	blt.n	1000903a <__ledf2+0xa2>
1000902e:	45bc      	cmp	ip, r7
10009030:	d8e7      	bhi.n	10009002 <__ledf2+0x6a>
10009032:	d00f      	beq.n	10009054 <__ledf2+0xbc>
10009034:	2000      	movs	r0, #0
10009036:	45bc      	cmp	ip, r7
10009038:	d2e8      	bcs.n	1000900c <__ledf2+0x74>
1000903a:	4658      	mov	r0, fp
1000903c:	4241      	negs	r1, r0
1000903e:	4148      	adcs	r0, r1
10009040:	4241      	negs	r1, r0
10009042:	2001      	movs	r0, #1
10009044:	4308      	orrs	r0, r1
10009046:	e7e1      	b.n	1000900c <__ledf2+0x74>
10009048:	433a      	orrs	r2, r7
1000904a:	d1c7      	bne.n	10008fdc <__ledf2+0x44>
1000904c:	2000      	movs	r0, #0
1000904e:	2e00      	cmp	r6, #0
10009050:	d1dc      	bne.n	1000900c <__ledf2+0x74>
10009052:	e7d6      	b.n	10009002 <__ledf2+0x6a>
10009054:	45c8      	cmp	r8, r9
10009056:	d8d4      	bhi.n	10009002 <__ledf2+0x6a>
10009058:	2000      	movs	r0, #0
1000905a:	45c8      	cmp	r8, r9
1000905c:	d3ed      	bcc.n	1000903a <__ledf2+0xa2>
1000905e:	e7d5      	b.n	1000900c <__ledf2+0x74>
10009060:	000007ff 	.word	0x000007ff

10009064 <__aeabi_dmul>:
10009064:	b5f0      	push	{r4, r5, r6, r7, lr}
10009066:	465f      	mov	r7, fp
10009068:	4656      	mov	r6, sl
1000906a:	464d      	mov	r5, r9
1000906c:	4644      	mov	r4, r8
1000906e:	b4f0      	push	{r4, r5, r6, r7}
10009070:	1c05      	adds	r5, r0, #0
10009072:	1c06      	adds	r6, r0, #0
10009074:	0308      	lsls	r0, r1, #12
10009076:	b087      	sub	sp, #28
10009078:	4699      	mov	r9, r3
1000907a:	004f      	lsls	r7, r1, #1
1000907c:	0b03      	lsrs	r3, r0, #12
1000907e:	0fcc      	lsrs	r4, r1, #31
10009080:	4692      	mov	sl, r2
10009082:	469b      	mov	fp, r3
10009084:	0d7f      	lsrs	r7, r7, #21
10009086:	9401      	str	r4, [sp, #4]
10009088:	d067      	beq.n	1000915a <__aeabi_dmul+0xf6>
1000908a:	4b6c      	ldr	r3, [pc, #432]	; (1000923c <__aeabi_dmul+0x1d8>)
1000908c:	429f      	cmp	r7, r3
1000908e:	d036      	beq.n	100090fe <__aeabi_dmul+0x9a>
10009090:	2080      	movs	r0, #128	; 0x80
10009092:	465b      	mov	r3, fp
10009094:	0340      	lsls	r0, r0, #13
10009096:	4318      	orrs	r0, r3
10009098:	00c0      	lsls	r0, r0, #3
1000909a:	0f6b      	lsrs	r3, r5, #29
1000909c:	4318      	orrs	r0, r3
1000909e:	4b68      	ldr	r3, [pc, #416]	; (10009240 <__aeabi_dmul+0x1dc>)
100090a0:	4683      	mov	fp, r0
100090a2:	469c      	mov	ip, r3
100090a4:	2300      	movs	r3, #0
100090a6:	4698      	mov	r8, r3
100090a8:	00ee      	lsls	r6, r5, #3
100090aa:	4467      	add	r7, ip
100090ac:	9300      	str	r3, [sp, #0]
100090ae:	464b      	mov	r3, r9
100090b0:	4649      	mov	r1, r9
100090b2:	031d      	lsls	r5, r3, #12
100090b4:	0fc9      	lsrs	r1, r1, #31
100090b6:	005b      	lsls	r3, r3, #1
100090b8:	4652      	mov	r2, sl
100090ba:	0b2d      	lsrs	r5, r5, #12
100090bc:	0d5b      	lsrs	r3, r3, #21
100090be:	4689      	mov	r9, r1
100090c0:	d100      	bne.n	100090c4 <__aeabi_dmul+0x60>
100090c2:	e06e      	b.n	100091a2 <__aeabi_dmul+0x13e>
100090c4:	495d      	ldr	r1, [pc, #372]	; (1000923c <__aeabi_dmul+0x1d8>)
100090c6:	428b      	cmp	r3, r1
100090c8:	d064      	beq.n	10009194 <__aeabi_dmul+0x130>
100090ca:	2080      	movs	r0, #128	; 0x80
100090cc:	495c      	ldr	r1, [pc, #368]	; (10009240 <__aeabi_dmul+0x1dc>)
100090ce:	0340      	lsls	r0, r0, #13
100090d0:	468c      	mov	ip, r1
100090d2:	2100      	movs	r1, #0
100090d4:	4305      	orrs	r5, r0
100090d6:	00ed      	lsls	r5, r5, #3
100090d8:	0f50      	lsrs	r0, r2, #29
100090da:	4305      	orrs	r5, r0
100090dc:	00d2      	lsls	r2, r2, #3
100090de:	4463      	add	r3, ip
100090e0:	4648      	mov	r0, r9
100090e2:	18ff      	adds	r7, r7, r3
100090e4:	1c7b      	adds	r3, r7, #1
100090e6:	469a      	mov	sl, r3
100090e8:	9b00      	ldr	r3, [sp, #0]
100090ea:	4060      	eors	r0, r4
100090ec:	9002      	str	r0, [sp, #8]
100090ee:	430b      	orrs	r3, r1
100090f0:	2b0f      	cmp	r3, #15
100090f2:	d900      	bls.n	100090f6 <__aeabi_dmul+0x92>
100090f4:	e0ac      	b.n	10009250 <__aeabi_dmul+0x1ec>
100090f6:	4853      	ldr	r0, [pc, #332]	; (10009244 <__aeabi_dmul+0x1e0>)
100090f8:	009b      	lsls	r3, r3, #2
100090fa:	58c3      	ldr	r3, [r0, r3]
100090fc:	469f      	mov	pc, r3
100090fe:	465b      	mov	r3, fp
10009100:	431d      	orrs	r5, r3
10009102:	d000      	beq.n	10009106 <__aeabi_dmul+0xa2>
10009104:	e082      	b.n	1000920c <__aeabi_dmul+0x1a8>
10009106:	2308      	movs	r3, #8
10009108:	9300      	str	r3, [sp, #0]
1000910a:	2300      	movs	r3, #0
1000910c:	469b      	mov	fp, r3
1000910e:	3302      	adds	r3, #2
10009110:	2600      	movs	r6, #0
10009112:	4698      	mov	r8, r3
10009114:	e7cb      	b.n	100090ae <__aeabi_dmul+0x4a>
10009116:	9b02      	ldr	r3, [sp, #8]
10009118:	9301      	str	r3, [sp, #4]
1000911a:	4643      	mov	r3, r8
1000911c:	2b02      	cmp	r3, #2
1000911e:	d159      	bne.n	100091d4 <__aeabi_dmul+0x170>
10009120:	2401      	movs	r4, #1
10009122:	2500      	movs	r5, #0
10009124:	2600      	movs	r6, #0
10009126:	9b01      	ldr	r3, [sp, #4]
10009128:	401c      	ands	r4, r3
1000912a:	4b44      	ldr	r3, [pc, #272]	; (1000923c <__aeabi_dmul+0x1d8>)
1000912c:	2100      	movs	r1, #0
1000912e:	032d      	lsls	r5, r5, #12
10009130:	0d0a      	lsrs	r2, r1, #20
10009132:	0512      	lsls	r2, r2, #20
10009134:	0b2d      	lsrs	r5, r5, #12
10009136:	4315      	orrs	r5, r2
10009138:	4a43      	ldr	r2, [pc, #268]	; (10009248 <__aeabi_dmul+0x1e4>)
1000913a:	051b      	lsls	r3, r3, #20
1000913c:	4015      	ands	r5, r2
1000913e:	431d      	orrs	r5, r3
10009140:	006d      	lsls	r5, r5, #1
10009142:	07e4      	lsls	r4, r4, #31
10009144:	086d      	lsrs	r5, r5, #1
10009146:	4325      	orrs	r5, r4
10009148:	1c30      	adds	r0, r6, #0
1000914a:	1c29      	adds	r1, r5, #0
1000914c:	b007      	add	sp, #28
1000914e:	bc3c      	pop	{r2, r3, r4, r5}
10009150:	4690      	mov	r8, r2
10009152:	4699      	mov	r9, r3
10009154:	46a2      	mov	sl, r4
10009156:	46ab      	mov	fp, r5
10009158:	bdf0      	pop	{r4, r5, r6, r7, pc}
1000915a:	432b      	orrs	r3, r5
1000915c:	d04e      	beq.n	100091fc <__aeabi_dmul+0x198>
1000915e:	465b      	mov	r3, fp
10009160:	2b00      	cmp	r3, #0
10009162:	d100      	bne.n	10009166 <__aeabi_dmul+0x102>
10009164:	e185      	b.n	10009472 <__aeabi_dmul+0x40e>
10009166:	4658      	mov	r0, fp
10009168:	f7fc f9d8 	bl	1000551c <__clzsi2>
1000916c:	1c02      	adds	r2, r0, #0
1000916e:	2328      	movs	r3, #40	; 0x28
10009170:	1c29      	adds	r1, r5, #0
10009172:	1a9b      	subs	r3, r3, r2
10009174:	1c16      	adds	r6, r2, #0
10009176:	4658      	mov	r0, fp
10009178:	40d9      	lsrs	r1, r3
1000917a:	3e08      	subs	r6, #8
1000917c:	40b0      	lsls	r0, r6
1000917e:	1c0b      	adds	r3, r1, #0
10009180:	40b5      	lsls	r5, r6
10009182:	4303      	orrs	r3, r0
10009184:	469b      	mov	fp, r3
10009186:	1c2e      	adds	r6, r5, #0
10009188:	2300      	movs	r3, #0
1000918a:	4f30      	ldr	r7, [pc, #192]	; (1000924c <__aeabi_dmul+0x1e8>)
1000918c:	9300      	str	r3, [sp, #0]
1000918e:	1abf      	subs	r7, r7, r2
10009190:	4698      	mov	r8, r3
10009192:	e78c      	b.n	100090ae <__aeabi_dmul+0x4a>
10009194:	4651      	mov	r1, sl
10009196:	4329      	orrs	r1, r5
10009198:	d12e      	bne.n	100091f8 <__aeabi_dmul+0x194>
1000919a:	2500      	movs	r5, #0
1000919c:	2200      	movs	r2, #0
1000919e:	2102      	movs	r1, #2
100091a0:	e79e      	b.n	100090e0 <__aeabi_dmul+0x7c>
100091a2:	4651      	mov	r1, sl
100091a4:	4329      	orrs	r1, r5
100091a6:	d023      	beq.n	100091f0 <__aeabi_dmul+0x18c>
100091a8:	2d00      	cmp	r5, #0
100091aa:	d100      	bne.n	100091ae <__aeabi_dmul+0x14a>
100091ac:	e154      	b.n	10009458 <__aeabi_dmul+0x3f4>
100091ae:	1c28      	adds	r0, r5, #0
100091b0:	f7fc f9b4 	bl	1000551c <__clzsi2>
100091b4:	1c03      	adds	r3, r0, #0
100091b6:	2128      	movs	r1, #40	; 0x28
100091b8:	4650      	mov	r0, sl
100091ba:	1ac9      	subs	r1, r1, r3
100091bc:	1c1a      	adds	r2, r3, #0
100091be:	40c8      	lsrs	r0, r1
100091c0:	4651      	mov	r1, sl
100091c2:	3a08      	subs	r2, #8
100091c4:	4091      	lsls	r1, r2
100091c6:	4095      	lsls	r5, r2
100091c8:	1c0a      	adds	r2, r1, #0
100091ca:	4305      	orrs	r5, r0
100091cc:	481f      	ldr	r0, [pc, #124]	; (1000924c <__aeabi_dmul+0x1e8>)
100091ce:	2100      	movs	r1, #0
100091d0:	1ac3      	subs	r3, r0, r3
100091d2:	e785      	b.n	100090e0 <__aeabi_dmul+0x7c>
100091d4:	2b03      	cmp	r3, #3
100091d6:	d100      	bne.n	100091da <__aeabi_dmul+0x176>
100091d8:	e1c2      	b.n	10009560 <__aeabi_dmul+0x4fc>
100091da:	2b01      	cmp	r3, #1
100091dc:	d000      	beq.n	100091e0 <__aeabi_dmul+0x17c>
100091de:	e16d      	b.n	100094bc <__aeabi_dmul+0x458>
100091e0:	4644      	mov	r4, r8
100091e2:	9b01      	ldr	r3, [sp, #4]
100091e4:	2500      	movs	r5, #0
100091e6:	401c      	ands	r4, r3
100091e8:	b2e4      	uxtb	r4, r4
100091ea:	2300      	movs	r3, #0
100091ec:	2600      	movs	r6, #0
100091ee:	e79d      	b.n	1000912c <__aeabi_dmul+0xc8>
100091f0:	2500      	movs	r5, #0
100091f2:	2200      	movs	r2, #0
100091f4:	2101      	movs	r1, #1
100091f6:	e773      	b.n	100090e0 <__aeabi_dmul+0x7c>
100091f8:	2103      	movs	r1, #3
100091fa:	e771      	b.n	100090e0 <__aeabi_dmul+0x7c>
100091fc:	2304      	movs	r3, #4
100091fe:	9300      	str	r3, [sp, #0]
10009200:	2300      	movs	r3, #0
10009202:	469b      	mov	fp, r3
10009204:	3301      	adds	r3, #1
10009206:	2600      	movs	r6, #0
10009208:	4698      	mov	r8, r3
1000920a:	e750      	b.n	100090ae <__aeabi_dmul+0x4a>
1000920c:	230c      	movs	r3, #12
1000920e:	9300      	str	r3, [sp, #0]
10009210:	3b09      	subs	r3, #9
10009212:	4698      	mov	r8, r3
10009214:	e74b      	b.n	100090ae <__aeabi_dmul+0x4a>
10009216:	2580      	movs	r5, #128	; 0x80
10009218:	2400      	movs	r4, #0
1000921a:	032d      	lsls	r5, r5, #12
1000921c:	2600      	movs	r6, #0
1000921e:	4b07      	ldr	r3, [pc, #28]	; (1000923c <__aeabi_dmul+0x1d8>)
10009220:	e784      	b.n	1000912c <__aeabi_dmul+0xc8>
10009222:	464b      	mov	r3, r9
10009224:	46ab      	mov	fp, r5
10009226:	1c16      	adds	r6, r2, #0
10009228:	9301      	str	r3, [sp, #4]
1000922a:	4688      	mov	r8, r1
1000922c:	e775      	b.n	1000911a <__aeabi_dmul+0xb6>
1000922e:	9b02      	ldr	r3, [sp, #8]
10009230:	46ab      	mov	fp, r5
10009232:	1c16      	adds	r6, r2, #0
10009234:	9301      	str	r3, [sp, #4]
10009236:	4688      	mov	r8, r1
10009238:	e76f      	b.n	1000911a <__aeabi_dmul+0xb6>
1000923a:	46c0      	nop			; (mov r8, r8)
1000923c:	000007ff 	.word	0x000007ff
10009240:	fffffc01 	.word	0xfffffc01
10009244:	1000a568 	.word	0x1000a568
10009248:	800fffff 	.word	0x800fffff
1000924c:	fffffc0d 	.word	0xfffffc0d
10009250:	0c33      	lsrs	r3, r6, #16
10009252:	0436      	lsls	r6, r6, #16
10009254:	0c36      	lsrs	r6, r6, #16
10009256:	469c      	mov	ip, r3
10009258:	1c33      	adds	r3, r6, #0
1000925a:	0c14      	lsrs	r4, r2, #16
1000925c:	0412      	lsls	r2, r2, #16
1000925e:	0c12      	lsrs	r2, r2, #16
10009260:	4353      	muls	r3, r2
10009262:	4698      	mov	r8, r3
10009264:	4663      	mov	r3, ip
10009266:	4353      	muls	r3, r2
10009268:	4699      	mov	r9, r3
1000926a:	4663      	mov	r3, ip
1000926c:	4363      	muls	r3, r4
1000926e:	9301      	str	r3, [sp, #4]
10009270:	1c33      	adds	r3, r6, #0
10009272:	4641      	mov	r1, r8
10009274:	4363      	muls	r3, r4
10009276:	0c09      	lsrs	r1, r1, #16
10009278:	444b      	add	r3, r9
1000927a:	185b      	adds	r3, r3, r1
1000927c:	4599      	cmp	r9, r3
1000927e:	d905      	bls.n	1000928c <__aeabi_dmul+0x228>
10009280:	2080      	movs	r0, #128	; 0x80
10009282:	0240      	lsls	r0, r0, #9
10009284:	4681      	mov	r9, r0
10009286:	9901      	ldr	r1, [sp, #4]
10009288:	4449      	add	r1, r9
1000928a:	9101      	str	r1, [sp, #4]
1000928c:	0c19      	lsrs	r1, r3, #16
1000928e:	9103      	str	r1, [sp, #12]
10009290:	4641      	mov	r1, r8
10009292:	0409      	lsls	r1, r1, #16
10009294:	0c09      	lsrs	r1, r1, #16
10009296:	041b      	lsls	r3, r3, #16
10009298:	185b      	adds	r3, r3, r1
1000929a:	9304      	str	r3, [sp, #16]
1000929c:	0c2b      	lsrs	r3, r5, #16
1000929e:	4698      	mov	r8, r3
100092a0:	1c33      	adds	r3, r6, #0
100092a2:	042d      	lsls	r5, r5, #16
100092a4:	0c29      	lsrs	r1, r5, #16
100092a6:	434b      	muls	r3, r1
100092a8:	4660      	mov	r0, ip
100092aa:	9300      	str	r3, [sp, #0]
100092ac:	4643      	mov	r3, r8
100092ae:	4665      	mov	r5, ip
100092b0:	4358      	muls	r0, r3
100092b2:	435e      	muls	r6, r3
100092b4:	9b00      	ldr	r3, [sp, #0]
100092b6:	434d      	muls	r5, r1
100092b8:	0c1b      	lsrs	r3, r3, #16
100092ba:	4699      	mov	r9, r3
100092bc:	19ae      	adds	r6, r5, r6
100092be:	444e      	add	r6, r9
100092c0:	4684      	mov	ip, r0
100092c2:	42b5      	cmp	r5, r6
100092c4:	d903      	bls.n	100092ce <__aeabi_dmul+0x26a>
100092c6:	2380      	movs	r3, #128	; 0x80
100092c8:	025b      	lsls	r3, r3, #9
100092ca:	4699      	mov	r9, r3
100092cc:	44cc      	add	ip, r9
100092ce:	0c35      	lsrs	r5, r6, #16
100092d0:	1c2b      	adds	r3, r5, #0
100092d2:	9803      	ldr	r0, [sp, #12]
100092d4:	4463      	add	r3, ip
100092d6:	4684      	mov	ip, r0
100092d8:	9305      	str	r3, [sp, #20]
100092da:	9b00      	ldr	r3, [sp, #0]
100092dc:	0436      	lsls	r6, r6, #16
100092de:	041b      	lsls	r3, r3, #16
100092e0:	0c1b      	lsrs	r3, r3, #16
100092e2:	18f3      	adds	r3, r6, r3
100092e4:	449c      	add	ip, r3
100092e6:	4660      	mov	r0, ip
100092e8:	9003      	str	r0, [sp, #12]
100092ea:	4658      	mov	r0, fp
100092ec:	0405      	lsls	r5, r0, #16
100092ee:	0c06      	lsrs	r6, r0, #16
100092f0:	0c28      	lsrs	r0, r5, #16
100092f2:	4684      	mov	ip, r0
100092f4:	4350      	muls	r0, r2
100092f6:	1c35      	adds	r5, r6, #0
100092f8:	4681      	mov	r9, r0
100092fa:	4660      	mov	r0, ip
100092fc:	4365      	muls	r5, r4
100092fe:	4344      	muls	r4, r0
10009300:	4648      	mov	r0, r9
10009302:	0c00      	lsrs	r0, r0, #16
10009304:	4683      	mov	fp, r0
10009306:	4372      	muls	r2, r6
10009308:	1914      	adds	r4, r2, r4
1000930a:	445c      	add	r4, fp
1000930c:	42a2      	cmp	r2, r4
1000930e:	d903      	bls.n	10009318 <__aeabi_dmul+0x2b4>
10009310:	2280      	movs	r2, #128	; 0x80
10009312:	0252      	lsls	r2, r2, #9
10009314:	4693      	mov	fp, r2
10009316:	445d      	add	r5, fp
10009318:	0c22      	lsrs	r2, r4, #16
1000931a:	18ad      	adds	r5, r5, r2
1000931c:	464a      	mov	r2, r9
1000931e:	0412      	lsls	r2, r2, #16
10009320:	0c12      	lsrs	r2, r2, #16
10009322:	0424      	lsls	r4, r4, #16
10009324:	4640      	mov	r0, r8
10009326:	18a4      	adds	r4, r4, r2
10009328:	4662      	mov	r2, ip
1000932a:	434a      	muls	r2, r1
1000932c:	4371      	muls	r1, r6
1000932e:	4346      	muls	r6, r0
10009330:	4660      	mov	r0, ip
10009332:	9600      	str	r6, [sp, #0]
10009334:	4646      	mov	r6, r8
10009336:	4370      	muls	r0, r6
10009338:	4680      	mov	r8, r0
1000933a:	0c10      	lsrs	r0, r2, #16
1000933c:	4684      	mov	ip, r0
1000933e:	4488      	add	r8, r1
10009340:	44e0      	add	r8, ip
10009342:	4541      	cmp	r1, r8
10009344:	d905      	bls.n	10009352 <__aeabi_dmul+0x2ee>
10009346:	2180      	movs	r1, #128	; 0x80
10009348:	0249      	lsls	r1, r1, #9
1000934a:	468c      	mov	ip, r1
1000934c:	9900      	ldr	r1, [sp, #0]
1000934e:	4461      	add	r1, ip
10009350:	9100      	str	r1, [sp, #0]
10009352:	9801      	ldr	r0, [sp, #4]
10009354:	9903      	ldr	r1, [sp, #12]
10009356:	4684      	mov	ip, r0
10009358:	4461      	add	r1, ip
1000935a:	4299      	cmp	r1, r3
1000935c:	419b      	sbcs	r3, r3
1000935e:	425b      	negs	r3, r3
10009360:	4699      	mov	r9, r3
10009362:	9805      	ldr	r0, [sp, #20]
10009364:	4643      	mov	r3, r8
10009366:	4684      	mov	ip, r0
10009368:	0412      	lsls	r2, r2, #16
1000936a:	0c12      	lsrs	r2, r2, #16
1000936c:	041b      	lsls	r3, r3, #16
1000936e:	189b      	adds	r3, r3, r2
10009370:	4463      	add	r3, ip
10009372:	469c      	mov	ip, r3
10009374:	46ab      	mov	fp, r5
10009376:	4283      	cmp	r3, r0
10009378:	419b      	sbcs	r3, r3
1000937a:	4640      	mov	r0, r8
1000937c:	190a      	adds	r2, r1, r4
1000937e:	44cc      	add	ip, r9
10009380:	42a2      	cmp	r2, r4
10009382:	4189      	sbcs	r1, r1
10009384:	44e3      	add	fp, ip
10009386:	45cc      	cmp	ip, r9
10009388:	41b6      	sbcs	r6, r6
1000938a:	465c      	mov	r4, fp
1000938c:	0c00      	lsrs	r0, r0, #16
1000938e:	4680      	mov	r8, r0
10009390:	4249      	negs	r1, r1
10009392:	4276      	negs	r6, r6
10009394:	425b      	negs	r3, r3
10009396:	1864      	adds	r4, r4, r1
10009398:	4333      	orrs	r3, r6
1000939a:	4498      	add	r8, r3
1000939c:	428c      	cmp	r4, r1
1000939e:	4189      	sbcs	r1, r1
100093a0:	45ab      	cmp	fp, r5
100093a2:	419b      	sbcs	r3, r3
100093a4:	4249      	negs	r1, r1
100093a6:	425b      	negs	r3, r3
100093a8:	4319      	orrs	r1, r3
100093aa:	1c0d      	adds	r5, r1, #0
100093ac:	9b00      	ldr	r3, [sp, #0]
100093ae:	4445      	add	r5, r8
100093b0:	18ee      	adds	r6, r5, r3
100093b2:	0276      	lsls	r6, r6, #9
100093b4:	0de5      	lsrs	r5, r4, #23
100093b6:	432e      	orrs	r6, r5
100093b8:	46b3      	mov	fp, r6
100093ba:	9b04      	ldr	r3, [sp, #16]
100093bc:	0256      	lsls	r6, r2, #9
100093be:	431e      	orrs	r6, r3
100093c0:	1e73      	subs	r3, r6, #1
100093c2:	419e      	sbcs	r6, r3
100093c4:	465b      	mov	r3, fp
100093c6:	0dd2      	lsrs	r2, r2, #23
100093c8:	4332      	orrs	r2, r6
100093ca:	0266      	lsls	r6, r4, #9
100093cc:	4316      	orrs	r6, r2
100093ce:	01db      	lsls	r3, r3, #7
100093d0:	d50a      	bpl.n	100093e8 <__aeabi_dmul+0x384>
100093d2:	2301      	movs	r3, #1
100093d4:	4033      	ands	r3, r6
100093d6:	0876      	lsrs	r6, r6, #1
100093d8:	431e      	orrs	r6, r3
100093da:	465b      	mov	r3, fp
100093dc:	07db      	lsls	r3, r3, #31
100093de:	431e      	orrs	r6, r3
100093e0:	465b      	mov	r3, fp
100093e2:	085b      	lsrs	r3, r3, #1
100093e4:	469b      	mov	fp, r3
100093e6:	4657      	mov	r7, sl
100093e8:	4b63      	ldr	r3, [pc, #396]	; (10009578 <__aeabi_dmul+0x514>)
100093ea:	18fb      	adds	r3, r7, r3
100093ec:	2b00      	cmp	r3, #0
100093ee:	dd5a      	ble.n	100094a6 <__aeabi_dmul+0x442>
100093f0:	0772      	lsls	r2, r6, #29
100093f2:	d009      	beq.n	10009408 <__aeabi_dmul+0x3a4>
100093f4:	220f      	movs	r2, #15
100093f6:	4032      	ands	r2, r6
100093f8:	2a04      	cmp	r2, #4
100093fa:	d005      	beq.n	10009408 <__aeabi_dmul+0x3a4>
100093fc:	1d32      	adds	r2, r6, #4
100093fe:	42b2      	cmp	r2, r6
10009400:	41b6      	sbcs	r6, r6
10009402:	4276      	negs	r6, r6
10009404:	44b3      	add	fp, r6
10009406:	1c16      	adds	r6, r2, #0
10009408:	465a      	mov	r2, fp
1000940a:	01d2      	lsls	r2, r2, #7
1000940c:	d506      	bpl.n	1000941c <__aeabi_dmul+0x3b8>
1000940e:	465a      	mov	r2, fp
10009410:	4b5a      	ldr	r3, [pc, #360]	; (1000957c <__aeabi_dmul+0x518>)
10009412:	401a      	ands	r2, r3
10009414:	2380      	movs	r3, #128	; 0x80
10009416:	4693      	mov	fp, r2
10009418:	00db      	lsls	r3, r3, #3
1000941a:	18fb      	adds	r3, r7, r3
1000941c:	4a58      	ldr	r2, [pc, #352]	; (10009580 <__aeabi_dmul+0x51c>)
1000941e:	4293      	cmp	r3, r2
10009420:	dd34      	ble.n	1000948c <__aeabi_dmul+0x428>
10009422:	2401      	movs	r4, #1
10009424:	9b02      	ldr	r3, [sp, #8]
10009426:	2500      	movs	r5, #0
10009428:	401c      	ands	r4, r3
1000942a:	2600      	movs	r6, #0
1000942c:	4b55      	ldr	r3, [pc, #340]	; (10009584 <__aeabi_dmul+0x520>)
1000942e:	e67d      	b.n	1000912c <__aeabi_dmul+0xc8>
10009430:	2080      	movs	r0, #128	; 0x80
10009432:	465b      	mov	r3, fp
10009434:	0300      	lsls	r0, r0, #12
10009436:	4203      	tst	r3, r0
10009438:	d008      	beq.n	1000944c <__aeabi_dmul+0x3e8>
1000943a:	4205      	tst	r5, r0
1000943c:	d106      	bne.n	1000944c <__aeabi_dmul+0x3e8>
1000943e:	4305      	orrs	r5, r0
10009440:	032d      	lsls	r5, r5, #12
10009442:	0b2d      	lsrs	r5, r5, #12
10009444:	464c      	mov	r4, r9
10009446:	1c16      	adds	r6, r2, #0
10009448:	4b4e      	ldr	r3, [pc, #312]	; (10009584 <__aeabi_dmul+0x520>)
1000944a:	e66f      	b.n	1000912c <__aeabi_dmul+0xc8>
1000944c:	465d      	mov	r5, fp
1000944e:	4305      	orrs	r5, r0
10009450:	032d      	lsls	r5, r5, #12
10009452:	0b2d      	lsrs	r5, r5, #12
10009454:	4b4b      	ldr	r3, [pc, #300]	; (10009584 <__aeabi_dmul+0x520>)
10009456:	e669      	b.n	1000912c <__aeabi_dmul+0xc8>
10009458:	4650      	mov	r0, sl
1000945a:	f7fc f85f 	bl	1000551c <__clzsi2>
1000945e:	1c03      	adds	r3, r0, #0
10009460:	3320      	adds	r3, #32
10009462:	2b27      	cmp	r3, #39	; 0x27
10009464:	dc00      	bgt.n	10009468 <__aeabi_dmul+0x404>
10009466:	e6a6      	b.n	100091b6 <__aeabi_dmul+0x152>
10009468:	4655      	mov	r5, sl
1000946a:	3808      	subs	r0, #8
1000946c:	4085      	lsls	r5, r0
1000946e:	2200      	movs	r2, #0
10009470:	e6ac      	b.n	100091cc <__aeabi_dmul+0x168>
10009472:	1c28      	adds	r0, r5, #0
10009474:	f7fc f852 	bl	1000551c <__clzsi2>
10009478:	1c02      	adds	r2, r0, #0
1000947a:	3220      	adds	r2, #32
1000947c:	2a27      	cmp	r2, #39	; 0x27
1000947e:	dc00      	bgt.n	10009482 <__aeabi_dmul+0x41e>
10009480:	e675      	b.n	1000916e <__aeabi_dmul+0x10a>
10009482:	3808      	subs	r0, #8
10009484:	4085      	lsls	r5, r0
10009486:	2600      	movs	r6, #0
10009488:	46ab      	mov	fp, r5
1000948a:	e67d      	b.n	10009188 <__aeabi_dmul+0x124>
1000948c:	465a      	mov	r2, fp
1000948e:	08f6      	lsrs	r6, r6, #3
10009490:	0752      	lsls	r2, r2, #29
10009492:	4316      	orrs	r6, r2
10009494:	465a      	mov	r2, fp
10009496:	2401      	movs	r4, #1
10009498:	0255      	lsls	r5, r2, #9
1000949a:	9a02      	ldr	r2, [sp, #8]
1000949c:	055b      	lsls	r3, r3, #21
1000949e:	0b2d      	lsrs	r5, r5, #12
100094a0:	0d5b      	lsrs	r3, r3, #21
100094a2:	4014      	ands	r4, r2
100094a4:	e642      	b.n	1000912c <__aeabi_dmul+0xc8>
100094a6:	4d38      	ldr	r5, [pc, #224]	; (10009588 <__aeabi_dmul+0x524>)
100094a8:	1bed      	subs	r5, r5, r7
100094aa:	2d38      	cmp	r5, #56	; 0x38
100094ac:	dd0a      	ble.n	100094c4 <__aeabi_dmul+0x460>
100094ae:	2401      	movs	r4, #1
100094b0:	9b02      	ldr	r3, [sp, #8]
100094b2:	2500      	movs	r5, #0
100094b4:	401c      	ands	r4, r3
100094b6:	2600      	movs	r6, #0
100094b8:	2300      	movs	r3, #0
100094ba:	e637      	b.n	1000912c <__aeabi_dmul+0xc8>
100094bc:	9b01      	ldr	r3, [sp, #4]
100094be:	4657      	mov	r7, sl
100094c0:	9302      	str	r3, [sp, #8]
100094c2:	e791      	b.n	100093e8 <__aeabi_dmul+0x384>
100094c4:	2d1f      	cmp	r5, #31
100094c6:	dc25      	bgt.n	10009514 <__aeabi_dmul+0x4b0>
100094c8:	4b30      	ldr	r3, [pc, #192]	; (1000958c <__aeabi_dmul+0x528>)
100094ca:	1c32      	adds	r2, r6, #0
100094cc:	469c      	mov	ip, r3
100094ce:	4467      	add	r7, ip
100094d0:	40be      	lsls	r6, r7
100094d2:	465b      	mov	r3, fp
100094d4:	40bb      	lsls	r3, r7
100094d6:	1c37      	adds	r7, r6, #0
100094d8:	40ea      	lsrs	r2, r5
100094da:	1e7e      	subs	r6, r7, #1
100094dc:	41b7      	sbcs	r7, r6
100094de:	4313      	orrs	r3, r2
100094e0:	433b      	orrs	r3, r7
100094e2:	1c1e      	adds	r6, r3, #0
100094e4:	465b      	mov	r3, fp
100094e6:	40eb      	lsrs	r3, r5
100094e8:	1c1d      	adds	r5, r3, #0
100094ea:	0773      	lsls	r3, r6, #29
100094ec:	d009      	beq.n	10009502 <__aeabi_dmul+0x49e>
100094ee:	230f      	movs	r3, #15
100094f0:	4033      	ands	r3, r6
100094f2:	2b04      	cmp	r3, #4
100094f4:	d005      	beq.n	10009502 <__aeabi_dmul+0x49e>
100094f6:	1d33      	adds	r3, r6, #4
100094f8:	42b3      	cmp	r3, r6
100094fa:	41b6      	sbcs	r6, r6
100094fc:	4276      	negs	r6, r6
100094fe:	19ad      	adds	r5, r5, r6
10009500:	1c1e      	adds	r6, r3, #0
10009502:	022b      	lsls	r3, r5, #8
10009504:	d520      	bpl.n	10009548 <__aeabi_dmul+0x4e4>
10009506:	2401      	movs	r4, #1
10009508:	9b02      	ldr	r3, [sp, #8]
1000950a:	2500      	movs	r5, #0
1000950c:	401c      	ands	r4, r3
1000950e:	2600      	movs	r6, #0
10009510:	2301      	movs	r3, #1
10009512:	e60b      	b.n	1000912c <__aeabi_dmul+0xc8>
10009514:	465a      	mov	r2, fp
10009516:	4b1e      	ldr	r3, [pc, #120]	; (10009590 <__aeabi_dmul+0x52c>)
10009518:	1bdb      	subs	r3, r3, r7
1000951a:	40da      	lsrs	r2, r3
1000951c:	1c13      	adds	r3, r2, #0
1000951e:	2d20      	cmp	r5, #32
10009520:	d01c      	beq.n	1000955c <__aeabi_dmul+0x4f8>
10009522:	4a1c      	ldr	r2, [pc, #112]	; (10009594 <__aeabi_dmul+0x530>)
10009524:	4694      	mov	ip, r2
10009526:	465a      	mov	r2, fp
10009528:	4467      	add	r7, ip
1000952a:	40ba      	lsls	r2, r7
1000952c:	1c17      	adds	r7, r2, #0
1000952e:	433e      	orrs	r6, r7
10009530:	1e72      	subs	r2, r6, #1
10009532:	4196      	sbcs	r6, r2
10009534:	431e      	orrs	r6, r3
10009536:	2307      	movs	r3, #7
10009538:	2500      	movs	r5, #0
1000953a:	4033      	ands	r3, r6
1000953c:	d007      	beq.n	1000954e <__aeabi_dmul+0x4ea>
1000953e:	230f      	movs	r3, #15
10009540:	2500      	movs	r5, #0
10009542:	4033      	ands	r3, r6
10009544:	2b04      	cmp	r3, #4
10009546:	d1d6      	bne.n	100094f6 <__aeabi_dmul+0x492>
10009548:	076b      	lsls	r3, r5, #29
1000954a:	026d      	lsls	r5, r5, #9
1000954c:	0b2d      	lsrs	r5, r5, #12
1000954e:	2401      	movs	r4, #1
10009550:	08f6      	lsrs	r6, r6, #3
10009552:	431e      	orrs	r6, r3
10009554:	9b02      	ldr	r3, [sp, #8]
10009556:	401c      	ands	r4, r3
10009558:	2300      	movs	r3, #0
1000955a:	e5e7      	b.n	1000912c <__aeabi_dmul+0xc8>
1000955c:	2700      	movs	r7, #0
1000955e:	e7e6      	b.n	1000952e <__aeabi_dmul+0x4ca>
10009560:	2580      	movs	r5, #128	; 0x80
10009562:	465b      	mov	r3, fp
10009564:	2401      	movs	r4, #1
10009566:	032d      	lsls	r5, r5, #12
10009568:	431d      	orrs	r5, r3
1000956a:	9b01      	ldr	r3, [sp, #4]
1000956c:	032d      	lsls	r5, r5, #12
1000956e:	4023      	ands	r3, r4
10009570:	1c1c      	adds	r4, r3, #0
10009572:	0b2d      	lsrs	r5, r5, #12
10009574:	4b03      	ldr	r3, [pc, #12]	; (10009584 <__aeabi_dmul+0x520>)
10009576:	e5d9      	b.n	1000912c <__aeabi_dmul+0xc8>
10009578:	000003ff 	.word	0x000003ff
1000957c:	feffffff 	.word	0xfeffffff
10009580:	000007fe 	.word	0x000007fe
10009584:	000007ff 	.word	0x000007ff
10009588:	fffffc02 	.word	0xfffffc02
1000958c:	0000041e 	.word	0x0000041e
10009590:	fffffbe2 	.word	0xfffffbe2
10009594:	0000043e 	.word	0x0000043e

10009598 <__aeabi_dsub>:
10009598:	b5f0      	push	{r4, r5, r6, r7, lr}
1000959a:	464d      	mov	r5, r9
1000959c:	4644      	mov	r4, r8
1000959e:	465f      	mov	r7, fp
100095a0:	4656      	mov	r6, sl
100095a2:	b4f0      	push	{r4, r5, r6, r7}
100095a4:	1c0e      	adds	r6, r1, #0
100095a6:	1c11      	adds	r1, r2, #0
100095a8:	0332      	lsls	r2, r6, #12
100095aa:	0a52      	lsrs	r2, r2, #9
100095ac:	0f47      	lsrs	r7, r0, #29
100095ae:	4317      	orrs	r7, r2
100095b0:	00c5      	lsls	r5, r0, #3
100095b2:	031a      	lsls	r2, r3, #12
100095b4:	0058      	lsls	r0, r3, #1
100095b6:	0fdb      	lsrs	r3, r3, #31
100095b8:	4699      	mov	r9, r3
100095ba:	0a52      	lsrs	r2, r2, #9
100095bc:	0f4b      	lsrs	r3, r1, #29
100095be:	b083      	sub	sp, #12
100095c0:	431a      	orrs	r2, r3
100095c2:	00cb      	lsls	r3, r1, #3
100095c4:	9301      	str	r3, [sp, #4]
100095c6:	4bcf      	ldr	r3, [pc, #828]	; (10009904 <__aeabi_dsub+0x36c>)
100095c8:	0074      	lsls	r4, r6, #1
100095ca:	0ff6      	lsrs	r6, r6, #31
100095cc:	0d64      	lsrs	r4, r4, #21
100095ce:	46b0      	mov	r8, r6
100095d0:	0d40      	lsrs	r0, r0, #21
100095d2:	4298      	cmp	r0, r3
100095d4:	d100      	bne.n	100095d8 <__aeabi_dsub+0x40>
100095d6:	e0e8      	b.n	100097aa <__aeabi_dsub+0x212>
100095d8:	2301      	movs	r3, #1
100095da:	4649      	mov	r1, r9
100095dc:	4059      	eors	r1, r3
100095de:	1c0b      	adds	r3, r1, #0
100095e0:	429e      	cmp	r6, r3
100095e2:	d100      	bne.n	100095e6 <__aeabi_dsub+0x4e>
100095e4:	e0b1      	b.n	1000974a <__aeabi_dsub+0x1b2>
100095e6:	1a26      	subs	r6, r4, r0
100095e8:	2e00      	cmp	r6, #0
100095ea:	dc00      	bgt.n	100095ee <__aeabi_dsub+0x56>
100095ec:	e11c      	b.n	10009828 <__aeabi_dsub+0x290>
100095ee:	2800      	cmp	r0, #0
100095f0:	d142      	bne.n	10009678 <__aeabi_dsub+0xe0>
100095f2:	1c13      	adds	r3, r2, #0
100095f4:	9901      	ldr	r1, [sp, #4]
100095f6:	430b      	orrs	r3, r1
100095f8:	d000      	beq.n	100095fc <__aeabi_dsub+0x64>
100095fa:	e0e6      	b.n	100097ca <__aeabi_dsub+0x232>
100095fc:	076b      	lsls	r3, r5, #29
100095fe:	d100      	bne.n	10009602 <__aeabi_dsub+0x6a>
10009600:	e08e      	b.n	10009720 <__aeabi_dsub+0x188>
10009602:	230f      	movs	r3, #15
10009604:	402b      	ands	r3, r5
10009606:	2b04      	cmp	r3, #4
10009608:	d100      	bne.n	1000960c <__aeabi_dsub+0x74>
1000960a:	e089      	b.n	10009720 <__aeabi_dsub+0x188>
1000960c:	1d2a      	adds	r2, r5, #4
1000960e:	42aa      	cmp	r2, r5
10009610:	41ad      	sbcs	r5, r5
10009612:	2380      	movs	r3, #128	; 0x80
10009614:	2601      	movs	r6, #1
10009616:	4641      	mov	r1, r8
10009618:	426d      	negs	r5, r5
1000961a:	197f      	adds	r7, r7, r5
1000961c:	041b      	lsls	r3, r3, #16
1000961e:	403b      	ands	r3, r7
10009620:	400e      	ands	r6, r1
10009622:	1c15      	adds	r5, r2, #0
10009624:	2b00      	cmp	r3, #0
10009626:	d100      	bne.n	1000962a <__aeabi_dsub+0x92>
10009628:	e083      	b.n	10009732 <__aeabi_dsub+0x19a>
1000962a:	4bb6      	ldr	r3, [pc, #728]	; (10009904 <__aeabi_dsub+0x36c>)
1000962c:	3401      	adds	r4, #1
1000962e:	429c      	cmp	r4, r3
10009630:	d100      	bne.n	10009634 <__aeabi_dsub+0x9c>
10009632:	e116      	b.n	10009862 <__aeabi_dsub+0x2ca>
10009634:	1c3a      	adds	r2, r7, #0
10009636:	4bb4      	ldr	r3, [pc, #720]	; (10009908 <__aeabi_dsub+0x370>)
10009638:	08ed      	lsrs	r5, r5, #3
1000963a:	401a      	ands	r2, r3
1000963c:	0750      	lsls	r0, r2, #29
1000963e:	0564      	lsls	r4, r4, #21
10009640:	0252      	lsls	r2, r2, #9
10009642:	4305      	orrs	r5, r0
10009644:	0b12      	lsrs	r2, r2, #12
10009646:	0d64      	lsrs	r4, r4, #21
10009648:	2100      	movs	r1, #0
1000964a:	0312      	lsls	r2, r2, #12
1000964c:	0d0b      	lsrs	r3, r1, #20
1000964e:	051b      	lsls	r3, r3, #20
10009650:	0564      	lsls	r4, r4, #21
10009652:	0b12      	lsrs	r2, r2, #12
10009654:	431a      	orrs	r2, r3
10009656:	0863      	lsrs	r3, r4, #1
10009658:	4cac      	ldr	r4, [pc, #688]	; (1000990c <__aeabi_dsub+0x374>)
1000965a:	07f6      	lsls	r6, r6, #31
1000965c:	4014      	ands	r4, r2
1000965e:	431c      	orrs	r4, r3
10009660:	0064      	lsls	r4, r4, #1
10009662:	0864      	lsrs	r4, r4, #1
10009664:	4334      	orrs	r4, r6
10009666:	1c28      	adds	r0, r5, #0
10009668:	1c21      	adds	r1, r4, #0
1000966a:	b003      	add	sp, #12
1000966c:	bc3c      	pop	{r2, r3, r4, r5}
1000966e:	4690      	mov	r8, r2
10009670:	4699      	mov	r9, r3
10009672:	46a2      	mov	sl, r4
10009674:	46ab      	mov	fp, r5
10009676:	bdf0      	pop	{r4, r5, r6, r7, pc}
10009678:	4ba2      	ldr	r3, [pc, #648]	; (10009904 <__aeabi_dsub+0x36c>)
1000967a:	429c      	cmp	r4, r3
1000967c:	d0be      	beq.n	100095fc <__aeabi_dsub+0x64>
1000967e:	2380      	movs	r3, #128	; 0x80
10009680:	041b      	lsls	r3, r3, #16
10009682:	431a      	orrs	r2, r3
10009684:	2e38      	cmp	r6, #56	; 0x38
10009686:	dd00      	ble.n	1000968a <__aeabi_dsub+0xf2>
10009688:	e103      	b.n	10009892 <__aeabi_dsub+0x2fa>
1000968a:	2e1f      	cmp	r6, #31
1000968c:	dd00      	ble.n	10009690 <__aeabi_dsub+0xf8>
1000968e:	e13f      	b.n	10009910 <__aeabi_dsub+0x378>
10009690:	2020      	movs	r0, #32
10009692:	1b83      	subs	r3, r0, r6
10009694:	4699      	mov	r9, r3
10009696:	1c13      	adds	r3, r2, #0
10009698:	4649      	mov	r1, r9
1000969a:	408b      	lsls	r3, r1
1000969c:	469c      	mov	ip, r3
1000969e:	9b01      	ldr	r3, [sp, #4]
100096a0:	4660      	mov	r0, ip
100096a2:	40f3      	lsrs	r3, r6
100096a4:	4303      	orrs	r3, r0
100096a6:	9801      	ldr	r0, [sp, #4]
100096a8:	40f2      	lsrs	r2, r6
100096aa:	4088      	lsls	r0, r1
100096ac:	1c01      	adds	r1, r0, #0
100096ae:	1e48      	subs	r0, r1, #1
100096b0:	4181      	sbcs	r1, r0
100096b2:	430b      	orrs	r3, r1
100096b4:	1aeb      	subs	r3, r5, r3
100096b6:	429d      	cmp	r5, r3
100096b8:	4180      	sbcs	r0, r0
100096ba:	1c1d      	adds	r5, r3, #0
100096bc:	1aba      	subs	r2, r7, r2
100096be:	4240      	negs	r0, r0
100096c0:	1a17      	subs	r7, r2, r0
100096c2:	023b      	lsls	r3, r7, #8
100096c4:	d400      	bmi.n	100096c8 <__aeabi_dsub+0x130>
100096c6:	e0a8      	b.n	1000981a <__aeabi_dsub+0x282>
100096c8:	027a      	lsls	r2, r7, #9
100096ca:	0a56      	lsrs	r6, r2, #9
100096cc:	2e00      	cmp	r6, #0
100096ce:	d100      	bne.n	100096d2 <__aeabi_dsub+0x13a>
100096d0:	e0ca      	b.n	10009868 <__aeabi_dsub+0x2d0>
100096d2:	1c30      	adds	r0, r6, #0
100096d4:	f7fb ff22 	bl	1000551c <__clzsi2>
100096d8:	1c03      	adds	r3, r0, #0
100096da:	3b08      	subs	r3, #8
100096dc:	2b1f      	cmp	r3, #31
100096de:	dd00      	ble.n	100096e2 <__aeabi_dsub+0x14a>
100096e0:	e0cb      	b.n	1000987a <__aeabi_dsub+0x2e2>
100096e2:	2228      	movs	r2, #40	; 0x28
100096e4:	1c29      	adds	r1, r5, #0
100096e6:	1a12      	subs	r2, r2, r0
100096e8:	40d1      	lsrs	r1, r2
100096ea:	409e      	lsls	r6, r3
100096ec:	1c0a      	adds	r2, r1, #0
100096ee:	409d      	lsls	r5, r3
100096f0:	4332      	orrs	r2, r6
100096f2:	429c      	cmp	r4, r3
100096f4:	dd00      	ble.n	100096f8 <__aeabi_dsub+0x160>
100096f6:	e0c8      	b.n	1000988a <__aeabi_dsub+0x2f2>
100096f8:	1b1c      	subs	r4, r3, r4
100096fa:	1c67      	adds	r7, r4, #1
100096fc:	2f1f      	cmp	r7, #31
100096fe:	dd00      	ble.n	10009702 <__aeabi_dsub+0x16a>
10009700:	e0ed      	b.n	100098de <__aeabi_dsub+0x346>
10009702:	231f      	movs	r3, #31
10009704:	1c29      	adds	r1, r5, #0
10009706:	1b1c      	subs	r4, r3, r4
10009708:	1c13      	adds	r3, r2, #0
1000970a:	40a5      	lsls	r5, r4
1000970c:	40a3      	lsls	r3, r4
1000970e:	40f9      	lsrs	r1, r7
10009710:	1e6c      	subs	r4, r5, #1
10009712:	41a5      	sbcs	r5, r4
10009714:	40fa      	lsrs	r2, r7
10009716:	4319      	orrs	r1, r3
10009718:	430d      	orrs	r5, r1
1000971a:	1c17      	adds	r7, r2, #0
1000971c:	2400      	movs	r4, #0
1000971e:	e76d      	b.n	100095fc <__aeabi_dsub+0x64>
10009720:	2380      	movs	r3, #128	; 0x80
10009722:	2601      	movs	r6, #1
10009724:	4642      	mov	r2, r8
10009726:	041b      	lsls	r3, r3, #16
10009728:	403b      	ands	r3, r7
1000972a:	4016      	ands	r6, r2
1000972c:	2b00      	cmp	r3, #0
1000972e:	d000      	beq.n	10009732 <__aeabi_dsub+0x19a>
10009730:	e77b      	b.n	1000962a <__aeabi_dsub+0x92>
10009732:	4b74      	ldr	r3, [pc, #464]	; (10009904 <__aeabi_dsub+0x36c>)
10009734:	08ed      	lsrs	r5, r5, #3
10009736:	0778      	lsls	r0, r7, #29
10009738:	4305      	orrs	r5, r0
1000973a:	08fa      	lsrs	r2, r7, #3
1000973c:	429c      	cmp	r4, r3
1000973e:	d03b      	beq.n	100097b8 <__aeabi_dsub+0x220>
10009740:	0312      	lsls	r2, r2, #12
10009742:	0564      	lsls	r4, r4, #21
10009744:	0b12      	lsrs	r2, r2, #12
10009746:	0d64      	lsrs	r4, r4, #21
10009748:	e77e      	b.n	10009648 <__aeabi_dsub+0xb0>
1000974a:	1a23      	subs	r3, r4, r0
1000974c:	469a      	mov	sl, r3
1000974e:	2b00      	cmp	r3, #0
10009750:	dc00      	bgt.n	10009754 <__aeabi_dsub+0x1bc>
10009752:	e0a5      	b.n	100098a0 <__aeabi_dsub+0x308>
10009754:	2800      	cmp	r0, #0
10009756:	d044      	beq.n	100097e2 <__aeabi_dsub+0x24a>
10009758:	486a      	ldr	r0, [pc, #424]	; (10009904 <__aeabi_dsub+0x36c>)
1000975a:	4284      	cmp	r4, r0
1000975c:	d100      	bne.n	10009760 <__aeabi_dsub+0x1c8>
1000975e:	e74d      	b.n	100095fc <__aeabi_dsub+0x64>
10009760:	2080      	movs	r0, #128	; 0x80
10009762:	0400      	lsls	r0, r0, #16
10009764:	4302      	orrs	r2, r0
10009766:	4653      	mov	r3, sl
10009768:	2b38      	cmp	r3, #56	; 0x38
1000976a:	dc00      	bgt.n	1000976e <__aeabi_dsub+0x1d6>
1000976c:	e11c      	b.n	100099a8 <__aeabi_dsub+0x410>
1000976e:	9b01      	ldr	r3, [sp, #4]
10009770:	431a      	orrs	r2, r3
10009772:	1e51      	subs	r1, r2, #1
10009774:	418a      	sbcs	r2, r1
10009776:	b2d1      	uxtb	r1, r2
10009778:	2200      	movs	r2, #0
1000977a:	1949      	adds	r1, r1, r5
1000977c:	42a9      	cmp	r1, r5
1000977e:	4180      	sbcs	r0, r0
10009780:	1c0d      	adds	r5, r1, #0
10009782:	19d2      	adds	r2, r2, r7
10009784:	4240      	negs	r0, r0
10009786:	1817      	adds	r7, r2, r0
10009788:	023b      	lsls	r3, r7, #8
1000978a:	d546      	bpl.n	1000981a <__aeabi_dsub+0x282>
1000978c:	4b5d      	ldr	r3, [pc, #372]	; (10009904 <__aeabi_dsub+0x36c>)
1000978e:	3401      	adds	r4, #1
10009790:	429c      	cmp	r4, r3
10009792:	d100      	bne.n	10009796 <__aeabi_dsub+0x1fe>
10009794:	e169      	b.n	10009a6a <__aeabi_dsub+0x4d2>
10009796:	2001      	movs	r0, #1
10009798:	4a5b      	ldr	r2, [pc, #364]	; (10009908 <__aeabi_dsub+0x370>)
1000979a:	086b      	lsrs	r3, r5, #1
1000979c:	403a      	ands	r2, r7
1000979e:	4028      	ands	r0, r5
100097a0:	4318      	orrs	r0, r3
100097a2:	07d5      	lsls	r5, r2, #31
100097a4:	4305      	orrs	r5, r0
100097a6:	0857      	lsrs	r7, r2, #1
100097a8:	e728      	b.n	100095fc <__aeabi_dsub+0x64>
100097aa:	1c13      	adds	r3, r2, #0
100097ac:	9901      	ldr	r1, [sp, #4]
100097ae:	430b      	orrs	r3, r1
100097b0:	d100      	bne.n	100097b4 <__aeabi_dsub+0x21c>
100097b2:	e711      	b.n	100095d8 <__aeabi_dsub+0x40>
100097b4:	464b      	mov	r3, r9
100097b6:	e713      	b.n	100095e0 <__aeabi_dsub+0x48>
100097b8:	1c2b      	adds	r3, r5, #0
100097ba:	4313      	orrs	r3, r2
100097bc:	d051      	beq.n	10009862 <__aeabi_dsub+0x2ca>
100097be:	2380      	movs	r3, #128	; 0x80
100097c0:	031b      	lsls	r3, r3, #12
100097c2:	431a      	orrs	r2, r3
100097c4:	0312      	lsls	r2, r2, #12
100097c6:	0b12      	lsrs	r2, r2, #12
100097c8:	e73e      	b.n	10009648 <__aeabi_dsub+0xb0>
100097ca:	3e01      	subs	r6, #1
100097cc:	2e00      	cmp	r6, #0
100097ce:	d000      	beq.n	100097d2 <__aeabi_dsub+0x23a>
100097d0:	e080      	b.n	100098d4 <__aeabi_dsub+0x33c>
100097d2:	1a69      	subs	r1, r5, r1
100097d4:	428d      	cmp	r5, r1
100097d6:	419b      	sbcs	r3, r3
100097d8:	1aba      	subs	r2, r7, r2
100097da:	425b      	negs	r3, r3
100097dc:	1ad7      	subs	r7, r2, r3
100097de:	1c0d      	adds	r5, r1, #0
100097e0:	e76f      	b.n	100096c2 <__aeabi_dsub+0x12a>
100097e2:	1c10      	adds	r0, r2, #0
100097e4:	9b01      	ldr	r3, [sp, #4]
100097e6:	4318      	orrs	r0, r3
100097e8:	d100      	bne.n	100097ec <__aeabi_dsub+0x254>
100097ea:	e707      	b.n	100095fc <__aeabi_dsub+0x64>
100097ec:	2301      	movs	r3, #1
100097ee:	425b      	negs	r3, r3
100097f0:	469c      	mov	ip, r3
100097f2:	44e2      	add	sl, ip
100097f4:	4653      	mov	r3, sl
100097f6:	2b00      	cmp	r3, #0
100097f8:	d000      	beq.n	100097fc <__aeabi_dsub+0x264>
100097fa:	e102      	b.n	10009a02 <__aeabi_dsub+0x46a>
100097fc:	9b01      	ldr	r3, [sp, #4]
100097fe:	19d2      	adds	r2, r2, r7
10009800:	1959      	adds	r1, r3, r5
10009802:	42a9      	cmp	r1, r5
10009804:	419b      	sbcs	r3, r3
10009806:	425b      	negs	r3, r3
10009808:	18d7      	adds	r7, r2, r3
1000980a:	1c0d      	adds	r5, r1, #0
1000980c:	e7bc      	b.n	10009788 <__aeabi_dsub+0x1f0>
1000980e:	4663      	mov	r3, ip
10009810:	4303      	orrs	r3, r0
10009812:	d100      	bne.n	10009816 <__aeabi_dsub+0x27e>
10009814:	e128      	b.n	10009a68 <__aeabi_dsub+0x4d0>
10009816:	1c07      	adds	r7, r0, #0
10009818:	4665      	mov	r5, ip
1000981a:	076b      	lsls	r3, r5, #29
1000981c:	d000      	beq.n	10009820 <__aeabi_dsub+0x288>
1000981e:	e6f0      	b.n	10009602 <__aeabi_dsub+0x6a>
10009820:	2601      	movs	r6, #1
10009822:	4643      	mov	r3, r8
10009824:	401e      	ands	r6, r3
10009826:	e784      	b.n	10009732 <__aeabi_dsub+0x19a>
10009828:	2e00      	cmp	r6, #0
1000982a:	d000      	beq.n	1000982e <__aeabi_dsub+0x296>
1000982c:	e081      	b.n	10009932 <__aeabi_dsub+0x39a>
1000982e:	1c60      	adds	r0, r4, #1
10009830:	0540      	lsls	r0, r0, #21
10009832:	0d40      	lsrs	r0, r0, #21
10009834:	2801      	cmp	r0, #1
10009836:	dc00      	bgt.n	1000983a <__aeabi_dsub+0x2a2>
10009838:	e107      	b.n	10009a4a <__aeabi_dsub+0x4b2>
1000983a:	9901      	ldr	r1, [sp, #4]
1000983c:	1a68      	subs	r0, r5, r1
1000983e:	4684      	mov	ip, r0
10009840:	4565      	cmp	r5, ip
10009842:	41b6      	sbcs	r6, r6
10009844:	1ab8      	subs	r0, r7, r2
10009846:	4276      	negs	r6, r6
10009848:	1b86      	subs	r6, r0, r6
1000984a:	0230      	lsls	r0, r6, #8
1000984c:	d400      	bmi.n	10009850 <__aeabi_dsub+0x2b8>
1000984e:	e0a1      	b.n	10009994 <__aeabi_dsub+0x3fc>
10009850:	468c      	mov	ip, r1
10009852:	1b4d      	subs	r5, r1, r5
10009854:	45ac      	cmp	ip, r5
10009856:	4189      	sbcs	r1, r1
10009858:	1bd2      	subs	r2, r2, r7
1000985a:	4249      	negs	r1, r1
1000985c:	1a56      	subs	r6, r2, r1
1000985e:	4698      	mov	r8, r3
10009860:	e734      	b.n	100096cc <__aeabi_dsub+0x134>
10009862:	2200      	movs	r2, #0
10009864:	2500      	movs	r5, #0
10009866:	e6ef      	b.n	10009648 <__aeabi_dsub+0xb0>
10009868:	1c28      	adds	r0, r5, #0
1000986a:	f7fb fe57 	bl	1000551c <__clzsi2>
1000986e:	3020      	adds	r0, #32
10009870:	1c03      	adds	r3, r0, #0
10009872:	3b08      	subs	r3, #8
10009874:	2b1f      	cmp	r3, #31
10009876:	dc00      	bgt.n	1000987a <__aeabi_dsub+0x2e2>
10009878:	e733      	b.n	100096e2 <__aeabi_dsub+0x14a>
1000987a:	1c02      	adds	r2, r0, #0
1000987c:	3a28      	subs	r2, #40	; 0x28
1000987e:	4095      	lsls	r5, r2
10009880:	1c2a      	adds	r2, r5, #0
10009882:	2500      	movs	r5, #0
10009884:	429c      	cmp	r4, r3
10009886:	dc00      	bgt.n	1000988a <__aeabi_dsub+0x2f2>
10009888:	e736      	b.n	100096f8 <__aeabi_dsub+0x160>
1000988a:	4f1f      	ldr	r7, [pc, #124]	; (10009908 <__aeabi_dsub+0x370>)
1000988c:	1ae4      	subs	r4, r4, r3
1000988e:	4017      	ands	r7, r2
10009890:	e6b4      	b.n	100095fc <__aeabi_dsub+0x64>
10009892:	9b01      	ldr	r3, [sp, #4]
10009894:	431a      	orrs	r2, r3
10009896:	1e51      	subs	r1, r2, #1
10009898:	418a      	sbcs	r2, r1
1000989a:	b2d3      	uxtb	r3, r2
1000989c:	2200      	movs	r2, #0
1000989e:	e709      	b.n	100096b4 <__aeabi_dsub+0x11c>
100098a0:	2b00      	cmp	r3, #0
100098a2:	d000      	beq.n	100098a6 <__aeabi_dsub+0x30e>
100098a4:	e101      	b.n	10009aaa <__aeabi_dsub+0x512>
100098a6:	1c60      	adds	r0, r4, #1
100098a8:	0543      	lsls	r3, r0, #21
100098aa:	0d5b      	lsrs	r3, r3, #21
100098ac:	2b01      	cmp	r3, #1
100098ae:	dc00      	bgt.n	100098b2 <__aeabi_dsub+0x31a>
100098b0:	e0b0      	b.n	10009a14 <__aeabi_dsub+0x47c>
100098b2:	4b14      	ldr	r3, [pc, #80]	; (10009904 <__aeabi_dsub+0x36c>)
100098b4:	4298      	cmp	r0, r3
100098b6:	d100      	bne.n	100098ba <__aeabi_dsub+0x322>
100098b8:	e11e      	b.n	10009af8 <__aeabi_dsub+0x560>
100098ba:	9b01      	ldr	r3, [sp, #4]
100098bc:	19d2      	adds	r2, r2, r7
100098be:	1959      	adds	r1, r3, r5
100098c0:	42a9      	cmp	r1, r5
100098c2:	419b      	sbcs	r3, r3
100098c4:	425b      	negs	r3, r3
100098c6:	18d2      	adds	r2, r2, r3
100098c8:	0849      	lsrs	r1, r1, #1
100098ca:	07d5      	lsls	r5, r2, #31
100098cc:	430d      	orrs	r5, r1
100098ce:	0857      	lsrs	r7, r2, #1
100098d0:	1c04      	adds	r4, r0, #0
100098d2:	e693      	b.n	100095fc <__aeabi_dsub+0x64>
100098d4:	4b0b      	ldr	r3, [pc, #44]	; (10009904 <__aeabi_dsub+0x36c>)
100098d6:	429c      	cmp	r4, r3
100098d8:	d000      	beq.n	100098dc <__aeabi_dsub+0x344>
100098da:	e6d3      	b.n	10009684 <__aeabi_dsub+0xec>
100098dc:	e68e      	b.n	100095fc <__aeabi_dsub+0x64>
100098de:	1c21      	adds	r1, r4, #0
100098e0:	1c13      	adds	r3, r2, #0
100098e2:	391f      	subs	r1, #31
100098e4:	40cb      	lsrs	r3, r1
100098e6:	1c19      	adds	r1, r3, #0
100098e8:	2f20      	cmp	r7, #32
100098ea:	d100      	bne.n	100098ee <__aeabi_dsub+0x356>
100098ec:	e08e      	b.n	10009a0c <__aeabi_dsub+0x474>
100098ee:	233f      	movs	r3, #63	; 0x3f
100098f0:	1b1c      	subs	r4, r3, r4
100098f2:	40a2      	lsls	r2, r4
100098f4:	4315      	orrs	r5, r2
100098f6:	1e6a      	subs	r2, r5, #1
100098f8:	4195      	sbcs	r5, r2
100098fa:	2700      	movs	r7, #0
100098fc:	430d      	orrs	r5, r1
100098fe:	2400      	movs	r4, #0
10009900:	e78b      	b.n	1000981a <__aeabi_dsub+0x282>
10009902:	46c0      	nop			; (mov r8, r8)
10009904:	000007ff 	.word	0x000007ff
10009908:	ff7fffff 	.word	0xff7fffff
1000990c:	800fffff 	.word	0x800fffff
10009910:	1c33      	adds	r3, r6, #0
10009912:	1c10      	adds	r0, r2, #0
10009914:	3b20      	subs	r3, #32
10009916:	40d8      	lsrs	r0, r3
10009918:	2e20      	cmp	r6, #32
1000991a:	d079      	beq.n	10009a10 <__aeabi_dsub+0x478>
1000991c:	2340      	movs	r3, #64	; 0x40
1000991e:	1b9b      	subs	r3, r3, r6
10009920:	409a      	lsls	r2, r3
10009922:	1c13      	adds	r3, r2, #0
10009924:	9a01      	ldr	r2, [sp, #4]
10009926:	4313      	orrs	r3, r2
10009928:	1e59      	subs	r1, r3, #1
1000992a:	418b      	sbcs	r3, r1
1000992c:	2200      	movs	r2, #0
1000992e:	4303      	orrs	r3, r0
10009930:	e6c0      	b.n	100096b4 <__aeabi_dsub+0x11c>
10009932:	2c00      	cmp	r4, #0
10009934:	d053      	beq.n	100099de <__aeabi_dsub+0x446>
10009936:	4cc7      	ldr	r4, [pc, #796]	; (10009c54 <__aeabi_dsub+0x6bc>)
10009938:	42a0      	cmp	r0, r4
1000993a:	d100      	bne.n	1000993e <__aeabi_dsub+0x3a6>
1000993c:	e0b0      	b.n	10009aa0 <__aeabi_dsub+0x508>
1000993e:	2480      	movs	r4, #128	; 0x80
10009940:	4271      	negs	r1, r6
10009942:	4689      	mov	r9, r1
10009944:	0424      	lsls	r4, r4, #16
10009946:	4327      	orrs	r7, r4
10009948:	4649      	mov	r1, r9
1000994a:	2938      	cmp	r1, #56	; 0x38
1000994c:	dd00      	ble.n	10009950 <__aeabi_dsub+0x3b8>
1000994e:	e0cd      	b.n	10009aec <__aeabi_dsub+0x554>
10009950:	291f      	cmp	r1, #31
10009952:	dd00      	ble.n	10009956 <__aeabi_dsub+0x3be>
10009954:	e159      	b.n	10009c0a <__aeabi_dsub+0x672>
10009956:	2420      	movs	r4, #32
10009958:	1c3e      	adds	r6, r7, #0
1000995a:	1a61      	subs	r1, r4, r1
1000995c:	408e      	lsls	r6, r1
1000995e:	468a      	mov	sl, r1
10009960:	46b0      	mov	r8, r6
10009962:	4649      	mov	r1, r9
10009964:	1c2e      	adds	r6, r5, #0
10009966:	40ce      	lsrs	r6, r1
10009968:	4651      	mov	r1, sl
1000996a:	46b4      	mov	ip, r6
1000996c:	408d      	lsls	r5, r1
1000996e:	4664      	mov	r4, ip
10009970:	4646      	mov	r6, r8
10009972:	4649      	mov	r1, r9
10009974:	4326      	orrs	r6, r4
10009976:	1e6c      	subs	r4, r5, #1
10009978:	41a5      	sbcs	r5, r4
1000997a:	40cf      	lsrs	r7, r1
1000997c:	4335      	orrs	r5, r6
1000997e:	9901      	ldr	r1, [sp, #4]
10009980:	1bd7      	subs	r7, r2, r7
10009982:	468c      	mov	ip, r1
10009984:	1b4d      	subs	r5, r1, r5
10009986:	45ac      	cmp	ip, r5
10009988:	4192      	sbcs	r2, r2
1000998a:	4252      	negs	r2, r2
1000998c:	1abf      	subs	r7, r7, r2
1000998e:	1c04      	adds	r4, r0, #0
10009990:	4698      	mov	r8, r3
10009992:	e696      	b.n	100096c2 <__aeabi_dsub+0x12a>
10009994:	4663      	mov	r3, ip
10009996:	4665      	mov	r5, ip
10009998:	4333      	orrs	r3, r6
1000999a:	d000      	beq.n	1000999e <__aeabi_dsub+0x406>
1000999c:	e696      	b.n	100096cc <__aeabi_dsub+0x134>
1000999e:	2600      	movs	r6, #0
100099a0:	2700      	movs	r7, #0
100099a2:	2400      	movs	r4, #0
100099a4:	2500      	movs	r5, #0
100099a6:	e6c4      	b.n	10009732 <__aeabi_dsub+0x19a>
100099a8:	2b1f      	cmp	r3, #31
100099aa:	dc61      	bgt.n	10009a70 <__aeabi_dsub+0x4d8>
100099ac:	2020      	movs	r0, #32
100099ae:	1ac3      	subs	r3, r0, r3
100099b0:	469b      	mov	fp, r3
100099b2:	1c13      	adds	r3, r2, #0
100099b4:	4659      	mov	r1, fp
100099b6:	408b      	lsls	r3, r1
100099b8:	4651      	mov	r1, sl
100099ba:	4699      	mov	r9, r3
100099bc:	9b01      	ldr	r3, [sp, #4]
100099be:	40cb      	lsrs	r3, r1
100099c0:	469c      	mov	ip, r3
100099c2:	464b      	mov	r3, r9
100099c4:	4660      	mov	r0, ip
100099c6:	4303      	orrs	r3, r0
100099c8:	469c      	mov	ip, r3
100099ca:	465b      	mov	r3, fp
100099cc:	9901      	ldr	r1, [sp, #4]
100099ce:	4099      	lsls	r1, r3
100099d0:	4663      	mov	r3, ip
100099d2:	1e48      	subs	r0, r1, #1
100099d4:	4181      	sbcs	r1, r0
100099d6:	4319      	orrs	r1, r3
100099d8:	4653      	mov	r3, sl
100099da:	40da      	lsrs	r2, r3
100099dc:	e6cd      	b.n	1000977a <__aeabi_dsub+0x1e2>
100099de:	1c3c      	adds	r4, r7, #0
100099e0:	432c      	orrs	r4, r5
100099e2:	d05d      	beq.n	10009aa0 <__aeabi_dsub+0x508>
100099e4:	43f1      	mvns	r1, r6
100099e6:	4689      	mov	r9, r1
100099e8:	2900      	cmp	r1, #0
100099ea:	d155      	bne.n	10009a98 <__aeabi_dsub+0x500>
100099ec:	9901      	ldr	r1, [sp, #4]
100099ee:	1bd2      	subs	r2, r2, r7
100099f0:	468c      	mov	ip, r1
100099f2:	1b4d      	subs	r5, r1, r5
100099f4:	45ac      	cmp	ip, r5
100099f6:	4189      	sbcs	r1, r1
100099f8:	4249      	negs	r1, r1
100099fa:	1a57      	subs	r7, r2, r1
100099fc:	1c04      	adds	r4, r0, #0
100099fe:	4698      	mov	r8, r3
10009a00:	e65f      	b.n	100096c2 <__aeabi_dsub+0x12a>
10009a02:	4894      	ldr	r0, [pc, #592]	; (10009c54 <__aeabi_dsub+0x6bc>)
10009a04:	4284      	cmp	r4, r0
10009a06:	d000      	beq.n	10009a0a <__aeabi_dsub+0x472>
10009a08:	e6ad      	b.n	10009766 <__aeabi_dsub+0x1ce>
10009a0a:	e5f7      	b.n	100095fc <__aeabi_dsub+0x64>
10009a0c:	2200      	movs	r2, #0
10009a0e:	e771      	b.n	100098f4 <__aeabi_dsub+0x35c>
10009a10:	2300      	movs	r3, #0
10009a12:	e787      	b.n	10009924 <__aeabi_dsub+0x38c>
10009a14:	1c3b      	adds	r3, r7, #0
10009a16:	432b      	orrs	r3, r5
10009a18:	2c00      	cmp	r4, #0
10009a1a:	d000      	beq.n	10009a1e <__aeabi_dsub+0x486>
10009a1c:	e0da      	b.n	10009bd4 <__aeabi_dsub+0x63c>
10009a1e:	2b00      	cmp	r3, #0
10009a20:	d100      	bne.n	10009a24 <__aeabi_dsub+0x48c>
10009a22:	e113      	b.n	10009c4c <__aeabi_dsub+0x6b4>
10009a24:	1c13      	adds	r3, r2, #0
10009a26:	9901      	ldr	r1, [sp, #4]
10009a28:	430b      	orrs	r3, r1
10009a2a:	d100      	bne.n	10009a2e <__aeabi_dsub+0x496>
10009a2c:	e5e6      	b.n	100095fc <__aeabi_dsub+0x64>
10009a2e:	1949      	adds	r1, r1, r5
10009a30:	42a9      	cmp	r1, r5
10009a32:	419b      	sbcs	r3, r3
10009a34:	19d2      	adds	r2, r2, r7
10009a36:	425b      	negs	r3, r3
10009a38:	18d7      	adds	r7, r2, r3
10009a3a:	023b      	lsls	r3, r7, #8
10009a3c:	d400      	bmi.n	10009a40 <__aeabi_dsub+0x4a8>
10009a3e:	e121      	b.n	10009c84 <__aeabi_dsub+0x6ec>
10009a40:	4b85      	ldr	r3, [pc, #532]	; (10009c58 <__aeabi_dsub+0x6c0>)
10009a42:	1c0d      	adds	r5, r1, #0
10009a44:	401f      	ands	r7, r3
10009a46:	1c04      	adds	r4, r0, #0
10009a48:	e5d8      	b.n	100095fc <__aeabi_dsub+0x64>
10009a4a:	1c38      	adds	r0, r7, #0
10009a4c:	4328      	orrs	r0, r5
10009a4e:	2c00      	cmp	r4, #0
10009a50:	d140      	bne.n	10009ad4 <__aeabi_dsub+0x53c>
10009a52:	2800      	cmp	r0, #0
10009a54:	d000      	beq.n	10009a58 <__aeabi_dsub+0x4c0>
10009a56:	e083      	b.n	10009b60 <__aeabi_dsub+0x5c8>
10009a58:	1c10      	adds	r0, r2, #0
10009a5a:	9901      	ldr	r1, [sp, #4]
10009a5c:	4308      	orrs	r0, r1
10009a5e:	d003      	beq.n	10009a68 <__aeabi_dsub+0x4d0>
10009a60:	1c17      	adds	r7, r2, #0
10009a62:	1c0d      	adds	r5, r1, #0
10009a64:	4698      	mov	r8, r3
10009a66:	e5c9      	b.n	100095fc <__aeabi_dsub+0x64>
10009a68:	2600      	movs	r6, #0
10009a6a:	2700      	movs	r7, #0
10009a6c:	2500      	movs	r5, #0
10009a6e:	e660      	b.n	10009732 <__aeabi_dsub+0x19a>
10009a70:	4650      	mov	r0, sl
10009a72:	1c13      	adds	r3, r2, #0
10009a74:	3820      	subs	r0, #32
10009a76:	40c3      	lsrs	r3, r0
10009a78:	1c18      	adds	r0, r3, #0
10009a7a:	4653      	mov	r3, sl
10009a7c:	2b20      	cmp	r3, #32
10009a7e:	d100      	bne.n	10009a82 <__aeabi_dsub+0x4ea>
10009a80:	e0c1      	b.n	10009c06 <__aeabi_dsub+0x66e>
10009a82:	2340      	movs	r3, #64	; 0x40
10009a84:	4651      	mov	r1, sl
10009a86:	1a5b      	subs	r3, r3, r1
10009a88:	409a      	lsls	r2, r3
10009a8a:	9901      	ldr	r1, [sp, #4]
10009a8c:	4311      	orrs	r1, r2
10009a8e:	1e4a      	subs	r2, r1, #1
10009a90:	4191      	sbcs	r1, r2
10009a92:	2200      	movs	r2, #0
10009a94:	4301      	orrs	r1, r0
10009a96:	e670      	b.n	1000977a <__aeabi_dsub+0x1e2>
10009a98:	4c6e      	ldr	r4, [pc, #440]	; (10009c54 <__aeabi_dsub+0x6bc>)
10009a9a:	42a0      	cmp	r0, r4
10009a9c:	d000      	beq.n	10009aa0 <__aeabi_dsub+0x508>
10009a9e:	e753      	b.n	10009948 <__aeabi_dsub+0x3b0>
10009aa0:	1c17      	adds	r7, r2, #0
10009aa2:	9d01      	ldr	r5, [sp, #4]
10009aa4:	1c04      	adds	r4, r0, #0
10009aa6:	4698      	mov	r8, r3
10009aa8:	e5a8      	b.n	100095fc <__aeabi_dsub+0x64>
10009aaa:	2c00      	cmp	r4, #0
10009aac:	d128      	bne.n	10009b00 <__aeabi_dsub+0x568>
10009aae:	1c3c      	adds	r4, r7, #0
10009ab0:	432c      	orrs	r4, r5
10009ab2:	d100      	bne.n	10009ab6 <__aeabi_dsub+0x51e>
10009ab4:	e08a      	b.n	10009bcc <__aeabi_dsub+0x634>
10009ab6:	43db      	mvns	r3, r3
10009ab8:	469a      	mov	sl, r3
10009aba:	2b00      	cmp	r3, #0
10009abc:	d000      	beq.n	10009ac0 <__aeabi_dsub+0x528>
10009abe:	e082      	b.n	10009bc6 <__aeabi_dsub+0x62e>
10009ac0:	9b01      	ldr	r3, [sp, #4]
10009ac2:	19d2      	adds	r2, r2, r7
10009ac4:	469c      	mov	ip, r3
10009ac6:	4465      	add	r5, ip
10009ac8:	429d      	cmp	r5, r3
10009aca:	4189      	sbcs	r1, r1
10009acc:	4249      	negs	r1, r1
10009ace:	1857      	adds	r7, r2, r1
10009ad0:	1c04      	adds	r4, r0, #0
10009ad2:	e659      	b.n	10009788 <__aeabi_dsub+0x1f0>
10009ad4:	2800      	cmp	r0, #0
10009ad6:	d15b      	bne.n	10009b90 <__aeabi_dsub+0x5f8>
10009ad8:	1c10      	adds	r0, r2, #0
10009ada:	9901      	ldr	r1, [sp, #4]
10009adc:	4308      	orrs	r0, r1
10009ade:	d100      	bne.n	10009ae2 <__aeabi_dsub+0x54a>
10009ae0:	e0a4      	b.n	10009c2c <__aeabi_dsub+0x694>
10009ae2:	1c17      	adds	r7, r2, #0
10009ae4:	1c0d      	adds	r5, r1, #0
10009ae6:	4698      	mov	r8, r3
10009ae8:	4c5a      	ldr	r4, [pc, #360]	; (10009c54 <__aeabi_dsub+0x6bc>)
10009aea:	e587      	b.n	100095fc <__aeabi_dsub+0x64>
10009aec:	433d      	orrs	r5, r7
10009aee:	1e6f      	subs	r7, r5, #1
10009af0:	41bd      	sbcs	r5, r7
10009af2:	2700      	movs	r7, #0
10009af4:	b2ed      	uxtb	r5, r5
10009af6:	e742      	b.n	1000997e <__aeabi_dsub+0x3e6>
10009af8:	1c04      	adds	r4, r0, #0
10009afa:	2700      	movs	r7, #0
10009afc:	2500      	movs	r5, #0
10009afe:	e618      	b.n	10009732 <__aeabi_dsub+0x19a>
10009b00:	4c54      	ldr	r4, [pc, #336]	; (10009c54 <__aeabi_dsub+0x6bc>)
10009b02:	42a0      	cmp	r0, r4
10009b04:	d062      	beq.n	10009bcc <__aeabi_dsub+0x634>
10009b06:	4653      	mov	r3, sl
10009b08:	2480      	movs	r4, #128	; 0x80
10009b0a:	425b      	negs	r3, r3
10009b0c:	469a      	mov	sl, r3
10009b0e:	0424      	lsls	r4, r4, #16
10009b10:	4327      	orrs	r7, r4
10009b12:	4653      	mov	r3, sl
10009b14:	2b38      	cmp	r3, #56	; 0x38
10009b16:	dd00      	ble.n	10009b1a <__aeabi_dsub+0x582>
10009b18:	e08e      	b.n	10009c38 <__aeabi_dsub+0x6a0>
10009b1a:	2b1f      	cmp	r3, #31
10009b1c:	dd00      	ble.n	10009b20 <__aeabi_dsub+0x588>
10009b1e:	e09d      	b.n	10009c5c <__aeabi_dsub+0x6c4>
10009b20:	2420      	movs	r4, #32
10009b22:	1ae3      	subs	r3, r4, r3
10009b24:	469b      	mov	fp, r3
10009b26:	1c3b      	adds	r3, r7, #0
10009b28:	4659      	mov	r1, fp
10009b2a:	408b      	lsls	r3, r1
10009b2c:	4651      	mov	r1, sl
10009b2e:	4699      	mov	r9, r3
10009b30:	1c2b      	adds	r3, r5, #0
10009b32:	40cb      	lsrs	r3, r1
10009b34:	469c      	mov	ip, r3
10009b36:	464b      	mov	r3, r9
10009b38:	4664      	mov	r4, ip
10009b3a:	4323      	orrs	r3, r4
10009b3c:	469c      	mov	ip, r3
10009b3e:	465b      	mov	r3, fp
10009b40:	409d      	lsls	r5, r3
10009b42:	4663      	mov	r3, ip
10009b44:	1e6c      	subs	r4, r5, #1
10009b46:	41a5      	sbcs	r5, r4
10009b48:	40cf      	lsrs	r7, r1
10009b4a:	431d      	orrs	r5, r3
10009b4c:	9b01      	ldr	r3, [sp, #4]
10009b4e:	18bf      	adds	r7, r7, r2
10009b50:	469c      	mov	ip, r3
10009b52:	4465      	add	r5, ip
10009b54:	429d      	cmp	r5, r3
10009b56:	4192      	sbcs	r2, r2
10009b58:	4252      	negs	r2, r2
10009b5a:	18bf      	adds	r7, r7, r2
10009b5c:	1c04      	adds	r4, r0, #0
10009b5e:	e613      	b.n	10009788 <__aeabi_dsub+0x1f0>
10009b60:	1c10      	adds	r0, r2, #0
10009b62:	9901      	ldr	r1, [sp, #4]
10009b64:	4308      	orrs	r0, r1
10009b66:	d100      	bne.n	10009b6a <__aeabi_dsub+0x5d2>
10009b68:	e548      	b.n	100095fc <__aeabi_dsub+0x64>
10009b6a:	1a68      	subs	r0, r5, r1
10009b6c:	4684      	mov	ip, r0
10009b6e:	4285      	cmp	r5, r0
10009b70:	4180      	sbcs	r0, r0
10009b72:	1abe      	subs	r6, r7, r2
10009b74:	4240      	negs	r0, r0
10009b76:	1a30      	subs	r0, r6, r0
10009b78:	0206      	lsls	r6, r0, #8
10009b7a:	d400      	bmi.n	10009b7e <__aeabi_dsub+0x5e6>
10009b7c:	e647      	b.n	1000980e <__aeabi_dsub+0x276>
10009b7e:	468c      	mov	ip, r1
10009b80:	1b4d      	subs	r5, r1, r5
10009b82:	45ac      	cmp	ip, r5
10009b84:	4189      	sbcs	r1, r1
10009b86:	1bd2      	subs	r2, r2, r7
10009b88:	4249      	negs	r1, r1
10009b8a:	1a57      	subs	r7, r2, r1
10009b8c:	4698      	mov	r8, r3
10009b8e:	e535      	b.n	100095fc <__aeabi_dsub+0x64>
10009b90:	1c10      	adds	r0, r2, #0
10009b92:	9901      	ldr	r1, [sp, #4]
10009b94:	4308      	orrs	r0, r1
10009b96:	d034      	beq.n	10009c02 <__aeabi_dsub+0x66a>
10009b98:	2480      	movs	r4, #128	; 0x80
10009b9a:	0778      	lsls	r0, r7, #29
10009b9c:	08ed      	lsrs	r5, r5, #3
10009b9e:	08ff      	lsrs	r7, r7, #3
10009ba0:	0324      	lsls	r4, r4, #12
10009ba2:	4328      	orrs	r0, r5
10009ba4:	4227      	tst	r7, r4
10009ba6:	d008      	beq.n	10009bba <__aeabi_dsub+0x622>
10009ba8:	08d6      	lsrs	r6, r2, #3
10009baa:	4226      	tst	r6, r4
10009bac:	d105      	bne.n	10009bba <__aeabi_dsub+0x622>
10009bae:	08c9      	lsrs	r1, r1, #3
10009bb0:	0752      	lsls	r2, r2, #29
10009bb2:	430a      	orrs	r2, r1
10009bb4:	1c10      	adds	r0, r2, #0
10009bb6:	1c37      	adds	r7, r6, #0
10009bb8:	4698      	mov	r8, r3
10009bba:	00ff      	lsls	r7, r7, #3
10009bbc:	0f42      	lsrs	r2, r0, #29
10009bbe:	4317      	orrs	r7, r2
10009bc0:	00c5      	lsls	r5, r0, #3
10009bc2:	4c24      	ldr	r4, [pc, #144]	; (10009c54 <__aeabi_dsub+0x6bc>)
10009bc4:	e51a      	b.n	100095fc <__aeabi_dsub+0x64>
10009bc6:	4c23      	ldr	r4, [pc, #140]	; (10009c54 <__aeabi_dsub+0x6bc>)
10009bc8:	42a0      	cmp	r0, r4
10009bca:	d1a2      	bne.n	10009b12 <__aeabi_dsub+0x57a>
10009bcc:	1c17      	adds	r7, r2, #0
10009bce:	9d01      	ldr	r5, [sp, #4]
10009bd0:	1c04      	adds	r4, r0, #0
10009bd2:	e513      	b.n	100095fc <__aeabi_dsub+0x64>
10009bd4:	2b00      	cmp	r3, #0
10009bd6:	d035      	beq.n	10009c44 <__aeabi_dsub+0x6ac>
10009bd8:	1c13      	adds	r3, r2, #0
10009bda:	9901      	ldr	r1, [sp, #4]
10009bdc:	430b      	orrs	r3, r1
10009bde:	d010      	beq.n	10009c02 <__aeabi_dsub+0x66a>
10009be0:	2480      	movs	r4, #128	; 0x80
10009be2:	0778      	lsls	r0, r7, #29
10009be4:	08ed      	lsrs	r5, r5, #3
10009be6:	08ff      	lsrs	r7, r7, #3
10009be8:	0324      	lsls	r4, r4, #12
10009bea:	4328      	orrs	r0, r5
10009bec:	4227      	tst	r7, r4
10009bee:	d0e4      	beq.n	10009bba <__aeabi_dsub+0x622>
10009bf0:	08d3      	lsrs	r3, r2, #3
10009bf2:	4223      	tst	r3, r4
10009bf4:	d1e1      	bne.n	10009bba <__aeabi_dsub+0x622>
10009bf6:	08c9      	lsrs	r1, r1, #3
10009bf8:	0752      	lsls	r2, r2, #29
10009bfa:	430a      	orrs	r2, r1
10009bfc:	1c10      	adds	r0, r2, #0
10009bfe:	1c1f      	adds	r7, r3, #0
10009c00:	e7db      	b.n	10009bba <__aeabi_dsub+0x622>
10009c02:	4c14      	ldr	r4, [pc, #80]	; (10009c54 <__aeabi_dsub+0x6bc>)
10009c04:	e4fa      	b.n	100095fc <__aeabi_dsub+0x64>
10009c06:	2200      	movs	r2, #0
10009c08:	e73f      	b.n	10009a8a <__aeabi_dsub+0x4f2>
10009c0a:	464c      	mov	r4, r9
10009c0c:	1c3e      	adds	r6, r7, #0
10009c0e:	3c20      	subs	r4, #32
10009c10:	40e6      	lsrs	r6, r4
10009c12:	4649      	mov	r1, r9
10009c14:	1c34      	adds	r4, r6, #0
10009c16:	2920      	cmp	r1, #32
10009c18:	d032      	beq.n	10009c80 <__aeabi_dsub+0x6e8>
10009c1a:	2640      	movs	r6, #64	; 0x40
10009c1c:	1a76      	subs	r6, r6, r1
10009c1e:	40b7      	lsls	r7, r6
10009c20:	433d      	orrs	r5, r7
10009c22:	1e6f      	subs	r7, r5, #1
10009c24:	41bd      	sbcs	r5, r7
10009c26:	2700      	movs	r7, #0
10009c28:	4325      	orrs	r5, r4
10009c2a:	e6a8      	b.n	1000997e <__aeabi_dsub+0x3e6>
10009c2c:	2780      	movs	r7, #128	; 0x80
10009c2e:	2600      	movs	r6, #0
10009c30:	03ff      	lsls	r7, r7, #15
10009c32:	4c08      	ldr	r4, [pc, #32]	; (10009c54 <__aeabi_dsub+0x6bc>)
10009c34:	2500      	movs	r5, #0
10009c36:	e57c      	b.n	10009732 <__aeabi_dsub+0x19a>
10009c38:	433d      	orrs	r5, r7
10009c3a:	1e6f      	subs	r7, r5, #1
10009c3c:	41bd      	sbcs	r5, r7
10009c3e:	2700      	movs	r7, #0
10009c40:	b2ed      	uxtb	r5, r5
10009c42:	e783      	b.n	10009b4c <__aeabi_dsub+0x5b4>
10009c44:	1c17      	adds	r7, r2, #0
10009c46:	9d01      	ldr	r5, [sp, #4]
10009c48:	4c02      	ldr	r4, [pc, #8]	; (10009c54 <__aeabi_dsub+0x6bc>)
10009c4a:	e4d7      	b.n	100095fc <__aeabi_dsub+0x64>
10009c4c:	1c17      	adds	r7, r2, #0
10009c4e:	9d01      	ldr	r5, [sp, #4]
10009c50:	e4d4      	b.n	100095fc <__aeabi_dsub+0x64>
10009c52:	46c0      	nop			; (mov r8, r8)
10009c54:	000007ff 	.word	0x000007ff
10009c58:	ff7fffff 	.word	0xff7fffff
10009c5c:	4654      	mov	r4, sl
10009c5e:	1c3b      	adds	r3, r7, #0
10009c60:	3c20      	subs	r4, #32
10009c62:	40e3      	lsrs	r3, r4
10009c64:	1c1c      	adds	r4, r3, #0
10009c66:	4653      	mov	r3, sl
10009c68:	2b20      	cmp	r3, #32
10009c6a:	d00d      	beq.n	10009c88 <__aeabi_dsub+0x6f0>
10009c6c:	2340      	movs	r3, #64	; 0x40
10009c6e:	4651      	mov	r1, sl
10009c70:	1a5b      	subs	r3, r3, r1
10009c72:	409f      	lsls	r7, r3
10009c74:	433d      	orrs	r5, r7
10009c76:	1e6f      	subs	r7, r5, #1
10009c78:	41bd      	sbcs	r5, r7
10009c7a:	2700      	movs	r7, #0
10009c7c:	4325      	orrs	r5, r4
10009c7e:	e765      	b.n	10009b4c <__aeabi_dsub+0x5b4>
10009c80:	2700      	movs	r7, #0
10009c82:	e7cd      	b.n	10009c20 <__aeabi_dsub+0x688>
10009c84:	1c0d      	adds	r5, r1, #0
10009c86:	e5c8      	b.n	1000981a <__aeabi_dsub+0x282>
10009c88:	2700      	movs	r7, #0
10009c8a:	e7f3      	b.n	10009c74 <__aeabi_dsub+0x6dc>

10009c8c <__aeabi_d2iz>:
10009c8c:	030b      	lsls	r3, r1, #12
10009c8e:	b530      	push	{r4, r5, lr}
10009c90:	4c13      	ldr	r4, [pc, #76]	; (10009ce0 <__aeabi_d2iz+0x54>)
10009c92:	0b1a      	lsrs	r2, r3, #12
10009c94:	004b      	lsls	r3, r1, #1
10009c96:	1c05      	adds	r5, r0, #0
10009c98:	0d5b      	lsrs	r3, r3, #21
10009c9a:	0fc9      	lsrs	r1, r1, #31
10009c9c:	2000      	movs	r0, #0
10009c9e:	42a3      	cmp	r3, r4
10009ca0:	dd10      	ble.n	10009cc4 <__aeabi_d2iz+0x38>
10009ca2:	4810      	ldr	r0, [pc, #64]	; (10009ce4 <__aeabi_d2iz+0x58>)
10009ca4:	4283      	cmp	r3, r0
10009ca6:	dc0e      	bgt.n	10009cc6 <__aeabi_d2iz+0x3a>
10009ca8:	2080      	movs	r0, #128	; 0x80
10009caa:	4c0f      	ldr	r4, [pc, #60]	; (10009ce8 <__aeabi_d2iz+0x5c>)
10009cac:	0340      	lsls	r0, r0, #13
10009cae:	4302      	orrs	r2, r0
10009cb0:	1ae4      	subs	r4, r4, r3
10009cb2:	2c1f      	cmp	r4, #31
10009cb4:	dd0a      	ble.n	10009ccc <__aeabi_d2iz+0x40>
10009cb6:	480d      	ldr	r0, [pc, #52]	; (10009cec <__aeabi_d2iz+0x60>)
10009cb8:	1ac3      	subs	r3, r0, r3
10009cba:	40da      	lsrs	r2, r3
10009cbc:	1c13      	adds	r3, r2, #0
10009cbe:	4248      	negs	r0, r1
10009cc0:	4043      	eors	r3, r0
10009cc2:	1858      	adds	r0, r3, r1
10009cc4:	bd30      	pop	{r4, r5, pc}
10009cc6:	4b0a      	ldr	r3, [pc, #40]	; (10009cf0 <__aeabi_d2iz+0x64>)
10009cc8:	18c8      	adds	r0, r1, r3
10009cca:	e7fb      	b.n	10009cc4 <__aeabi_d2iz+0x38>
10009ccc:	1c28      	adds	r0, r5, #0
10009cce:	40e0      	lsrs	r0, r4
10009cd0:	4c08      	ldr	r4, [pc, #32]	; (10009cf4 <__aeabi_d2iz+0x68>)
10009cd2:	46a4      	mov	ip, r4
10009cd4:	4463      	add	r3, ip
10009cd6:	409a      	lsls	r2, r3
10009cd8:	1c13      	adds	r3, r2, #0
10009cda:	4303      	orrs	r3, r0
10009cdc:	e7ef      	b.n	10009cbe <__aeabi_d2iz+0x32>
10009cde:	46c0      	nop			; (mov r8, r8)
10009ce0:	000003fe 	.word	0x000003fe
10009ce4:	0000041d 	.word	0x0000041d
10009ce8:	00000433 	.word	0x00000433
10009cec:	00000413 	.word	0x00000413
10009cf0:	7fffffff 	.word	0x7fffffff
10009cf4:	fffffbed 	.word	0xfffffbed

10009cf8 <__aeabi_i2d>:
10009cf8:	b538      	push	{r3, r4, r5, lr}
10009cfa:	1e04      	subs	r4, r0, #0
10009cfc:	d016      	beq.n	10009d2c <__aeabi_i2d+0x34>
10009cfe:	0fc5      	lsrs	r5, r0, #31
10009d00:	d000      	beq.n	10009d04 <__aeabi_i2d+0xc>
10009d02:	4244      	negs	r4, r0
10009d04:	1c20      	adds	r0, r4, #0
10009d06:	f7fb fc09 	bl	1000551c <__clzsi2>
10009d0a:	4b17      	ldr	r3, [pc, #92]	; (10009d68 <__aeabi_i2d+0x70>)
10009d0c:	1a1b      	subs	r3, r3, r0
10009d0e:	280a      	cmp	r0, #10
10009d10:	dc21      	bgt.n	10009d56 <__aeabi_i2d+0x5e>
10009d12:	1c02      	adds	r2, r0, #0
10009d14:	1c21      	adds	r1, r4, #0
10009d16:	3215      	adds	r2, #21
10009d18:	4091      	lsls	r1, r2
10009d1a:	1c0a      	adds	r2, r1, #0
10009d1c:	210b      	movs	r1, #11
10009d1e:	1a08      	subs	r0, r1, r0
10009d20:	40c4      	lsrs	r4, r0
10009d22:	055b      	lsls	r3, r3, #21
10009d24:	0324      	lsls	r4, r4, #12
10009d26:	0b24      	lsrs	r4, r4, #12
10009d28:	0d5b      	lsrs	r3, r3, #21
10009d2a:	e003      	b.n	10009d34 <__aeabi_i2d+0x3c>
10009d2c:	2500      	movs	r5, #0
10009d2e:	2300      	movs	r3, #0
10009d30:	2400      	movs	r4, #0
10009d32:	2200      	movs	r2, #0
10009d34:	2100      	movs	r1, #0
10009d36:	1c10      	adds	r0, r2, #0
10009d38:	0324      	lsls	r4, r4, #12
10009d3a:	0d0a      	lsrs	r2, r1, #20
10009d3c:	0512      	lsls	r2, r2, #20
10009d3e:	0b24      	lsrs	r4, r4, #12
10009d40:	4314      	orrs	r4, r2
10009d42:	4a0a      	ldr	r2, [pc, #40]	; (10009d6c <__aeabi_i2d+0x74>)
10009d44:	051b      	lsls	r3, r3, #20
10009d46:	4014      	ands	r4, r2
10009d48:	431c      	orrs	r4, r3
10009d4a:	0064      	lsls	r4, r4, #1
10009d4c:	07ed      	lsls	r5, r5, #31
10009d4e:	0864      	lsrs	r4, r4, #1
10009d50:	432c      	orrs	r4, r5
10009d52:	1c21      	adds	r1, r4, #0
10009d54:	bd38      	pop	{r3, r4, r5, pc}
10009d56:	380b      	subs	r0, #11
10009d58:	4084      	lsls	r4, r0
10009d5a:	055b      	lsls	r3, r3, #21
10009d5c:	0324      	lsls	r4, r4, #12
10009d5e:	0b24      	lsrs	r4, r4, #12
10009d60:	0d5b      	lsrs	r3, r3, #21
10009d62:	2200      	movs	r2, #0
10009d64:	e7e6      	b.n	10009d34 <__aeabi_i2d+0x3c>
10009d66:	46c0      	nop			; (mov r8, r8)
10009d68:	0000041e 	.word	0x0000041e
10009d6c:	800fffff 	.word	0x800fffff

10009d70 <__aeabi_ui2d>:
10009d70:	b510      	push	{r4, lr}
10009d72:	1e04      	subs	r4, r0, #0
10009d74:	d010      	beq.n	10009d98 <__aeabi_ui2d+0x28>
10009d76:	f7fb fbd1 	bl	1000551c <__clzsi2>
10009d7a:	4a14      	ldr	r2, [pc, #80]	; (10009dcc <__aeabi_ui2d+0x5c>)
10009d7c:	1a12      	subs	r2, r2, r0
10009d7e:	280a      	cmp	r0, #10
10009d80:	dc1a      	bgt.n	10009db8 <__aeabi_ui2d+0x48>
10009d82:	230b      	movs	r3, #11
10009d84:	1c21      	adds	r1, r4, #0
10009d86:	1a1b      	subs	r3, r3, r0
10009d88:	40d9      	lsrs	r1, r3
10009d8a:	3015      	adds	r0, #21
10009d8c:	030b      	lsls	r3, r1, #12
10009d8e:	0552      	lsls	r2, r2, #21
10009d90:	4084      	lsls	r4, r0
10009d92:	0b1b      	lsrs	r3, r3, #12
10009d94:	0d52      	lsrs	r2, r2, #21
10009d96:	e001      	b.n	10009d9c <__aeabi_ui2d+0x2c>
10009d98:	2200      	movs	r2, #0
10009d9a:	2300      	movs	r3, #0
10009d9c:	2100      	movs	r1, #0
10009d9e:	031b      	lsls	r3, r3, #12
10009da0:	1c20      	adds	r0, r4, #0
10009da2:	0b1c      	lsrs	r4, r3, #12
10009da4:	0d0b      	lsrs	r3, r1, #20
10009da6:	051b      	lsls	r3, r3, #20
10009da8:	4323      	orrs	r3, r4
10009daa:	4c09      	ldr	r4, [pc, #36]	; (10009dd0 <__aeabi_ui2d+0x60>)
10009dac:	0512      	lsls	r2, r2, #20
10009dae:	4023      	ands	r3, r4
10009db0:	4313      	orrs	r3, r2
10009db2:	005b      	lsls	r3, r3, #1
10009db4:	0859      	lsrs	r1, r3, #1
10009db6:	bd10      	pop	{r4, pc}
10009db8:	1c03      	adds	r3, r0, #0
10009dba:	3b0b      	subs	r3, #11
10009dbc:	409c      	lsls	r4, r3
10009dbe:	0552      	lsls	r2, r2, #21
10009dc0:	0323      	lsls	r3, r4, #12
10009dc2:	0b1b      	lsrs	r3, r3, #12
10009dc4:	0d52      	lsrs	r2, r2, #21
10009dc6:	2400      	movs	r4, #0
10009dc8:	e7e8      	b.n	10009d9c <__aeabi_ui2d+0x2c>
10009dca:	46c0      	nop			; (mov r8, r8)
10009dcc:	0000041e 	.word	0x0000041e
10009dd0:	800fffff 	.word	0x800fffff

10009dd4 <findslot>:
10009dd4:	4b0a      	ldr	r3, [pc, #40]	; (10009e00 <findslot+0x2c>)
10009dd6:	b510      	push	{r4, lr}
10009dd8:	1c04      	adds	r4, r0, #0
10009dda:	6818      	ldr	r0, [r3, #0]
10009ddc:	2800      	cmp	r0, #0
10009dde:	d004      	beq.n	10009dea <findslot+0x16>
10009de0:	6983      	ldr	r3, [r0, #24]
10009de2:	2b00      	cmp	r3, #0
10009de4:	d101      	bne.n	10009dea <findslot+0x16>
10009de6:	f7fd fa0b 	bl	10007200 <__sinit>
10009dea:	2000      	movs	r0, #0
10009dec:	2c13      	cmp	r4, #19
10009dee:	d805      	bhi.n	10009dfc <findslot+0x28>
10009df0:	4b04      	ldr	r3, [pc, #16]	; (10009e04 <findslot+0x30>)
10009df2:	00e4      	lsls	r4, r4, #3
10009df4:	58e2      	ldr	r2, [r4, r3]
10009df6:	3201      	adds	r2, #1
10009df8:	d000      	beq.n	10009dfc <findslot+0x28>
10009dfa:	1918      	adds	r0, r3, r4
10009dfc:	bd10      	pop	{r4, pc}
10009dfe:	46c0      	nop			; (mov r8, r8)
10009e00:	20000664 	.word	0x20000664
10009e04:	20000834 	.word	0x20000834

10009e08 <error>:
10009e08:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
10009e0a:	1c05      	adds	r5, r0, #0
10009e0c:	f7fb fba4 	bl	10005558 <__errno>
10009e10:	2700      	movs	r7, #0
10009e12:	1c06      	adds	r6, r0, #0
10009e14:	2413      	movs	r4, #19
10009e16:	1c20      	adds	r0, r4, #0
10009e18:	1c39      	adds	r1, r7, #0
10009e1a:	beab      	bkpt	0x00ab
10009e1c:	1c04      	adds	r4, r0, #0
10009e1e:	1c28      	adds	r0, r5, #0
10009e20:	6034      	str	r4, [r6, #0]
10009e22:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

10009e24 <checkerror>:
10009e24:	b508      	push	{r3, lr}
10009e26:	1c43      	adds	r3, r0, #1
10009e28:	d101      	bne.n	10009e2e <checkerror+0xa>
10009e2a:	f7ff ffed 	bl	10009e08 <error>
10009e2e:	bd08      	pop	{r3, pc}

10009e30 <initialise_monitor_handles>:
10009e30:	b5f0      	push	{r4, r5, r6, r7, lr}
10009e32:	4b20      	ldr	r3, [pc, #128]	; (10009eb4 <initialise_monitor_handles+0x84>)
10009e34:	b085      	sub	sp, #20
10009e36:	9301      	str	r3, [sp, #4]
10009e38:	2303      	movs	r3, #3
10009e3a:	ac01      	add	r4, sp, #4
10009e3c:	60a3      	str	r3, [r4, #8]
10009e3e:	2300      	movs	r3, #0
10009e40:	2501      	movs	r5, #1
10009e42:	6063      	str	r3, [r4, #4]
10009e44:	1c28      	adds	r0, r5, #0
10009e46:	1c21      	adds	r1, r4, #0
10009e48:	beab      	bkpt	0x00ab
10009e4a:	1c06      	adds	r6, r0, #0
10009e4c:	4b19      	ldr	r3, [pc, #100]	; (10009eb4 <initialise_monitor_handles+0x84>)
10009e4e:	4f1a      	ldr	r7, [pc, #104]	; (10009eb8 <initialise_monitor_handles+0x88>)
10009e50:	9301      	str	r3, [sp, #4]
10009e52:	2303      	movs	r3, #3
10009e54:	60a3      	str	r3, [r4, #8]
10009e56:	195b      	adds	r3, r3, r5
10009e58:	603e      	str	r6, [r7, #0]
10009e5a:	6063      	str	r3, [r4, #4]
10009e5c:	1c28      	adds	r0, r5, #0
10009e5e:	1c21      	adds	r1, r4, #0
10009e60:	beab      	bkpt	0x00ab
10009e62:	1c06      	adds	r6, r0, #0
10009e64:	1c33      	adds	r3, r6, #0
10009e66:	4e15      	ldr	r6, [pc, #84]	; (10009ebc <initialise_monitor_handles+0x8c>)
10009e68:	6033      	str	r3, [r6, #0]
10009e6a:	4b12      	ldr	r3, [pc, #72]	; (10009eb4 <initialise_monitor_handles+0x84>)
10009e6c:	9301      	str	r3, [sp, #4]
10009e6e:	2303      	movs	r3, #3
10009e70:	60a3      	str	r3, [r4, #8]
10009e72:	3305      	adds	r3, #5
10009e74:	6063      	str	r3, [r4, #4]
10009e76:	1c28      	adds	r0, r5, #0
10009e78:	1c21      	adds	r1, r4, #0
10009e7a:	beab      	bkpt	0x00ab
10009e7c:	1c04      	adds	r4, r0, #0
10009e7e:	4a10      	ldr	r2, [pc, #64]	; (10009ec0 <initialise_monitor_handles+0x90>)
10009e80:	1c39      	adds	r1, r7, #0
10009e82:	6014      	str	r4, [r2, #0]
10009e84:	1c63      	adds	r3, r4, #1
10009e86:	d101      	bne.n	10009e8c <initialise_monitor_handles+0x5c>
10009e88:	6833      	ldr	r3, [r6, #0]
10009e8a:	6013      	str	r3, [r2, #0]
10009e8c:	2000      	movs	r0, #0
10009e8e:	2401      	movs	r4, #1
10009e90:	4b0c      	ldr	r3, [pc, #48]	; (10009ec4 <initialise_monitor_handles+0x94>)
10009e92:	4264      	negs	r4, r4
10009e94:	50c4      	str	r4, [r0, r3]
10009e96:	3008      	adds	r0, #8
10009e98:	28a0      	cmp	r0, #160	; 0xa0
10009e9a:	d1f8      	bne.n	10009e8e <initialise_monitor_handles+0x5e>
10009e9c:	6809      	ldr	r1, [r1, #0]
10009e9e:	6830      	ldr	r0, [r6, #0]
10009ea0:	6019      	str	r1, [r3, #0]
10009ea2:	2100      	movs	r1, #0
10009ea4:	6812      	ldr	r2, [r2, #0]
10009ea6:	6059      	str	r1, [r3, #4]
10009ea8:	6098      	str	r0, [r3, #8]
10009eaa:	60d9      	str	r1, [r3, #12]
10009eac:	611a      	str	r2, [r3, #16]
10009eae:	6159      	str	r1, [r3, #20]
10009eb0:	b005      	add	sp, #20
10009eb2:	bdf0      	pop	{r4, r5, r6, r7, pc}
10009eb4:	1000a5a8 	.word	0x1000a5a8
10009eb8:	2000082c 	.word	0x2000082c
10009ebc:	20000828 	.word	0x20000828
10009ec0:	20000830 	.word	0x20000830
10009ec4:	20000834 	.word	0x20000834

10009ec8 <_swiread>:
10009ec8:	b530      	push	{r4, r5, lr}
10009eca:	b085      	sub	sp, #20
10009ecc:	ad01      	add	r5, sp, #4
10009ece:	9001      	str	r0, [sp, #4]
10009ed0:	9102      	str	r1, [sp, #8]
10009ed2:	9203      	str	r2, [sp, #12]
10009ed4:	2406      	movs	r4, #6
10009ed6:	1c20      	adds	r0, r4, #0
10009ed8:	1c29      	adds	r1, r5, #0
10009eda:	beab      	bkpt	0x00ab
10009edc:	1c04      	adds	r4, r0, #0
10009ede:	1c20      	adds	r0, r4, #0
10009ee0:	f7ff ffa0 	bl	10009e24 <checkerror>
10009ee4:	b005      	add	sp, #20
10009ee6:	bd30      	pop	{r4, r5, pc}

10009ee8 <_read>:
10009ee8:	b570      	push	{r4, r5, r6, lr}
10009eea:	1c0e      	adds	r6, r1, #0
10009eec:	1c15      	adds	r5, r2, #0
10009eee:	f7ff ff71 	bl	10009dd4 <findslot>
10009ef2:	1e04      	subs	r4, r0, #0
10009ef4:	d105      	bne.n	10009f02 <_read+0x1a>
10009ef6:	f7fb fb2f 	bl	10005558 <__errno>
10009efa:	2309      	movs	r3, #9
10009efc:	6003      	str	r3, [r0, #0]
10009efe:	3b0a      	subs	r3, #10
10009f00:	e00b      	b.n	10009f1a <_read+0x32>
10009f02:	6800      	ldr	r0, [r0, #0]
10009f04:	1c31      	adds	r1, r6, #0
10009f06:	1c2a      	adds	r2, r5, #0
10009f08:	f7ff ffde 	bl	10009ec8 <_swiread>
10009f0c:	1c03      	adds	r3, r0, #0
10009f0e:	1c42      	adds	r2, r0, #1
10009f10:	d003      	beq.n	10009f1a <_read+0x32>
10009f12:	6862      	ldr	r2, [r4, #4]
10009f14:	1a2b      	subs	r3, r5, r0
10009f16:	18d2      	adds	r2, r2, r3
10009f18:	6062      	str	r2, [r4, #4]
10009f1a:	1c18      	adds	r0, r3, #0
10009f1c:	bd70      	pop	{r4, r5, r6, pc}

10009f1e <_swilseek>:
10009f1e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
10009f20:	1c0c      	adds	r4, r1, #0
10009f22:	1c16      	adds	r6, r2, #0
10009f24:	f7ff ff56 	bl	10009dd4 <findslot>
10009f28:	1e05      	subs	r5, r0, #0
10009f2a:	d103      	bne.n	10009f34 <_swilseek+0x16>
10009f2c:	f7fb fb14 	bl	10005558 <__errno>
10009f30:	2309      	movs	r3, #9
10009f32:	e004      	b.n	10009f3e <_swilseek+0x20>
10009f34:	2e02      	cmp	r6, #2
10009f36:	d906      	bls.n	10009f46 <_swilseek+0x28>
10009f38:	f7fb fb0e 	bl	10005558 <__errno>
10009f3c:	2316      	movs	r3, #22
10009f3e:	6003      	str	r3, [r0, #0]
10009f40:	2001      	movs	r0, #1
10009f42:	4240      	negs	r0, r0
10009f44:	e025      	b.n	10009f92 <_swilseek+0x74>
10009f46:	2e01      	cmp	r6, #1
10009f48:	d103      	bne.n	10009f52 <_swilseek+0x34>
10009f4a:	6843      	ldr	r3, [r0, #4]
10009f4c:	18e4      	adds	r4, r4, r3
10009f4e:	d510      	bpl.n	10009f72 <_swilseek+0x54>
10009f50:	e7f2      	b.n	10009f38 <_swilseek+0x1a>
10009f52:	2e02      	cmp	r6, #2
10009f54:	d10d      	bne.n	10009f72 <_swilseek+0x54>
10009f56:	6803      	ldr	r3, [r0, #0]
10009f58:	360a      	adds	r6, #10
10009f5a:	9300      	str	r3, [sp, #0]
10009f5c:	466f      	mov	r7, sp
10009f5e:	1c30      	adds	r0, r6, #0
10009f60:	1c39      	adds	r1, r7, #0
10009f62:	beab      	bkpt	0x00ab
10009f64:	1c06      	adds	r6, r0, #0
10009f66:	1c30      	adds	r0, r6, #0
10009f68:	f7ff ff5c 	bl	10009e24 <checkerror>
10009f6c:	1824      	adds	r4, r4, r0
10009f6e:	1c43      	adds	r3, r0, #1
10009f70:	d0e6      	beq.n	10009f40 <_swilseek+0x22>
10009f72:	682b      	ldr	r3, [r5, #0]
10009f74:	466f      	mov	r7, sp
10009f76:	9300      	str	r3, [sp, #0]
10009f78:	9401      	str	r4, [sp, #4]
10009f7a:	260a      	movs	r6, #10
10009f7c:	1c30      	adds	r0, r6, #0
10009f7e:	1c39      	adds	r1, r7, #0
10009f80:	beab      	bkpt	0x00ab
10009f82:	1c06      	adds	r6, r0, #0
10009f84:	1c30      	adds	r0, r6, #0
10009f86:	f7ff ff4d 	bl	10009e24 <checkerror>
10009f8a:	2800      	cmp	r0, #0
10009f8c:	dbd8      	blt.n	10009f40 <_swilseek+0x22>
10009f8e:	1c20      	adds	r0, r4, #0
10009f90:	606c      	str	r4, [r5, #4]
10009f92:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

10009f94 <_lseek>:
10009f94:	b508      	push	{r3, lr}
10009f96:	f7ff ffc2 	bl	10009f1e <_swilseek>
10009f9a:	bd08      	pop	{r3, pc}

10009f9c <_swiwrite>:
10009f9c:	b530      	push	{r4, r5, lr}
10009f9e:	b085      	sub	sp, #20
10009fa0:	ad01      	add	r5, sp, #4
10009fa2:	9001      	str	r0, [sp, #4]
10009fa4:	9102      	str	r1, [sp, #8]
10009fa6:	9203      	str	r2, [sp, #12]
10009fa8:	2405      	movs	r4, #5
10009faa:	1c20      	adds	r0, r4, #0
10009fac:	1c29      	adds	r1, r5, #0
10009fae:	beab      	bkpt	0x00ab
10009fb0:	1c04      	adds	r4, r0, #0
10009fb2:	1c20      	adds	r0, r4, #0
10009fb4:	f7ff ff36 	bl	10009e24 <checkerror>
10009fb8:	b005      	add	sp, #20
10009fba:	bd30      	pop	{r4, r5, pc}

10009fbc <_write>:
10009fbc:	b570      	push	{r4, r5, r6, lr}
10009fbe:	1c0e      	adds	r6, r1, #0
10009fc0:	1c15      	adds	r5, r2, #0
10009fc2:	f7ff ff07 	bl	10009dd4 <findslot>
10009fc6:	1e04      	subs	r4, r0, #0
10009fc8:	d104      	bne.n	10009fd4 <_write+0x18>
10009fca:	f7fb fac5 	bl	10005558 <__errno>
10009fce:	2309      	movs	r3, #9
10009fd0:	6003      	str	r3, [r0, #0]
10009fd2:	e010      	b.n	10009ff6 <_write+0x3a>
10009fd4:	6800      	ldr	r0, [r0, #0]
10009fd6:	1c31      	adds	r1, r6, #0
10009fd8:	1c2a      	adds	r2, r5, #0
10009fda:	f7ff ffdf 	bl	10009f9c <_swiwrite>
10009fde:	1e03      	subs	r3, r0, #0
10009fe0:	db09      	blt.n	10009ff6 <_write+0x3a>
10009fe2:	6862      	ldr	r2, [r4, #4]
10009fe4:	1a28      	subs	r0, r5, r0
10009fe6:	1812      	adds	r2, r2, r0
10009fe8:	6062      	str	r2, [r4, #4]
10009fea:	429d      	cmp	r5, r3
10009fec:	d105      	bne.n	10009ffa <_write+0x3e>
10009fee:	2000      	movs	r0, #0
10009ff0:	f7ff ff0a 	bl	10009e08 <error>
10009ff4:	e001      	b.n	10009ffa <_write+0x3e>
10009ff6:	2001      	movs	r0, #1
10009ff8:	4240      	negs	r0, r0
10009ffa:	bd70      	pop	{r4, r5, r6, pc}

10009ffc <_swiclose>:
10009ffc:	b537      	push	{r0, r1, r2, r4, r5, lr}
10009ffe:	2402      	movs	r4, #2
1000a000:	9001      	str	r0, [sp, #4]
1000a002:	ad01      	add	r5, sp, #4
1000a004:	1c20      	adds	r0, r4, #0
1000a006:	1c29      	adds	r1, r5, #0
1000a008:	beab      	bkpt	0x00ab
1000a00a:	1c04      	adds	r4, r0, #0
1000a00c:	1c20      	adds	r0, r4, #0
1000a00e:	f7ff ff09 	bl	10009e24 <checkerror>
1000a012:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}

1000a014 <_close>:
1000a014:	b538      	push	{r3, r4, r5, lr}
1000a016:	1c05      	adds	r5, r0, #0
1000a018:	f7ff fedc 	bl	10009dd4 <findslot>
1000a01c:	1e04      	subs	r4, r0, #0
1000a01e:	d106      	bne.n	1000a02e <_close+0x1a>
1000a020:	f7fb fa9a 	bl	10005558 <__errno>
1000a024:	2309      	movs	r3, #9
1000a026:	6003      	str	r3, [r0, #0]
1000a028:	2001      	movs	r0, #1
1000a02a:	4240      	negs	r0, r0
1000a02c:	e014      	b.n	1000a058 <_close+0x44>
1000a02e:	3d01      	subs	r5, #1
1000a030:	2d01      	cmp	r5, #1
1000a032:	d809      	bhi.n	1000a048 <_close+0x34>
1000a034:	4b09      	ldr	r3, [pc, #36]	; (1000a05c <_close+0x48>)
1000a036:	689a      	ldr	r2, [r3, #8]
1000a038:	691b      	ldr	r3, [r3, #16]
1000a03a:	429a      	cmp	r2, r3
1000a03c:	d104      	bne.n	1000a048 <_close+0x34>
1000a03e:	2301      	movs	r3, #1
1000a040:	425b      	negs	r3, r3
1000a042:	6003      	str	r3, [r0, #0]
1000a044:	2000      	movs	r0, #0
1000a046:	e007      	b.n	1000a058 <_close+0x44>
1000a048:	6820      	ldr	r0, [r4, #0]
1000a04a:	f7ff ffd7 	bl	10009ffc <_swiclose>
1000a04e:	2800      	cmp	r0, #0
1000a050:	d102      	bne.n	1000a058 <_close+0x44>
1000a052:	2301      	movs	r3, #1
1000a054:	425b      	negs	r3, r3
1000a056:	6023      	str	r3, [r4, #0]
1000a058:	bd38      	pop	{r3, r4, r5, pc}
1000a05a:	46c0      	nop			; (mov r8, r8)
1000a05c:	20000834 	.word	0x20000834

1000a060 <_swistat>:
1000a060:	b570      	push	{r4, r5, r6, lr}
1000a062:	1c0c      	adds	r4, r1, #0
1000a064:	f7ff feb6 	bl	10009dd4 <findslot>
1000a068:	1e06      	subs	r6, r0, #0
1000a06a:	d105      	bne.n	1000a078 <_swistat+0x18>
1000a06c:	f7fb fa74 	bl	10005558 <__errno>
1000a070:	2309      	movs	r3, #9
1000a072:	6003      	str	r3, [r0, #0]
1000a074:	3b0a      	subs	r3, #10
1000a076:	e014      	b.n	1000a0a2 <_swistat+0x42>
1000a078:	2380      	movs	r3, #128	; 0x80
1000a07a:	6862      	ldr	r2, [r4, #4]
1000a07c:	019b      	lsls	r3, r3, #6
1000a07e:	4313      	orrs	r3, r2
1000a080:	6063      	str	r3, [r4, #4]
1000a082:	2380      	movs	r3, #128	; 0x80
1000a084:	00db      	lsls	r3, r3, #3
1000a086:	62e3      	str	r3, [r4, #44]	; 0x2c
1000a088:	250c      	movs	r5, #12
1000a08a:	1c28      	adds	r0, r5, #0
1000a08c:	1c31      	adds	r1, r6, #0
1000a08e:	beab      	bkpt	0x00ab
1000a090:	1c05      	adds	r5, r0, #0
1000a092:	1c28      	adds	r0, r5, #0
1000a094:	f7ff fec6 	bl	10009e24 <checkerror>
1000a098:	1c03      	adds	r3, r0, #0
1000a09a:	1c42      	adds	r2, r0, #1
1000a09c:	d001      	beq.n	1000a0a2 <_swistat+0x42>
1000a09e:	2300      	movs	r3, #0
1000a0a0:	6120      	str	r0, [r4, #16]
1000a0a2:	1c18      	adds	r0, r3, #0
1000a0a4:	bd70      	pop	{r4, r5, r6, pc}

1000a0a6 <_fstat>:
1000a0a6:	b538      	push	{r3, r4, r5, lr}
1000a0a8:	1c05      	adds	r5, r0, #0
1000a0aa:	1c0c      	adds	r4, r1, #0
1000a0ac:	223c      	movs	r2, #60	; 0x3c
1000a0ae:	1c08      	adds	r0, r1, #0
1000a0b0:	2100      	movs	r1, #0
1000a0b2:	f7fb fa74 	bl	1000559e <memset>
1000a0b6:	1c28      	adds	r0, r5, #0
1000a0b8:	1c21      	adds	r1, r4, #0
1000a0ba:	f7ff ffd1 	bl	1000a060 <_swistat>
1000a0be:	bd38      	pop	{r3, r4, r5, pc}

1000a0c0 <_isatty>:
1000a0c0:	b570      	push	{r4, r5, r6, lr}
1000a0c2:	f7ff fe87 	bl	10009dd4 <findslot>
1000a0c6:	2509      	movs	r5, #9
1000a0c8:	1e04      	subs	r4, r0, #0
1000a0ca:	d103      	bne.n	1000a0d4 <_isatty+0x14>
1000a0cc:	f7fb fa44 	bl	10005558 <__errno>
1000a0d0:	6005      	str	r5, [r0, #0]
1000a0d2:	e010      	b.n	1000a0f6 <_isatty+0x36>
1000a0d4:	1c28      	adds	r0, r5, #0
1000a0d6:	1c21      	adds	r1, r4, #0
1000a0d8:	beab      	bkpt	0x00ab
1000a0da:	1c04      	adds	r4, r0, #0
1000a0dc:	2001      	movs	r0, #1
1000a0de:	4284      	cmp	r4, r0
1000a0e0:	d00a      	beq.n	1000a0f8 <_isatty+0x38>
1000a0e2:	f7fb fa39 	bl	10005558 <__errno>
1000a0e6:	2400      	movs	r4, #0
1000a0e8:	1c06      	adds	r6, r0, #0
1000a0ea:	2513      	movs	r5, #19
1000a0ec:	1c28      	adds	r0, r5, #0
1000a0ee:	1c21      	adds	r1, r4, #0
1000a0f0:	beab      	bkpt	0x00ab
1000a0f2:	1c05      	adds	r5, r0, #0
1000a0f4:	6035      	str	r5, [r6, #0]
1000a0f6:	1c20      	adds	r0, r4, #0
1000a0f8:	bd70      	pop	{r4, r5, r6, pc}
1000a0fa:	0000      	movs	r0, r0
1000a0fc:	100015fa 	.word	0x100015fa
1000a100:	100015fa 	.word	0x100015fa
1000a104:	10001604 	.word	0x10001604
1000a108:	10001604 	.word	0x10001604
1000a10c:	10001632 	.word	0x10001632
1000a110:	10001632 	.word	0x10001632
1000a114:	10001632 	.word	0x10001632
1000a118:	10001632 	.word	0x10001632
1000a11c:	1000160e 	.word	0x1000160e
1000a120:	1000161a 	.word	0x1000161a
1000a124:	10001626 	.word	0x10001626
1000a128:	10001626 	.word	0x10001626

1000a12c <UART_BLUETOOTH_channel_config>:
1000a12c:	00002580 01080800 00000010              .%..........

1000a138 <UART_BLUETOOTH_tx_pin_config>:
1000a138:	000000b8 00000001                       ........

1000a140 <UART_BLUETOOTH_tx_pin>:
1000a140:	40040100 00000003 1000a138              ...@....8...

1000a14c <UART_BLUETOOTH_config>:
1000a14c:	1000a12c 100023f9 00000000 00000000     ,....#..........
	...
1000a170:	1000a140 04000000 00000104              @...........

1000a17c <UART_BLUETOOTH_rx_pin_config>:
1000a17c:	00000000 00000001                       ........

1000a184 <TRIGGER_IN_compare_config>:
1000a184:	00000000 0000000a                       ........

1000a18c <TRIGGER_IN_gpio_out_config>:
1000a18c:	00000090 00010000                       ........

1000a194 <TRIGGER_OUT_compare_config>:
1000a194:	00000000 0000000a                       ........

1000a19c <TRIGGER_OUT_gpio_out_config>:
1000a19c:	00000090 00010000                       ........

1000a1a4 <INTERRUPT_ECHO_IN>:
1000a1a4:	00010317                                ....

1000a1a8 <INTERRUPT_ECHO_OUT>:
1000a1a8:	00010318 454c4449 00000000 09632509     ....IDLE.....%c.
1000a1b8:	25097525 75250975 00000a0d 20726d54     %u.%u.%u....Tmr 
1000a1c8:	00637653 51726d54 00000000 100048d6     Svc.TmrQ.....H..
1000a1d8:	100048d6 100048d6 1000494a 1000495e     .H...H..JI..^I..
1000a1e8:	1000499a 100048d6 100048d6 1000494a     .I...H...H..JI..
1000a1f8:	1000495e                                ^I..

1000a1fc <ECHO_OUT>:
1000a1fc:	40040200 00000000 00000000 00000001     ...@............

1000a20c <ECHO_IN>:
1000a20c:	40040100 00000000 00000000 00000000     ...@............

1000a21c <GREEN_LED>:
1000a21c:	40040000 00000080 00010000 00000008     ...@............

1000a22c <RED_LED>:
1000a22c:	40040000 00000080 00010000 0000000c     ...@............
1000a23c:	00000100 00010000 00000000 45564144     ............DAVE
1000a24c:	50504120 6e692073 61697469 617a696c      APPs initializa
1000a25c:	6e6f6974 69616620 0064656c 72617453     tion failed.Star
1000a26c:	00000074 636f7250 69737365 5420676e     t...Processing T
1000a27c:	006b7361 6d6d6f43 63696e75 6f697461     ask.Communicatio
1000a28c:	6154206e 00006b73 636f7250 69737365     n Task..Processi
1000a29c:	6154676e 64206b73 74617275 3a6e6f69     ngTask duration:
1000a2ac:	756c2520 0a737520 00000000 7563636f      %lu us.....occu
1000a2bc:	64656970 6170735f 20736563 6c25203d     pied_spaces = %l
1000a2cc:	00000a75 65657246 61707320 3a736563     u...Free spaces:
1000a2dc:	0a642520 00000000 72746e45 65636e61      %d.....Entrance
1000a2ec:	6f6c6220 64656b63 00000a21 656e6547      blocked!...Gene
1000a2fc:	65746172 656d2064 67617373 25203a65     rated message: %
1000a30c:	00000073 74736964 65636e61 206e695f     s...distance_in 
1000a31c:	6c25203d 00000a75 7261430a 206e4920     = %lu....Car In 
1000a32c:	65746564 64657463 00000000 74736964     detected....dist
1000a33c:	65636e61 74756f5f 25203d20 000a756c     ance_out = %lu..
1000a34c:	7261430a 74754f20 74656420 65746365     .Car Out detecte
1000a35c:	00000064 00000043                       d...C...

1000a364 <_global_impure_ptr>:
1000a364:	20000604 00464e49 00666e69 004e414e     ... INF.inf.NAN.
1000a374:	006e616e 31300030 35343332 39383736     nan.0.0123456789
1000a384:	44434241 30004645 34333231 38373635     ABCDEF.012345678
1000a394:	63626139 00666564 69666e49 7974696e     9abcdef.Infinity
1000a3a4:	4e614e00 00000000                       .NaN....

1000a3ac <__sf_fake_stdin>:
	...

1000a3cc <__sf_fake_stdout>:
	...

1000a3ec <__sf_fake_stderr>:
	...
1000a40c:	49534f50 002e0058 00000000              POSIX.......

1000a418 <__mprec_tens>:
1000a418:	00000000 3ff00000 00000000 40240000     .......?......$@
1000a428:	00000000 40590000 00000000 408f4000     ......Y@.....@.@
1000a438:	00000000 40c38800 00000000 40f86a00     .......@.....j.@
1000a448:	00000000 412e8480 00000000 416312d0     .......A......cA
1000a458:	00000000 4197d784 00000000 41cdcd65     .......A....e..A
1000a468:	20000000 4202a05f e8000000 42374876     ... _..B....vH7B
1000a478:	a2000000 426d1a94 e5400000 42a2309c     ......mB..@..0.B
1000a488:	1e900000 42d6bcc4 26340000 430c6bf5     .......B..4&.k.C
1000a498:	37e08000 4341c379 85d8a000 43763457     ...7y.AC....W4vC
1000a4a8:	674ec800 43abc16d 60913d00 43e158e4     ..Ngm..C.=.`.X.C
1000a4b8:	78b58c40 4415af1d d6e2ef50 444b1ae4     @..x...DP.....KD
1000a4c8:	064dd592 4480f0cf c7e14af6 44b52d02     ..M....D.J...-.D
1000a4d8:	79d99db4 44ea7843                       ...yCx.D

1000a4e0 <__mprec_bigtens>:
1000a4e0:	37e08000 4341c379 b5056e17 4693b8b5     ...7y.AC.n.....F
1000a4f0:	e93ff9f5 4d384f03 f9301d32 5a827748     ..?..O8M2.0.Hw.Z
1000a500:	7f73bf3c 75154fdd                       <.s..O.u

1000a508 <p05.5277>:
1000a508:	00000005 00000019 0000007d 2b302d23     ........}...#-0+
1000a518:	6c680020 6665004c 47464567 00000000      .hlL.efgEFG....
1000a528:	100089bc 100088aa 10008990 10008896     ................
1000a538:	10008990 1000899a 10008990 10008896     ................
1000a548:	100088aa 100088aa 1000899a 10008896     ................
1000a558:	100088a0 100088a0 100088a0 10008c02     ................
1000a568:	10009250 1000922e 1000922e 10009222     P..........."...
1000a578:	10009116 10009116 10009216 10009222     ............"...
1000a588:	10009116 10009216 10009116 10009222     ............"...
1000a598:	1000911a 1000911a 1000911a 10009430     ............0...
1000a5a8:	0074743a                                :tt.

Disassembly of section .VENEER_Code:

2000000c <HardFault_Veneer>:
    
    .align 1
    
    .globl HardFault_Veneer
HardFault_Veneer:
    LDR R0, =HardFault_Handler
2000000c:	482c      	ldr	r0, [pc, #176]	; (200000c0 <CCU40_3_Veneer+0x20>)
    MOV PC,R0
2000000e:	4687      	mov	pc, r0
	...

2000002c <SVC_Veneer>:
    .long 0
    
/* ======================================================================== */
    .globl SVC_Veneer
SVC_Veneer:
    LDR R0, =SVC_Handler
2000002c:	4825      	ldr	r0, [pc, #148]	; (200000c4 <CCU40_3_Veneer+0x24>)
    MOV PC,R0
2000002e:	4687      	mov	pc, r0
	...

20000038 <PendSV_Veneer>:
    .long 0
    .long 0
/* ======================================================================== */
    .globl PendSV_Veneer
PendSV_Veneer:
    LDR R0, =PendSV_Handler
20000038:	4823      	ldr	r0, [pc, #140]	; (200000c8 <CCU40_3_Veneer+0x28>)
    MOV PC,R0
2000003a:	4687      	mov	pc, r0

2000003c <SysTick_Veneer>:
/* ======================================================================== */
    .globl SysTick_Veneer 
SysTick_Veneer:
    LDR R0, =SysTick_Handler
2000003c:	4823      	ldr	r0, [pc, #140]	; (200000cc <CCU40_3_Veneer+0x2c>)
    MOV PC,R0
2000003e:	4687      	mov	pc, r0

20000040 <SCU_0_Veneer>:
/* ======================================================================== */
    .globl SCU_0_Veneer 
SCU_0_Veneer:
    LDR R0, =SCU_0_IRQHandler
20000040:	4823      	ldr	r0, [pc, #140]	; (200000d0 <CCU40_3_Veneer+0x30>)
    MOV PC,R0
20000042:	4687      	mov	pc, r0

20000044 <SCU_1_Veneer>:
/* ======================================================================== */
    .globl SCU_1_Veneer 
SCU_1_Veneer:
    LDR R0, =SCU_1_IRQHandler
20000044:	4823      	ldr	r0, [pc, #140]	; (200000d4 <CCU40_3_Veneer+0x34>)
    MOV PC,R0
20000046:	4687      	mov	pc, r0

20000048 <SCU_2_Veneer>:
/* ======================================================================== */
    .globl SCU_2_Veneer
SCU_2_Veneer:
    LDR R0, =SCU_2_IRQHandler
20000048:	4823      	ldr	r0, [pc, #140]	; (200000d8 <CCU40_3_Veneer+0x38>)
    MOV PC,R0
2000004a:	4687      	mov	pc, r0

2000004c <SCU_3_Veneer>:
/* ======================================================================== */
    .globl SCU_3_Veneer 
SCU_3_Veneer:
    LDR R0, =ERU0_0_IRQHandler
2000004c:	4823      	ldr	r0, [pc, #140]	; (200000dc <CCU40_3_Veneer+0x3c>)
    MOV PC,R0
2000004e:	4687      	mov	pc, r0

20000050 <SCU_4_Veneer>:
/* ======================================================================== */
    .globl SCU_4_Veneer 
SCU_4_Veneer:
    LDR R0, =ERU0_1_IRQHandler
20000050:	4823      	ldr	r0, [pc, #140]	; (200000e0 <CCU40_3_Veneer+0x40>)
    MOV PC,R0
20000052:	4687      	mov	pc, r0

20000054 <SCU_5_Veneer>:
/* ======================================================================== */
    .globl SCU_5_Veneer 
SCU_5_Veneer:
    LDR R0, =ERU0_2_IRQHandler
20000054:	4823      	ldr	r0, [pc, #140]	; (200000e4 <CCU40_3_Veneer+0x44>)
    MOV PC,R0
20000056:	4687      	mov	pc, r0

20000058 <SCU_6_Veneer>:
/* ======================================================================== */
    .globl SCU_6_Veneer 
SCU_6_Veneer:
    LDR R0, =ERU0_3_IRQHandler
20000058:	4823      	ldr	r0, [pc, #140]	; (200000e8 <CCU40_3_Veneer+0x48>)
    MOV PC,R0
2000005a:	4687      	mov	pc, r0
	...

20000064 <USIC0_0_Veneer>:
    .long 0
    .long 0
/* ======================================================================== */
    .globl USIC0_0_Veneer
USIC0_0_Veneer:
    LDR R0, =USIC0_0_IRQHandler
20000064:	4821      	ldr	r0, [pc, #132]	; (200000ec <CCU40_3_Veneer+0x4c>)
    MOV PC,R0
20000066:	4687      	mov	pc, r0

20000068 <USIC0_1_Veneer>:
/* ======================================================================== */
    .globl USIC0_1_Veneer
USIC0_1_Veneer:
    LDR R0, =USIC0_1_IRQHandler
20000068:	4821      	ldr	r0, [pc, #132]	; (200000f0 <CCU40_3_Veneer+0x50>)
    MOV PC,R0
2000006a:	4687      	mov	pc, r0

2000006c <USIC0_2_Veneer>:
/* ======================================================================== */
    .globl USIC0_2_Veneer
USIC0_2_Veneer:
    LDR R0, =USIC0_2_IRQHandler
2000006c:	4821      	ldr	r0, [pc, #132]	; (200000f4 <CCU40_3_Veneer+0x54>)
    MOV PC,R0
2000006e:	4687      	mov	pc, r0

20000070 <USIC0_3_Veneer>:
/* ======================================================================== */
    .globl USIC0_3_Veneer
USIC0_3_Veneer:
    LDR R0, =USIC0_3_IRQHandler
20000070:	4821      	ldr	r0, [pc, #132]	; (200000f8 <CCU40_3_Veneer+0x58>)
    MOV PC,R0
20000072:	4687      	mov	pc, r0

20000074 <USIC0_4_Veneer>:
/* ======================================================================== */
    .globl USIC0_4_Veneer
USIC0_4_Veneer:
    LDR R0, =USIC0_4_IRQHandler
20000074:	4821      	ldr	r0, [pc, #132]	; (200000fc <CCU40_3_Veneer+0x5c>)
    MOV PC,R0
20000076:	4687      	mov	pc, r0

20000078 <USIC0_5_Veneer>:
/* ======================================================================== */
    .globl USIC0_5_Veneer
USIC0_5_Veneer:
    LDR R0, =USIC0_5_IRQHandler
20000078:	4821      	ldr	r0, [pc, #132]	; (20000100 <CCU40_3_Veneer+0x60>)
    MOV PC,R0
2000007a:	4687      	mov	pc, r0

2000007c <VADC0_C0_0_Veneer>:
/* ======================================================================== */
    .globl VADC0_C0_0_Veneer 
VADC0_C0_0_Veneer:
    LDR R0, =VADC0_C0_0_IRQHandler
2000007c:	4821      	ldr	r0, [pc, #132]	; (20000104 <CCU40_3_Veneer+0x64>)
    MOV PC,R0
2000007e:	4687      	mov	pc, r0

20000080 <VADC0_C0_1_Veneer>:
/* ======================================================================== */
    .globl VADC0_C0_1_Veneer
VADC0_C0_1_Veneer:
    LDR R0, =VADC0_C0_1_IRQHandler
20000080:	4821      	ldr	r0, [pc, #132]	; (20000108 <CCU40_3_Veneer+0x68>)
    MOV PC,R0
20000082:	4687      	mov	pc, r0
	...

20000094 <CCU40_0_Veneer>:
    .long 0
    .long 0
/* ======================================================================== */
    .globl CCU40_0_Veneer
CCU40_0_Veneer:
    LDR R0, =CCU40_0_IRQHandler
20000094:	481d      	ldr	r0, [pc, #116]	; (2000010c <CCU40_3_Veneer+0x6c>)
    MOV PC,R0
20000096:	4687      	mov	pc, r0

20000098 <CCU40_1_Veneer>:
/* ======================================================================== */
    .globl CCU40_1_Veneer
CCU40_1_Veneer:
    LDR R0, =CCU40_1_IRQHandler
20000098:	481d      	ldr	r0, [pc, #116]	; (20000110 <CCU40_3_Veneer+0x70>)
    MOV PC,R0
2000009a:	4687      	mov	pc, r0

2000009c <CCU40_2_Veneer>:
/* ======================================================================== */
    .globl CCU40_2_Veneer
CCU40_2_Veneer:
    LDR R0, =CCU40_2_IRQHandler
2000009c:	481d      	ldr	r0, [pc, #116]	; (20000114 <CCU40_3_Veneer+0x74>)
    MOV PC,R0
2000009e:	4687      	mov	pc, r0

200000a0 <CCU40_3_Veneer>:
/* ======================================================================== */
    .globl CCU40_3_Veneer
CCU40_3_Veneer:
    LDR R0, =CCU40_3_IRQHandler
200000a0:	481d      	ldr	r0, [pc, #116]	; (20000118 <CCU40_3_Veneer+0x78>)
    MOV PC,R0
200000a2:	4687      	mov	pc, r0
	...
    
    .align 1
    
    .globl HardFault_Veneer
HardFault_Veneer:
    LDR R0, =HardFault_Handler
200000c0:	10001091 	.word	0x10001091
    .long 0
    
/* ======================================================================== */
    .globl SVC_Veneer
SVC_Veneer:
    LDR R0, =SVC_Handler
200000c4:	10002bf5 	.word	0x10002bf5
    .long 0
    .long 0
/* ======================================================================== */
    .globl PendSV_Veneer
PendSV_Veneer:
    LDR R0, =PendSV_Handler
200000c8:	10002d11 	.word	0x10002d11
    MOV PC,R0
/* ======================================================================== */
    .globl SysTick_Veneer 
SysTick_Veneer:
    LDR R0, =SysTick_Handler
200000cc:	10002d61 	.word	0x10002d61
    MOV PC,R0
/* ======================================================================== */
    .globl SCU_0_Veneer 
SCU_0_Veneer:
    LDR R0, =SCU_0_IRQHandler
200000d0:	10001091 	.word	0x10001091
    MOV PC,R0
/* ======================================================================== */
    .globl SCU_1_Veneer 
SCU_1_Veneer:
    LDR R0, =SCU_1_IRQHandler
200000d4:	10001091 	.word	0x10001091
    MOV PC,R0
/* ======================================================================== */
    .globl SCU_2_Veneer
SCU_2_Veneer:
    LDR R0, =SCU_2_IRQHandler
200000d8:	10001091 	.word	0x10001091
    MOV PC,R0
/* ======================================================================== */
    .globl SCU_3_Veneer 
SCU_3_Veneer:
    LDR R0, =ERU0_0_IRQHandler
200000dc:	10001091 	.word	0x10001091
    MOV PC,R0
/* ======================================================================== */
    .globl SCU_4_Veneer 
SCU_4_Veneer:
    LDR R0, =ERU0_1_IRQHandler
200000e0:	10001091 	.word	0x10001091
    MOV PC,R0
/* ======================================================================== */
    .globl SCU_5_Veneer 
SCU_5_Veneer:
    LDR R0, =ERU0_2_IRQHandler
200000e4:	10001091 	.word	0x10001091
    MOV PC,R0
/* ======================================================================== */
    .globl SCU_6_Veneer 
SCU_6_Veneer:
    LDR R0, =ERU0_3_IRQHandler
200000e8:	10001091 	.word	0x10001091
    .long 0
    .long 0
/* ======================================================================== */
    .globl USIC0_0_Veneer
USIC0_0_Veneer:
    LDR R0, =USIC0_0_IRQHandler
200000ec:	100024f5 	.word	0x100024f5
    MOV PC,R0
/* ======================================================================== */
    .globl USIC0_1_Veneer
USIC0_1_Veneer:
    LDR R0, =USIC0_1_IRQHandler
200000f0:	100024e1 	.word	0x100024e1
    MOV PC,R0
/* ======================================================================== */
    .globl USIC0_2_Veneer
USIC0_2_Veneer:
    LDR R0, =USIC0_2_IRQHandler
200000f4:	10001091 	.word	0x10001091
    MOV PC,R0
/* ======================================================================== */
    .globl USIC0_3_Veneer
USIC0_3_Veneer:
    LDR R0, =USIC0_3_IRQHandler
200000f8:	10001091 	.word	0x10001091
    MOV PC,R0
/* ======================================================================== */
    .globl USIC0_4_Veneer
USIC0_4_Veneer:
    LDR R0, =USIC0_4_IRQHandler
200000fc:	10001091 	.word	0x10001091
    MOV PC,R0
/* ======================================================================== */
    .globl USIC0_5_Veneer
USIC0_5_Veneer:
    LDR R0, =USIC0_5_IRQHandler
20000100:	10001091 	.word	0x10001091
    MOV PC,R0
/* ======================================================================== */
    .globl VADC0_C0_0_Veneer 
VADC0_C0_0_Veneer:
    LDR R0, =VADC0_C0_0_IRQHandler
20000104:	10001091 	.word	0x10001091
    MOV PC,R0
/* ======================================================================== */
    .globl VADC0_C0_1_Veneer
VADC0_C0_1_Veneer:
    LDR R0, =VADC0_C0_1_IRQHandler
20000108:	10001091 	.word	0x10001091
    .long 0
    .long 0
/* ======================================================================== */
    .globl CCU40_0_Veneer
CCU40_0_Veneer:
    LDR R0, =CCU40_0_IRQHandler
2000010c:	10001091 	.word	0x10001091
    MOV PC,R0
/* ======================================================================== */
    .globl CCU40_1_Veneer
CCU40_1_Veneer:
    LDR R0, =CCU40_1_IRQHandler
20000110:	10001091 	.word	0x10001091
    MOV PC,R0
/* ======================================================================== */
    .globl CCU40_2_Veneer
CCU40_2_Veneer:
    LDR R0, =CCU40_2_IRQHandler
20000114:	100051dd 	.word	0x100051dd
    MOV PC,R0
/* ======================================================================== */
    .globl CCU40_3_Veneer
CCU40_3_Veneer:
    LDR R0, =CCU40_3_IRQHandler
20000118:	10005201 	.word	0x10005201
